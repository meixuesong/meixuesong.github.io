<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 算法 | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/suan-fa/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2014-11-02T23:18:25+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[最小生成树]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/31/zui-xiao-sheng-cheng-shu/"/>
    <updated>2014-10-31T22:38:49+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/31/zui-xiao-sheng-cheng-shu</id>
    <content type="html"><![CDATA[<p>加权图是一种为每条边关联一个权值或成本的图模型。这种图最令人感兴趣的是将成本最小化。本节学习加权无向图模型并找到它的一棵最小生成树。</p>

<p>图的生成树是它的一棵含有其所有顶点的无环连通子图。一幅加权图的最小生成树（MST）是它的一棵权值（树中所有边的权值之和）最小的生成树。</p>

<!--more-->


<h2>1. 一些约定</h2>

<p>为了方便说明，有以下这些约定：</p>

<ul>
<li>只考虑连通图。如果图是非连通的，只能计算它的所有连通分量的最小生成树，合并起来称为最小生成森林。</li>
<li>边的权重不一定表示距离。但为了看起来方便，示意图会用距离来表示权重。</li>
<li>边的权重可能是0或者负数。</li>
<li>所有边的权重都各不相同。如果权重可以相同，最小生成树就不一定唯一，算法证明会更复杂。但实际上算法也适用于存在权重相等的情况。</li>
</ul>


<h2>2. 原理</h2>

<p>图的一种<strong>切分</strong>是将图的所有顶点分为两个非空且不重叠的两个集合。<strong>横切边</strong>是一条连接两个属于不同集合的顶点的边。</p>

<blockquote><p>切分定理：在一幅加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图的最小生成树。</p></blockquote>

<p>切分定理会把加权图中的所有顶点分为两个集合，检查横跨两个集合的所有边并识别哪边边应属于图的最小生成树。</p>

<h2>3. 加权无向图的数据结构</h2>

<p>通过扩展无向图的邻接矩阵来表示加权无向图。在无向图的邻接表表示中，第v个顶点的列表中每个元素都是和顶点v相邻的顶点。在加权无向图中，我们将其替换为一个加权边Edge：</p>

<p><img src="/myresource/images/image_blog_2014-11-02-edge-api.png" alt="image" /></p>

<p>上图中，eaither()表示边的两个顶点中的某一个，而other()则返回另一个顶点。有了加权边Edge，加权无向图的API就与无向图非常接近，在实现上，只是在邻接表中用Edge对象替代了无向图Graph中的整数作为链表的结点：</p>

<p><img src="/myresource/images/image_blog_2014-11-02-edge-weighted-graph-api.png" alt="image" /></p>

<p>加权无向图的表示如下：</p>

<p><img src="/myresource/images/image_blog_2014-11-02-edge-weighted-graph-representation.png" alt="image" /></p>

<p>代码实现如下：</p>

<p>```java
public class Edge implements Comparable<Edge> {</p>

<pre><code>private final int v;
private final int w;
private final double weight;

public Edge(int v, int w, double weight) {
    if (v &lt; 0) throw new IndexOutOfBoundsException("Vertex name must be a nonnegative integer");
    if (w &lt; 0) throw new IndexOutOfBoundsException("Vertex name must be a nonnegative integer");
    if (Double.isNaN(weight)) throw new IllegalArgumentException("Weight is NaN");
    this.v = v;
    this.w = w;
    this.weight = weight;
}

public double weight() {
    return weight;
}

public int either() {
    return v;
}

public int other(int vertex) {
    if      (vertex == v) return w;
    else if (vertex == w) return v;
    else throw new IllegalArgumentException("Illegal endpoint");
}

public int compareTo(Edge that) {
    if      (this.weight() &lt; that.weight()) return -1;
    else if (this.weight() &gt; that.weight()) return +1;
    else                                    return  0;
}

public String toString() {
    return String.format("%d-%d %.5f", v, w, weight);
}
</code></pre>

<p>}  <br/>
```</p>

<p>```java
public class EdgeWeightedGraph {</p>

<pre><code>private final int V;
private int E;
private Bag&lt;Edge&gt;[] adj;

/**
 * Initializes an empty edge-weighted graph with &lt;tt&gt;V&lt;/tt&gt; vertices and 0 edges.
 * param V the number of vertices
 * @throws java.lang.IllegalArgumentException if &lt;tt&gt;V&lt;/tt&gt; &lt; 0
 */
public EdgeWeightedGraph(int V) {
    if (V &lt; 0) throw new IllegalArgumentException("Number of vertices must be nonnegative");
    this.V = V;
    this.E = 0;
    adj = (Bag&lt;Edge&gt;[]) new Bag[V];
    for (int v = 0; v &lt; V; v++) {
        adj[v] = new Bag&lt;Edge&gt;();
    }
}

/**
 * Initializes a random edge-weighted graph with &lt;tt&gt;V&lt;/tt&gt; vertices and &lt;em&gt;E&lt;/em&gt; edges.
 * param V the number of vertices
 * param E the number of edges
 * @throws java.lang.IllegalArgumentException if &lt;tt&gt;V&lt;/tt&gt; &lt; 0
 * @throws java.lang.IllegalArgumentException if &lt;tt&gt;E&lt;/tt&gt; &lt; 0
 */
public EdgeWeightedGraph(int V, int E) {
    this(V);
    if (E &lt; 0) throw new IllegalArgumentException("Number of edges must be nonnegative");
    for (int i = 0; i &lt; E; i++) {
        int v = (int) (Math.random() * V);
        int w = (int) (Math.random() * V);
        double weight = Math.round(100 * Math.random()) / 100.0;
        Edge e = new Edge(v, w, weight);
        addEdge(e);
    }
}

/**  
 * Initializes an edge-weighted graph from an input stream.
 * The format is the number of vertices &lt;em&gt;V&lt;/em&gt;,
 * followed by the number of edges &lt;em&gt;E&lt;/em&gt;,
 * followed by &lt;em&gt;E&lt;/em&gt; pairs of vertices and edge weights,
 * with each entry separated by whitespace.
 * @param in the input stream
 * @throws java.lang.IndexOutOfBoundsException if the endpoints of any edge are not in prescribed range
 * @throws java.lang.IllegalArgumentException if the number of vertices or edges is negative
 */
public EdgeWeightedGraph(In in) {
    this(in.readInt());
    int E = in.readInt();
    if (E &lt; 0) throw new IllegalArgumentException("Number of edges must be nonnegative");
    for (int i = 0; i &lt; E; i++) {
        int v = in.readInt();
        int w = in.readInt();
        double weight = in.readDouble();
        Edge e = new Edge(v, w, weight);
        addEdge(e);
    }
}

/**
 * Initializes a new edge-weighted graph that is a deep copy of &lt;tt&gt;G&lt;/tt&gt;.
 * @param G the edge-weighted graph to copy
 */
public EdgeWeightedGraph(EdgeWeightedGraph G) {
    this(G.V());
    this.E = G.E();
    for (int v = 0; v &lt; G.V(); v++) {
        // reverse so that adjacency list is in same order as original
        Stack&lt;Edge&gt; reverse = new Stack&lt;Edge&gt;();
        for (Edge e : G.adj[v]) {
            reverse.push(e);
        }
        for (Edge e : reverse) {
            adj[v].add(e);
        }
    }
}

//图的顶点数
public int V() {
    return V;
}

//图的边数
public int E() {
    return E;
}

//向图中添加一条边e
public void addEdge(Edge e) {
    int v = e.either();
    int w = e.other(v);
    if (v &lt; 0 || v &gt;= V) throw new IndexOutOfBoundsException("vertex " + v + " is not between 0 and " + (V-1));
    if (w &lt; 0 || w &gt;= V) throw new IndexOutOfBoundsException("vertex " + w + " is not between 0 and " + (V-1));
    adj[v].add(e);
    adj[w].add(e);
    E++;
}

//与v相关联的所有边
public Iterable&lt;Edge&gt; adj(int v) {
    if (v &lt; 0 || v &gt;= V) throw new IndexOutOfBoundsException("vertex " + v + " is not between 0 and " + (V-1));
    return adj[v];
}

//图中的所有边
public Iterable&lt;Edge&gt; edges() {
    Bag&lt;Edge&gt; list = new Bag&lt;Edge&gt;();
    for (int v = 0; v &lt; V; v++) {
        int selfLoops = 0;
        for (Edge e : adj(v)) {
            if (e.other(v) &gt; v) {
                list.add(e);
            }
            // only add one copy of each self loop (self loops will be consecutive)
            else if (e.other(v) == v) {
                if (selfLoops % 2 == 0) list.add(e);
                selfLoops++;
            }
        }
    }
    return list;
}

public String toString() {
    String NEWLINE = System.getProperty("line.separator");
    StringBuilder s = new StringBuilder();
    s.append(V + " " + E + NEWLINE);
    for (int v = 0; v &lt; V; v++) {
        s.append(v + ": ");
        for (Edge e : adj[v]) {
            s.append(e + "  ");
        }
        s.append(NEWLINE);
    }
    return s.toString();
}
</code></pre>

<p>}
```</p>

<h2>4. 最小生成树的API及实现</h2>

<p>下面API定义的构造函数接受加权无向图作为参数，并返回最小生成树和其权重。</p>

<p><img src="/myresource/images/image_blog_2014-11-02-mst-api.png" alt="image" /></p>

<p>Prim算法和Kruskal算法都可以实现最小生成树，它们都基于贪心算法，区别在于保存切分和判定权重最小的横切边的方式。</p>

<blockquote><p>贪心算法：初始状态下所有边均为灰色，找到一种切分，它产生的横切边均不为黑色。将权重最小的横切边标记为黑色。反复这个步骤直到标记了V-1条黑色边为止。</p></blockquote>

<h3>4.1 Prim算法</h3>

<p>Prim算法每一步都会为一棵生长中的树添加一条边。一开始这棵树只有一个顶点，然后会向它添加V-1条边，每次总是找到这样一条边并将其加入树中：这条边的一端在树中，另一端不在树中，并且权值最小。</p>

<p><img src="/myresource/images/image_blog_2014-11-02-prim-eager.png" alt="image" /></p>

<p>每当向树中添加一条边后，也向树中添加了一个顶点。要维护一个包含所有横切边的集合，可以将连接这个顶点和其他所有不在树中的顶点的边加入优先队列。这样就可以得到符合条件的权值最小的边。当一个顶点加入树中后，连接这个顶点与树中其它顶点的所有边就失效了，因为这些边的两个顶点都已经在树中，这些边不再是横切边。那么何时删除这些边就形成了Prim算法的两种实现：</p>

<ul>
<li>延时(Lazy)实现会先把它们留在队列中，等要删除时再检查边的有效性；</li>
<li>即时实现可以将它们从优先队列中删除。</li>
</ul>


<p>这两种实现所需的时间都与ElogE成正比（最坏情况下），延时实现所需的空间与E成正比，瓶颈在于优先队列的insert()和delMin()中比较边的权重次数。而即时实现所需空间的上限与V成正比，比延时实现有优势。两种实现代码如下：</p>

<p>```java
public class LazyPrimMST {</p>

<pre><code>private double weight;       // total weight of MST
private Queue&lt;Edge&gt; mst;     // edges in the MST
private boolean[] marked;    // marked[v] = true if v on tree
private MinPQ&lt;Edge&gt; pq;      // edges with one endpoint in tree

/**
 * Compute a minimum spanning tree (or forest) of an edge-weighted graph.
 * @param G the edge-weighted graph
 */
public LazyPrimMST(EdgeWeightedGraph G) {
    mst = new Queue&lt;Edge&gt;();
    pq = new MinPQ&lt;Edge&gt;();
    marked = new boolean[G.V()];
    for (int v = 0; v &lt; G.V(); v++)     // run Prim from all vertices to
        if (!marked[v]) prim(G, v);     // get a minimum spanning forest
}

// run Prim's algorithm
private void prim(EdgeWeightedGraph G, int s) {
    scan(G, s);
    while (!pq.isEmpty()) {                        // better to stop when mst has V-1 edges
        Edge e = pq.delMin();                      // smallest edge on pq
        int v = e.either(), w = e.other(v);        // two endpoints
        assert marked[v] || marked[w];
        if (marked[v] &amp;&amp; marked[w]) continue;      // lazy, both v and w already scanned
        mst.enqueue(e);                            // add e to MST
        weight += e.weight();
        if (!marked[v]) scan(G, v);               // v becomes part of tree
        if (!marked[w]) scan(G, w);               // w becomes part of tree
    }
}

//标记顶点v并将所有连接v和未被标记顶点的边加入pq
private void scan(EdgeWeightedGraph G, int v) {
    assert !marked[v];
    marked[v] = true;
    for (Edge e : G.adj(v))
        if (!marked[e.other(v)]) pq.insert(e);
}

//树的所有边
public Iterable&lt;Edge&gt; edges() {
    return mst;
}

//树的权重
public double weight() {
    return weight;
}
</code></pre>

<p>}
```</p>

<p>```java
public class PrimMST {</p>

<pre><code>private Edge[] edgeTo;        // 距离树最近的边，edgeTo[v] = shortest edge from tree vertex to non-tree vertex
private double[] distTo;      // distTo[v] = weight of shortest such edge
private boolean[] marked;     // marked[v] = true if v on tree, false otherwise
private IndexMinPQ&lt;Double&gt; pq;  //有效的横切边

/**
 * Compute a minimum spanning tree (or forest) of an edge-weighted graph.
 * @param G the edge-weighted graph
 */
public PrimMST(EdgeWeightedGraph G) {
    edgeTo = new Edge[G.V()];
    distTo = new double[G.V()];
    marked = new boolean[G.V()];
    pq = new IndexMinPQ&lt;Double&gt;(G.V());
    for (int v = 0; v &lt; G.V(); v++) distTo[v] = Double.POSITIVE_INFINITY;

    for (int v = 0; v &lt; G.V(); v++)      // run from each vertex to find
        if (!marked[v]) prim(G, v);      // minimum spanning forest
}

// run Prim's algorithm in graph G, starting from vertex s
private void prim(EdgeWeightedGraph G, int s) {
    distTo[s] = 0.0;
    pq.insert(s, distTo[s]); //用顶点0和权重0初始化pq
    while (!pq.isEmpty()) {
        int v = pq.delMin();  
        scan(G, v);          //将最近的顶点添加到树中
    }
}

// scan vertex v
private void scan(EdgeWeightedGraph G, int v) {
        //将顶点v添加到树中，更新数据
    marked[v] = true;
    for (Edge e : G.adj(v)) {
        int w = e.other(v);
        if (marked[w]) continue;         // v-w 已经失效
        if (e.weight() &lt; distTo[w]) {
                //连接w和树的最佳边Edge变为e
            distTo[w] = e.weight();
            edgeTo[w] = e;
            if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);
            else                pq.insert(w, distTo[w]);
        }
    }
}

//所有边
public Iterable&lt;Edge&gt; edges() {
    Queue&lt;Edge&gt; mst = new Queue&lt;Edge&gt;();
    for (int v = 0; v &lt; edgeTo.length; v++) {
        Edge e = edgeTo[v];
        if (e != null) {
            mst.enqueue(e);
        }
    }
    return mst;
}

//权重
public double weight() {
    double weight = 0.0;
    for (Edge e : edges())
        weight += e.weight();
    return weight;
}
</code></pre>

<p>}
```</p>

<h3>4.2 Kruskal算法</h3>

<p>Kruskal算法构造最小生成树时也是一条边一条边地构造，但它寻找的边会连接一片森林中的两棵树。我们从一片由V棵单顶点的树构成的森林开始并不断将两棵树合并（用可以找到的最短边）直到只剩下一棵树。其主要思想是按边的权重顺序处理它们，将边加入最小生成树中，加入的边不会与已经加入的边构成环，直到树中含有V-1条边为止。</p>

<p><img src="/myresource/images/image_blog_2014-11-02-kruskal.png" alt="image" /></p>

<p>实现时，采用优先队列将边按照权重排序，用一个union-find数据结构识别会形成环的边，以及一个队列来保存最小生成树的所有边。代码实现如下：</p>

<p>```
public class KruskalMST {</p>

<pre><code>private double weight;  // weight of MST
private Queue&lt;Edge&gt; mst = new Queue&lt;Edge&gt;();  // edges in MST

public KruskalMST(EdgeWeightedGraph G) {
    // more efficient to build heap by passing array of edges
    MinPQ&lt;Edge&gt; pq = new MinPQ&lt;Edge&gt;();
    for (Edge e : G.edges()) {
        pq.insert(e);
    }

    // run greedy algorithm
    UF uf = new UF(G.V());
    while (!pq.isEmpty() &amp;&amp; mst.size() &lt; G.V() - 1) {
        Edge e = pq.delMin();  //从pq得到权重最小的边和它的顶点
        int v = e.either();
        int w = e.other(v);
        if (!uf.connected(v, w)) { // v-w does not create a cycle
            uf.union(v, w);  // merge v and w components
            mst.enqueue(e);  // add edge e to mst
            weight += e.weight();
        }
    }
}

//树的所有边
public Iterable&lt;Edge&gt; edges() {
    return mst;
}

//树的权重
public double weight() {
    return weight;
}
</code></pre>

<p>}
```</p>

<p>Kruskal算法所需的空间与E成正比，所需时间与ElogE成正比（最坏情况下）。</p>

<p>Prim和Kruskal算法不能处理有向图。</p>

<p>参考：<a href="http://algs4.cs.princeton.edu/43mst/">http://algs4.cs.princeton.edu/43mst</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[有向图]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/30/you-xiang-tu/"/>
    <updated>2014-10-30T20:10:54+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/30/you-xiang-tu</id>
    <content type="html"><![CDATA[<p>有向图也就是有方向性的图，是由一组顶点和一组有方向的边组成，每条有方向的边都连接着有序的一对顶点。本文要解决的有向图问题：</p>

<ol>
<li>单点和多点的可达性</li>
<li>单点有向路径</li>
<li>单点最短有向路径</li>
<li>有向环检测</li>
<li>深度优先的顶点排序</li>
<li>优先级限制下的调度问题</li>
<li>拓扑排序</li>
<li>强连通性</li>
<li>顶点对的可达性</li>
</ol>


<!--more-->


<h2>1. 术语</h2>

<ul>
<li>出度：一个顶点指出的边的总数；</li>
<li>入度：指向该顶点的边的总数；</li>
<li>一条有向边的第一个顶点称为头，第二个顶点称为尾。</li>
<li>在一幅有向图中，有向路径由一系列顶点组成，对于其中的每个顶点都存在一条有向边从它指向序列中的下一个顶点。</li>
</ul>


<h2>2. 有向图的数据类型</h2>

<p>有向图的API与无向图本质相同，只是多了一个取反操作。如下图：</p>

<p><img src="/myresource/images/image_blog_2014-10-20-digraph-api.png" alt="image" /></p>

<p>其中，reverse()方向返回有向图的一个副本，但是将其中的方向反转。adj()返回的是每个顶点指出的边所连接的所有顶点。</p>

<p>Diagraph的实现与无向图Graph非常类似，也是采用邻接表实现，但由于边是有向的，所以假设7&mdash;>8的一条边，则在顶点7的邻接表中有8，而顶点8的邻接表却没有7. <a href="http://algs4.cs.princeton.edu/42directed/Digraph.java.html">实现代码</a>不再重复。</p>

<h2>3. 有向图中的可达性</h2>

<ul>
<li>单点可达性：是否存在一条从s到达给定顶点v的有向路径？</li>
<li>多点可达性：是否存在一条从集合中的任意顶点到达给定顶点v的有向路径？</li>
</ul>


<p>API定义和实现如下：</p>

<p>```
public class DirectedDFS {</p>

<pre><code>private boolean[] marked;

//在G中找到从s可达的所有顶点
public DirectedDFS(Digraph G, int s) {
    marked = new boolean[G.V()];
    dfs(G, s);
}

//在G中找到从sources中的所有顶点可达的所有顶点
public DirectedDFS(Digraph G, Iterable&lt;Integer&gt; sources) {
    marked = new boolean[G.V()];
    for(int s : sources) {
        if (! marked[s]) dfs(G, s);
    }
}

private void dfs(Digraph G, int v) {
    marked[v] = true;
    for(int w : G.adj(v)){
        if (!marked[w]) dfs(G, w);
    }
}

//v是可达的吗？
public boolean marked(int v) {
    return marked[v];
}
</code></pre>

<p>}
```</p>

<p><strong>标记-清除：</strong>多点可达性的一个重要典型应用就是内存管理，包括许多Java的实现。一个顶点表示一个对象，一条边表示一个对象对另一个对象的引用。在程序执行任何时候，都有某些对象是可以被直接访问的，而不能通过这些对象访问到的所有对象都应该被回收。标记-清除的垃圾回收策略会为每个对象保留一个位做垃圾收集之用。</p>

<p><strong>有向图的寻路：</strong></p>

<ul>
<li>单点有向路径：从s到给定的顶点v是否存在一条有向路径？如果有，找出这条路径。</li>
<li>单点最短有向路径：从s到给定的顶点v是否存在一条有向路径？如果有，找出最短的那边。</li>
</ul>


<p>这两个问题都可以通过深度优先和广度优先解决，它们仍是有向图的重要算法。API和代码也基本相同。</p>

<h2>4. 环和有向无环图</h2>

<h3>4.1 有向图中的环</h3>

<p>任务调度是一个典型的有向图用例，其限制条件包括任务的起始时间、时耗、优先级限制（某个任务是另一个任务的前置条件）等。如何进行正确的任务调度？这需要<strong>拓扑排序</strong>：给定一幅有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素。拓扑排序的例子还包括课程安排（先导课程限制）、继承（Java extends）、电子表格公式等等。</p>

<p>如果一个有优先级限制的问题中存在有向环，例如任务x必须在任务y之前完成，而y必须在z之前完成，但z又必须在x之前完成，那么这个问题就无解了！所以首先要解决<strong>有向环的检测</strong>：给定的有向图中包含有向环吗？</p>

<p><strong>有向无环图（DAG）是一幅不含有向环的有向图。</strong></p>

<p>有向环的检测可以通过深度优先搜索来解决。用一个栈表示正在遍历的有向路径，一旦找到一条有向边v->w且w已经在堆栈中，就找到了一个环。</p>

<p>```java
public class DirectedCycle {</p>

<pre><code>private boolean[] marked;        // marked[v] = 顶点v是否已经访问过?
private int[] edgeTo;            // edgeTo[v] = 指向v的前一个顶点
private boolean[] onStack;       // onStack[v] = 顶点v在递归调用的堆栈上吗？
private Stack&lt;Integer&gt; cycle;    // 有向环 (null表示不存在有向环)

public DirectedCycle(Digraph G) {
    marked  = new boolean[G.V()];
    onStack = new boolean[G.V()];
    edgeTo  = new int[G.V()];
    for (int v = 0; v &lt; G.V(); v++)
        if (!marked[v]) dfs(G, v);
}

private void dfs(Digraph G, int v) {
    onStack[v] = true;
    marked[v] = true;
    for (int w : G.adj(v)) {
        // 如果环已找到，退出
        if (cycle != null) {
               return;
        }
        //找到新顶点，继续
        else if (!marked[w]) {
            edgeTo[w] = v;
            dfs(G, w);
        }
        // 找到有向环，记录下路径
        else if (onStack[w]) {
            cycle = new Stack&lt;Integer&gt;();
            for (int x = v; x != w; x = edgeTo[x]) {
                cycle.push(x);
            }
            cycle.push(w);
            cycle.push(v);
        }
    }

    onStack[v] = false;
}

//是否含有有向环
public boolean hasCycle() {
    return cycle != null;
}

//有向环中的所有顶点（如果存在有向环的话）
public Iterable&lt;Integer&gt; cycle() {
    return cycle;
}
</code></pre>

<p>}
```</p>

<h3>4.2 顶点的深度优先次序与拓扑排序</h3>

<p>优先级限制下的调度问题等价于计算有向无环图中的所有顶点的拓扑排序。只需要在标准深度优先搜索中，将<code>dfs()</code>的顶点参数保存在一个数据结构中，遍历这个数据结构就能访问所有的顶点。遍历的顺序取决于这个数据结构的性质以及是在递归调用之前还是之后进行保存。主要有3种排序顺序：</p>

<ol>
<li>前序(pre)：在递归调用之前将顶点加入队列。</li>
<li>后序(post)：在递归调用之后将顶点加入队列。</li>
<li>逆后序(reversePost)：在递归调用之后将顶点压入堆栈。</li>
</ol>


<p>对于这样一张有向图，三种顺序遍历过程如下：</p>

<p><img src="/myresource/images/image_blog_2014-10-29-dag.png" alt="image" /></p>

<p><img src="/myresource/images/image_blog_2014-10-29-depth-first-orders.png" alt="image" /></p>

<p>下面实现的DepthFirstOrder实现了这三种排序：</p>

<p>```java
public class DepthFirstOrder {</p>

<pre><code>private boolean[] marked;          // marked[v] = has v been marked in dfs?
private Queue&lt;Integer&gt; pre;                 // pre[v]    = preorder  number of v
private Queue&lt;Integer&gt; post;                // post[v]   = postorder number of v
private Stack&lt;Integer&gt; reversePost;

public DepthFirstOrder(Digraph G) {
    pre    = new Queue&lt;Integer&gt;();
    post   = new Queue&lt;Integer&gt;();
    reversePost = new Stack&lt;Integer&gt;();
    marked    = new boolean[G.V()];

    for (int v = 0; v &lt; G.V(); v++)
        if (!marked[v]) dfs(G, v);
}

private void dfs(Digraph G, int v) {
    pre.enqueue(v);

    marked[v] = true;

    for (int w : G.adj(v)) {
        if (!marked[w]) {
            dfs(G, w);
        }
    }

    post.enqueue(v);
    reversePost.push(v);
}

public Iterable&lt;Integer&gt; pre() {
    return pre;
}
public Iterable&lt;Integer&gt; post() {
    return post;
}   
public Iterable&lt;Integer&gt; reversePost() {
    return reversePost;
}
</code></pre>

<p>}
```</p>

<p>DepthFirstOrder提供了三种排序的顶点列表：pre, post, reversePost，因此拓扑排序就非常简单了：</p>

<p>```java
public class Topological {</p>

<pre><code>private Iterable&lt;Integer&gt; order;    // topological order

public Topological(Digraph G) {
    DirectedCycle finder = new DirectedCycle(G);
    if (!finder.hasCycle()) {
        DepthFirstOrder dfs = new DepthFirstOrder(G);
        order = dfs.reversePost();
    }
}

//拓扑有序的所有顶点
public Iterable&lt;Integer&gt; order() {
    return order;
}

//G是有向无环图吗？
public boolean isDAG() {
    return order != null;
}
</code></pre>

<p>}  <br/>
```</p>

<p><strong>一幅有向无环图的拓扑顺序就是所有顶点的逆后序排列。</strong>这是一个重要结论！证明如下：对于任意边v->w, 在调用dfs(v)时，必有以下三种情况之一：</p>

<ol>
<li>dfs(w)已经被调用过且已经返回（w已经被标记）。</li>
<li>dfs(w)还没有被调用，因此v->会直接或间接调用并返回dfs(w)，且dfs(w)会在dfs(v)返回前返回。</li>
<li>dfs(w)已经被调用但未返回。</li>
</ol>


<p>第3种情况表示存在环，所以在有向无环图中是不可能出现的。第1、2种情况都证明了dfs(w)会先于dfs(v)完成。后序排列时w在v之前，只有逆后序时，w排在v之后。因此逆后序是有向无环图的拓扑顺序。</p>

<p>再次说明，拓扑排序和有向环的检测总是一起出现的，因为有向环的检测是排序的前提。</p>

<h2>5. 有向图的强连通性</h2>

<p>如果两个顶点v和w是互相可达的，也就是存在一条从v到w的有向路径，同时还存在一条从w到v的有向路径，那么v和w是<strong>强连通</strong>的。</p>

<p>强连通性将所有顶点分为一些等价类，每个等价类都由相互均为强连通的顶点的最大子集组成，这些子集称为<strong>强连通分量</strong>。强连通分量的典型应用包括：网络（网页和超链接）、软件（模块和调用）、食物链（物种和捕食关系）等。强连通分量的API:</p>

<p><img src="/myresource/images/image_blog_2014-10-30-scc-api.png" alt="image" /></p>

<h3>5.1 Kosaraju算法</h3>

<p>Kosaraju算法实现了SCC API：</p>

<ul>
<li>在给定的一幅有向图G中，使用DepthFirstOrder来计算它的反向图G<sup>R</sup>的逆后序排列。</li>
<li>在G中进行标准的深度优先搜索，但是要按照刚才计算得到的顺序而非标准的顺序来访问所有未被标记的顶点。</li>
<li>在构造函数中，所有在同一个递归dfs()调用中被访问到的顶点都在同一个强连通分量中，将它们按照和CC相同的方式识别出来。</li>
</ul>


<p>要证明Kosaraju算法的正确性，首先证明：“每个和s强连通的顶点v都会在构造函数调用的dfs(G,s)中被访问到。”这个毫无疑问。然后再证明：“构造函数调用的dfs(G,s)所到达的任意顶点v都必然是和s强连通的。”设v为dfs(G,s)到达的某个顶点。那么G中必然存在一条从s到v的路径，因此只需证明G中还存在一条从v到s的路径即可。也就等价于证明G<sup>R</sup>中存在一条从s到v的路径：</p>

<blockquote><p>按照逆后序进行的深度优先搜索意味着，在G<sup>R</sup>中进行的深度优先搜索中，dfs(G,v)必然在dfs(G,s)之前就已经结束了，这样dfs(G,v)的调用就只会出现两种情况：</p>

<ol>
<li>调用在dfs(G,s)的调用之前（并且也在dfs(G,s)的调用之前结束）</li>
<li>调用在dfs(G,s)的调用之后（并且也在dfs(G,s)的调用之前结束）</li>
</ol>


<p>第一种情况不可能出现，因为在G<sup>R</sup>中存在一条从v到s的路径；而第二种情况说明G<sup>R</sup>中存在一条从s到v的路径。证毕。</p></blockquote>

<p>```java
public class KosarajuSharirSCC {</p>

<pre><code>private boolean[] marked;     //已访问过的顶点
private int[] id;             //强连通分量的标识符
private int count;            //强连通分量的数量

public KosarajuSharirSCC(Digraph G) {

    // compute reverse postorder of reverse graph
    DepthFirstOrder dfs = new DepthFirstOrder(G.reverse());

    // run DFS on G, using reverse postorder to guide calculation
    marked = new boolean[G.V()];
    id = new int[G.V()];
    for (int v : dfs.reversePost()) {
        if (!marked[v]) {
            dfs(G, v);
            count++;
        }
    }
}

private void dfs(Digraph G, int v) { 
    marked[v] = true;
    id[v] = count;
    for (int w : G.adj(v)) {
        if (!marked[w]) dfs(G, w);
    }
}

//图中的强连通分量的总数
public int count() {
    return count;
}

//v和w是强连通的吗
public boolean stronglyConnected(int v, int w) {
    return id[v] == id[w];
}

//v所在的强连通分量的标识符（在0至count()-1之间）
public int id(int v) {
    return id[v];
}
</code></pre>

<p>}  <br/>
```</p>

<h3>5.2 顶点对的可达性</h3>

<p>给定一幅有向图，回答“是否存在一条从一个给定的顶点v到达另一个给定的顶点w的路径？”对于无向图，这个问题等价于连通性问题。而对有向图，有很大区别。看似简单的问题困难了专家数十年。如何大幅减少预处理所需的时间和空间，又保证常数的查询时间。这仍然是一个有待解决的问题。而且这个问题有重要的实际意义：处理互联网这样的巨型有向图。</p>

<p>下面的算法只是简单地实现了可达性，但不适用于处理大型有向图，因为它所需的空间与V<sup>2</sup>成正比，所需时间和V(V+E)成正比。但如果图小的话，仍然是一个理想的解决办法。</p>

<p>```
public class TransitiveClosure {</p>

<pre><code>private DirectedDFS[] tc;  // tc[v] = reachable from v

//预处理的构造方法
public TransitiveClosure(Digraph G) {
    tc = new DirectedDFS[G.V()];
    for (int v = 0; v &lt; G.V(); v++)
        tc[v] = new DirectedDFS(G, v);
}

//w是从v可达的吗？
public boolean reachable(int v, int w) {
    return tc[v].marked(w);
}
</code></pre>

<p>}
```</p>

<p>参考：<a href="http://algs4.cs.princeton.edu/42directed/">http://algs4.cs.princeton.edu/42directed/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[无向图]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/03/wu-xiang-tu/"/>
    <updated>2014-10-03T18:18:44+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/03/wu-xiang-tu</id>
    <content type="html"><![CDATA[<p>无向图由一组顶点(Vertex)和一组能够将两个顶点相连的边(Edge)组成。本章学习无向图的邻接表实现，以及相关的搜索和应用，例如深度优先和广度优先搜索，路径查找和最短路径计算，连通分量和符号图。本文要解决的无向图问题包括：</p>

<ol>
<li>单点连通性</li>
<li>单点路径</li>
<li>单点最短路径</li>
<li>连通性</li>
<li>检测环</li>
<li>双色问题（图的二分性）</li>
</ol>


<!--more-->


<h2>1. 术语</h2>

<p>v-w表示连接v和w的边。自环和平行边是两种特殊的图。<strong>自环</strong>即一条连接一个顶点和其自身的边；<strong>平行边</strong>是连接同一对顶点的两条边。含有平行边的图称为多重图，没有平行边和自环的图称为<strong>简单图</strong>。</p>

<p>当两个顶点通过一条边相连时，这两个顶点是<strong>相邻的</strong>。某个顶点的<strong>度数(Degree)</strong>即为依附于它的边的总数。<strong>子图</strong>是由一幅图的所有边的一个子集（以及它们所依附的所有顶点）组成的图。</p>

<p>在图中，<strong>路径</strong>是由边顺序连接的一系列顶点。<strong>简单路径</strong>是一条没有重复顶点的路径。<strong>环</strong>是一条至少含有一条边，并且起点和终点相同的路径。<strong>简单环</strong>是一条（除了起点和终点必须相同之外）不含有重复顶点和边的环。路径或环的<strong>长度</strong>为其中所包含的边数。</p>

<p>如果从任意一个顶点都存在一条路径到达另一个任意顶点，这幅图就是<strong>连通图</strong>。一幅非连通的图由若干连通的部分组成，它们都是其极大连通子图。</p>

<p>树是一幅无环(Acyclic)连通图。互不相连的树组成的集合称为<strong>森林</strong>。连通图的<strong>生成树</strong>是它的一幅子图，它含有图中的所有顶点且是一棵树。图的<strong>生成树森林</strong>是它的所有连通子图的生成树的集合。</p>

<p>当且仅当一幅含有V个顶点的图G满足下列5个条件之一时，它就是一棵树：</p>

<ul>
<li>G有V-1条边且不含有环；</li>
<li>G有V-1条边且是连通的；</li>
<li>G是连通的，但删除任意一条边都会使它不再连通；</li>
<li>G是无环图，但添加任意一条边都会产生一条环；</li>
<li>G中的任意一对顶点之间仅存在一条简单路径。</li>
</ul>


<h2>2. API</h2>

<p>先看一份定义了无向图的基本操作的API：</p>

<p><img src="/myresource/images/image_blog_2014-10-04_graph-api.png" alt="image" /></p>

<p>```java
//////////////////常用的图处理代码//////////////////</p>

<p>//计算v的度数
public static int degree(Graph G, int v) {</p>

<pre><code>int degree = 0;
for(int w: G.adj(v)) degree++;
return degree;
</code></pre>

<p>}</p>

<p>//计算所有顶点的最大度数
public static int maxDegree(Graph G) {</p>

<pre><code>int max = 0;
for(int v = 0; v &lt; G.V(); v++) 
    if (degree(G, v) &gt; max)
        max = degree(G, v);
return max;
</code></pre>

<p>}</p>

<p>//计算所有顶点的平均度数
public static double avgDegree(Graph G) {</p>

<pre><code>return 2.0 * G.E() / G.V(); 
</code></pre>

<p>}</p>

<p>//计算自环的个数
public static int numberOfSelfLoops(Graph G) {</p>

<pre><code>int count = 0;
for(int v = 0; v &lt; G.V(); v++)
    for(int w : G.adj(v))
        if (v == w) count++;
return count / 2; //每条边都被记过2次
</code></pre>

<p>}
```</p>

<h3>2.1 邻接表</h3>

<p>图有多种表示方法，包括邻接矩阵（V乘V的布尔矩阵，占用空间过大），边的数组（边类含有两个int实例变量，实现adj方法需要检查图中的所有边）和邻接表数组。</p>

<p>邻接表数组是以顶点为索引的列表数组，例如第0个顶点的列表中每个元素都是和顶点0相邻的顶点。示意图如下：</p>

<p><img src="/myresource/images/image_blog_2014-10-03_adjacency-lists.png" alt="image" /></p>

<p>它具有以下特点：</p>

<ul>
<li>使用的空间和V+E成正比；</li>
<li>添加一条边所需的时间为常数；</li>
<li>遍历顶点v的所有相邻顶点所需的时间和v的度数成正比。</li>
</ul>


<p>代码实现示意如下：</p>

<p>```java
public class Graph {</p>

<pre><code>private final int V;        //顶点数目
private int E;              //边的数目
private Bag&lt;Integer&gt;[] adj; //邻接表

public void addEdge(int v, int w) {
    adj[v].add(w);
    adj[w].add(v);
    E++;
}

public Iterable&lt;Integer&gt; adj(int v) {
    return adj[v];
}
</code></pre>

<p>}
```</p>

<h3>2.2 图的处理算法API</h3>

<p><img src="/myresource/images/image_blog_2014-10-04_search-api.png" alt="image" /></p>

<h2>3. 深度优先搜索(DFS)</h2>

<p>深度优先搜索一幅图，只需要一个递归方法来遍历所有顶点。在访问其中一个顶点时：</p>

<ul>
<li>将它标记为已访问；</li>
<li>递归地访问它的所有没有被标记过的邻居顶点。</li>
</ul>


<p>```java
//深度优先搜索
public class DepthFirstSearch {</p>

<pre><code>private boolean[] marked;
private int count;

public DepthFirstSearch(Graph G, int s) {
    marked = new boolean[G.V()];
    dfs(G, s);
}

private void dfs(Graph G, int v) {
    marked[v] = true;
    count++;
    for(int w : G.adj(v))
        if (!marked[w]) dfs(G, w);
}

public boolean marked(int w) {return marked[w];}

public int count() {return count;}
</code></pre>

<p>}
```</p>

<p>利用深度优先搜索很容易找到一些问题的答案。例如“两个给定的顶点是否连通？有多少个连通子图？从s到给定目的顶点v是否存在一条路径？如果有，找到这条路径。”</p>

<h2>4. 寻找路径</h2>

<p>路径的API:</p>

<p><img src="/myresource/images/image_blog_2014-10-04_paths-api.png" alt="image" /></p>

<p>```java
//使用深度优先搜索查找图的路径
public class DepthFirstPaths {</p>

<pre><code>private boolean[] marked;   //这个顶点上调用过dfs()吗？
private int[] edgeTo;       //从起点到一个顶点的已知路径上的最后一个顶点
private final int s;        //起点

public DepthFirstPaths(Graph G, int s) {
    marked = new boolean[G.V()];
    edgeTo = new int[G.V()];
    this.s = s;
    dfs(G, s);
}

private void dfs(Graph G, int v) {
    marked[v] = true;
    for(int w : G.adj(v))
        if (!marked[w]) {
            edgeTo[w] = v;
            dfs(G, w);
        }
}

public boolean hasPathTo(int v) {return marked[v];}

public Iterable&lt;Integer&gt; pathTo(int v) {
    if (!hasPathTo(v)) return null;
    Stack&lt;Integer&gt; path = new Stack&lt;Integer&gt;();
    for(int x = v; x != s; x = edgeTo[x])
        path.push(x);
    path.push(s);
    return path;
}
</code></pre>

<p>}
```</p>

<h2>5. 广度优先搜索(BFS)</h2>

<p>广度优先搜索可以解决单点最短路径的问题，即“从s到给定目的顶点v是否存在一条路径？如果有，找出其中最短的那条。”要找到从s到v的最短路径，从s开始，在所有由一条边就可以到达的顶点中寻找v，如果找不到就继续在与s距离两条边的所有顶点中找v，如此一直进行。实现广度优先搜索时，可以使用先进先出（FIFO）队列。代码示意如下：</p>

<p>```java
public class BreadthFirstPaths {</p>

<pre><code>private boolean[] marked;  //到达该顶点的最短路径已知吗？
private int[] edgeTo;      //到达该顶点的已知路径上的最后一个顶点
private final int s;       //起点

public BreadthFirstPaths(Graph G, int s) {
    marked = new boolean[G.V()];
    edgeTo = new int[G.v()];
    this.s = s;
    bfs(G, s);
}

private void bfs(Grapth G, int s) {
    Queue&lt;Integer&gt; queue = new Queue&lt;Integer&gt;();
    marked[s] = true;  //标记起点
    queue.enqueue(s);  //入列
    while (!queue.isEmpty()) {
        int v = queue.dequeue();
        for(int w : G.adj(v))
            if (!marked[w]) {
                edgeTo[w] = v;
                marked[w] = true;
                queue.enqueue(w);
            }
    }
}

public boolean hasPathTo(int v) {return marked[v];}

public Iterable&lt;Integer&gt; pathTo(int v) {//与深度优先实现相同}
</code></pre>

<p>}
```</p>

<h2>6. 连通分量</h2>

<p>所谓连通分量就是连通子图，深度优先搜索可用于找出一幅图的所有连通分量。其API定义如下：</p>

<p><img src="/myresource/images/image_blog_2014-10-04_cc-api.png" alt="image" /></p>

<p>递归的深度优先搜索第一次调用的参数是顶点0，它会标记所有与0连通的顶点。然后构造函数中的for循环会查找每个没有被标记的顶点并递归调用dfs()来标记和它相邻的所有顶点。代码如下：</p>

<p>```java
public class CC {</p>

<pre><code>private boolean[] marked;
private int[] id;
private int count = 0;

public CC(Graph G) {
    marked = new boolean[G.V()];
    id = new int[G.V()];
    for(int s = 0; s &lt; G.V(); s++)
        if (!marked[s]) {
            dfs(G, s);
            count++;
        }
}

private void dfs(Graph G, int v) {
    marked[v] = true;
    id[v] = count;
    for(int w : G.adj(v))
        if (!marked[w])
            dfs(G, w);
}

public boolean connected(int v, int w) { return id[v] == id[w]; }

public int id(int v) {return id[v]; }

public int count() {return count;}
</code></pre>

<p>}
```</p>

<p>深度优先搜索还可用于解决两个问题：1. 给定的图是无环图吗（假定不存在自环和平行边）？<a href="http://algs4.cs.princeton.edu/41undirected/Cycle.java.html">代码实现</a> 2. 这是一幅二分图吗？也就是说能够用两种颜色将图的所有顶点着色，使得任意一条边的两个端点的颜色都不相同。<a href="http://baike.baidu.com/view/501081.htm">二分图</a>，<a href="http://algs4.cs.princeton.edu/41undirected/Bipartite.java.html">代码实现</a></p>

<h2>7. 符号图</h2>

<p>在典型应用中，通常使用字符串而非整数来表示和指代顶点。为了适应这样的应用，需要符号图。符号图使用字符串代替整数索引。其API定义如下：</p>

<p><img src="/myresource/images/image_blog_2014-10-04_symbol-graph-api.png" alt="image" /></p>

<p>符号图的实现可以在无向图的基础上增加一个符号表和反向索引。符号表完成符号到邻接表索引的映射，键为String(顶点名)，值的类型为int(邻接表的索引)。反向索引是一个数组keys[]，保存每个顶点索引所对应的顶点名。结构如下图：</p>

<p><img src="/myresource/images/image_blog_2014-10-04_symbol-graph.png" alt="image" /></p>

<p>其实现较为简单，<a href="http://algs4.cs.princeton.edu/41undirected/SymbolGraph.java.html">查看代码</a>。</p>

<p><strong>利用符号图可以处理一个经典问题，找到一个社交网络中两个人间隔的度数。这其实就是用符号图+广度优先求最短路径的用例。</strong></p>

<h2>总结</h2>

<p>本文主要学习无向图的邻接表实现，以及深度、广度优先算法及其应用：</p>

<p>深度优先：</p>

<ol>
<li>两个顶点是否连通？如果有，给出路径。</li>
<li>有多少个连通子图？找出所有连通分量。</li>
<li>给定的图是无环图吗？</li>
<li>是一幅二分图吗？</li>
</ol>


<p>广度优先：</p>

<ol>
<li>找出两个顶点间的最短路径。</li>
</ol>


<p>参考：<a href="http://algs4.cs.princeton.edu/41undirected/">http://algs4.cs.princeton.edu/41undirected/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[散列表(HashTable)]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/03/san-lie-biao/"/>
    <updated>2014-10-03T10:03:40+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/03/san-lie-biao</id>
    <content type="html"><![CDATA[<p>散列表也是一种符号表，它通过算法将键转化为数组的索引来访问数组中的键值对。散列表查找的第一步是用散列函数将被查找的键转化为一数组索引，第二步是处理碰撞冲突。解决碰撞冲突的方法有拉链法和线性探测法。</p>

<!--more-->


<h2>1. 散列函数</h2>

<p>散列函数用于将键转化为数组的索引，它应该易于计算并且能够均匀分布所有的键。散列函数和键的类型有关，对于每种类型的键都需要一个与之对应的散列函数。</p>

<p>Java对正整数采用除留余数法计算散列值。选择大小为素数M的数组，对于任意正整数k，计算余数：<code>k%M</code>，能够有效地将键散布在0到M-1的范围内。素数又称为质数，是一个大于1的自然数，除了1和它本身外，不能被其他自然数整除（除0以外）的数。Java对浮点数会将键表示为二进制数然后再使用除留余数法。对字符串采用类似Homer方法，用N次乘法、加法和取余来计算散列值。</p>

<p>对Java程序，<code>hashCode()</code>和<code>equals()</code>方法必须一致。如果<code>equals()</code>返回<code>true</code>那么<code>hashCode()</code>返回值必须一致，反过来则可以不同。</p>

<h2>2. 基于拉链法的散列表</h2>

<p>当<code>hashCode()</code>返回值相同，但<code>equals()</code>为false时，就发生了碰撞。解决碰撞的一种方法是拉链法。拉链法是指数组中的每个元素都指向一个链表，链表中的每个结点都存储了散列值为该元素的索引的键值对。因此这样的散列表由数组+链表构成。查找时先根据散列值找到对应的链表，然后沿着链表顺序查找相应的键。</p>

<p><img src="/myresource/images/image_blog_2014-10-03_separate-chaining.png" alt="image" /></p>

<p>可以看出，散列表的查找性能与散列表的大小有很大关系，对N个元素来说，当散列表的大小M过小时，碰撞机率就会增加，链表的长度必然增加，从而降低了查找效率。因此在内存不紧张时，可以选择一个足够大的M，内存紧张时，选择尽量大的M。另一种方法是动态调整数据的大小以保持短小的链表。</p>

<p>执行删除操作时，先用散列值找到索引及对应的链表，然后调用链表的删除方法即可。</p>

<p>对于有序性相关的符号表操作，散列表都不是合适的选择，因为这些操作的运行时间都是线性的。</p>

<p>Java的TreeMap和HashMap分别是基于红黑树和拉链法的散列表的符号表实现。</p>

<h2>3. 基于线性探测法的散列表</h2>

<p>实现散列表的另一种方式是用大小为M的数组保存N个键值对，其中M>N。依靠数据中的空位解决碰撞冲突。基于这种策略的所有方法都统称为开放地址散列表。其中最简单的方法叫做线性探测法：当碰撞发生时，直接检查散列表的下一个位置（索引加1），可能产生三种结果：</p>

<ul>
<li>命中，该位置的键和被查找的键相同；</li>
<li>未命中，键为空（该位置没有键）；</li>
<li>继续查找，该位置的键和被查找的键不同。</li>
</ul>


<p>其核心思想是与其将内存用作链表，不如将它们作为散列表的空元素。即用散列函数找到索引，检查其中的键和被查找的键是否相同。如果不同则继续查找（增加索引，到达数组结尾后再折回数组开头），直到找到该键或者遇到一个空元素。过程如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10-03_linear-probing.png" alt="image" /></p>

<p>在基于线性探测法的散列表中执行删除操作比较复杂，如果将该键所在位置为为null是不行的。需要将簇中被删除键的右侧的所有键重新插入散列表。</p>

<p>这种散列表的性能也依赖于N/M，但在这里表示散列表的利用率。如果利用率达到1，即散列表满了，会造成未命中的查找无限循环。为了保证性能，要动态调整数组的大小来保证利用率在1/8到1/2之间。</p>

<h2>4. 数组的大小和内存使用</h2>

<p>对于线性探测法，调整数组的大小是必需的。对于拉链法，如果你能准确估计所需的散列表大小N，调整数据的工作不是必需的，只需要根据查找耗时和<code>(1+N/M)</code>成正比来选取一个适当的M即可。</p>

<p>符号表的内存使用：</p>

<table>
<thead>
<tr>
<th>方法 </th>
<th> N个元素所需的内存（引用类型）</th>
</tr>
</thead>
<tbody>
<tr>
<td>基于拉链法的散列表 </td>
<td> ~48N + 32M</td>
</tr>
<tr>
<td>基于线性探测的散列表 </td>
<td> 在~32N和~128N之间</td>
</tr>
<tr>
<td>各种二叉查找树 </td>
<td> ~56N</td>
</tr>
</tbody>
</table>


<h2>Q&amp;A</h2>

<p>Q: Java的Integer, Double和Long类型的hashCode()是如何实现的？</p>

<blockquote><p>Integer类型直接返回该整数的32位值。对Double和Long返回机器表示的前32位和后32位异或的结果。</p></blockquote>

<p>Q: 为什么不将<code>hash(x)</code>实现为<code>x.hashCode() % M</code>?</p>

<blockquote><p>Java中，取余的结果可能是负数。</p></blockquote>

<p>Q: 为什么不将<code>hash(x)</code>实现为<code>Math.abs(x.hashCode()) % M</code>?</p>

<blockquote><p>对于最大的整数<code>Math.abs()</code>会返回一个负值，这种溢出可能使程序崩溃。</p></blockquote>

<p>Q: 在拉链法中，链表是否可以使用二叉查找树或者红黑树？</p>

<blockquote><p>一般来说，散列表碰撞机率越少越好，因此链表越短越好。所以链表的初级实现的性能一般会更好，特殊情况下最好由专家进行这种调优。</p></blockquote>

<p>Q: 散列表的查找比红黑树更快吗？</p>

<blockquote><p>取决于键的类型，也就是hashCode()的计算成本是否大于compareTo()的比较成本。但通常散列表会比红黑树快得多。但散列表无法高效支持有序性相关的操作。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[符号表]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/02/cha-zhao-suan-fa-fu-hao-biao/"/>
    <updated>2014-10-02T11:26:20+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/02/cha-zhao-suan-fa-fu-hao-biao</id>
    <content type="html"><![CDATA[<p>符号表就是用键和值的方式来存储和检索数据。其关键点在于如何快速检索和高效插入。本章介绍了符号表的简单实现、二叉查找树、红黑树的实现。</p>

<!--more-->


<p>首先还是来定义一下简单的符号表API：</p>

<p><img src="/myresource/images/image_blog_20141002_170641.jpg" alt="image" /></p>

<h2>1. API定义</h2>

<p>符号表遵循以下规则：</p>

<ul>
<li>每个键只对应一个值；</li>
<li>当存入的键值对和表中已有的键冲突时，新的值会替代旧的值；</li>
<li>键不能为空；</li>
<li>值不允许为空；</li>
</ul>


<p>在简单的符号表中，键的等价性由equals()方法保证。而很多典型应用中，键都是Comparable对象，因此有序符号表可以保持键的有序并扩展其API：</p>

<p><img src="/myresource/images/image_blog_20141002_170651.jpg" alt="image" /></p>

<ul>
<li>floor：向下取整，找出小于等于该键的最大键；</li>
<li>ceiling：向上取整，找出大于等于该键的最小键；</li>
<li>rank：小于key的键的数量；</li>
<li>select：获得排名为第k的键。</li>
</ul>


<p>对于0到size()-1的所有i都有：i == rank(select(i))，且所有键都满足：key == select(rank(key))。</p>

<h2>2. 实现</h2>

<h3>2.1 无序链表的顺序查找</h3>

<p>可以用链表来实现符号表，每个结点存储一个键值对，并保持一个链接指向下一个结点。这种方式非常简单，但是效率非常低。不论是get方法还是put方法，都需要从首节点开始一个一个地遍历。</p>

<h3>2.2 有序数组中的二分查找</h3>

<p>另一种实现方法是通过两个平行的数组来存储符号表。一个储存键，一个存储值。二分法可以用于保证数组中Comparable类型的键有序，并高效地实现get和其他操作(如select)。</p>

<p>对N个键的有序数组进行二分查找最多需要（lgN + 1）次比较。然而put方法却仍然很慢，向大小为N的有序数组插入一个新的元素，在最坏的情况下需要访问约2N次数组。因此向一个空的符号表插入N个元素时，最坏的情况下需要访问约N<sup>2</sup>次数组。</p>

<p>因此，我们需要一种结构，能够同时拥有二分法的查找效率和链表的插入效率。这就是二叉查找树。</p>

<h3>2.3 二叉查找树(BST)</h3>

<p>二叉查找树的定义：它是一棵二叉树，其中每个结点都含有一个Comparable的键以及相关联的值，每个结点的键都大于其左子树任意结点的键，同时小于右子树任意结点的键。</p>

<h4>2.3.1 基本实现</h4>

<p>如果将一棵二叉查找树的所有键投影到一条直线上，我们可以得到一条有序的键列，如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_15.10.37.png" alt="image" /></p>

<p>树结点的实现：</p>

<p>```java</p>

<pre><code>private class Node {
    private Key key;           // sorted by key
    private Value val;         // associated data
    private Node left, right;  // left and right subtrees
    private int N;             // number of nodes in subtree

    public Node(Key key, Value val, int N) {
        this.key = key;
        this.val = val;
        this.N = N;
    }
}
</code></pre>

<p>```</p>

<h5>查找</h5>

<p>可以使用递归算法在二叉查找树中查找一个键：如果树是空的，则查找未命中；如果被查找的键和根结点的键相等，查找命中；否则就（递归地）在某个子树中继续查找。如果被查找的键较小就选择左子树，较大则选择右子树。查找过程与二分查找一样简单，代码实现如下：</p>

<p>```java</p>

<pre><code>public Value get(Key key) {
    return get(root, key);
}

private Value get(Node x, Key key) {
    if (x == null) return null;
    int cmp = key.compareTo(x.key);
    if      (cmp &lt; 0) return get(x.left, key);
    else if (cmp &gt; 0) return get(x.right, key);
    else              return x.val;
}
</code></pre>

<p>```</p>

<h5>插入</h5>

<p>二叉查找树的插入实现难度和查找差不多。当查找到一个不存在于树中的结点并结束于一条空链接时，我们需要做的就是将链接指向一个含有被查找的键的新结点。代码实现如下：</p>

<p>```java</p>

<pre><code>public void put(Key key, Value val) {
    if (val == null) { delete(key); return; }
    root = put(root, key, val);
}

private Node put(Node x, Key key, Value val) {
    if (x == null) return new Node(key, val, 1);
    int cmp = key.compareTo(x.key);
    if      (cmp &lt; 0) x.left  = put(x.left,  key, val);
    else if (cmp &gt; 0) x.right = put(x.right, key, val);
    else              x.val   = val;
    x.N = 1 + size(x.left) + size(x.right);
    return x;
}
</code></pre>

<p>```</p>

<h5>分析</h5>

<p>二叉查找树的算法效率取决于树的形状。在最好的情况下，树是完全平衡的，此时查找和插入的效率都非常高。</p>

<p>但是，树的结构与结点插入的顺序是相关的。在最坏的情况下（例如升序队列中的元素按顺序插入）可能形成一条单边的树，就变成了链表的结构。这种不平衡的树完全失去了二分查找的效率。</p>

<p>因此，如何保持树的平衡是一个重要问题。要在二叉树动态插入中保证树的完美平衡，代价太高了。因此需要对结构进行一些调整，这就是平衡查找树。</p>

<h3>2.4 2-3查找树</h3>

<p>所谓2-3查找树，是指它或者为一棵空树，或者由以下结点组成：</p>

<ul>
<li>2-结点，含有一个键（及其对应的值）和两条链接，左链接指向的树的所有键都小于该结点，右链接指向的树的所有键都大于该结点。</li>
<li>3-结点，含有两个键（及其对应的值）和两条链接，左链接指向的树的所有键都小于该结点，中链接指向的树的所有键都位于该结点的两个键之间，右链接指向的树的所有键都大于该结点。</li>
</ul>


<p>利用2-3查找树，可以方便地实现完美平衡的查找树，2-3查找树示意图如下：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_17_49.png" alt="image" /></p>

<h4>2.4.1 查找</h4>

<p>查找的过程与二叉查找树类似，区别仅在于3-结点树多了一个中链接。</p>

<h4>2.4.2 插入</h4>

<p>2-3查找树实现平衡的关键是插入过程，插入时先进行查找，如果未命中，将根据结束位置的多种情况，采用不同的方法。详细说明如下：</p>

<h5>向2-结点插入新键</h5>

<p>如果查找结束于一个2-结点，只要把这个2-结点替换为一个3-结点，将要插入的键保存在其中即可。如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_23tree-insert2.png" alt="image" /></p>

<h5>向一棵只含有一个3-结点的树中插入新键</h5>

<p>向3-结点的树中插入新键，也有多种情况，先看最简单的这种。如下图所示，先将3-结点变成4-结点，然后再分解为2-3树。</p>

<p><img src="/myresource/images/image_blog_2014-10-02_23tree-insert3a.png" alt="image" /></p>

<h5>向一个父结点为2-结点的3-结点插入新键</h5>

<p>如果父结点为2-结点，则先把3-结点变成4-结点，然后将2-结点变成3-结点，如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_23tree-insert3b.png" alt="image" /></p>

<h5>向一个父结点为3-结点的3-结点插入新键</h5>

<p>跟前一步一样，先变成4-结点并分解它，然后再将它的中键插入它的父结点中。但其父结点也是3-结点，因此再用这个中键构造一个临时的4-结点，进行相同的变化，直到遇到一个2-结点将它变成3-结点。如果一直到根结点都是3-结点，则需要分解根结点。插入新键的过程如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10_02_23tree-insert3c.png" alt="image" /></p>

<h5>分解根结点</h5>

<p>在上一步中，根结点变成了一个临时的4-结点，此时我们按照向一棵只有一个3-结点的树中插入新键的方法处理此问题。将4-结点分解成3个2-结点，树高加1。如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_23tree-split.png" alt="image" /></p>

<h4>2.4.3 性能分析</h4>

<p>从上面这些情况可以看出，插入过程都是进行局部变换，除了相关的结点和链接之外不必修改或检查树的其他部分，因此效率非常高。经过变换后，保持了树的有序性和平衡性。因此在一棵大小为N的2-3树中，查找和插入操作访问的结点必然不超过lgN个！例如含有10亿个结点的一棵2-3树的高度仅在19-30之间，最多只需要访问30个结点就能够在10亿个键中进行任意查找和插入操作，这是多么惊人！这也是<a href="/blog/2014/08/25/cheng-xu-yuan-de-shu-zi/">程序员的数学</a>中提到的利用指数爆炸解决问题。</p>

<h3>2.5 红黑二叉查找树</h3>

<p>2-3查找树很容易理解，现在我们通过红黑二叉树来表达并实现它。其关键是3-结点如何实现。我们将树中的链接分为两种类型：红链接将两个2-结点连接起来构成一个3-结点，黑链接则是普通链接。如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_redblack-encoding.png" alt="image" /></p>

<p>红黑树是含有红黑链接并满足以下条件的二叉查找树：</p>

<ul>
<li>红链接均为左链接；</li>
<li>没有任何一个结点同时和两条红链接相连；</li>
<li>该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。</li>
</ul>


<p>因此在节点类（Node）中，增加一个属性color表示从父结点指向自己的链接是否为红链接：</p>

<p>```java</p>

<pre><code>private class Node {
    private Key key;           // sorted by key
    private Value val;         // associated data
    private Node left, right;  // left and right subtrees
    private int N;             // number of nodes in subtree
    boolean color;             //是否红链接    

    public Node(Key key, Value val, int N, boolean color) {
        this.key = key;
        this.val = val;
        this.N = N;
        this.color = color;
    }
}
</code></pre>

<p>```</p>

<p>在进一步实现红黑树之前，要了解几个基本的动作：左旋转、右旋转和颜色转换。</p>

<h4>2.5.1 旋转</h4>

<p>左旋转是将一条红色的右链接转化为左链接。转换的过程为：将两个键中的较小者作为根结点变为将较大者作为根结点。如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_redblack-left-rotate.png" alt="image" /></p>

<p>右旋转是将一条红色的左链接转化为右链接，实现过程与左旋转相似，只需要将left和right互换即可：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_redblack-right-rotate.png" alt="image" /></p>

<h4>2.5.2 颜色转换</h4>

<p>颜色转换是对一个结点的两个红色子结点的颜色进行转换。除了将子结点的颜色由红变黑外，还要同时将父结点的颜色由黑变红。如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_color-flip.png" alt="image" /></p>

<h4>2.5.3 插入处理过程</h4>

<p>插入新键时，都使用红链接与父结点相连，然后谨慎地使用左旋转、右旋转和颜色转换这三个简单的操作，就能够保证操作后的红黑树与2-3树一一对应的关系。在沿着插入点到根结点的路径向上移动时在所经过的每个结点中顺序完成以下操作，我们就能完成插入操作：</p>

<ol>
<li>如果右子结点是红色，而左子结点是黑色，进行左旋转；</li>
<li>如果左子结点是红色，且它的左子结点也是红色，进行右旋转；</li>
<li>如果左右子结点都是红色，进行颜色转换。</li>
</ol>


<p>下面是各种情况的示例：</p>

<p><img src="/myresource/images/IMG_20141002_222628.jpg" alt="image" /></p>

<p><img src="/myresource/images/IMG_20141002_222714.jpg" alt="image" /></p>

<h4>2.5.4 插入算法的实现</h4>

<p>以下为红黑树的插入算法：</p>

<p>```java
public class RedBlackBST<Key extends Comparable<Key>, Value> {</p>

<pre><code>private static final boolean RED   = true;
private static final boolean BLACK = false;

private Node root;     // root of the BST

// BST helper node data type
private class Node {
    private Key key;           // key
    private Value val;         // associated data
    private Node left, right;  // links to left and right subtrees
    private boolean color;     // color of parent link
    private int N;             // subtree count

    public Node(Key key, Value val, boolean color, int N) {
        this.key = key;
        this.val = val;
        this.color = color;
        this.N = N;
    }
}

// insert the key-value pair; overwrite the old value with the new value
// if the key is already present
public void put(Key key, Value val) {
    root = put(root, key, val);
    root.color = BLACK;
}

// insert the key-value pair in the subtree rooted at h
private Node put(Node h, Key key, Value val) { 
    if (h == null) return new Node(key, val, RED, 1);

    int cmp = key.compareTo(h.key);
    if      (cmp &lt; 0) h.left  = put(h.left,  key, val); 
    else if (cmp &gt; 0) h.right = put(h.right, key, val); 
    else              h.val   = val;

    // fix-up any right-leaning links
    if (isRed(h.right) &amp;&amp; !isRed(h.left))      h = rotateLeft(h);
    if (isRed(h.left)  &amp;&amp;  isRed(h.left.left)) h = rotateRight(h);
    if (isRed(h.left)  &amp;&amp;  isRed(h.right))     flipColors(h);
    h.N = size(h.left) + size(h.right) + 1;

    return h;
}
</code></pre>

<p>}
```</p>

<h4>2.5.5 删除操作</h4>

<h5>删除最小键</h5>

<p>先来看删除最小键。从树底部的3-结点删除键很简单，但2-结点则不然。为了保证我们不会删除一个2-结点，我们沿着左链接向下进行变换，确保当前结点不是2-结点。在沿着左链接向下的过程中，保证以下情况之一成立：</p>

<ul>
<li>如果当前结点的左子结点不是2-结点，完成；</li>
<li>如果当前结点的左子结点是2-结点而它的亲兄弟结点不是2-结点，将左子结点的兄弟结点中的一个键移到左子结点；</li>
<li>如果当前结点的左子结点和它的亲兄弟结点都是2-结点，将左子结点、父结点中的最小键和左子结点最近的兄弟结点合并为一个4-结点，使父结点由3-结点变为2-结点或者4-结点变为3-结点。</li>
</ul>


<p>在遍历的过程中执行这个过程，最后能够得到一个含有最小键的3-结点或者4-结点，然后我们就可以直接从中将其删除，将3-结点变为2-结点，或者将4-结点变为3-结点。然后我们再回头向上分解所有临时的4-结点。</p>

<p><img src="/myresource/images/IMG_20141002_232607.jpg" alt="image" /></p>

<h5>删除操作</h5>

<p>在查找路径上进行和删除最小键相同的变换同样可以保证在查找过程中任意当前结点均不是2-结点。如果被查找的键在树的底部，我们可以直接删除它。如果不在，我们需要将它和它的后续结点交换，就和二叉查找树一样。因为当前结点必然不是2-结点，问题已经转化为在一棵根结点不是2-结点的子树中删除最小键，我们可以在这棵子树中使用上面的算法。删除之后，同样需要向上回溯并分解余下的4-结点。</p>

<p><a href="/myresource/code/RedBlackBST.java">红黑树完整代码</a></p>

<h4>2.5.6 红黑树的性能</h4>

<p>一棵大小为N的红黑树的高度不会超过2lgN，根结点到任意结点的平均路径长度为1.00lgN，以下操作在最坏的情况下所需的时间是对数级别的：get, put, min, max, floor, ceiling, rank, select, deleteMin, deleteMax, delete, range。</p>

<h2>总结</h2>

<p>各种符号表实现的性能总结：</p>

<p><img src="/myresource/images/IMG_20141002_233353.jpg" alt="image" /></p>

<p>在信息世界的汪洋大海中，表的大小可能是上千亿，但我们仍然能够确保在几十次比较之内就完成这些操作！</p>
]]></content>
  </entry>
  
</feed>
