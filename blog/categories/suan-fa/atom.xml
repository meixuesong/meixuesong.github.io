<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 算法 | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/suan-fa/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2014-10-18T22:46:37+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[无向图]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/03/wu-xiang-tu/"/>
    <updated>2014-10-03T18:18:44+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/03/wu-xiang-tu</id>
    <content type="html"><![CDATA[<p>无向图由一组顶点(Vertex)和一组能够将两个顶点相连的边(Edge)组成。本章学习无向图的邻接表实现，以及相关的搜索和应用，例如深度优先和广度优先搜索，路径查找和最短路径计算，连通分量和符号图。</p>

<!--more-->


<h2>1. 术语</h2>

<p>v-w表示连接v和w的边。自环和平行边是两种特殊的图。<strong>自环</strong>即一条连接一个顶点和其自身的边；<strong>平行边</strong>是连接同一对顶点的两条边。含有平行边的图称为多重图，没有平行边和自环的图称为<strong>简单图</strong>。</p>

<p>当两个顶点通过一条边相连时，这两个顶点是<strong>相邻的</strong>。某个顶点的<strong>度数(Degree)</strong>即为依附于它的边的总数。<strong>子图</strong>是由一幅图的所有边的一个子集（以及它们所依附的所有顶点）组成的图。</p>

<p>在图中，<strong>路径</strong>是由边顺序连接的一系列顶点。<strong>简单路径</strong>是一条没有重复顶点的路径。<strong>环</strong>是一条至少含有一条边，并且起点和终点相同的路径。<strong>简单环</strong>是一条（除了起点和终点必须相同之外）不含有重复顶点和边的环。路径或环的<strong>长度</strong>为其中所包含的边数。</p>

<p>如果从任意一个顶点都存在一条路径到达另一个任意顶点，这幅图就是<strong>连通图</strong>。一幅非连通的图由若干连通的部分组成，它们都是其极大连通子图。</p>

<p>树是一幅无环(Acyclic)连通图。互不相连的树组成的集合称为<strong>森林</strong>。连通图的<strong>生成树</strong>是它的一幅子图，它含有图中的所有顶点且是一棵树。图的<strong>生成树森林</strong>是它的所有连通子图的生成树的集合。</p>

<p>当且仅当一幅含有V个顶点的图G满足下列5个条件之一时，它就是一棵树：</p>

<ul>
<li>G有V-1条边且不含有环；</li>
<li>G有V-1条边且是连通的；</li>
<li>G是连通的，但删除任意一条边都会使它不再连通；</li>
<li>G是无环图，但添加任意一条边都会产生一条环；</li>
<li>G中的任意一对顶点之间仅存在一条简单路径。</li>
</ul>


<h2>2. API</h2>

<p>先看一份定义了无向图的基本操作的API：</p>

<p><img src="/myresource/images/image_blog_2014-10-04_graph-api.png" alt="image" /></p>

<p>```java
//////////////////常用的图处理代码//////////////////</p>

<p>//计算v的度数
public static int degree(Graph G, int v) {</p>

<pre><code>int degree = 0;
for(int w: G.adj(v)) degree++;
return degree;
</code></pre>

<p>}</p>

<p>//计算所有顶点的最大度数
public static int maxDegree(Graph G) {</p>

<pre><code>int max = 0;
for(int v = 0; v &lt; G.V(); v++) 
    if (degree(G, v) &gt; max)
        max = degree(G, v);
return max;
</code></pre>

<p>}</p>

<p>//计算所有顶点的平均度数
public static double avgDegree(Graph G) {</p>

<pre><code>return 2.0 * G.E() / G.V(); 
</code></pre>

<p>}</p>

<p>//计算自环的个数
public static int numberOfSelfLoops(Graph G) {</p>

<pre><code>int count = 0;
for(int v = 0; v &lt; G.V(); v++)
    for(int w : G.adj(v))
        if (v == w) count++;
return count / 2; //每条边都被记过2次
</code></pre>

<p>}
```</p>

<h3>2.1 邻接表</h3>

<p>图有多种表示方法，包括邻接矩阵（V乘V的布尔矩阵，占用空间过大），边的数组（边类含有两个int实例变量，实现adj方法需要检查图中的所有边）和邻接表数组。</p>

<p>邻接表数组是以顶点为索引的列表数组，例如第0个顶点的列表中每个元素都是和顶点0相邻的顶点。示意图如下：</p>

<p><img src="/myresource/images/image_blog_2014-10-03_adjacency-lists.png" alt="image" /></p>

<p>它具有以下特点：</p>

<ul>
<li>使用的空间和V+E成正比；</li>
<li>添加一条边所需的时间为常数；</li>
<li>遍历顶点v的所有相邻顶点所需的时间和v的度数成正比。</li>
</ul>


<p>代码实现示意如下：</p>

<p>```java
public class Graph {</p>

<pre><code>private final int V;        //顶点数目
private int E;              //边的数目
private Bag&lt;Integer&gt;[] adj; //邻接表

public void addEdge(int v, int w) {
    adj[v].add(w);
    adj[w].add(v);
    E++;
}

public Iterable&lt;Integer&gt; adj(int v) {
    return adj[v];
}
</code></pre>

<p>}
```</p>

<h3>2.2 图的处理算法API</h3>

<p><img src="/myresource/images/image_blog_2014-10-04_search-api.png" alt="image" /></p>

<h2>3. 深度优先搜索(DFS)</h2>

<p>深度优先搜索一幅图，只需要一个递归方法来遍历所有顶点。在访问其中一个顶点时：</p>

<ul>
<li>将它标记为已访问；</li>
<li>递归地访问它的所有没有被标记过的邻居顶点。</li>
</ul>


<p>```java
//深度优先搜索
public class DepthFirstSearch {</p>

<pre><code>private boolean[] marked;
private int count;

public DepthFirstSearch(Graph G, int s) {
    marked = new boolean[G.V()];
    dfs(G, s);
}

private void dfs(Graph G, int v) {
    marked[v] = true;
    count++;
    for(int w : G.adj(v))
        if (!marked[w]) dfs(G, w);
}

public boolean marked(int w) {return marked[w];}

public int count() {return count;}
</code></pre>

<p>}
```</p>

<p>利用深度优先搜索很容易找到一些问题的答案。例如“两个给定的顶点是否连通？有多少个连通子图？从s到给定目的顶点v是否存在一条路径？如果有，找到这条路径。”</p>

<h2>4. 寻找路径</h2>

<p>路径的API:</p>

<p><img src="/myresource/images/image_blog_2014-10-04_paths-api.png" alt="image" /></p>

<p>```java
//使用深度优先搜索查找图的路径
public class DepthFirstPaths {</p>

<pre><code>private boolean[] marked;   //这个顶点上调用过dfs()吗？
private int[] edgeTo;       //从起点到一个顶点的已知路径上的最后一个顶点
private final int s;        //起点

public DepthFirstPaths(Graph G, int s) {
    marked = new boolean[G.V()];
    edgeTo = new int[G.V()];
    this.s = s;
    dfs(G, s);
}

private void dfs(Graph G, int v) {
    marked[v] = true;
    for(int w : G.adj(v))
        if (!marked[w]) {
            edgeTo[w] = v;
            dfs(G, w);
        }
}

public boolean hasPathTo(int v) {return marked[v];}

public Iterable&lt;Integer&gt; pathTo(int v) {
    if (!hasPathTo(v)) return null;
    Stack&lt;Integer&gt; path = new Stack&lt;Integer&gt;();
    for(int x = v; x != s; x = edgeTo[x])
        path.push(x);
    path.push(s);
    return path;
}
</code></pre>

<p>}
```</p>

<h2>5. 广度优先搜索(BFS)</h2>

<p>广度优先搜索可以解决单点最短路径的问题，即“从s到给定目的顶点v是否存在一条路径？如果有，找出其中最短的那条。”要找到从s到v的最短路径，从s开始，在所有由一条边就可以到达的顶点中寻找v，如果找不到就继续在与s距离两条边的所有顶点中找v，如此一直进行。实现广度优先搜索时，可以使用先进先出（FIFO）队列。代码示意如下：</p>

<p>```java
public class BreadthFirstPaths {</p>

<pre><code>private boolean[] marked;  //到达该顶点的最短路径已知吗？
private int[] edgeTo;      //到达该顶点的已知路径上的最后一个顶点
private final int s;       //起点

public BreadthFirstPaths(Graph G, int s) {
    marked = new boolean[G.V()];
    edgeTo = new int[G.v()];
    this.s = s;
    bfs(G, s);
}

private void bfs(Grapth G, int s) {
    Queue&lt;Integer&gt; queue = new Queue&lt;Integer&gt;();
    marked[s] = true;  //标记起点
    queue.enqueue(s);  //入列
    while (!queue.isEmpty()) {
        int v = queue.dequeue();
        for(int w : G.adj(v))
            if (!marked[w]) {
                edgeTo[w] = v;
                marked[w] = true;
                queue.enqueue(w);
            }
    }
}

public boolean hasPathTo(int v) {return marked[v];}

public Iterable&lt;Integer&gt; pathTo(int v) {//与深度优先实现相同}
</code></pre>

<p>}
```</p>

<h2>6. 连通分量</h2>

<p>所谓连通分量就是连通子图，深度优先搜索可用于找出一幅图的所有连通分量。其API定义如下：</p>

<p><img src="/myresource/images/image_blog_2014-10-04_cc-api.png" alt="image" /></p>

<p>递归的深度优先搜索第一次调用的参数是顶点0，它会标记所有与0连通的顶点。然后构造函数中的for循环会查找每个没有被标记的顶点并递归调用dfs()来标记和它相邻的所有顶点。代码如下：</p>

<p>```java
public class CC {</p>

<pre><code>private boolean[] marked;
private int[] id;
private int count = 0;

public CC(Graph G) {
    marked = new boolean[G.V()];
    id = new int[G.V()];
    for(int s = 0; s &lt; G.V(); s++)
        if (!marked[s]) {
            dfs(G, s);
            count++;
        }
}

private void dfs(Graph G, int v) {
    marked[v] = true;
    id[v] = count;
    for(int w : G.adj(v))
        if (!marked[w])
            dfs(G, w);
}

public boolean connected(int v, int w) { return id[v] == id[w]; }

public int id(int v) {return id[v]; }

public int count() {return count;}
</code></pre>

<p>}
```</p>

<p>深度优先搜索还可用于解决两个问题：1. 给定的图是无环图吗（假定不存在自环和平行边）？<a href="http://algs4.cs.princeton.edu/41undirected/Cycle.java.html">代码实现</a> 2. 这是一幅二分图吗？也就是说能够用两种颜色将图的所有顶点着色，使得任意一条边的两个端点的颜色都不相同。<a href="http://baike.baidu.com/view/501081.htm">二分图</a>，<a href="http://algs4.cs.princeton.edu/41undirected/Bipartite.java.html">代码实现</a></p>

<h2>7. 符号图</h2>

<p>在典型应用中，通常使用字符串而非整数来表示和指代顶点。为了适应这样的应用，需要符号图。符号图使用字符串代替整数索引。其API定义如下：</p>

<p><img src="/myresource/images/image_blog_2014-10-04_symbol-graph-api.png" alt="image" /></p>

<p>符号图的实现可以在无向图的基础上增加一个符号表和反向索引。符号表完成符号到邻接表索引的映射，键为String(顶点名)，值的类型为int(邻接表的索引)。反向索引是一个数组keys[]，保存每个顶点索引所对应的顶点名。结构如下图：</p>

<p><img src="/myresource/images/image_blog_2014-10-04_symbol-graph.png" alt="image" /></p>

<p>其实现较为简单，<a href="http://algs4.cs.princeton.edu/41undirected/SymbolGraph.java.html">查看代码</a>。</p>

<p>利用符号图可以处理一个经典问题，找到一个社交网络中两个人间隔的度数。这其实就是用符号图+广度优先求最短路径的用例。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[散列表(HashTable)]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/03/san-lie-biao/"/>
    <updated>2014-10-03T10:03:40+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/03/san-lie-biao</id>
    <content type="html"><![CDATA[<p>散列表也是一种符号表，它通过算法将键转化为数组的索引来访问数组中的键值对。散列表查找的第一步是用散列函数将被查找的键转化为一数组索引，第二步是处理碰撞冲突。解决碰撞冲突的方法有拉链法和线性探测法。</p>

<!--more-->


<h2>1. 散列函数</h2>

<p>散列函数用于将键转化为数组的索引，它应该易于计算并且能够均匀分布所有的键。散列函数和键的类型有关，对于每种类型的键都需要一个与之对应的散列函数。</p>

<p>Java对正整数采用除留余数法计算散列值。选择大小为素数M的数组，对于任意正整数k，计算余数：<code>k%M</code>，能够有效地将键散布在0到M-1的范围内。素数又称为质数，是一个大于1的自然数，除了1和它本身外，不能被其他自然数整除（除0以外）的数。Java对浮点数会将键表示为二进制数然后再使用除留余数法。对字符串采用类似Homer方法，用N次乘法、加法和取余来计算散列值。</p>

<p>对Java程序，<code>hashCode()</code>和<code>equals()</code>方法必须一致。如果<code>equals()</code>返回<code>true</code>那么<code>hashCode()</code>返回值必须一致，反过来则可以不同。</p>

<h2>2. 基于拉链法的散列表</h2>

<p>当<code>hashCode()</code>返回值相同，但<code>equals()</code>为false时，就发生了碰撞。解决碰撞的一种方法是拉链法。拉链法是指数组中的每个元素都指向一个链表，链表中的每个结点都存储了散列值为该元素的索引的键值对。因此这样的散列表由数组+链表构成。查找时先根据散列值找到对应的链表，然后沿着链表顺序查找相应的键。</p>

<p><img src="/myresource/images/image_blog_2014-10-03_separate-chaining.png" alt="image" /></p>

<p>可以看出，散列表的查找性能与散列表的大小有很大关系，对N个元素来说，当散列表的大小M过小时，碰撞机率就会增加，链表的长度必然增加，从而降低了查找效率。因此在内存不紧张时，可以选择一个足够大的M，内存紧张时，选择尽量大的M。另一种方法是动态调整数据的大小以保持短小的链表。</p>

<p>执行删除操作时，先用散列值找到索引及对应的链表，然后调用链表的删除方法即可。</p>

<p>对于有序性相关的符号表操作，散列表都不是合适的选择，因为这些操作的运行时间都是线性的。</p>

<p>Java的TreeMap和HashMap分别是基于红黑树和拉链法的散列表的符号表实现。</p>

<h2>3. 基于线性探测法的散列表</h2>

<p>实现散列表的另一种方式是用大小为M的数组保存N个键值对，其中M>N。依靠数据中的空位解决碰撞冲突。基于这种策略的所有方法都统称为开放地址散列表。其中最简单的方法叫做线性探测法：当碰撞发生时，直接检查散列表的下一个位置（索引加1），可能产生三种结果：</p>

<ul>
<li>命中，该位置的键和被查找的键相同；</li>
<li>未命中，键为空（该位置没有键）；</li>
<li>继续查找，该位置的键和被查找的键不同。</li>
</ul>


<p>其核心思想是与其将内存用作链表，不如将它们作为散列表的空元素。即用散列函数找到索引，检查其中的键和被查找的键是否相同。如果不同则继续查找（增加索引，到达数组结尾后再折回数组开头），直到找到该键或者遇到一个空元素。过程如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10-03_linear-probing.png" alt="image" /></p>

<p>在基于线性探测法的散列表中执行删除操作比较复杂，如果将该键所在位置为为null是不行的。需要将簇中被删除键的右侧的所有键重新插入散列表。</p>

<p>这种散列表的性能也依赖于N/M，但在这里表示散列表的利用率。如果利用率达到1，即散列表满了，会造成未命中的查找无限循环。为了保证性能，要动态调整数组的大小来保证利用率在1/8到1/2之间。</p>

<h2>4. 数组的大小和内存使用</h2>

<p>对于线性探测法，调整数组的大小是必需的。对于拉链法，如果你能准确估计所需的散列表大小N，调整数据的工作不是必需的，只需要根据查找耗时和<code>(1+N/M)</code>成正比来选取一个适当的M即可。</p>

<p>符号表的内存使用：</p>

<table>
<thead>
<tr>
<th>方法 </th>
<th> N个元素所需的内存（引用类型）</th>
</tr>
</thead>
<tbody>
<tr>
<td>基于拉链法的散列表 </td>
<td> ~48N + 32M</td>
</tr>
<tr>
<td>基于线性探测的散列表 </td>
<td> 在~32N和~128N之间</td>
</tr>
<tr>
<td>各种二叉查找树 </td>
<td> ~56N</td>
</tr>
</tbody>
</table>


<h2>Q&amp;A</h2>

<p>Q: Java的Integer, Double和Long类型的hashCode()是如何实现的？</p>

<blockquote><p>Integer类型直接返回该整数的32位值。对Double和Long返回机器表示的前32位和后32位异或的结果。</p></blockquote>

<p>Q: 为什么不将<code>hash(x)</code>实现为<code>x.hashCode() % M</code>?</p>

<blockquote><p>Java中，取余的结果可能是负数。</p></blockquote>

<p>Q: 为什么不将<code>hash(x)</code>实现为<code>Math.abs(x.hashCode()) % M</code>?</p>

<blockquote><p>对于最大的整数<code>Math.abs()</code>会返回一个负值，这种溢出可能使程序崩溃。</p></blockquote>

<p>Q: 在拉链法中，链表是否可以使用二叉查找树或者红黑树？</p>

<blockquote><p>一般来说，散列表碰撞机率越少越好，因此链表越短越好。所以链表的初级实现的性能一般会更好，特殊情况下最好由专家进行这种调优。</p></blockquote>

<p>Q: 散列表的查找比红黑树更快吗？</p>

<blockquote><p>取决于键的类型，也就是hashCode()的计算成本是否大于compareTo()的比较成本。但通常散列表会比红黑树快得多。但散列表无法高效支持有序性相关的操作。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[符号表]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/02/cha-zhao-suan-fa-fu-hao-biao/"/>
    <updated>2014-10-02T11:26:20+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/02/cha-zhao-suan-fa-fu-hao-biao</id>
    <content type="html"><![CDATA[<p>符号表就是用键和值的方式来存储和检索数据。其关键点在于如何快速检索和高效插入。本章介绍了符号表的简单实现、二叉查找树、红黑树的实现。</p>

<!--more-->


<p>首先还是来定义一下简单的符号表API：</p>

<p><img src="/myresource/images/image_blog_20141002_170641.jpg" alt="image" /></p>

<h2>1. API定义</h2>

<p>符号表遵循以下规则：</p>

<ul>
<li>每个键只对应一个值；</li>
<li>当存入的键值对和表中已有的键冲突时，新的值会替代旧的值；</li>
<li>键不能为空；</li>
<li>值不允许为空；</li>
</ul>


<p>在简单的符号表中，键的等价性由equals()方法保证。而很多典型应用中，键都是Comparable对象，因此有序符号表可以保持键的有序并扩展其API：</p>

<p><img src="/myresource/images/image_blog_20141002_170651.jpg" alt="image" /></p>

<ul>
<li>floor：向下取整，找出小于等于该键的最大键；</li>
<li>ceiling：向上取整，找出大于等于该键的最小键；</li>
<li>rank：小于key的键的数量；</li>
<li>select：获得排名为第k的键。</li>
</ul>


<p>对于0到size()-1的所有i都有：i == rank(select(i))，且所有键都满足：key == select(rank(key))。</p>

<h2>2. 实现</h2>

<h3>2.1 无序链表的顺序查找</h3>

<p>可以用链表来实现符号表，每个结点存储一个键值对，并保持一个链接指向下一个结点。这种方式非常简单，但是效率非常低。不论是get方法还是put方法，都需要从首节点开始一个一个地遍历。</p>

<h3>2.2 有序数组中的二分查找</h3>

<p>另一种实现方法是通过两个平行的数组来存储符号表。一个储存键，一个存储值。二分法可以用于保证数组中Comparable类型的键有序，并高效地实现get和其他操作(如select)。</p>

<p>对N个键的有序数组进行二分查找最多需要（lgN + 1）次比较。然而put方法却仍然很慢，向大小为N的有序数组插入一个新的元素，在最坏的情况下需要访问约2N次数组。因此向一个空的符号表插入N个元素时，最坏的情况下需要访问约N<sup>2</sup>次数组。</p>

<p>因此，我们需要一种结构，能够同时拥有二分法的查找效率和链表的插入效率。这就是二叉查找树。</p>

<h3>2.3 二叉查找树(BST)</h3>

<p>二叉查找树的定义：它是一棵二叉树，其中每个结点都含有一个Comparable的键以及相关联的值，每个结点的键都大于其左子树任意结点的键，同时小于右子树任意结点的键。</p>

<h4>2.3.1 基本实现</h4>

<p>如果将一棵二叉查找树的所有键投影到一条直线上，我们可以得到一条有序的键列，如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_15.10.37.png" alt="image" /></p>

<p>树结点的实现：</p>

<p>```java</p>

<pre><code>private class Node {
    private Key key;           // sorted by key
    private Value val;         // associated data
    private Node left, right;  // left and right subtrees
    private int N;             // number of nodes in subtree

    public Node(Key key, Value val, int N) {
        this.key = key;
        this.val = val;
        this.N = N;
    }
}
</code></pre>

<p>```</p>

<h5>查找</h5>

<p>可以使用递归算法在二叉查找树中查找一个键：如果树是空的，则查找未命中；如果被查找的键和根结点的键相等，查找命中；否则就（递归地）在某个子树中继续查找。如果被查找的键较小就选择左子树，较大则选择右子树。查找过程与二分查找一样简单，代码实现如下：</p>

<p>```java</p>

<pre><code>public Value get(Key key) {
    return get(root, key);
}

private Value get(Node x, Key key) {
    if (x == null) return null;
    int cmp = key.compareTo(x.key);
    if      (cmp &lt; 0) return get(x.left, key);
    else if (cmp &gt; 0) return get(x.right, key);
    else              return x.val;
}
</code></pre>

<p>```</p>

<h5>插入</h5>

<p>二叉查找树的插入实现难度和查找差不多。当查找到一个不存在于树中的结点并结束于一条空链接时，我们需要做的就是将链接指向一个含有被查找的键的新结点。代码实现如下：</p>

<p>```java</p>

<pre><code>public void put(Key key, Value val) {
    if (val == null) { delete(key); return; }
    root = put(root, key, val);
}

private Node put(Node x, Key key, Value val) {
    if (x == null) return new Node(key, val, 1);
    int cmp = key.compareTo(x.key);
    if      (cmp &lt; 0) x.left  = put(x.left,  key, val);
    else if (cmp &gt; 0) x.right = put(x.right, key, val);
    else              x.val   = val;
    x.N = 1 + size(x.left) + size(x.right);
    return x;
}
</code></pre>

<p>```</p>

<h5>分析</h5>

<p>二叉查找树的算法效率取决于树的形状。在最好的情况下，树是完全平衡的，此时查找和插入的效率都非常高。</p>

<p>但是，树的结构与结点插入的顺序是相关的。在最坏的情况下（例如升序队列中的元素按顺序插入）可能形成一条单边的树，就变成了链表的结构。这种不平衡的树完全失去了二分查找的效率。</p>

<p>因此，如何保持树的平衡是一个重要问题。要在二叉树动态插入中保证树的完美平衡，代价太高了。因此需要对结构进行一些调整，这就是平衡查找树。</p>

<h3>2.4 2-3查找树</h3>

<p>所谓2-3查找树，是指它或者为一棵空树，或者由以下结点组成：</p>

<ul>
<li>2-结点，含有一个键（及其对应的值）和两条链接，左链接指向的树的所有键都小于该结点，右链接指向的树的所有键都大于该结点。</li>
<li>3-结点，含有两个键（及其对应的值）和两条链接，左链接指向的树的所有键都小于该结点，中链接指向的树的所有键都位于该结点的两个键之间，右链接指向的树的所有键都大于该结点。</li>
</ul>


<p>利用2-3查找树，可以方便地实现完美平衡的查找树，2-3查找树示意图如下：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_17_49.png" alt="image" /></p>

<h4>2.4.1 查找</h4>

<p>查找的过程与二叉查找树类似，区别仅在于3-结点树多了一个中链接。</p>

<h4>2.4.2 插入</h4>

<p>2-3查找树实现平衡的关键是插入过程，插入时先进行查找，如果未命中，将根据结束位置的多种情况，采用不同的方法。详细说明如下：</p>

<h5>向2-结点插入新键</h5>

<p>如果查找结束于一个2-结点，只要把这个2-结点替换为一个3-结点，将要插入的键保存在其中即可。如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_23tree-insert2.png" alt="image" /></p>

<h5>向一棵只含有一个3-结点的树中插入新键</h5>

<p>向3-结点的树中插入新键，也有多种情况，先看最简单的这种。如下图所示，先将3-结点变成4-结点，然后再分解为2-3树。</p>

<p><img src="/myresource/images/image_blog_2014-10-02_23tree-insert3a.png" alt="image" /></p>

<h5>向一个父结点为2-结点的3-结点插入新键</h5>

<p>如果父结点为2-结点，则先把3-结点变成4-结点，然后将2-结点变成3-结点，如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_23tree-insert3b.png" alt="image" /></p>

<h5>向一个父结点为3-结点的3-结点插入新键</h5>

<p>跟前一步一样，先变成4-结点并分解它，然后再将它的中键插入它的父结点中。但其父结点也是3-结点，因此再用这个中键构造一个临时的4-结点，进行相同的变化，直到遇到一个2-结点将它变成3-结点。如果一直到根结点都是3-结点，则需要分解根结点。插入新键的过程如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10_02_23tree-insert3c.png" alt="image" /></p>

<h5>分解根结点</h5>

<p>在上一步中，根结点变成了一个临时的4-结点，此时我们按照向一棵只有一个3-结点的树中插入新键的方法处理此问题。将4-结点分解成3个2-结点，树高加1。如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_23tree-split.png" alt="image" /></p>

<h4>2.4.3 性能分析</h4>

<p>从上面这些情况可以看出，插入过程都是进行局部变换，除了相关的结点和链接之外不必修改或检查树的其他部分，因此效率非常高。经过变换后，保持了树的有序性和平衡性。因此在一棵大小为N的2-3树中，查找和插入操作访问的结点必然不超过lgN个！例如含有10亿个结点的一棵2-3树的高度仅在19-30之间，最多只需要访问30个结点就能够在10亿个键中进行任意查找和插入操作，这是多么惊人！这也是<a href="/blog/2014/08/25/cheng-xu-yuan-de-shu-zi/">程序员的数学</a>中提到的利用指数爆炸解决问题。</p>

<h3>2.5 红黑二叉查找树</h3>

<p>2-3查找树很容易理解，现在我们通过红黑二叉树来表达并实现它。其关键是3-结点如何实现。我们将树中的链接分为两种类型：红链接将两个2-结点连接起来构成一个3-结点，黑链接则是普通链接。如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_redblack-encoding.png" alt="image" /></p>

<p>红黑树是含有红黑链接并满足以下条件的二叉查找树：</p>

<ul>
<li>红链接均为左链接；</li>
<li>没有任何一个结点同时和两条红链接相连；</li>
<li>该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。</li>
</ul>


<p>因此在节点类（Node）中，增加一个属性color表示从父结点指向自己的链接是否为红链接：</p>

<p>```java</p>

<pre><code>private class Node {
    private Key key;           // sorted by key
    private Value val;         // associated data
    private Node left, right;  // left and right subtrees
    private int N;             // number of nodes in subtree
    boolean color;             //是否红链接    

    public Node(Key key, Value val, int N, boolean color) {
        this.key = key;
        this.val = val;
        this.N = N;
        this.color = color;
    }
}
</code></pre>

<p>```</p>

<p>在进一步实现红黑树之前，要了解几个基本的动作：左旋转、右旋转和颜色转换。</p>

<h4>2.5.1 旋转</h4>

<p>左旋转是将一条红色的右链接转化为左链接。转换的过程为：将两个键中的较小者作为根结点变为将较大者作为根结点。如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_redblack-left-rotate.png" alt="image" /></p>

<p>右旋转是将一条红色的左链接转化为右链接，实现过程与左旋转相似，只需要将left和right互换即可：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_redblack-right-rotate.png" alt="image" /></p>

<h4>2.5.2 颜色转换</h4>

<p>颜色转换是对一个结点的两个红色子结点的颜色进行转换。除了将子结点的颜色由红变黑外，还要同时将父结点的颜色由黑变红。如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_color-flip.png" alt="image" /></p>

<h4>2.5.3 插入处理过程</h4>

<p>插入新键时，都使用红链接与父结点相连，然后谨慎地使用左旋转、右旋转和颜色转换这三个简单的操作，就能够保证操作后的红黑树与2-3树一一对应的关系。在沿着插入点到根结点的路径向上移动时在所经过的每个结点中顺序完成以下操作，我们就能完成插入操作：</p>

<ol>
<li>如果右子结点是红色，而左子结点是黑色，进行左旋转；</li>
<li>如果左子结点是红色，且它的左子结点也是红色，进行右旋转；</li>
<li>如果左右子结点都是红色，进行颜色转换。</li>
</ol>


<p>下面是各种情况的示例：</p>

<p><img src="/myresource/images/IMG_20141002_222628.jpg" alt="image" /></p>

<p><img src="/myresource/images/IMG_20141002_222714.jpg" alt="image" /></p>

<h4>2.5.4 插入算法的实现</h4>

<p>以下为红黑树的插入算法：</p>

<p>```java
public class RedBlackBST<Key extends Comparable<Key>, Value> {</p>

<pre><code>private static final boolean RED   = true;
private static final boolean BLACK = false;

private Node root;     // root of the BST

// BST helper node data type
private class Node {
    private Key key;           // key
    private Value val;         // associated data
    private Node left, right;  // links to left and right subtrees
    private boolean color;     // color of parent link
    private int N;             // subtree count

    public Node(Key key, Value val, boolean color, int N) {
        this.key = key;
        this.val = val;
        this.color = color;
        this.N = N;
    }
}

// insert the key-value pair; overwrite the old value with the new value
// if the key is already present
public void put(Key key, Value val) {
    root = put(root, key, val);
    root.color = BLACK;
}

// insert the key-value pair in the subtree rooted at h
private Node put(Node h, Key key, Value val) { 
    if (h == null) return new Node(key, val, RED, 1);

    int cmp = key.compareTo(h.key);
    if      (cmp &lt; 0) h.left  = put(h.left,  key, val); 
    else if (cmp &gt; 0) h.right = put(h.right, key, val); 
    else              h.val   = val;

    // fix-up any right-leaning links
    if (isRed(h.right) &amp;&amp; !isRed(h.left))      h = rotateLeft(h);
    if (isRed(h.left)  &amp;&amp;  isRed(h.left.left)) h = rotateRight(h);
    if (isRed(h.left)  &amp;&amp;  isRed(h.right))     flipColors(h);
    h.N = size(h.left) + size(h.right) + 1;

    return h;
}
</code></pre>

<p>}
```</p>

<h4>2.5.5 删除操作</h4>

<h5>删除最小键</h5>

<p>先来看删除最小键。从树底部的3-结点删除键很简单，但2-结点则不然。为了保证我们不会删除一个2-结点，我们沿着左链接向下进行变换，确保当前结点不是2-结点。在沿着左链接向下的过程中，保证以下情况之一成立：</p>

<ul>
<li>如果当前结点的左子结点不是2-结点，完成；</li>
<li>如果当前结点的左子结点是2-结点而它的亲兄弟结点不是2-结点，将左子结点的兄弟结点中的一个键移到左子结点；</li>
<li>如果当前结点的左子结点和它的亲兄弟结点都是2-结点，将左子结点、父结点中的最小键和左子结点最近的兄弟结点合并为一个4-结点，使父结点由3-结点变为2-结点或者4-结点变为3-结点。</li>
</ul>


<p>在遍历的过程中执行这个过程，最后能够得到一个含有最小键的3-结点或者4-结点，然后我们就可以直接从中将其删除，将3-结点变为2-结点，或者将4-结点变为3-结点。然后我们再回头向上分解所有临时的4-结点。</p>

<p><img src="/myresource/images/IMG_20141002_232607.jpg" alt="image" /></p>

<h5>删除操作</h5>

<p>在查找路径上进行和删除最小键相同的变换同样可以保证在查找过程中任意当前结点均不是2-结点。如果被查找的键在树的底部，我们可以直接删除它。如果不在，我们需要将它和它的后续结点交换，就和二叉查找树一样。因为当前结点必然不是2-结点，问题已经转化为在一棵根结点不是2-结点的子树中删除最小键，我们可以在这棵子树中使用上面的算法。删除之后，同样需要向上回溯并分解余下的4-结点。</p>

<p><a href="/myresource/code/RedBlackBST.java">红黑树完整代码</a></p>

<h4>2.5.6 红黑树的性能</h4>

<p>一棵大小为N的红黑树的高度不会超过2lgN，根结点到任意结点的平均路径长度为1.00lgN，以下操作在最坏的情况下所需的时间是对数级别的：get, put, min, max, floor, ceiling, rank, select, deleteMin, deleteMax, delete, range。</p>

<h2>总结</h2>

<p>各种符号表实现的性能总结：</p>

<p><img src="/myresource/images/IMG_20141002_233353.jpg" alt="image" /></p>

<p>在信息世界的汪洋大海中，表的大小可能是上千亿，但我们仍然能够确保在几十次比较之内就完成这些操作！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[优先队列]]></title>
    <link href="http://blog.ubone.com/blog/2014/09/27/you-xian-dui-lie/"/>
    <updated>2014-09-27T23:08:56+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/09/27/you-xian-dui-lie</id>
    <content type="html"><![CDATA[<p>优先队列是广泛使用的一种抽象数据类型。例如如果你需要从10亿个元素中选出最大的十个，你不可能对10亿规模的数组排序。对于这些类似的场景，我们不一定要求它们全部有序，或者不一定要一次就将它们排序。我们会收集一些元素，处理当前键值最大的元素，然后再收集更多的元素，再处理当前键值最大的元素。例如应用程序的事件优先级，模拟系统，任务调度等。在这种情况下，优先队列应该支持两种操作：<strong>删除最大元素和插入元素。</strong></p>

<!--more-->


<h2>1. API</h2>

<p>先定义优先队列的API框架：</p>

<p>```java
public interface IMaxPQ<T extends Comparable<T>> {</p>

<pre><code>public void insert(T v);
public T max();
public T delMax();
public boolean isEmpty();
public int size();
</code></pre>

<p>}
```</p>

<h2>2. 实现方法</h2>

<p>优先队列可以使用有序或无序的数组或链表来实现。其思路非常简单，插入时，向数组或链表增加元素。如果数组或链表是有序的，新元素就应该在适当的位置。而删除时，找出最大的元素进行删除。</p>

<p>上面的实现方法性能非常差，在最坏的情况下，需要线性时间来完成。而基于堆的实现则能够保证更好的性能。</p>

<h3>2.1 堆的定义</h3>

<p>在二叉堆的数组中，每个元素都要保证大于等于另外两个特定位置的元素。如果把所有元素画成一棵二叉树，就是父结点要大于等于子结点，此时表示<strong>堆有序</strong>。</p>

<p>完全二叉树只用数组就可以表示。根结点在位置1，其子结点在位置2和3。位置k的结点的父结点的位置为k/2, 它的两个子结点的位置分别为2k和2k+1。</p>

<h3>2.2 堆的算法</h3>

<p>堆的有序化过程涉及上浮和下沉。当某个结点的优先级上升时，我们需要由下至上恢复堆的顺序（上浮）。当某个结点的优先级下降时，我们需要由上至下恢复堆的顺序（下沉）。</p>

<h4>2.2.1 上浮</h4>

<p>如果某个结点的优先级上升，比它的父结点更大，那么就需要交换它和它的父结点。交换后，还要继续判断是否比现在的父结点更大，一直到遇到更大的父结点。</p>

<h4>2.2.2 下沉</h4>

<p>下沉与上浮正好相反，当某个结点的优先级下降时，需要<strong>与它的两个结点中的较大者比较</strong>，如果比子结点小，就进行交换。交换后继续与子结点比较，直到比它的两个子结点都大。</p>

<h4>2.2.3 算法实现</h4>

<p>```java
public class MaxPQ<T extends Comparable<T>> implements IMaxPQ<T>{</p>

<pre><code>private T[] pq;
private int n = 0;

public MaxPQ(int maxN) {
    pq = (T[]) new Comparable[maxN + 1];
}

@Override
public void insert(T v) {
    pq[++n] = v;
    swim(n);
}

@Override
public T max() {
    if (n &gt; 0) {
        return pq[1];
    }

    return null;
}

@Override
public T delMax() {
    T max = pq[1];    //根结点最大
    exchange(1, n--); //与最后一个结点交换
    pq[n + 1] = null; //防止对象游离
    sink(1);          //恢复堆的有序性

    return max;
}

@Override
public boolean isEmpty() {
    return n == 0;
}

@Override
public int size() {
    return n;
}

private boolean less(int i, int j) {
    return pq[i].compareTo(pq[j]) &lt; 0;
}

private void exchange(int i, int j) {
    T t = pq[i]; pq[i] = pq[j]; pq[j] = t;
}

//上浮
private void swim(int k) {
    while (k &gt; 1 &amp;&amp; less(k / 2, k)) {
        exchange(k / 2, k);
        k = k / 2;
    }
}

//下沉
private void sink(int k) {
    while (2 * k &lt;= n) {
        int j = 2 * k;
        if (j &lt; n &amp;&amp; less(j, j + 1)) {
            j++;
        }

        if (!less(k, j)) {
            break;
        }

        exchange(k, j);
        k = j;
    }
}
</code></pre>

<p>}
```</p>

<p><strong>对于含有N个元素的基于堆的优先队列，插入元素操作只需不超过(lgN + 1)次比较，删除最大元素的操作需要不超过2lgN次比较！</strong></p>

<h4>2.2.4 多叉堆</h4>

<p>用数组表示的完全三叉树构造堆也很容易。位置k的结点大于等于3k-1, 3k, 3k+1的结点，小于等于位于(k+1)/3的结点。甚至任意的d叉树也不困难，只是需要平衡在树高和每个结点的d个子结点中找到最大值的代价。</p>

<h4>2.2.5 动态数组大小</h4>

<p>上面代码中的数组大小是固定的，如果要实现动态数组大小，只需要根据情况在insert中增加数组长度，在delMax中减少数组长度。</p>

<h2>3. 堆排序</h2>

<p>使用优先队列，我们有了一种新的排序方法：堆排序。把所有元素插入一个查找最小元素的优先队列，然后重复调用删除最小元素的操作来将它们按顺序删除。</p>

<p>堆排序分为两个阶段：构造堆和下沉排序。</p>

<h3>3.1 堆的构造</h3>

<p>对于N个给定元素的数组，最简单的堆构造方法是从左至右遍历数组，用swim()保证指针左侧的所有元素已经是一棵堆有序的完全树。但一个更聪明更高效的办法是从右至左用sink()函数构造子堆。如果一个结点的两个子结点都已经是堆了，那么在该结点上调用sink可以将它们变成一个堆。这个过程会递归地建立起堆的秩序。开始时我们只需要扫描数据中的一半元素，最后在位置1上调用sink方法，扫描结束。</p>

<h3>3.2 下沉排序</h3>

<p>当堆构造完成后，将堆中的最大元素删除，然后放到堆缩小后数组中空出的位置。</p>

<h3>3.3 算法实现</h3>

<p>```java
public class PQSort {</p>

<pre><code>public void sort(Comparable[] a) {
    int n = a.length;
    //构造堆
    for(int k = n/2; k &gt;= 1; k--) {
        sink(a, k, n);
    }

    //下沉排序
    while (n &gt; 1) {
        exchange(a, 1, n--);
        sink(a, 1, n);
    }
}

private void sink(Comparable[] a, int k, int n) {
    while (2 * k &lt;= n) {
        int j = 2 * k;
        if (j &lt; n &amp;&amp; less(a, j, j+1)) {
            j++;
        }

        if (!less(a, k, j)) {
            break;
        }

        exchange(a, k, j);
        k = j;
    }
}

private static boolean less(Comparable[] a, int i, int j) {
    //要减1
    return a[i - 1].compareTo(a[j - 1]) &lt; 0;
}

private static void exchange(Comparable[] a, int i, int j) {
    //要减1
    Comparable t = a[i - 1];
    a[i - 1] = a[j - 1];
    a[j - 1] = t;
}
</code></pre>

<p>}
```
对于一百万随机整数，排序时间大约在750ms。</p>

<p>用堆实现的优先队列在现代应用程序中越来越重要，因为它能在<strong>插入操作和删除最大元素操作</strong>混合的动态场景中保证对数级别的运行时间。</p>

<h2>小结</h2>

<p>学完了常用的算法，总结一下。各种算法的性能特点如下表：</p>

<p><img src="/myresource/images/IMG_20140928_224145.jpg" alt="image" /></p>

<p>快速排序是最快的通用排序算法。</p>

<p>Java中，java.util.Arrays.sort()方法会根据不同的参数类型选择排序方法。对于原始数据类型使用（三向切分）快速排序，对引用类型使用归并排序。这种选择实际上暗示着用速度和空间（对于原始数据类型）来换取稳定性（对于引用类型）。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快速排序算法]]></title>
    <link href="http://blog.ubone.com/blog/2014/09/27/kuai-su-pai-xu-suan-fa/"/>
    <updated>2014-09-27T10:38:32+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/09/27/kuai-su-pai-xu-suan-fa</id>
    <content type="html"><![CDATA[<p>快速排序可能是应用最广泛的算法，原因是它实现简单、速度快。它完美地实现了原地排序（只需要一个很小的辅助栈），并且时间与NlgN成正比。它的内循环比大多数排序算法都要短小，因此理论上要更快。但它的主要缺点是非常脆弱，实现时要非常小心才能避免低劣的性能。</p>

<!--more-->


<h2>1. 算法理论</h2>

<p>快速算法也是一种分治的排序算法，它将一个数组分成两个子数组，将两部份独立地排序。但与归并排序将两个子数组分别排序再归并到整个数组排序不同，快速排序时，当两个子数组都有序时整个数组也就自然有序了。</p>

<p>快速排序算法的关键是切分，通过切分使数组满足下面三个条件：</p>

<ol>
<li>对于某个j, a[j]已经排定;</li>
<li>a[lo]到a[j-1]中的所有元素都不大于a[j];</li>
<li>a[j+1]到a[hi]中的所有元素都不小于a[j];</li>
</ol>


<p>因为切分过程总能排定一个元素，因此递归调用切分过程就能够正确地将数组排序。切分实现方法如下：先随意取a[lo]作为切分元素，然后从数组的左端开始向右扫描直到找到一个大于等于它的元素，再从数组右端向左扫描直到找到一个小于等于它的元素，交换它俩的位置。如此继续，当两个指针相遇时，只需要将切分元素和左子数组最右侧的元素a[j]交换然后返回j即可。j即满足上述三个条件。</p>

<h2>2. 算法实现</h2>

<p>下面是排序算法的实现。需要注意的是还有几个细节需要完善，它们可能导致错误或影响性能。</p>

<p>```java
public class Quick extends AbstractSort {</p>

<pre><code>@Override
public void sort(Comparable[] a) {
    StdRandom.shuffle(a); //打乱数组，消除对输入的依赖
    sort(a, 0, a.length - 1);
}

private static void sort(Comparable[] a, int lo, int hi) {
    if (hi &lt;= lo) return;

    int j = partition(a, lo, hi);
    sort(a, lo, j - 1);
    sort(a, j + 1, hi);
}

private static int partition(Comparable[] a, int lo, int hi) {
    //i, j分别代表左右扫描指针
    int i = lo, j = hi + 1;
    Comparable v = a[lo]; //选择切分元素

    while(true) {
        //从左往右扫描
        while (less(a[++i], v)) {
            if (i == hi) break; //冗余，可以去除。
        }

        //从右往左扫描
        while (less(v, a[--j])) {
            if (j == lo) break; //冗余，可以去除。
        }

        //检查两指针是否相遇
        if (i &gt;= j) break; 

        exchange(a, i, j);
    }

    //与切分元素交换
    exchange(a, lo, j);

    //现在满足：a[lo .. j-1] &lt;= a[j] &lt;= a[j+1 .. hi]
    return j;
}
</code></pre>

<p>}
//对一百万个随机整数排序，时间大致在350ms，但加上shuffle后，时间在600多ms.
```</p>

<h2>3. 性能特点</h2>

<p>快速排序算法的内循环用一个递增的索引将数组元素和一个定值比较，因此内循环非常短。归并和希尔排序需要在内循环中移动数据，所以它们通常比快速排序要慢一些。</p>

<p>快速排序算法的另一个优势是比较的次数很少。其效率最终还是依赖切分数组的效果。最好的情况下，每次都正好能将数组对半分。尽管事情并不总会这么顺利，但平均而言切分元素都能落在数组的中间。如果将切分位置的概率考虑到算法中，将使递归更复杂，而结果还是类似的。</p>

<p>它有一个潜在的缺点，切分不平衡时效率会相当低效。例如第一次从最小的元素切分，第二次从第二小的元素切分。。。这样每次调用只会移除一个元素。这也是快速排序前先随机排序(shuffle)的主要原因。</p>

<h2>4. 算法改进</h2>

<p>如果排序代码会执行很多次或者将用在大型数组上，那么就需要进行一些改进。</p>

<h3>4.1 切换到插入排序</h3>

<p>由于小数组的快速排序比插入排序慢，并且小数组时的递归调用也会消耗资源，因此在排序小数组时应该切换到插入排序。</p>

<p>可以在sort方法中，将<code>if (hi &lt;= lo) return;</code>替换为：<code>if (hi &lt;= lo + M) {Insertion.sort(a, lo, hi); return;}</code>。M的最佳值和系统相关，但一般在5~15之间在大多数情况下都能令人满意。</p>

<h3>4.2 三取样切分</h3>

<p>第二个改进的方法是使用子数组的一小部分元素的中位数来切分数组。人们发现将取样大小设为3并用大小居中的元素切分效果最好。</p>

<h3>4.3 熵最优的排序</h3>

<p>对于有大量重复元素的数组，快速排序算法仍然会递归调用，而三向切分的快速排序算法可以更好地处理这种情况。</p>

<p>```
public class Quick3way extends AbstractSort {</p>

<pre><code>@Override
public void sort(Comparable[] a) {
    StdRandom.shuffle(a); //打乱数组，消除对输入的依赖
    sort(a, 0, a.length - 1);
}

private static void sort(Comparable[] a, int lo, int hi) {
    if (hi &lt;= lo) return;

    int lt = lo, i = lo + 1, gt = hi;
    Comparable v = a[lo];
    while (i &lt;= gt) {
        int cmp = a[i].compareTo(v);
        if (cmp &lt; 0) {
            exchange(a, lt++, i++);
        } else if (cmp &gt; 0) {
            exchange(a, i, gt--);
        } else {
            i++;
        }
    }//现在a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi]

    sort(a, lo, lt - 1);
    sort(a, gt + 1, hi);
}
</code></pre>

<p>}</p>

<p>//（不含shuffle的时间）对于一百万随机整数，排序时间也在350ms左右。但如果存在大量重复时，时间将降到250ms左右。
```</p>

<p>对有大量重复元素的数组排序时，三向切分算法具有更高的效率。而在最差的情况下，也就是没有重复元素时，它的效率与标准快速排序算法相当。因此，三向切分的快速排序成为排序函数的最佳算法选择。</p>

<p>在基于比较的排序算法中，经过精心调优的快速排序算法性能最好。但它不是终点，还有完全不需要比较的排序算法！</p>
]]></content>
  </entry>
  
</feed>
