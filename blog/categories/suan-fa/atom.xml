<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 算法 | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/suan-fa/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2015-04-08T22:47:34+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[B树]]></title>
    <link href="http://blog.ubone.com/blog/2014/11/17/bshu/"/>
    <updated>2014-11-17T21:44:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/11/17/bshu</id>
    <content type="html"><![CDATA[<p>B树就是B-树，英语原文为B-Tree，但不知道以前的翻译为何要翻译成B-树。它是对平衡树的扩展，支持对保存在磁盘或网络上的符号表进行外部查找。只需要4～5个指向一小块数据的引用就可以支持在含有数百亿或者更多元素的符号表中进行查找和插入操作。</p>

<!--more-->


<h2>1. B树</h2>

<p>B树与2-3树的关键不同在于，数据不会保存在树中，而是会构造一棵由键的副本组成的树。每个副本都关联着一条链接。这种方式能够更加方便地将索引和符号表本身分开。与2-3树一样，也限制了“键-链接”对的上下数量界限。对于M阶B树，每个结点最多含有M-1对键和链接，最少含有M/2对键和链接。根结点例外，可以含有少于M/2对键和链接，但不能少于2对。M必须是正偶数。</p>

<p>“页”表示一块连续的数据，用“探查”表示访问一个页。一个页可能是本地计算机上的一个文件，也可能是另一计算机上的一网页等等。对于B树，使用两种不同类型的结点：</p>

<ol>
<li>内部结点：含有与页相关联的键的副本。</li>
<li>外部结点：含有指向实际数据的引用。</li>
</ol>


<p>内部结点中的每个键都与一个结点相关联，以此结点为根的子树中，所有的键都大于等于与此结点关联的键，但小于原内部结点中的更大的键（如果存在的话）。为了描述方便，使用一个特殊的哨兵键“*”，它小于其他所有键。一开始B树只有一个根结点，并且根结点只有哨兵键。同时符号表不含有重复键，但B树中会使用键的多个副本来引导查找。一棵B树如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-11-17-btree.jpg" alt="image" /></p>

<h2>2. 查找与插入</h2>

<p>B树中查找的方法是在可能含有被查找键的唯一子树中进行递归搜索。当且仅当被查找的键包含在集合中时，每次查找便会结束于一个外部结点。在内部结点中遇到被查找的键的副本时就判断查找命中并结束，但总会找到相应的外部结点。</p>

<p>在查找时，从根结点开始，根据被查找的键选择当前结点中的适当区间并根据适当的链接从一个结点移动到下一个结点。最终，查找过程会到达树底的一个含有键的页。如果被查找的键在该页中，查找命中并结束；如果不在，则查找未命中。</p>

<p>和2-3树一样，要在树的底部插入一个新键，可以使用递归代码。如果空间不足，那么可以允许被插入的结点暂时“溢出”（也就是利用最后一个结点），并在递归调用后向上不断分裂结点，直到根结点。如果根结点也溢出就把它分裂成两个结点。如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-11-17-btreeinsert.jpg" alt="image" /></p>

<h2>3. 数据表示与实现</h2>

<p>我们将B树结点的表示方法及其操作封装在Page API中。它可以关联键与指向Page对象的链接，支持检测页是否溢出、分裂页并区分内部页和外部页的操作。可以将Page看作一张符号表，但是是保存在外部介质上。Page<Key> API定义如下：</p>

<table>
<thead>
<tr>
<th>方法 </th>
<th> 说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Page(boolean bottom) </td>
<td> 创建并打开一个页</td>
</tr>
<tr>
<td>void close() </td>
<td> 关闭页</td>
</tr>
<tr>
<td>void add(Key key) </td>
<td> 将键插入（外部的）页中</td>
</tr>
<tr>
<td>void add(Page p) </td>
<td> 打开p，向这个（内部）而中插入一个条目，并将p和p中的最小键相关联</td>
</tr>
<tr>
<td>boolean isExternal() </td>
<td> 这是一个外部页吗</td>
</tr>
<tr>
<td>boolean contains(Key key) </td>
<td> 键key在页中吗</td>
</tr>
<tr>
<td>Page next(Key key) </td>
<td> 可能含有键key的子树</td>
</tr>
<tr>
<td>boolean isFull() </td>
<td> 页是否已经溢出</td>
</tr>
<tr>
<td>Page split() </td>
<td> 将较大的中间键移动到一个新页中</td>
</tr>
<tr>
<td>Iterable<Key> keys() </td>
<td> 页中所有键的迭代器</td>
</tr>
</tbody>
</table>


<p>open和close操作是指将外部页读入内存和将内存内容写加外部页（如果需要的话）的过程。</p>

<p>内部页的add方法是一个符号表操作，将给定页和以该页为根结点的子树中的最小键关联起来。外部页的add和contains方法和SET中相应的方法类似。</p>

<p>最重要的是split方法，分裂一张饱和页时，将排序后位置正好大于M/2的键移动到一个新的Page对象中，并返回该对象的引用。</p>

<p>有了Page，B树集合的实现就简单了：</p>

<p>```java
public class BTreeSET<Key extends Comparable<Key>> {</p>

<pre><code>private Page root = new Page(true);

public BTreeSET(Key sentinel) {
    add(sentinel);
}

public boolean contains(Key key) {
    return contains(root, key);
}

private boolean contains(Page h, Key key) {
    if (h.isExternal()) return h.contains(key);
    return contains(h.next(key), key);
}

public void add(Key key) {
    add(root, key);
    if (root.isFull()) {
        Page lefthalf = root;
        Page righthalf = root.split();
        root = new Page(false);
        root.add(lefthalf);
        root.add(righthalf);
    }
}

public void add(Page h, Key key) {
    if (h.isExternal()) {
        h.add(key);
        return;
    }

    Page next = h.next(key);
    add(next, key);
    if (next.isFull())
        h.add(next.split());        
    next.close();
}   
</code></pre>

<p>}
```</p>

<h2>4. 性能与空间</h2>

<p><strong>B树最重要的性质就是，在实际应用中对于适当的参数M，查找的成本是常数级别的。</strong></p>

<blockquote><p>含有N个元素的M阶B树中的一次查找或者插入操作需要log<sub>M</sub>N ~ log<sub>M/2</sub>N 次探查，在实际情况下这基本是一个常数。</p></blockquote>

<p>B树的空间至少是半满的，在最坏的情况下，B树所需的空间是所有键占用的实际空间的两倍再加上链接所需的空间。对于随机键，B树浪费的空间约占44%。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单词查找树]]></title>
    <link href="http://blog.ubone.com/blog/2014/11/16/dan-ci-cha-zhao-shu/"/>
    <updated>2014-11-16T22:37:38+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/11/16/dan-ci-cha-zhao-shu</id>
    <content type="html"><![CDATA[<p>在<a href="/blog/2014/10/02/cha-zhao-suan-fa-fu-hao-biao/">符号表</a>中学习了二叉树、红黑树等，单词查找树比这些通用算法更加有效。它查找命中所需的时间与被查找的键的长度成正比，查找未命中只需检查若干个字符。这样的性能是相当惊人的，它们是算法研究的最高成就之一。</p>

<!--more-->


<p>我们扩展符号表的API，增加基于字符的用于处理字符串类型的键的操作。</p>

<p>以字符串为键的符号表的API(<code>StringST&lt;Value&gt;</code>)</p>

<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>StringST()</code> </td>
<td> 创建一个符号表</td>
</tr>
<tr>
<td><code>void put(String key, Value val)</code> </td>
<td> 向表中插入键值对（如果值为null则删除键key）</td>
</tr>
<tr>
<td><code>Value get(String key)</code> </td>
<td> 键key所对应的值，如果不存在则返回null</td>
</tr>
<tr>
<td><code>void delete(String key)</code> </td>
<td> 删除键key（和它的值）</td>
</tr>
<tr>
<td><code>boolean contains(String key)</code> </td>
<td> 表中是否存在key的值</td>
</tr>
<tr>
<td><code>boolean isEmpty()</code> </td>
<td> 符号表是否为空</td>
</tr>
<tr>
<td><strong><code>String longestPrefixOf(String s)</code></strong> </td>
<td> s的前缀中最长的键 </td>
</tr>
<tr>
<td><strong><code>Iterable&lt;String&gt; keysWithPrefix(String s)</code></strong> </td>
<td> 所有以s为前缀的键</td>
</tr>
<tr>
<td><strong><code>Iterable&lt;String&gt; keysThatMatch(String s)</code></strong> </td>
<td> 所有和s匹配的键（其中“.”能够匹配任意字符）</td>
</tr>
<tr>
<td><code>int size()</code>  </td>
<td> 键值对的数量 </td>
</tr>
<tr>
<td><code>Iterable&lt;String&gt; keys()</code> </td>
<td> 符号表中的所有键 </td>
</tr>
</tbody>
</table>


<p>上面的API与符号表API的不同之处在于Key换成了String, 增加了粗体显示的三个方法。</p>

<h2>1. R向单词查找树</h2>

<p>与各种查找树一样，单词查找树也是由链接的结点所组成的数据结构。每个结点只有一个父结点（根结点除外），每个结点都含有R条链接，其中R为字母表的大小。每个键所关联的值保存在该键的最后一个字母所对应的结点中。值为空的结点在符号表中没有对应的键，它们的存在是为了简化单词查找树中的查找操作。</p>

<p><img src="/myresource/images/image_blog_2014-11-16-tries-node.jpg" alt="image" /></p>

<h3>1.1 查找操作</h3>

<p>单词查找树的查找操作非常简单，从首字母开始延着树结点查找就可以：</p>

<ul>
<li>键的尾字符所对应的结点中的值非空，命中！</li>
<li>键的尾字符所对应的结点中的值为空，未命中！</li>
<li>查找结束于一条空链接，未命中！</li>
</ul>


<h3>1.2 插入操作</h3>

<p>和二叉查找树一样，在插入之前要进行一次查找。</p>

<ul>
<li>在到达键的尾字符之前就遇到了一个空链接。证明不存在匹配的结点，为键中还未被检查的每个字符创建一个对应的结点，并将键对应的值保存到最后一个字符的结点中。</li>
<li>在遇到空链接之前就到达了键的尾字符。将该结点的值设为键对应的值（无论该值是否为空）。</li>
</ul>


<h3>1.3 删除操作</h3>

<p>删除的第一步是找到键所对应的结点并将它的值设为空null. 如果该结点含有一个非空的链接指向某个子结点，那么就不需要再进行其他操作了。如果它的所有链接均为空，那就需要从数据结构中删除这个结点。如果删除它使得它的父结点的所有链接也均为空，就要继续删除它的父结点，依此类推。</p>

<h3>1.4 实现</h3>

<p>```java
public class TrieST<Value> {</p>

<pre><code>private static final int R = 256;        // extended ASCII


private Node root;      // root of trie
private int N;          // number of keys in trie

// R-way trie node
private static class Node {
    private Object val;
    private Node[] next = new Node[R];
}

public TrieST() {
}
</code></pre>

<p>   /**</p>

<pre><code> * Initializes an empty string symbol table.
 */

/**
 * Returns the value associated with the given key.
 * @param key the key
 * @return the value associated with the given key if the key is in the symbol table
 *     and &lt;tt&gt;null&lt;/tt&gt; if the key is not in the symbol table
 * @throws NullPointerException if &lt;tt&gt;key&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;
 */
public Value get(String key) {
    Node x = get(root, key, 0);
    if (x == null) return null;
    return (Value) x.val;
}

/**
 * Does this symbol table contain the given key?
 * @param key the key
 * @return &lt;tt&gt;true&lt;/tt&gt; if this symbol table contains &lt;tt&gt;key&lt;/tt&gt; and
 *     &lt;tt&gt;false&lt;/tt&gt; otherwise
 * @throws NullPointerException if &lt;tt&gt;key&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;
 */
public boolean contains(String key) {
    return get(key) != null;
}

private Node get(Node x, String key, int d) {
    if (x == null) return null;
    if (d == key.length()) return x;
    char c = key.charAt(d);
    return get(x.next[c], key, d+1);
}

/**
 * Inserts the key-value pair into the symbol table, overwriting the old value
 * with the new value if the key is already in the symbol table.
 * If the value is &lt;tt&gt;null&lt;/tt&gt;, this effectively deletes the key from the symbol table.
 * @param key the key
 * @param val the value
 * @throws NullPointerException if &lt;tt&gt;key&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;
 */
public void put(String key, Value val) {
    if (val == null) delete(key);
    else root = put(root, key, val, 0);
}

private Node put(Node x, String key, Value val, int d) {
    if (x == null) x = new Node();
    if (d == key.length()) {
        if (x.val == null) N++;
        x.val = val;
        return x;
    }
    char c = key.charAt(d);
    x.next[c] = put(x.next[c], key, val, d+1);
    return x;
}

/**
 * Returns the number of key-value pairs in this symbol table.
 * @return the number of key-value pairs in this symbol table
 */
public int size() {
    return N;
}

/**
 * Is this symbol table empty?
 * @return &lt;tt&gt;true&lt;/tt&gt; if this symbol table is empty and &lt;tt&gt;false&lt;/tt&gt; otherwise
 */
public boolean isEmpty() {
    return size() == 0;
}

/**
 * Returns all keys in the symbol table as an &lt;tt&gt;Iterable&lt;/tt&gt;.
 * To iterate over all of the keys in the symbol table named &lt;tt&gt;st&lt;/tt&gt;,
 * use the foreach notation: &lt;tt&gt;for (Key key : st.keys())&lt;/tt&gt;.
 * @return all keys in the sybol table as an &lt;tt&gt;Iterable&lt;/tt&gt;
 */
public Iterable&lt;String&gt; keys() {
    return keysWithPrefix("");
}

/**
 * Returns all of the keys in the set that start with &lt;tt&gt;prefix&lt;/tt&gt;.
 * @param prefix the prefix
 * @return all of the keys in the set that start with &lt;tt&gt;prefix&lt;/tt&gt;,
 *     as an iterable
 */
public Iterable&lt;String&gt; keysWithPrefix(String prefix) {
    Queue&lt;String&gt; results = new Queue&lt;String&gt;();
    Node x = get(root, prefix, 0);
    collect(x, new StringBuilder(prefix), results);
    return results;
}

private void collect(Node x, StringBuilder prefix, Queue&lt;String&gt; results) {
    if (x == null) return;
    if (x.val != null) results.enqueue(prefix.toString());  //有值才是键
    for (char c = 0; c &lt; R; c++) {
        prefix.append(c);
        collect(x.next[c], prefix, results);
        prefix.deleteCharAt(prefix.length() - 1);
    }
}

/**
 * Returns all of the keys in the symbol table that match &lt;tt&gt;pattern&lt;/tt&gt;,
 * where . symbol is treated as a wildcard character.
 * @param pattern the pattern
 * @return all of the keys in the symbol table that match &lt;tt&gt;pattern&lt;/tt&gt;,
 *     as an iterable, where . is treated as a wildcard character.
 */
public Iterable&lt;String&gt; keysThatMatch(String pattern) {
    Queue&lt;String&gt; results = new Queue&lt;String&gt;();
    collect(root, new StringBuilder(), pattern, results);
    return results;
}

private void collect(Node x, StringBuilder prefix, String pattern, Queue&lt;String&gt; results) {
    if (x == null) return;
    int d = prefix.length();
    if (d == pattern.length() &amp;&amp; x.val != null)
        results.enqueue(prefix.toString());
    if (d == pattern.length())
        return;
    char c = pattern.charAt(d);
    if (c == '.') {
        for (char ch = 0; ch &lt; R; ch++) {
            prefix.append(ch);
            collect(x.next[ch], prefix, pattern, results);
            prefix.deleteCharAt(prefix.length() - 1);
        }
    }
    else {
        prefix.append(c);
        collect(x.next[c], prefix, pattern, results);
        prefix.deleteCharAt(prefix.length() - 1);
    }
}

/**
 * Returns the string in the symbol table that is the longest prefix of &lt;tt&gt;query&lt;/tt&gt;,
 * or &lt;tt&gt;null&lt;/tt&gt;, if no such string.
 * @param query the query string
 * @throws NullPointerException if &lt;tt&gt;query&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;
 * @return the string in the symbol table that is the longest prefix of &lt;tt&gt;query&lt;/tt&gt;,
 *     or &lt;tt&gt;null&lt;/tt&gt; if no such string
 */
public String longestPrefixOf(String query) {
    int length = longestPrefixOf(root, query, 0, 0);
    return query.substring(0, length);
}

// returns the length of the longest string key in the subtrie
// rooted at x that is a prefix of the query string,
// assuming the first d character match and we have already
// found a prefix match of length length
private int longestPrefixOf(Node x, String query, int d, int length) {
    if (x == null) return length;
    if (x.val != null) length = d;
    if (d == query.length()) return length;
    char c = query.charAt(d);
    return longestPrefixOf(x.next[c], query, d+1, length);
}

/**
 * Removes the key from the set if the key is present.
 * @param key the key
 * @throws NullPointerException if &lt;tt&gt;key&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;
 */
public void delete(String key) {
    root = delete(root, key, 0);
}

private Node delete(Node x, String key, int d) {
    if (x == null) return null;
    if (d == key.length()) {
        if (x.val != null) N--;
        x.val = null;
    }
    else {
        char c = key.charAt(d);
        x.next[c] = delete(x.next[c], key, d+1);
    }

    // remove subtrie rooted at x if it is completely empty
    if (x.val != null) return x;
    for (int c = 0; c &lt; R; c++)
        if (x.next[c] != null)
            return x;
    return null;
}
</code></pre>

<p>}
```</p>

<p>上面的代码可以处理扩展ASCII码，但很容易就可以修改为能够处理由任意字母表得到的键：</p>

<ol>
<li>实现一个构造函数，接受Alphabet，将R设置为字母表大小。</li>
<li>在get()、put()中使用Alphabet的toIndex()，将字符串中的字符转化为0到R-1的索引值。</li>
<li>在keys()、keysWithPrefix()和keysThatMatch()方法中，使用Alphabet的toChar()方法，将0到R-1之间的索引值转化为字符型(char)值。</li>
</ol>


<h3>1.5 单词查找树的性质</h3>

<p>单词查找树的链表结构（形状）和键的插入或删除顺序无关，对于任意给定的一组键，其单词查找树都是唯一的。</p>

<p>在单词查找树中查找一个键或是插入一个键时，访问数组的次数最多为键的长度加1！</p>

<p>字母表的大小为R，在一棵由N个随机键构造的单词树中，未命中查找平均所需检查的结点数量为~log<sub>R</sub><sup>N</sup>。</p>

<p>一棵单词查找树中的链接总数在RN到RNw之间，其中w为键的平均长度。因此单词查找树的空间消耗非常大。长键也可能占用大量空间，因为它通常有一条长长的尾巴。单词查找树的内部也可能存在单向的分支。例如两个长键可能只有最后一个字符不同。</p>

<p>如果能够负担得起R向单词查找树的庞大空间，它的性能是无可匹敌的。</p>

<h2>2. 三向单词查找树</h2>

<p>三向单词查找树可以避免R向单词查找树过度的空间消耗。它的每个结点都含有一个字符、三条链接和一个值。三条链接分别对应当前字母小于、等于和大于结点字母的所有键。</p>

<p><img src="/myresource/images/image_blog_2014-11-16-tst.jpg" alt="image" /></p>

<h3>2.1 查找、插入和删除操作</h3>

<p>在查找时，首先比较键的首字母和根结点的字母。如果键的首字母较小，就选择左链接；如果较大，就选择右链接；如果相等则选择中链接。然后递归地使用相同的算法。如果遇到一个空链接或者当键结束时结点的值为空，那么查找未命中。如果键结束时结点的值非空则查找命中。</p>

<p>插入一个新键时，首先进行查找，然后和单词查找树一样，在树中补全键末尾的所有结点。</p>

<p>在三向单词查找树中，需要使用在二叉查找树中删除结点的方法来删去与该字符对应的结点。</p>

<h3>2.2 实现</h3>

<p>```java
public class TST<Value> {</p>

<pre><code>private int N;       // size
private Node root;   // root of TST

private class Node {
    private char c;                 // character
    private Node left, mid, right;  // left, middle, and right subtries
    private Value val;              // value associated with string
}

// return number of key-value pairs
public int size() {
    return N;
}
</code></pre>

<p>   /**************************************************************</p>

<pre><code>* Is string key in the symbol table?
**************************************************************/
public boolean contains(String key) {
    return get(key) != null;
}

public Value get(String key) {
    if (key == null) throw new NullPointerException();
    if (key.length() == 0) throw new IllegalArgumentException("key must have length &gt;= 1");
    Node x = get(root, key, 0);
    if (x == null) return null;
    return x.val;
}

// return subtrie corresponding to given key
private Node get(Node x, String key, int d) {
    if (key == null) throw new NullPointerException();
    if (key.length() == 0) throw new IllegalArgumentException("key must have length &gt;= 1");
    if (x == null) return null;
    char c = key.charAt(d);
    if      (c &lt; x.c)              return get(x.left,  key, d);
    else if (c &gt; x.c)              return get(x.right, key, d);
    else if (d &lt; key.length() - 1) return get(x.mid,   key, d+1);
    else                           return x;
}
</code></pre>

<p>   /**************************************************************</p>

<pre><code>* Insert string s into the symbol table.
**************************************************************/
public void put(String s, Value val) {
    if (!contains(s)) N++;
    root = put(root, s, val, 0);
}

private Node put(Node x, String s, Value val, int d) {
    char c = s.charAt(d);
    if (x == null) {
        x = new Node();
        x.c = c;
    }
    if      (c &lt; x.c)             x.left  = put(x.left,  s, val, d);
    else if (c &gt; x.c)             x.right = put(x.right, s, val, d);
    else if (d &lt; s.length() - 1)  x.mid   = put(x.mid,   s, val, d+1);
    else                          x.val   = val;
    return x;
}
</code></pre>

<p>   /**************************************************************</p>

<pre><code>* Find and return longest prefix of s in TST
**************************************************************/
public String longestPrefixOf(String s) {
    if (s == null || s.length() == 0) return null;
    int length = 0;
    Node x = root;
    int i = 0;
    while (x != null &amp;&amp; i &lt; s.length()) {
        char c = s.charAt(i);
        if      (c &lt; x.c) x = x.left;
        else if (c &gt; x.c) x = x.right;
        else {
            i++;
            if (x.val != null) length = i;
            x = x.mid;
        }
    }
    return s.substring(0, length);
}

// all keys in symbol table
public Iterable&lt;String&gt; keys() {
    Queue&lt;String&gt; queue = new Queue&lt;String&gt;();
    collect(root, "", queue);
    return queue;
}

// all keys starting with given prefix
public Iterable&lt;String&gt; prefixMatch(String prefix) {
    Queue&lt;String&gt; queue = new Queue&lt;String&gt;();
    Node x = get(root, prefix, 0);
    if (x == null) return queue;
    if (x.val != null) queue.enqueue(prefix);
    collect(x.mid, prefix, queue);
    return queue;
}

// all keys in subtrie rooted at x with given prefix
private void collect(Node x, String prefix, Queue&lt;String&gt; queue) {
    if (x == null) return;
    collect(x.left,  prefix,       queue);
    if (x.val != null) queue.enqueue(prefix + x.c);
    collect(x.mid,   prefix + x.c, queue);
    collect(x.right, prefix,       queue);
}


// return all keys matching given wildcard pattern
public Iterable&lt;String&gt; wildcardMatch(String pat) {
    Queue&lt;String&gt; queue = new Queue&lt;String&gt;();
    collect(root, "", 0, pat, queue);
    return queue;
}

private void collect(Node x, String prefix, int i, String pat, Queue&lt;String&gt; q) {
    if (x == null) return;
    char c = pat.charAt(i);
    if (c == '.' || c &lt; x.c) collect(x.left, prefix, i, pat, q);
    if (c == '.' || c == x.c) {
        if (i == pat.length() - 1 &amp;&amp; x.val != null) q.enqueue(prefix + x.c);
        if (i &lt; pat.length() - 1) collect(x.mid, prefix + x.c, i+1, pat, q);
    }
    if (c == '.' || c &gt; x.c) collect(x.right, prefix, i, pat, q);
}
</code></pre>

<p>}
```</p>

<h3>2.3 三向单词查找树的性质</h3>

<p>三向单词查找树与R向单词查找树的数据结构性质截然不同。它和其他所有二叉查找树一样，每个单词查找树结点的二叉查找树表示也取决于键的插入顺序。</p>

<p>它的每个结点只含有三个链接，因此所需空间远小于对应的单词查找树。由N个平均长度为w的字符串构造的三向单词查找树中的链接总数在3N到3Nw之间。</p>

<p>在一棵由N个随机字符串构造的三向单词查找树中，查找未命中平均需要比较字符~lnN次。除~lnN次外，一次插入或命中的查找会比较一次被查找的键中的每个字符。</p>

<p>使用三向单词查找树的最大好处是它能够很好地适应实际应用中可能出现的被查找键的不规则性。它可以使用256个字符的ASCII编码或者65536个字符的Unicode编码，而不必担心分支带来的巨大开销。</p>

<h2>3. 总结</h2>

<p><img src="/myresource/images/image_blog_2014-11-16-wordsfind-conclude.jpg" alt="image" /></p>

<p>参考：<a href="http://algs4.cs.princeton.edu/52trie/">http://algs4.cs.princeton.edu/52trie/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字符串排序]]></title>
    <link href="http://blog.ubone.com/blog/2014/11/15/zi-fu-chuan-pai-xu/"/>
    <updated>2014-11-15T09:49:02+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/11/15/zi-fu-chuan-pai-xu</id>
    <content type="html"><![CDATA[<p>字符串是最常用的数据类型，因此它的排序算法非常重要。虽然Java的字符串排序已经非常快，但了解一些字符串的排序算法仍然很必要，也是进一步了解字符串其它应用的基础。</p>

<!--more-->


<p>在Java中表示字符串的两种方法：</p>

<table>
<thead>
<tr>
<th>操作 </th>
<th> 字符数组 </th>
<th> Java字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>声明</td>
<td> char[] a</td>
<td> String s</td>
</tr>
<tr>
<td>根据索引访问字符</td>
<td> a[i] </td>
<td> s.charAt(i)</td>
</tr>
<tr>
<td>获取字符串长度</td>
<td> a.length </td>
<td> s.length()</td>
</tr>
<tr>
<td>表示方法转换</td>
<td> a = s.toCharArray(); </td>
<td> s= new String(a);</td>
</tr>
</tbody>
</table>


<h2>1. 字母表</h2>

<p>字母表是字符串相关算法的基础，表示字符串由哪些字母组成。字符索引的数组能够提高算法的效率。在这个数组中，用字符作为索引来获取与之相关联的信息。在一些算法中会产生大量的这类数组。如果使用Java的String类，就必须使用大小为65536的数组。有了字母表，则只需要使用一个字母表大小的数组即可。</p>

<p>字母表(Alphabet)API定义如下：</p>

<table>
<thead>
<tr>
<th>方法 </th>
<th>  说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alphabet(String s) </td>
<td> 构造方法，根据s中的字符创建一张新的字母表</td>
</tr>
<tr>
<td>char toChar(int index) </td>
<td> 获取字母表中索引位置的字符</td>
</tr>
<tr>
<td>int toIndex(char c)  </td>
<td> 获取c的索引，在0到R-1之间</td>
</tr>
<tr>
<td>boolean contains(char c) </td>
<td> c在字母表中吗</td>
</tr>
<tr>
<td>int R() </td>
<td> 基数（字母表中的字符数量）</td>
</tr>
<tr>
<td>int lgR() </td>
<td> 表示一个索引所需的比特数</td>
</tr>
<tr>
<td>int[] toIndices(String s) </td>
<td> 将s转换为R进制的整数数组</td>
</tr>
<tr>
<td>String toChars(int[] indices) </td>
<td> 将R进制的整数数组转换为基于该字母表的字符串</td>
</tr>
</tbody>
</table>


<h3>标准字母表</h3>

<table>
<thead>
<tr>
<th>名称 </th>
<th> R() </th>
<th> lgR() </th>
<th> 字符集</th>
</tr>
</thead>
<tbody>
<tr>
<td>BINARY </td>
<td> 2 </td>
<td> 1 </td>
<td> 01</td>
</tr>
<tr>
<td>DNA </td>
<td> 4 </td>
<td> 2 </td>
<td> ACTG</td>
</tr>
<tr>
<td>OCTAL </td>
<td> 8 </td>
<td> 3 </td>
<td> 0..7</td>
</tr>
<tr>
<td>DECIMAL </td>
<td> 10 </td>
<td> 4 </td>
<td> 0..9</td>
</tr>
<tr>
<td>HEXADECIMAL </td>
<td> 16 </td>
<td> 4 </td>
<td> 0..9ABCDEF</td>
</tr>
<tr>
<td>PROTEIN </td>
<td> 20 </td>
<td> 5 </td>
<td> ACDEFGHIKLMNPQRSTVWY</td>
</tr>
<tr>
<td>LOWERCASE </td>
<td> 26 </td>
<td> 5 </td>
<td> a..z</td>
</tr>
<tr>
<td>UPPERCASE </td>
<td> 26 </td>
<td> 5 </td>
<td> A..Z</td>
</tr>
<tr>
<td>BASE64 </td>
<td> 64 </td>
<td> 6 </td>
<td> A..Za..z0..9+/</td>
</tr>
<tr>
<td>ASCII </td>
<td> 128 </td>
<td> 7 </td>
<td> ASCII字符集</td>
</tr>
<tr>
<td>EXTENDED_ASCII </td>
<td> 256 </td>
<td> 8 </td>
<td> 扩展ASCII字符集</td>
</tr>
<tr>
<td>UNICODE16 </td>
<td> 65536 </td>
<td> 16 </td>
<td> Unicode字符集</td>
</tr>
</tbody>
</table>


<h2>2. 键索引计数法</h2>

<p>假设老师在统计学生分数时，学生被分为若干组，标号为0、1、2、3等。老师希望将全班同学按组分类，也就是按组排序。因为组的编号是较小的整数，使用键索引计数法来排序非常合适。</p>

<p>我们用一个数组a[]来保存数据。每个元素都保存了一个姓名和一个组号。组号在0到R-1之间，a[i].key()会返回指定学生的组号。键索引计数法通过四个步骤来完成排序。</p>

<p><strong>第一步，频率统计</strong>
使用一个int数组count[]来计算每个键（组号）出现的频率。遍历一遍数组，如果键为r，则将count[r+1]加1。因此对第1组的学生，将会把count[2]++。（在第二步的代码中可以看到为什么是r+1）</p>

<p>```java
for (int i = 0; i &lt; N; i++) {</p>

<pre><code>count[a[i].key() + 1]++;
</code></pre>

<p>}
```</p>

<p><strong>第二步，将频率转换为索引</strong>
有了count[]中每个键出现的次数，就可以得到每个键在排序结果中的起始索引位置。假如第1组3个人，第2组5个人，那么第三种的同学在排序结果中的起始位置就是8. 因此可以将count[]转化为一张索引表。</p>

<p>```java
for (int r= 0; r &lt; R; r++) {</p>

<pre><code>count[r+1] += count[r];
</code></pre>

<p>}
```</p>

<p><strong>第三步，数据分类</strong>
在第二步中，得到了每个键的起始序号。我们就可以将所有元素（学生）移动到一个辅助数组aux[]。元素在aux[]中的位置由count[]值决定，在移动的过程中将count[]中对应的元素值加1。这个过程只需要遍历一遍数据就可以产生排序结果。并且这种方式是稳定的！键相同的元素在排序后会被聚集到一起，而且相对顺序没有变化。</p>

<p>```java
for (int i = 0; i &lt; N; i++) {</p>

<pre><code>aux[count[a[i].key()]++]  = a[i];
</code></pre>

<p>}
```</p>

<p><strong>第四步，回写</strong>
在第三步已经完成了排序，只需要将排序结果复制回原数组。</p>

<p>```java
for(int i = 0; i &lt; N; i++) {</p>

<pre><code>a[i] = aux[i];
</code></pre>

<p>}
```</p>

<p>键索引计数法是一种对于小整数键排序非常有效却常常被忽略的排序方法。它排序N个键为0到R-1之间的整数的元素需要访问数组11N+4R+1次。也就是说<strong>它突破了NlogN的排序算法运行时间下限（<a href="/blog/2014/09/27/kuai-su-pai-xu-suan-fa/">快速排序算法</a>）。原因是什么？因为它是不需要比较的，它只通过key()方法访问数据。只要当R在N的一个常数因子范围之内，它都是一个线性时间级别的排序方法。</strong></p>

<p>理解键索引计数法的工作原理非常重要。学生的组号对应字母表中的元素，利用字母表大小的数组count[]来统计每个字母出现的次数，计算出每个字母在最终数组的起始序号，从而完成排序。</p>

<p>有了键索引计数法，我们来看如何实现两种字符串排序算法。</p>

<h2>3. 低位优先(Least-Significant-DigitFirst, LSD)的字符串排序</h2>

<p>这种算法适用于<strong>键的长度相等</strong>的字符串排序应用。例如对车牌号进行排序。它会从右往左检查键中的字符，所以称为低位优先。</p>

<p>如果字符串的长度均为W，在排序的过程中，从右向左，将每个位置的字符作为键，用键索引计数法将字符串排序W遍。理解了键索引计数法，实现低位优先的字符串排序就很容易了：</p>

<p>```java
public class LSD {</p>

<pre><code>public static void sort(String[] a, int W) {
    int N = a.length;
    int R = 256;   // extend ASCII alphabet size
    String[] aux = new String[N];

    for (int d = W-1; d &gt;= 0; d--) {
        //将第d个字符用键索引计数法排序
        // 计算出现次数
        int[] count = new int[R+1];
        for (int i = 0; i &lt; N; i++)
            count[a[i].charAt(d) + 1]++;

        // 将次数转换为索引
        for (int r = 0; r &lt; R; r++)
            count[r+1] += count[r];

        // 移到辅助数组，进行排序
        for (int i = 0; i &lt; N; i++)
            aux[count[a[i].charAt(d)]++] = a[i];

        // 回写数据
        for (int i = 0; i &lt; N; i++)
            a[i] = aux[i];
    }
}
</code></pre>

<p>}
```</p>

<p>低位优先的字符串排序算法能够将定长字符串排序，其中的键索引计数法的稳定性起了关键作用。</p>

<p>对于基于R个字符的字母表的N个以长为W的字符串为键的元素，低位优先的字符串排序需要访问~7WN+3WR次数组，使用的额外空间与N+R成正比。</p>

<h2>4. 高位优先(MSD)的字符串排序</h2>

<p>这种算法从左往右检查键中的字符，所以称为高位优先。它不一定要检查所有的输入才能完成排序。它是更通用的字符串排序算法，字符串的长度不一定相同。</p>

<p>和快速排序一样，高位优先的字符串排序会将数组切分为能够独立排序的子数组来完成排序任务，但它的切分会为每个首字母得到一个子数组，而不是像快速排序中那样产生固定的两个或三个切分。首先用键索引计数法将所有字符串按照首字母排序，然后（递归地）再将每个首字母所对应的子数组排序（忽略首字母，因为每个子数组中的首字母是相同的）。</p>

<p>由于高位优先字符串排序算法要处理不等长的字符串，因此要处理字符串已经结束的情况。因此约定charAt方法中，如果指定位置超出字符串长度则返回-1. 其它情况则加1后返回。因此字符串中的每个字符都可能产生R+1种不同的值，0表示结束，1表示字母表的第一个字符。而键索引计数法还需要一个额外的位置，所以count[]的长度应为R+2。</p>

<p>对于很小的子数组（15个以内），采用插入排序更快。</p>

<p>```java
public class MSD {</p>

<pre><code>private static final int R             = 256;   // 基数 extended ASCII alphabet size
private static final int CUTOFF        =  15;   // 小数组的切换阈值 cutoff to insertion sort

// sort array of strings
public static void sort(String[] a) {
    int N = a.length;
    String[] aux = new String[N];
    sort(a, 0, N-1, 0, aux);
}

// return dth character of s, -1 if d = length of string
private static int charAt(String s, int d) {
    assert d &gt;= 0 &amp;&amp; d &lt;= s.length();
    if (d == s.length()) return -1;
    return s.charAt(d);
}

// sort from a[lo] to a[hi], starting at the dth character
private static void sort(String[] a, int lo, int hi, int d, String[] aux) {

    // cutoff to insertion sort for small subarrays
    if (hi &lt;= lo + CUTOFF) {
        insertion(a, lo, hi, d);
        return;
    }

    // 计算次数
    int[] count = new int[R+2];
    for (int i = lo; i &lt;= hi; i++) {
        int c = charAt(a[i], d);
        count[c+2]++;
    }

    // 将次数转换为索引
    for (int r = 0; r &lt; R+1; r++)
        count[r+1] += count[r];

    // 生成辅助数据内容，完成排序。
    for (int i = lo; i &lt;= hi; i++) {
        int c = charAt(a[i], d);
        aux[count[c+1]++] = a[i];
    }

    // 回写
    for (int i = lo; i &lt;= hi; i++) 
        a[i] = aux[i - lo];


    // 递归地以每个字符为键进行排序。
    for (int r = 0; r &lt; R; r++)
        sort(a, lo + count[r], lo + count[r+1] - 1, d+1, aux);
}


// 插入排序算法insertion sort a[lo..hi], starting at dth character
private static void insertion(String[] a, int lo, int hi, int d) {
    for (int i = lo; i &lt;= hi; i++)
        for (int j = i; j &gt; lo &amp;&amp; less(a[j], a[j-1], d); j--)
            exch(a, j, j-1);
}

// exchange a[i] and a[j]
private static void exch(String[] a, int i, int j) {
    String temp = a[i];
    a[i] = a[j];
    a[j] = temp;
}

// is v less than w, starting at character d
private static boolean less(String v, String w, int d) {
    // assert v.substring(0, d).equals(w.substring(0, d));
    for (int i = d; i &lt; Math.min(v.length(), w.length()); i++) {
        if (v.charAt(i) &lt; w.charAt(i)) return true;
        if (v.charAt(i) &gt; w.charAt(i)) return false;
    }
    return v.length() &lt; w.length();
}
</code></pre>

<p>}
```</p>

<h3>4.1 三个必须解决的问题</h3>

<h4>4.1.1 小型子数组</h4>

<p>高位优先的字符串排序算法能够快速地将需要排序的数组切分小的数组，但这肯定会需要处理大量的微型数组，因此必须快速处理它们。<strong>小型子数组对于高位优先的字符串排序性能至关重要！</strong>假设要将数百万个不同的ASCII字符串排序，每个字符串最终都会产生一个只含有它自己的子数组，因此你需要将数百万个大小为1的子数组排序。每次排序还需要将count[]r 258个元素初始化为0并转化为索引。这个代价比排序其他部分高得多。如果使用Unicode(R=65536)则可能会慢上千倍！</p>

<p>所以对小型子数组要切换到插入排序。在一个典型应用中，当长度小于等于10时切换到插入排序能够将运行时间降低到原来的十分之一。</p>

<h4>4.1.2 等值键</h4>

<p>如果字符串有大量重复的前缀，排序会较慢。高位优先字符串排序算法的最坏情况就是所有的键均相同。</p>

<h4>4.1.3 额外空间</h4>

<p>为了进行切分，高位优先的算法使用了两个辅助数组：aux[]和count[]. aux可以在递归方法sort()外创建。而count[]所需的空间是主要问题，它在内循环中创建。</p>

<p>解决这三个问题需要新算法。</p>

<h2>5. 三向字符串快速排序</h2>

<p>在高位优先的字符串排序算法上改进快速排序。根据键的首字母进行三向切分，分成三个数组：首字母小于、等于和大于切分字符的三个数组。仅在中间子数组中的下一个字符（因为首字母就是切分字符）继续递归排序。这是一种将高位优先字符串排序与快速排序结合的算法。</p>

<p>这种算法不会像高位优先算法那样创建大量（空）子数组，它的切分总是只有三个。能解决所有高位优先字符串排序算法不擅长的各种情况。并且它也不需要额外的空间。</p>

<p>对于所有递归算法都可以通过对小型子数组进行特殊处理高效率，所以它同样使用到了插入排序。</p>

<p>和快速排序一样，最好在排序之前将数组打乱，或者将第一个元素和一个随机位置的元素交换以得到一个随机的切分元素。这么做主要是预防数组已经有序或者接近有序的最坏情况。</p>

<p>```java
public class Quick3string {</p>

<pre><code>private static final int CUTOFF =  15;   // cutoff to insertion sort

// sort the array a[] of strings
public static void sort(String[] a) {
    StdRandom.shuffle(a);
    sort(a, 0, a.length-1, 0);
    assert isSorted(a);
}

// return the dth character of s, -1 if d = length of s
private static int charAt(String s, int d) { 
    assert d &gt;= 0 &amp;&amp; d &lt;= s.length();
    if (d == s.length()) return -1;
    return s.charAt(d);
}


// 3-way string quicksort a[lo..hi] starting at dth character
private static void sort(String[] a, int lo, int hi, int d) { 

    // cutoff to insertion sort for small subarrays
    if (hi &lt;= lo + CUTOFF) {
        insertion(a, lo, hi, d);
        return;
    }

    int lt = lo, gt = hi;
    int v = charAt(a[lo], d);
    int i = lo + 1;
    while (i &lt;= gt) {
        int t = charAt(a[i], d);
        if      (t &lt; v) exch(a, lt++, i++);
        else if (t &gt; v) exch(a, i, gt--);
        else              i++;
    }

    // a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi]. 
    sort(a, lo, lt-1, d);
    if (v &gt;= 0) sort(a, lt, gt, d+1);
    sort(a, gt+1, hi, d);
}

// sort from a[lo] to a[hi], starting at the dth character
private static void insertion(String[] a, int lo, int hi, int d) {
    for (int i = lo; i &lt;= hi; i++)
        for (int j = i; j &gt; lo &amp;&amp; less(a[j], a[j-1], d); j--)
            exch(a, j, j-1);
}

// exchange a[i] and a[j]
private static void exch(String[] a, int i, int j) {
    String temp = a[i];
    a[i] = a[j];
    a[j] = temp;
}

// is v less than w, starting at character d
// DEPRECATED BECAUSE OF SLOW SUBSTRING EXTRACTION IN JAVA 7
// private static boolean less(String v, String w, int d) {
//    assert v.substring(0, d).equals(w.substring(0, d));
//    return v.substring(d).compareTo(w.substring(d)) &lt; 0; 
// }

// is v less than w, starting at character d
private static boolean less(String v, String w, int d) {
    assert v.substring(0, d).equals(w.substring(0, d));
    for (int i = d; i &lt; Math.min(v.length(), w.length()); i++) {
        if (v.charAt(i) &lt; w.charAt(i)) return true;
        if (v.charAt(i) &gt; w.charAt(i)) return false;
    }
    return v.length() &lt; w.length();
}

// is the array sorted
private static boolean isSorted(String[] a) {
    for (int i = 1; i &lt; a.length; i++)
        if (a[i].compareTo(a[i-1]) &lt; 0) return false;
    return true;
}
</code></pre>

<p>}
```</p>

<p>要将含有N个随机字符串的数组排序，三向字符串快速排序平均需要比较字符~2NlnN次。</p>

<p>Java系统的标准实现中的字符串比较非常快，因此它的排序性能与上面的算法不相上下。</p>

<p><img src="/myresource/images/image_blog_2014-11-15-string-sort.jpg" alt="image" /></p>

<p>参考：<a href="http://algs4.cs.princeton.edu/51radix/">http://algs4.cs.princeton.edu/51radix/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最短路径]]></title>
    <link href="http://blog.ubone.com/blog/2014/11/03/zui-duan-lu-jing/"/>
    <updated>2014-11-03T20:22:31+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/11/03/zui-duan-lu-jing</id>
    <content type="html"><![CDATA[<p>最短路径算法可以解决很多问题，例如地图导航、任务调度和网络路由等。本章的主题就是找到从一个顶点到达另一个顶点的成本最小的路径。</p>

<blockquote><p>在一幅加权有向图中，从顶点s到顶点t的最短路径是所有从s到t的路径中的权重最小者。</p></blockquote>

<p>本章要涉及以下问题：</p>

<ul>
<li>加权有向图的API、单点最短路径的API及它们的实现；</li>
<li>解决边的权重非负的最短路径问题的经典Dijkstra算法；</li>
<li>在无环加权有向图中解决该问题的一种快速算法，边的权重甚至可以是负值；</li>
<li>适用于一般情况的经典Bellman-Ford算法，其中图可以含有环，边的权重也可以是负值。</li>
</ul>


<!--more-->


<h2>1. 最短路径的性质</h2>

<ul>
<li>路径是有向的；</li>
<li>权重不一定等价于距离，但示例图会用距离代表权重；</li>
<li>并不是所有顶点都是可达的；</li>
<li>负权重会使问题更复杂，暂时假定边的权重是非负的；</li>
<li>算法会忽略构成环的零权重边，找到的最短路径都不会含有环；</li>
<li>最短路径不一定是唯一的，只找到其中一条即可；</li>
<li>可能存在平行边和自环，为避免歧义假设不存在平行边，但代码处理它们并没有困难。</li>
</ul>


<p>单点最短路径的计算结果是一棵最短路径树（SPT），它包含了顶点s到达所有可达的顶点的最短路径。</p>

<blockquote><p>给定一幅加权有向图和一个顶点s，以s为起点的一棵最短路径树是图的一幅子图，它包含s和从s可达的所有顶点。这棵有向树的根结点是s，树的每条路径都是有向图中的一条最短路径。</p></blockquote>

<h2>2. 加权有向图的数据结构</h2>

<p>有向边的数据结构比无向边更简单，因为有向边只有一个方向。其API定义如下：</p>

<p><img src="/myresource/images/image_blog_2014-11-04-directed-edge-api.png" alt="image" /></p>

<p>```java
public class DirectedEdge {</p>

<pre><code>private final int v;                //边的起点
private final int w;                //边的终点
private final double weight;        //边的权重

public DirectedEdge(int v, int w, double weight) {
    if (v &lt; 0) throw new IndexOutOfBoundsException("Vertex names must be nonnegative integers");
    if (w &lt; 0) throw new IndexOutOfBoundsException("Vertex names must be nonnegative integers");
    if (Double.isNaN(weight)) throw new IllegalArgumentException("Weight is NaN");
    this.v = v;
    this.w = w;
    this.weight = weight;
}

public int from() {return v;}
public int to() {return w;}
public double weight() {return weight;}

public String toString() {
    return v + "-&gt;" + w + " " + String.format("%5.2f", weight);
}
</code></pre>

<p>}
```</p>

<p>加权有向图的API也与无向图类似：</p>

<p><img src="/myresource/images/image_blog_2014-11-04-edge-weighted-digraph-api.png" alt="image" /></p>

<p>```java
public class EdgeWeightedDigraph {</p>

<pre><code>private final int V;                    //顶点总数
private int E;                          //边的总数
private Bag&lt;DirectedEdge&gt;[] adj;        //邻接表

public EdgeWeightedDigraph(int V) {
    if (V &lt; 0) throw new IllegalArgumentException("Number of vertices in a Digraph must be nonnegative");
    this.V = V;
    this.E = 0;
    adj = (Bag&lt;DirectedEdge&gt;[]) new Bag[V];
    for (int v = 0; v &lt; V; v++)
        adj[v] = new Bag&lt;DirectedEdge&gt;();
}

public int V() {return V;}
public int E() {return E;}

//将e添加到有向图中
public void addEdge(DirectedEdge e) {
    adj[e.from()].add(e);
    E++;
}

//从v指出的边
public Iterable&lt;DirectedEdge&gt; adj(int v) {
    return adj[v];
}

//有向图中的所有边
public Iterable&lt;DirectedEdge&gt; edges() {
    Bag&lt;DirectedEdge&gt; list = new Bag&lt;DirectedEdge&gt;();
    for (int v = 0; v &lt; V; v++) {
        for (DirectedEdge e : adj(v)) {
            list.add(e);
        }
    }
    return list;
} 
</code></pre>

<p>}
```</p>

<p>加权有向图的表示：</p>

<p><img src="/myresource/images/image_blog_2014-11-04-edge-weighted-digraph-representation.png" alt="image" /></p>

<h3>2.1 最短路径</h3>

<p>最短路径的API：</p>

<p><img src="/myresource/images/image_blog_2014-11-04-sp-api.png" alt="image" /></p>

<p>在实现时，分别用两个数组来表示最短路径：</p>

<ul>
<li>最短路径树中的边：DirectedEdge[] edgeTo，edgeTo[v]的值为树中连接v和它的父结点的边。</li>
<li>到达起点的距离：Double[] distTo，distTo[v]为从起点s到v的已知最短路径的长度。</li>
</ul>


<p>同时约定edgeTo[s] == null, distTo[s] == 0; 不可达的顶点的距离为Double.POSITIVE_INFINITY。</p>

<h3>2.2 松弛操作</h3>

<p>松弛（Relaxation）操作是最短路径实现中使用的关键操作。对边v->w松弛意味着检查从s到w的最短路径是否是先从s到v，然后再由v到w。如果是，则由v到达w的最短路径是distTo[v] + e.weight()。如果这个值不小于distTo[w]，则证明刚才的边失效可忽略，否则证明现在的值更小，需要更新数据。</p>

<p>下图演示了这种情况，左侧的v->w不满足条件，被忽略。而右侧的图v->满足条件，替换为新的最短路径。</p>

<p><img src="/myresource/images/image_blog_2014-11-04-relaxation-edge.png" alt="image" /></p>

<p>对顶点的松弛操作就是对该顶点指出的所有边进行松弛操作。每次顶点的松弛操作都能得出到达某个顶点的更短的路径。算法就这样最终找出到达每个顶点的最短路径。</p>

<h2>3. 最短路径算法的理论基础</h2>

<p>最短路径的最优性条件：</p>

<blockquote><p>令G为一幅加权有向图，顶点s是G中的起点，distTo[]是一个由顶点索引的数组，保存的是G中路径的长度。对于从s可达的所有顶点v，distTo[v]的值是从s到v的某条路径的长度，对于从s不可达的所有顶点v，该值为无穷大。当且仅当对于从v到w的任意一条边e, 这些值都满足distTo[w] &lt;= distTo[v] + e.weight()时，它们是最短路径的长度。</p></blockquote>

<p>根据最优性条件，我们可以得到一个通用算法，暂时只考虑非负权重的情况：</p>

<blockquote><p>将distTo[s]初始化为0，其它distTo[]元素初始化为无穷大，继续如下操作：放松G中的任意边，直到不存在有效边为止。对于任意从s可达的顶点w，进行这些操作后，distTo[w]的值即为从s到w的最短路径的长度。</p></blockquote>

<h2>4. Dijkstra算法</h2>

<p>Dijkstra算法能够解决边权重非负的加权有向图的单起点最短路径问题。它与无向图的最小生成树的Prim算法（每一步都向最小生成树中添加一条新的边）非常相似。首先将distTo[s]初始华为0，distTo[]的其他元素初始化为正无穷。然后<strong>将distTo[]最小的非树顶点放松并加入树中，如此这般，直到所有的顶点都在树中或者所有的非树顶点的distTo[]值均为无穷大。</strong></p>

<p>Dijkstra算法实现时，除了要distTo[]和edgeTo[]之外，还需要一条索引优先队列pa，以保存需要被放松的顶点并确认下一个被放松的顶点。只要将v和distTo[v]关联起来放入队列就可以立即实现Dijkstra算法。Prim算法每次添加的都是离树最近的非树顶点，而Dijkstra算法每次添加的都是离起点最近的非树顶点。如果将加权无向图看成加权有向图，对无向图中的每条边都相应地创建方向相反的有向边，最短路径的问题是等价的。Dijkstra算法实现实现如下：</p>

<p>```
public class DijkstraSP {</p>

<pre><code>private double[] distTo;          // distTo[v] = distance  of shortest s-&gt;v path
private DirectedEdge[] edgeTo;    // edgeTo[v] = last edge on shortest s-&gt;v path
private IndexMinPQ&lt;Double&gt; pq;    // priority queue of vertices

/**
 * Computes a shortest paths tree from &lt;tt&gt;s&lt;/tt&gt; to every other vertex in
 * the edge-weighted digraph &lt;tt&gt;G&lt;/tt&gt;.
 * @param G the edge-weighted digraph
 * @param s the source vertex
 * @throws IllegalArgumentException if an edge weight is negative
 * @throws IllegalArgumentException unless 0 &amp;le; &lt;tt&gt;s&lt;/tt&gt; &amp;le; &lt;tt&gt;V&lt;/tt&gt; - 1
 */
public DijkstraSP(EdgeWeightedDigraph G, int s) {
    for (DirectedEdge e : G.edges()) {
        if (e.weight() &lt; 0)
            throw new IllegalArgumentException("edge " + e + " has negative weight");
    }

    distTo = new double[G.V()];
    edgeTo = new DirectedEdge[G.V()];
    for (int v = 0; v &lt; G.V(); v++)
        distTo[v] = Double.POSITIVE_INFINITY;
    distTo[s] = 0.0;

    // relax vertices in order of distance from s
    pq = new IndexMinPQ&lt;Double&gt;(G.V());
    pq.insert(s, distTo[s]);
    while (!pq.isEmpty()) {
        int v = pq.delMin();
        for (DirectedEdge e : G.adj(v))
            relax(e);
    }
}

// relax edge e and update pq if changed
private void relax(DirectedEdge e) {
    int v = e.from(), w = e.to();
    if (distTo[w] &gt; distTo[v] + e.weight()) {
        distTo[w] = distTo[v] + e.weight();
        edgeTo[w] = e;
        if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);
        else                pq.insert(w, distTo[w]);
    }
}

/**
 * Returns the length of a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;.
 * @param v the destination vertex
 * @return the length of a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;;
 *    &lt;tt&gt;Double.POSITIVE_INFINITY&lt;/tt&gt; if no such path
 */
public double distTo(int v) {
    return distTo[v];
}

/**
 * Is there a path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;?
 * @param v the destination vertex
 * @return &lt;tt&gt;true&lt;/tt&gt; if there is a path from the source vertex
 *    &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;, and &lt;tt&gt;false&lt;/tt&gt; otherwise
 */
public boolean hasPathTo(int v) {
    return distTo[v] &lt; Double.POSITIVE_INFINITY;
}

/**
 * Returns a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;.
 * @param v the destination vertex
 * @return a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;
 *    as an iterable of edges, and &lt;tt&gt;null&lt;/tt&gt; if no such path
 */
public Iterable&lt;DirectedEdge&gt; pathTo(int v) {
    if (!hasPathTo(v)) return null;
    Stack&lt;DirectedEdge&gt; path = new Stack&lt;DirectedEdge&gt;();
    for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {
        path.push(e);
    }
    return path;
}
</code></pre>

<p>}
```</p>

<p>要解决<strong>加权有向图中给定两点（从s到t）的最短路径</strong>这个问题，只要使用Dijkstra算法并从优先队列中取到t之后终止搜索。</p>

<h2>5. 无环加权有向图中的最短路径算法</h2>

<p>如果加权有向图是不含有有向环的，那么可以采用一种比Dijkstra更快、更简单的最短路径算法。它能够在线性时间内解决单点最短路径问题，能够处理负权重的边，还能解决一些其它问题，如找出最长的路径。</p>

<p>根据在<a href="/blog/2014/10/30/you-xiang-tu/">有向图</a>中学习的拓扑顺序知识，我们知道一幅有向无环图的拓扑顺序就是所有顶点的逆后序排列。如果我们按照拓扑顺序放松顶点，就能在E+V成正比的时间内解决无环加权有向图的单点最短路径问题。代码实现如下：</p>

<p>```
public class AcyclicSP {</p>

<pre><code>private double[] distTo;         // distTo[v] = distance  of shortest s-&gt;v path
private DirectedEdge[] edgeTo;   // edgeTo[v] = last edge on shortest s-&gt;v path


/**
 * Computes a shortest paths tree from &lt;tt&gt;s&lt;/tt&gt; to every other vertex in
 * the directed acyclic graph &lt;tt&gt;G&lt;/tt&gt;.
 * @param G the acyclic digraph
 * @param s the source vertex
 * @throws IllegalArgumentException if the digraph is not acyclic
 * @throws IllegalArgumentException unless 0 &amp;le; &lt;tt&gt;s&lt;/tt&gt; &amp;le; &lt;tt&gt;V&lt;/tt&gt; - 1
 */
public AcyclicSP(EdgeWeightedDigraph G, int s) {
    distTo = new double[G.V()];
    edgeTo = new DirectedEdge[G.V()];
    for (int v = 0; v &lt; G.V(); v++)
        distTo[v] = Double.POSITIVE_INFINITY;
    distTo[s] = 0.0;

    // visit vertices in toplogical order
    Topological topological = new Topological(G);
    if (!topological.hasOrder())
        throw new IllegalArgumentException("Digraph is not acyclic.");
    for (int v : topological.order()) {
        for (DirectedEdge e : G.adj(v))
            relax(e);
    }
}

// relax edge e
private void relax(DirectedEdge e) {
    int v = e.from(), w = e.to();
    if (distTo[w] &gt; distTo[v] + e.weight()) {
        distTo[w] = distTo[v] + e.weight();
        edgeTo[w] = e;
    }       
}

/**
 * Returns the length of a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;.
 * @param v the destination vertex
 * @return the length of a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;;
 *    &lt;tt&gt;Double.POSITIVE_INFINITY&lt;/tt&gt; if no such path
 */
public double distTo(int v) {
    return distTo[v];
}

/**
 * Is there a path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;?
 * @param v the destination vertex
 * @return &lt;tt&gt;true&lt;/tt&gt; if there is a path from the source vertex
 *    &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;, and &lt;tt&gt;false&lt;/tt&gt; otherwise
 */
public boolean hasPathTo(int v) {
    return distTo[v] &lt; Double.POSITIVE_INFINITY;
}

/**
 * Returns a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;.
 * @param v the destination vertex
 * @return a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;
 *    as an iterable of edges, and &lt;tt&gt;null&lt;/tt&gt; if no such path
 */
public Iterable&lt;DirectedEdge&gt; pathTo(int v) {
    if (!hasPathTo(v)) return null;
    Stack&lt;DirectedEdge&gt; path = new Stack&lt;DirectedEdge&gt;();
    for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {
        path.push(e);
    }
    return path;
}
</code></pre>

<p>}
```</p>

<p>上面这个算法的效率几乎已经没有提高的空间。<strong>在已知加权图是无环的情况下，它是找出最短路径的最好方法。</strong>而且它与边的权重是否非负无关，因此无环加权有向图不会受到任何限制。</p>

<h3>5.1 最长路径</h3>

<p><strong>无环加权有向图中的单点最长路径。</strong>给定一幅无环加权有向图（边的权重可能为负）和一个起点s，回答“是否存在一条从s到达给定的顶点v的路径？如果有，找出最长（总权重最大）的那条路径。”</p>

<p>最短路径的算法可以稍加改动就可以用于最长路径的计算。</p>

<ul>
<li>方法一：将无环加权有向图复制一份，将副本的所有边的权重取反数。这样副本中的最短路径即为原图中的最长路径。</li>
<li>方法二：改变AcyclicLP类中relax()方法中的不等式方向。这种方法更加简单。</li>
</ul>


<p>最长路径有什么意义？例如并行任务调度中的关键路径问题。关键路径是最长的任务序列，是任务调度中的关键手段。如何利用无环加权有向图计算关键路径？</p>

<blockquote><p>解决并行任务调度问题的关键路径方法的步骤如下：创建一幅无环加权有向图，其中包含一个起点s和一个终点t且每个任务都对应两个顶点（一个起点和一个结点顶点）。对于每个任务都有一条从它的起始顶点指向结束顶点的边，边的权重为任务所需的时间。对于每条优先级限制v->w，添加一条从v的结束顶点指向w的起始顶点的权重为零的边。为每个任务添加一条从起点指向该任务的起始顶点的权重为零的边以及一条从该任务的结束顶点到终点的权重为零的边。这样，每个任务预计的开始时间即为从起点到它的起始顶点的最长距离。</p></blockquote>

<p>下图展示了一个任务调度的无环加权有向图表示。共有0-9个任务，红线表示任务依赖关系（如任务1、7和9依赖于任务0）其权重为0，图形表示如下：</p>

<p><img src="/myresource/images/image_blog_2014-11-05-scheduling-reduction.png" alt="image" /></p>

<p>通过计算最长路径，得到任务的关键路径：</p>

<p><img src="/myresource/images/image_blog_2014-11-05-scheduling-critical-path.png" alt="image" /></p>

<p>最后期限是任务调度中常见的问题，即某个任务必须在指定的时间点之前开始，这种类型的问题如何解决？相对最后期限限制下的并行任务调度问题是一个加权有向图中的最短路径问题（可能存在环和负权重边）。这时可以为每条最后期限限制添加一条边：如果任务v必须在任务w启动后的d个时间单位内开始，则添加一条从v指向w的负权重为d的边。将所有边的权重取反即可将该问题转化为一个最短路径问题。</p>

<p>因此，负权重的边具有实际作用，但前面的算法Dijkstra只适用于非负权重的边，AcyclicSP要求有向图是无环的。它们都无法完成任务，因此需要一种更通用的方法。</p>

<h2>6. 一般加权有向图中的最短路径问题</h2>

<p>所谓一般加权有向图的最短路径问题，就是能够处理有环、负权重边的加权有向图最短路径问题。一幅加权有向图中包含环并不可怕，可怕的是这个环的总权重为负，这时候最短路径就会失去意义。因为无论何时绕这个环一圈都能得到权重更小的路径。<strong>负权重环</strong>就是这样一个总权重（环上的所有边的权重之和）为负的有向环。</p>

<blockquote><p>当且仅当加权有向图中至少存在一条从s到v的有向路径且所有从s到v的有向路径上的任意顶点都不存在于任何负权重环中时，s到v的最短路径才是存在的。</p></blockquote>

<p>Bellman-Ford算法，在任意含有V个顶点的加权有向图中给定起点s，从s无法到达任何负权重环，以下算法能够解决其中的单点最短路径问题：将distTo[s]初始化为0，其他distTo[]元素初始化为无穷大。以任意顺序放松有向图的所有边，重复V轮。</p>

<p>Bellman-Ford算法所需的时间和EV成正比，空间和V成正比。因为每一轮算法都会放松E条边，共重复了V轮。把这个算法稍加改进可以提高效率。每一轮放松所有边的过程中，许多边的放松都不会成功。只有上一轮中的distTo[]值发生变化的顶点指出的边才能够改变其他distTo[]元素的值。因此可以用FIFO队列记录这样的顶点，不需要放松所有边。代码实现如下（先忽略负权重环的代码）：</p>

<p>```
public class BellmanFordSP {</p>

<pre><code>private double[] distTo;               // distTo[v] = 从起点到某个顶点的路径长度
private DirectedEdge[] edgeTo;         // edgeTo[v] = 从起点到某个顶点的最后一条边
private boolean[] onQueue;             // onQueue[v] = 该顶点是否存在于队列中
private Queue&lt;Integer&gt; queue;          // 正在被放松的顶点
private int cost;                      // relax()的调用次数
private Iterable&lt;DirectedEdge&gt; cycle;  // edgeTo[]是否有负权重环

/**
 * Computes a shortest paths tree from &lt;tt&gt;s&lt;/tt&gt; to every other vertex in
 * the edge-weighted digraph &lt;tt&gt;G&lt;/tt&gt;.
 * @param G the acyclic digraph
 * @param s the source vertex
 * @throws IllegalArgumentException unless 0 &amp;le; &lt;tt&gt;s&lt;/tt&gt; &amp;le; &lt;tt&gt;V&lt;/tt&gt; - 1
 */
public BellmanFordSP(EdgeWeightedDigraph G, int s) {
    distTo  = new double[G.V()];
    edgeTo  = new DirectedEdge[G.V()];
    onQueue = new boolean[G.V()];
    for (int v = 0; v &lt; G.V(); v++)
        distTo[v] = Double.POSITIVE_INFINITY;
    distTo[s] = 0.0;

    // Bellman-Ford algorithm
    queue = new Queue&lt;Integer&gt;();
    queue.enqueue(s);
    onQueue[s] = true;
    while (!queue.isEmpty() &amp;&amp; !hasNegativeCycle()) {
        int v = queue.dequeue();
        onQueue[v] = false;
        relax(G, v);
    }
}

// relax vertex v and put other endpoints on queue if changed
private void relax(EdgeWeightedDigraph G, int v) {
    for (DirectedEdge e : G.adj(v)) {
        int w = e.to();
        if (distTo[w] &gt; distTo[v] + e.weight()) {
            //成功放松的边指向的所有顶点加入到FIFO队列
            distTo[w] = distTo[v] + e.weight();
            edgeTo[w] = e;
            if (!onQueue[w]) {
                queue.enqueue(w);
                onQueue[w] = true;
            }
        }
        //周期性地检查是否有负权重环，避免无限循环
        if (cost++ % G.V() == 0) 
            findNegativeCycle();
    }
}

/**
 * Is there a negative cycle reachable from the source vertex &lt;tt&gt;s&lt;/tt&gt;?
 * @return &lt;tt&gt;true&lt;/tt&gt; if there is a negative cycle reachable from the
 *    source vertex &lt;tt&gt;s&lt;/tt&gt;, and &lt;tt&gt;false&lt;/tt&gt; otherwise
 */
public boolean hasNegativeCycle() {
    return cycle != null;
}

/**
 * Returns a negative cycle reachable from the source vertex &lt;tt&gt;s&lt;/tt&gt;, or &lt;tt&gt;null&lt;/tt&gt;
 * if there is no such cycle.
 * @return a negative cycle reachable from the soruce vertex &lt;tt&gt;s&lt;/tt&gt; 
 *    as an iterable of edges, and &lt;tt&gt;null&lt;/tt&gt; if there is no such cycle
 */
public Iterable&lt;DirectedEdge&gt; negativeCycle() {
    return cycle;
}

// by finding a cycle in predecessor graph
private void findNegativeCycle() {
    int V = edgeTo.length;
    EdgeWeightedDigraph spt = new EdgeWeightedDigraph(V);
    for (int v = 0; v &lt; V; v++)
        if (edgeTo[v] != null)
            spt.addEdge(edgeTo[v]);

    EdgeWeightedDirectedCycle finder = new EdgeWeightedDirectedCycle(spt);
    cycle = finder.cycle();
}

/**
 * Returns the length of a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;.
 * @param v the destination vertex
 * @return the length of a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;;
 *    &lt;tt&gt;Double.POSITIVE_INFINITY&lt;/tt&gt; if no such path
 * @throws UnsupportedOperationException if there is a negative cost cycle reachable
 *    from the source vertex &lt;tt&gt;s&lt;/tt&gt;
 */
public double distTo(int v) {
    if (hasNegativeCycle())
        throw new UnsupportedOperationException("Negative cost cycle exists");
    return distTo[v];
}

/**
 * Is there a path from the source &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;?
 * @param v the destination vertex
 * @return &lt;tt&gt;true&lt;/tt&gt; if there is a path from the source vertex
 *    &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;, and &lt;tt&gt;false&lt;/tt&gt; otherwise
 */
public boolean hasPathTo(int v) {
    return distTo[v] &lt; Double.POSITIVE_INFINITY;
}

/**
 * Returns a shortest path from the source &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;.
 * @param v the destination vertex
 * @return a shortest path from the source &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;
 *    as an iterable of edges, and &lt;tt&gt;null&lt;/tt&gt; if no such path
 * @throws UnsupportedOperationException if there is a negative cost cycle reachable
 *    from the source vertex &lt;tt&gt;s&lt;/tt&gt;
 */
public Iterable&lt;DirectedEdge&gt; pathTo(int v) {
    if (hasNegativeCycle())
        throw new UnsupportedOperationException("Negative cost cycle exists");
    if (!hasPathTo(v)) return null;
    Stack&lt;DirectedEdge&gt; path = new Stack&lt;DirectedEdge&gt;();
    for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {
        path.push(e);
    }
    return path;
}
</code></pre>

<p>}
```</p>

<h3>6.1 负权重环的检测</h3>

<p>BellmanFordSP的实现会检测负权重环来避免陷入无限循环。当BellmanFordSP构造函数运行之后，将所有边放松V轮之后当且仅当队列非空时有向图中才存在从起点可达的负权重环。如果是这样，edgeTo[]数组中所表示的子图必然含有这个负权重环。因此nagativeCycle()的实现中，会根据edgeTo[]中的边构造一幅加权有向图并在该图中检测环。我们修改DirectedCycle类来在加权有向图中寻找环：</p>

<p>```
public class EdgeWeightedDirectedCycle {</p>

<pre><code>private boolean[] marked;             // marked[v] = has vertex v been marked?
private DirectedEdge[] edgeTo;        // edgeTo[v] = previous edge on path to v
private boolean[] onStack;            // onStack[v] = is vertex on the stack?
private Stack&lt;DirectedEdge&gt; cycle;    // directed cycle (or null if no such cycle)

/**
 * Determines whether the edge-weighted digraph &lt;tt&gt;G&lt;/tt&gt; has a directed cycle and,
 * if so, finds such a cycle.
 * @param G the edge-weighted digraph
 */
public EdgeWeightedDirectedCycle(EdgeWeightedDigraph G) {
    marked  = new boolean[G.V()];
    onStack = new boolean[G.V()];
    edgeTo  = new DirectedEdge[G.V()];
    for (int v = 0; v &lt; G.V(); v++)
        if (!marked[v]) dfs(G, v);
}

// check that algorithm computes either the topological order or finds a directed cycle
private void dfs(EdgeWeightedDigraph G, int v) {
    onStack[v] = true;
    marked[v] = true;
    for (DirectedEdge e : G.adj(v)) {
        int w = e.to();

        // short circuit if directed cycle found
        if (cycle != null) return;

        //found new vertex, so recur
        else if (!marked[w]) {
            edgeTo[w] = e;
            dfs(G, w);
        }

        // trace back directed cycle
        else if (onStack[w]) {
            cycle = new Stack&lt;DirectedEdge&gt;();
            while (e.from() != w) {
                cycle.push(e);
                e = edgeTo[e.from()];
            }
            cycle.push(e);
        }
    }

    onStack[v] = false;
}

/**
 * Does the edge-weighted digraph have a directed cycle?
 * @return &lt;tt&gt;true&lt;/tt&gt; if the edge-weighted digraph has a directed cycle,
 * &lt;tt&gt;false&lt;/tt&gt; otherwise
 */
public boolean hasCycle() {
    return cycle != null;
}

/**
 * Returns a directed cycle if the edge-weighted digraph has a directed cycle,
 * and &lt;tt&gt;null&lt;/tt&gt; otherwise.
 * @return a directed cycle (as an iterable) if the edge-weighted digraph
 *    has a directed cycle, and &lt;tt&gt;null&lt;/tt&gt; otherwise
 */
public Iterable&lt;DirectedEdge&gt; cycle() {
    return cycle;
}
</code></pre>

<p>}
```</p>

<h3>6.2 套汇</h3>

<p>前面的问题都是权重之和，而套汇问题演示了另一种方式。套汇是通过不同货币间进行兑换赚取利润。这也是一个加权有向图的应用。顶点是货币，s->t表示货币s到t的汇率。如何交易使得利润最大，就是找到各权重之<strong>积</strong>最大者。但我们之前所学的都是权重之和，那么如何解决这个问题呢？</p>

<p>套汇问题等价于加权有向图中的负权重环的检测问题：</p>

<blockquote><p>取每条边权重的自然对数并取反，这样在原始问题中所有边的权重之积的计算就转化为新图中所有边的权重之和的计算。任意权重之积 w<sub>1</sub>w<sub>2</sub>&hellip;w<sub>k</sub>即对应-ln(w<sub>1</sub>)-ln(w<sub>2</sub>)&ndash;&hellip;-ln(w<sub>k</sub>)之和。转换后边的权重可能为正也可能为负。一条从v到w的路径表示将货币v兑换为货币w，任意负权重环都是一次套汇的好机会。</p></blockquote>

<h2>7. 总结</h2>

<p>最短路径算法的性能特点如下表：</p>

<table>
<thead>
<tr>
<th>算法</th>
<th>局限</th>
<th>一般情况</th>
<th>最坏情况</th>
<th>所需空间</th>
<th> 优势</th>
</tr>
</thead>
<tbody>
<tr>
<td>Dijkstra算法（即时版本） </td>
<td> 边的权重必须为正 </td>
<td> ElogV </td>
<td> ElogV </td>
<td> V </td>
<td> 最坏情况下仍有较好的性能</td>
</tr>
<tr>
<td>拓扑排序</td>
<td> 只适用于无环加权有向图</td>
<td> E + V </td>
<td> E + V </td>
<td> V </td>
<td> 是无环图中的最优算法</td>
</tr>
<tr>
<td>Bellman-Ford算法（基于队列）</td>
<td>不能存在负权重环</td>
<td> E+V </td>
<td> EV </td>
<td> V</td>
<td> 适用领域广泛</td>
</tr>
</tbody>
</table>


<p>参考：<a href="http://algs4.cs.princeton.edu/44sp/">http://algs4.cs.princeton.edu/44sp/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最小生成树]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/31/zui-xiao-sheng-cheng-shu/"/>
    <updated>2014-10-31T22:38:49+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/31/zui-xiao-sheng-cheng-shu</id>
    <content type="html"><![CDATA[<p>加权图是一种为每条边关联一个权值或成本的图模型。这种图最令人感兴趣的是将成本最小化。本节学习加权无向图模型并找到它的一棵最小生成树。</p>

<p>图的生成树是它的一棵含有其所有顶点的无环连通子图。一幅加权图的最小生成树（MST）是它的一棵权值（树中所有边的权值之和）最小的生成树。</p>

<!--more-->


<h2>1. 一些约定</h2>

<p>为了方便说明，有以下这些约定：</p>

<ul>
<li>只考虑连通图。如果图是非连通的，只能计算它的所有连通分量的最小生成树，合并起来称为最小生成森林。</li>
<li>边的权重不一定表示距离。但为了看起来方便，示意图会用距离来表示权重。</li>
<li>边的权重可能是0或者负数。</li>
<li>所有边的权重都各不相同。如果权重可以相同，最小生成树就不一定唯一，算法证明会更复杂。但实际上算法也适用于存在权重相等的情况。</li>
</ul>


<h2>2. 原理</h2>

<p>图的一种<strong>切分</strong>是将图的所有顶点分为两个非空且不重叠的两个集合。<strong>横切边</strong>是一条连接两个属于不同集合的顶点的边。</p>

<blockquote><p>切分定理：在一幅加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图的最小生成树。</p></blockquote>

<p>切分定理会把加权图中的所有顶点分为两个集合，检查横跨两个集合的所有边并识别哪边边应属于图的最小生成树。</p>

<h2>3. 加权无向图的数据结构</h2>

<p>通过扩展无向图的邻接矩阵来表示加权无向图。在无向图的邻接表表示中，第v个顶点的列表中每个元素都是和顶点v相邻的顶点。在加权无向图中，我们将其替换为一个加权边Edge：</p>

<p><img src="/myresource/images/image_blog_2014-11-02-edge-api.png" alt="image" /></p>

<p>上图中，eaither()表示边的两个顶点中的某一个，而other()则返回另一个顶点。有了加权边Edge，加权无向图的API就与无向图非常接近，在实现上，只是在邻接表中用Edge对象替代了无向图Graph中的整数作为链表的结点：</p>

<p><img src="/myresource/images/image_blog_2014-11-02-edge-weighted-graph-api.png" alt="image" /></p>

<p>加权无向图的表示如下：</p>

<p><img src="/myresource/images/image_blog_2014-11-02-edge-weighted-graph-representation.png" alt="image" /></p>

<p>代码实现如下：</p>

<p>```java
public class Edge implements Comparable<Edge> {</p>

<pre><code>private final int v;
private final int w;
private final double weight;

public Edge(int v, int w, double weight) {
    if (v &lt; 0) throw new IndexOutOfBoundsException("Vertex name must be a nonnegative integer");
    if (w &lt; 0) throw new IndexOutOfBoundsException("Vertex name must be a nonnegative integer");
    if (Double.isNaN(weight)) throw new IllegalArgumentException("Weight is NaN");
    this.v = v;
    this.w = w;
    this.weight = weight;
}

public double weight() {
    return weight;
}

public int either() {
    return v;
}

public int other(int vertex) {
    if      (vertex == v) return w;
    else if (vertex == w) return v;
    else throw new IllegalArgumentException("Illegal endpoint");
}

public int compareTo(Edge that) {
    if      (this.weight() &lt; that.weight()) return -1;
    else if (this.weight() &gt; that.weight()) return +1;
    else                                    return  0;
}

public String toString() {
    return String.format("%d-%d %.5f", v, w, weight);
}
</code></pre>

<p>}  <br/>
```</p>

<p>```java
public class EdgeWeightedGraph {</p>

<pre><code>private final int V;
private int E;
private Bag&lt;Edge&gt;[] adj;

/**
 * Initializes an empty edge-weighted graph with &lt;tt&gt;V&lt;/tt&gt; vertices and 0 edges.
 * param V the number of vertices
 * @throws java.lang.IllegalArgumentException if &lt;tt&gt;V&lt;/tt&gt; &lt; 0
 */
public EdgeWeightedGraph(int V) {
    if (V &lt; 0) throw new IllegalArgumentException("Number of vertices must be nonnegative");
    this.V = V;
    this.E = 0;
    adj = (Bag&lt;Edge&gt;[]) new Bag[V];
    for (int v = 0; v &lt; V; v++) {
        adj[v] = new Bag&lt;Edge&gt;();
    }
}

/**
 * Initializes a random edge-weighted graph with &lt;tt&gt;V&lt;/tt&gt; vertices and &lt;em&gt;E&lt;/em&gt; edges.
 * param V the number of vertices
 * param E the number of edges
 * @throws java.lang.IllegalArgumentException if &lt;tt&gt;V&lt;/tt&gt; &lt; 0
 * @throws java.lang.IllegalArgumentException if &lt;tt&gt;E&lt;/tt&gt; &lt; 0
 */
public EdgeWeightedGraph(int V, int E) {
    this(V);
    if (E &lt; 0) throw new IllegalArgumentException("Number of edges must be nonnegative");
    for (int i = 0; i &lt; E; i++) {
        int v = (int) (Math.random() * V);
        int w = (int) (Math.random() * V);
        double weight = Math.round(100 * Math.random()) / 100.0;
        Edge e = new Edge(v, w, weight);
        addEdge(e);
    }
}

/**  
 * Initializes an edge-weighted graph from an input stream.
 * The format is the number of vertices &lt;em&gt;V&lt;/em&gt;,
 * followed by the number of edges &lt;em&gt;E&lt;/em&gt;,
 * followed by &lt;em&gt;E&lt;/em&gt; pairs of vertices and edge weights,
 * with each entry separated by whitespace.
 * @param in the input stream
 * @throws java.lang.IndexOutOfBoundsException if the endpoints of any edge are not in prescribed range
 * @throws java.lang.IllegalArgumentException if the number of vertices or edges is negative
 */
public EdgeWeightedGraph(In in) {
    this(in.readInt());
    int E = in.readInt();
    if (E &lt; 0) throw new IllegalArgumentException("Number of edges must be nonnegative");
    for (int i = 0; i &lt; E; i++) {
        int v = in.readInt();
        int w = in.readInt();
        double weight = in.readDouble();
        Edge e = new Edge(v, w, weight);
        addEdge(e);
    }
}

/**
 * Initializes a new edge-weighted graph that is a deep copy of &lt;tt&gt;G&lt;/tt&gt;.
 * @param G the edge-weighted graph to copy
 */
public EdgeWeightedGraph(EdgeWeightedGraph G) {
    this(G.V());
    this.E = G.E();
    for (int v = 0; v &lt; G.V(); v++) {
        // reverse so that adjacency list is in same order as original
        Stack&lt;Edge&gt; reverse = new Stack&lt;Edge&gt;();
        for (Edge e : G.adj[v]) {
            reverse.push(e);
        }
        for (Edge e : reverse) {
            adj[v].add(e);
        }
    }
}

//图的顶点数
public int V() {
    return V;
}

//图的边数
public int E() {
    return E;
}

//向图中添加一条边e
public void addEdge(Edge e) {
    int v = e.either();
    int w = e.other(v);
    if (v &lt; 0 || v &gt;= V) throw new IndexOutOfBoundsException("vertex " + v + " is not between 0 and " + (V-1));
    if (w &lt; 0 || w &gt;= V) throw new IndexOutOfBoundsException("vertex " + w + " is not between 0 and " + (V-1));
    adj[v].add(e);
    adj[w].add(e);
    E++;
}

//与v相关联的所有边
public Iterable&lt;Edge&gt; adj(int v) {
    if (v &lt; 0 || v &gt;= V) throw new IndexOutOfBoundsException("vertex " + v + " is not between 0 and " + (V-1));
    return adj[v];
}

//图中的所有边
public Iterable&lt;Edge&gt; edges() {
    Bag&lt;Edge&gt; list = new Bag&lt;Edge&gt;();
    for (int v = 0; v &lt; V; v++) {
        int selfLoops = 0;
        for (Edge e : adj(v)) {
            if (e.other(v) &gt; v) {
                list.add(e);
            }
            // only add one copy of each self loop (self loops will be consecutive)
            else if (e.other(v) == v) {
                if (selfLoops % 2 == 0) list.add(e);
                selfLoops++;
            }
        }
    }
    return list;
}

public String toString() {
    String NEWLINE = System.getProperty("line.separator");
    StringBuilder s = new StringBuilder();
    s.append(V + " " + E + NEWLINE);
    for (int v = 0; v &lt; V; v++) {
        s.append(v + ": ");
        for (Edge e : adj[v]) {
            s.append(e + "  ");
        }
        s.append(NEWLINE);
    }
    return s.toString();
}
</code></pre>

<p>}
```</p>

<h2>4. 最小生成树的API及实现</h2>

<p>下面API定义的构造函数接受加权无向图作为参数，并返回最小生成树和其权重。</p>

<p><img src="/myresource/images/image_blog_2014-11-02-mst-api.png" alt="image" /></p>

<p>Prim算法和Kruskal算法都可以实现最小生成树，它们都基于贪心算法，区别在于保存切分和判定权重最小的横切边的方式。</p>

<blockquote><p>贪心算法：初始状态下所有边均为灰色，找到一种切分，它产生的横切边均不为黑色。将权重最小的横切边标记为黑色。反复这个步骤直到标记了V-1条黑色边为止。</p></blockquote>

<h3>4.1 Prim算法</h3>

<p>Prim算法每一步都会为一棵生长中的树添加一条边。一开始这棵树只有一个顶点，然后会向它添加V-1条边，每次总是找到这样一条边并将其加入树中：这条边的一端在树中，另一端不在树中，并且权值最小。</p>

<p><img src="/myresource/images/image_blog_2014-11-02-prim-eager.jpg" alt="image" /></p>

<p>每当向树中添加一条边后，也向树中添加了一个顶点。要维护一个包含所有横切边的集合，可以将连接这个顶点和其他所有不在树中的顶点的边加入优先队列。这样就可以得到符合条件的权值最小的边。当一个顶点加入树中后，连接这个顶点与树中其它顶点的所有边就失效了，因为这些边的两个顶点都已经在树中，这些边不再是横切边。那么何时删除这些边就形成了Prim算法的两种实现：</p>

<ul>
<li>延时(Lazy)实现会先把它们留在队列中，等要删除时再检查边的有效性；</li>
<li>即时实现可以将它们从优先队列中删除。</li>
</ul>


<p>这两种实现所需的时间都与ElogE成正比（最坏情况下），延时实现所需的空间与E成正比，瓶颈在于优先队列的insert()和delMin()中比较边的权重次数。而即时实现所需空间的上限与V成正比，比延时实现有优势。两种实现代码如下：</p>

<p>```java
public class LazyPrimMST {</p>

<pre><code>private double weight;       // total weight of MST
private Queue&lt;Edge&gt; mst;     // edges in the MST
private boolean[] marked;    // marked[v] = true if v on tree
private MinPQ&lt;Edge&gt; pq;      // edges with one endpoint in tree

/**
 * Compute a minimum spanning tree (or forest) of an edge-weighted graph.
 * @param G the edge-weighted graph
 */
public LazyPrimMST(EdgeWeightedGraph G) {
    mst = new Queue&lt;Edge&gt;();
    pq = new MinPQ&lt;Edge&gt;();
    marked = new boolean[G.V()];
    for (int v = 0; v &lt; G.V(); v++)     // run Prim from all vertices to
        if (!marked[v]) prim(G, v);     // get a minimum spanning forest
}

// run Prim's algorithm
private void prim(EdgeWeightedGraph G, int s) {
    scan(G, s);
    while (!pq.isEmpty()) {                        // better to stop when mst has V-1 edges
        Edge e = pq.delMin();                      // smallest edge on pq
        int v = e.either(), w = e.other(v);        // two endpoints
        assert marked[v] || marked[w];
        if (marked[v] &amp;&amp; marked[w]) continue;      // lazy, both v and w already scanned
        mst.enqueue(e);                            // add e to MST
        weight += e.weight();
        if (!marked[v]) scan(G, v);               // v becomes part of tree
        if (!marked[w]) scan(G, w);               // w becomes part of tree
    }
}

//标记顶点v并将所有连接v和未被标记顶点的边加入pq
private void scan(EdgeWeightedGraph G, int v) {
    assert !marked[v];
    marked[v] = true;
    for (Edge e : G.adj(v))
        if (!marked[e.other(v)]) pq.insert(e);
}

//树的所有边
public Iterable&lt;Edge&gt; edges() {
    return mst;
}

//树的权重
public double weight() {
    return weight;
}
</code></pre>

<p>}
```</p>

<p>```java
public class PrimMST {</p>

<pre><code>private Edge[] edgeTo;        // 距离树最近的边，edgeTo[v] = shortest edge from tree vertex to non-tree vertex
private double[] distTo;      // distTo[v] = weight of shortest such edge
private boolean[] marked;     // marked[v] = true if v on tree, false otherwise
private IndexMinPQ&lt;Double&gt; pq;  //有效的横切边

/**
 * Compute a minimum spanning tree (or forest) of an edge-weighted graph.
 * @param G the edge-weighted graph
 */
public PrimMST(EdgeWeightedGraph G) {
    edgeTo = new Edge[G.V()];
    distTo = new double[G.V()];
    marked = new boolean[G.V()];
    pq = new IndexMinPQ&lt;Double&gt;(G.V());
    for (int v = 0; v &lt; G.V(); v++) distTo[v] = Double.POSITIVE_INFINITY;

    for (int v = 0; v &lt; G.V(); v++)      // run from each vertex to find
        if (!marked[v]) prim(G, v);      // minimum spanning forest
}

// run Prim's algorithm in graph G, starting from vertex s
private void prim(EdgeWeightedGraph G, int s) {
    distTo[s] = 0.0;
    pq.insert(s, distTo[s]); //用顶点0和权重0初始化pq
    while (!pq.isEmpty()) {
        int v = pq.delMin();  
        scan(G, v);          //将最近的顶点添加到树中
    }
}

// scan vertex v
private void scan(EdgeWeightedGraph G, int v) {
        //将顶点v添加到树中，更新数据
    marked[v] = true;
    for (Edge e : G.adj(v)) {
        int w = e.other(v);
        if (marked[w]) continue;         // v-w 已经失效
        if (e.weight() &lt; distTo[w]) {
                //连接w和树的最佳边Edge变为e
            distTo[w] = e.weight();
            edgeTo[w] = e;
            if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);
            else                pq.insert(w, distTo[w]);
        }
    }
}

//所有边
public Iterable&lt;Edge&gt; edges() {
    Queue&lt;Edge&gt; mst = new Queue&lt;Edge&gt;();
    for (int v = 0; v &lt; edgeTo.length; v++) {
        Edge e = edgeTo[v];
        if (e != null) {
            mst.enqueue(e);
        }
    }
    return mst;
}

//权重
public double weight() {
    double weight = 0.0;
    for (Edge e : edges())
        weight += e.weight();
    return weight;
}
</code></pre>

<p>}
```</p>

<h3>4.2 Kruskal算法</h3>

<p>Kruskal算法构造最小生成树时也是一条边一条边地构造，但它寻找的边会连接一片森林中的两棵树。我们从一片由V棵单顶点的树构成的森林开始并不断将两棵树合并（用可以找到的最短边）直到只剩下一棵树。其主要思想是按边的权重顺序处理它们，将边加入最小生成树中，加入的边不会与已经加入的边构成环，直到树中含有V-1条边为止。</p>

<p><img src="/myresource/images/image_blog_2014-11-02-kruskal.jpg" alt="image" /></p>

<p>实现时，采用优先队列将边按照权重排序，用一个union-find数据结构识别会形成环的边，以及一个队列来保存最小生成树的所有边。代码实现如下：</p>

<p>```
public class KruskalMST {</p>

<pre><code>private double weight;  // weight of MST
private Queue&lt;Edge&gt; mst = new Queue&lt;Edge&gt;();  // edges in MST

public KruskalMST(EdgeWeightedGraph G) {
    // more efficient to build heap by passing array of edges
    MinPQ&lt;Edge&gt; pq = new MinPQ&lt;Edge&gt;();
    for (Edge e : G.edges()) {
        pq.insert(e);
    }

    // run greedy algorithm
    UF uf = new UF(G.V());
    while (!pq.isEmpty() &amp;&amp; mst.size() &lt; G.V() - 1) {
        Edge e = pq.delMin();  //从pq得到权重最小的边和它的顶点
        int v = e.either();
        int w = e.other(v);
        if (!uf.connected(v, w)) { // v-w does not create a cycle
            uf.union(v, w);  // merge v and w components
            mst.enqueue(e);  // add edge e to mst
            weight += e.weight();
        }
    }
}

//树的所有边
public Iterable&lt;Edge&gt; edges() {
    return mst;
}

//树的权重
public double weight() {
    return weight;
}
</code></pre>

<p>}
```</p>

<p>Kruskal算法所需的空间与E成正比，所需时间与ElogE成正比（最坏情况下）。</p>

<p>Prim和Kruskal算法不能处理有向图。</p>

<p>参考：<a href="http://algs4.cs.princeton.edu/43mst/">http://algs4.cs.princeton.edu/43mst</a></p>
]]></content>
  </entry>
  
</feed>
