<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 算法 | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/suan-fa/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2014-11-09T14:06:43+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[最短路径]]></title>
    <link href="http://blog.ubone.com/blog/2014/11/03/zui-duan-lu-jing/"/>
    <updated>2014-11-03T20:22:31+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/11/03/zui-duan-lu-jing</id>
    <content type="html"><![CDATA[<p>最短路径算法可以解决很多问题，例如地图导航、任务调度和网络路由等。本章的主题就是找到从一个顶点到达另一个顶点的成本最小的路径。</p>

<blockquote><p>在一幅加权有向图中，从顶点s到顶点t的最短路径是所有从s到t的路径中的权重最小者。</p></blockquote>

<p>本章要涉及以下问题：</p>

<ul>
<li>加权有向图的API、单点最短路径的API及它们的实现；</li>
<li>解决边的权重非负的最短路径问题的经典Dijkstra算法；</li>
<li>在无环加权有向图中解决该问题的一种快速算法，边的权重甚至可以是负值；</li>
<li>适用于一般情况的经典Bellman-Ford算法，其中图可以含有环，边的权重也可以是负值。</li>
</ul>


<!--more-->


<h2>1. 最短路径的性质</h2>

<ul>
<li>路径是有向的；</li>
<li>权重不一定等价于距离，但示例图会用距离代表权重；</li>
<li>并不是所有顶点都是可达的；</li>
<li>负权重会使问题更复杂，暂时假定边的权重是非负的；</li>
<li>算法会忽略构成环的零权重边，找到的最短路径都不会含有环；</li>
<li>最短路径不一定是唯一的，只找到其中一条即可；</li>
<li>可能存在平行边和自环，为避免歧义假设不存在平行边，但代码处理它们并没有困难。</li>
</ul>


<p>单点最短路径的计算结果是一棵最短路径树（SPT），它包含了顶点s到达所有可达的顶点的最短路径。</p>

<blockquote><p>给定一幅加权有向图和一个顶点s，以s为起点的一棵最短路径树是图的一幅子图，它包含s和从s可达的所有顶点。这棵有向树的根结点是s，树的每条路径都是有向图中的一条最短路径。</p></blockquote>

<h2>2. 加权有向图的数据结构</h2>

<p>有向边的数据结构比无向边更简单，因为有向边只有一个方向。其API定义如下：</p>

<p><img src="/myresource/images/image_blog_2014-11-04-directed-edge-api.png" alt="image" /></p>

<p>```java
public class DirectedEdge {</p>

<pre><code>private final int v;                //边的起点
private final int w;                //边的终点
private final double weight;        //边的权重

public DirectedEdge(int v, int w, double weight) {
    if (v &lt; 0) throw new IndexOutOfBoundsException("Vertex names must be nonnegative integers");
    if (w &lt; 0) throw new IndexOutOfBoundsException("Vertex names must be nonnegative integers");
    if (Double.isNaN(weight)) throw new IllegalArgumentException("Weight is NaN");
    this.v = v;
    this.w = w;
    this.weight = weight;
}

public int from() {return v;}
public int to() {return w;}
public double weight() {return weight;}

public String toString() {
    return v + "-&gt;" + w + " " + String.format("%5.2f", weight);
}
</code></pre>

<p>}
```</p>

<p>加权有向图的API也与无向图类似：</p>

<p><img src="/myresource/images/image_blog_2014-11-04-edge-weighted-digraph-api.png" alt="image" /></p>

<p>```java
public class EdgeWeightedDigraph {</p>

<pre><code>private final int V;                    //顶点总数
private int E;                          //边的总数
private Bag&lt;DirectedEdge&gt;[] adj;        //邻接表

public EdgeWeightedDigraph(int V) {
    if (V &lt; 0) throw new IllegalArgumentException("Number of vertices in a Digraph must be nonnegative");
    this.V = V;
    this.E = 0;
    adj = (Bag&lt;DirectedEdge&gt;[]) new Bag[V];
    for (int v = 0; v &lt; V; v++)
        adj[v] = new Bag&lt;DirectedEdge&gt;();
}

public int V() {return V;}
public int E() {return E;}

//将e添加到有向图中
public void addEdge(DirectedEdge e) {
    adj[e.from()].add(e);
    E++;
}

//从v指出的边
public Iterable&lt;DirectedEdge&gt; adj(int v) {
    return adj[v];
}

//有向图中的所有边
public Iterable&lt;DirectedEdge&gt; edges() {
    Bag&lt;DirectedEdge&gt; list = new Bag&lt;DirectedEdge&gt;();
    for (int v = 0; v &lt; V; v++) {
        for (DirectedEdge e : adj(v)) {
            list.add(e);
        }
    }
    return list;
} 
</code></pre>

<p>}
```</p>

<p>加权有向图的表示：</p>

<p><img src="/myresource/images/image_blog_2014-11-04-edge-weighted-digraph-representation.png" alt="image" /></p>

<h3>2.1 最短路径</h3>

<p>最短路径的API：</p>

<p><img src="/myresource/images/image_blog_2014-11-04-sp-api.png" alt="image" /></p>

<p>在实现时，分别用两个数组来表示最短路径：</p>

<ul>
<li>最短路径树中的边：DirectedEdge[] edgeTo，edgeTo[v]的值为树中连接v和它的父结点的边。</li>
<li>到达起点的距离：Double[] distTo，distTo[v]为从起点s到v的已知最短路径的长度。</li>
</ul>


<p>同时约定edgeTo[s] == null, distTo[s] == 0; 不可达的顶点的距离为Double.POSITIVE_INFINITY。</p>

<h3>2.2 松弛操作</h3>

<p>松弛（Relaxation）操作是最短路径实现中使用的关键操作。对边v->w松弛意味着检查从s到w的最短路径是否是先从s到v，然后再由v到w。如果是，则由v到达w的最短路径是distTo[v] + e.weight()。如果这个值不小于distTo[w]，则证明刚才的边失效可忽略，否则证明现在的值更小，需要更新数据。</p>

<p>下图演示了这种情况，左侧的v->w不满足条件，被忽略。而右侧的图v->满足条件，替换为新的最短路径。</p>

<p><img src="/myresource/images/image_blog_2014-11-04-relaxation-edge.png" alt="image" /></p>

<p>对顶点的松弛操作就是对该顶点指出的所有边进行松弛操作。每次顶点的松弛操作都能得出到达某个顶点的更短的路径。算法就这样最终找出到达每个顶点的最短路径。</p>

<h2>3. 最短路径算法的理论基础</h2>

<p>最短路径的最优性条件：</p>

<blockquote><p>令G为一幅加权有向图，顶点s是G中的起点，distTo[]是一个由顶点索引的数组，保存的是G中路径的长度。对于从s可达的所有顶点v，distTo[v]的值是从s到v的某条路径的长度，对于从s不可达的所有顶点v，该值为无穷大。当且仅当对于从v到w的任意一条边e, 这些值都满足distTo[w] &lt;= distTo[v] + e.weight()时，它们是最短路径的长度。</p></blockquote>

<p>根据最优性条件，我们可以得到一个通用算法，暂时只考虑非负权重的情况：</p>

<blockquote><p>将distTo[s]初始化为0，其它distTo[]元素初始化为无穷大，继续如下操作：放松G中的任意边，直到不存在有效边为止。对于任意从s可达的顶点w，进行这些操作后，distTo[w]的值即为从s到w的最短路径的长度。</p></blockquote>

<h2>4. Dijkstra算法</h2>

<p>Dijkstra算法能够解决边权重非负的加权有向图的单起点最短路径问题。它与无向图的最小生成树的Prim算法（每一步都向最小生成树中添加一条新的边）非常相似。首先将distTo[s]初始华为0，distTo[]的其他元素初始化为正无穷。然后<strong>将distTo[]最小的非树顶点放松并加入树中，如此这般，直到所有的顶点都在树中或者所有的非树顶点的distTo[]值均为无穷大。</strong></p>

<p>Dijkstra算法实现时，除了要distTo[]和edgeTo[]之外，还需要一条索引优先队列pa，以保存需要被放松的顶点并确认下一个被放松的顶点。只要将v和distTo[v]关联起来放入队列就可以立即实现Dijkstra算法。Prim算法每次添加的都是离树最近的非树顶点，而Dijkstra算法每次添加的都是离起点最近的非树顶点。如果将加权无向图看成加权有向图，对无向图中的每条边都相应地创建方向相反的有向边，最短路径的问题是等价的。Dijkstra算法实现实现如下：</p>

<p>```
public class DijkstraSP {</p>

<pre><code>private double[] distTo;          // distTo[v] = distance  of shortest s-&gt;v path
private DirectedEdge[] edgeTo;    // edgeTo[v] = last edge on shortest s-&gt;v path
private IndexMinPQ&lt;Double&gt; pq;    // priority queue of vertices

/**
 * Computes a shortest paths tree from &lt;tt&gt;s&lt;/tt&gt; to every other vertex in
 * the edge-weighted digraph &lt;tt&gt;G&lt;/tt&gt;.
 * @param G the edge-weighted digraph
 * @param s the source vertex
 * @throws IllegalArgumentException if an edge weight is negative
 * @throws IllegalArgumentException unless 0 &amp;le; &lt;tt&gt;s&lt;/tt&gt; &amp;le; &lt;tt&gt;V&lt;/tt&gt; - 1
 */
public DijkstraSP(EdgeWeightedDigraph G, int s) {
    for (DirectedEdge e : G.edges()) {
        if (e.weight() &lt; 0)
            throw new IllegalArgumentException("edge " + e + " has negative weight");
    }

    distTo = new double[G.V()];
    edgeTo = new DirectedEdge[G.V()];
    for (int v = 0; v &lt; G.V(); v++)
        distTo[v] = Double.POSITIVE_INFINITY;
    distTo[s] = 0.0;

    // relax vertices in order of distance from s
    pq = new IndexMinPQ&lt;Double&gt;(G.V());
    pq.insert(s, distTo[s]);
    while (!pq.isEmpty()) {
        int v = pq.delMin();
        for (DirectedEdge e : G.adj(v))
            relax(e);
    }
}

// relax edge e and update pq if changed
private void relax(DirectedEdge e) {
    int v = e.from(), w = e.to();
    if (distTo[w] &gt; distTo[v] + e.weight()) {
        distTo[w] = distTo[v] + e.weight();
        edgeTo[w] = e;
        if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);
        else                pq.insert(w, distTo[w]);
    }
}

/**
 * Returns the length of a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;.
 * @param v the destination vertex
 * @return the length of a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;;
 *    &lt;tt&gt;Double.POSITIVE_INFINITY&lt;/tt&gt; if no such path
 */
public double distTo(int v) {
    return distTo[v];
}

/**
 * Is there a path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;?
 * @param v the destination vertex
 * @return &lt;tt&gt;true&lt;/tt&gt; if there is a path from the source vertex
 *    &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;, and &lt;tt&gt;false&lt;/tt&gt; otherwise
 */
public boolean hasPathTo(int v) {
    return distTo[v] &lt; Double.POSITIVE_INFINITY;
}

/**
 * Returns a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;.
 * @param v the destination vertex
 * @return a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;
 *    as an iterable of edges, and &lt;tt&gt;null&lt;/tt&gt; if no such path
 */
public Iterable&lt;DirectedEdge&gt; pathTo(int v) {
    if (!hasPathTo(v)) return null;
    Stack&lt;DirectedEdge&gt; path = new Stack&lt;DirectedEdge&gt;();
    for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {
        path.push(e);
    }
    return path;
}
</code></pre>

<p>}
```</p>

<p>要解决<strong>加权有向图中给定两点（从s到t）的最短路径</strong>这个问题，只要使用Dijkstra算法并从优先队列中取到t之后终止搜索。</p>

<h2>5. 无环加权有向图中的最短路径算法</h2>

<p>如果加权有向图是不含有有向环的，那么可以采用一种比Dijkstra更快、更简单的最短路径算法。它能够在线性时间内解决单点最短路径问题，能够处理负权重的边，还能解决一些其它问题，如找出最长的路径。</p>

<p>根据在<a href="/blog/2014/10/30/you-xiang-tu/">有向图</a>中学习的拓扑顺序知识，我们知道一幅有向无环图的拓扑顺序就是所有顶点的逆后序排列。如果我们按照拓扑顺序放松顶点，就能在E+V成正比的时间内解决无环加权有向图的单点最短路径问题。代码实现如下：</p>

<p>```
public class AcyclicSP {</p>

<pre><code>private double[] distTo;         // distTo[v] = distance  of shortest s-&gt;v path
private DirectedEdge[] edgeTo;   // edgeTo[v] = last edge on shortest s-&gt;v path


/**
 * Computes a shortest paths tree from &lt;tt&gt;s&lt;/tt&gt; to every other vertex in
 * the directed acyclic graph &lt;tt&gt;G&lt;/tt&gt;.
 * @param G the acyclic digraph
 * @param s the source vertex
 * @throws IllegalArgumentException if the digraph is not acyclic
 * @throws IllegalArgumentException unless 0 &amp;le; &lt;tt&gt;s&lt;/tt&gt; &amp;le; &lt;tt&gt;V&lt;/tt&gt; - 1
 */
public AcyclicSP(EdgeWeightedDigraph G, int s) {
    distTo = new double[G.V()];
    edgeTo = new DirectedEdge[G.V()];
    for (int v = 0; v &lt; G.V(); v++)
        distTo[v] = Double.POSITIVE_INFINITY;
    distTo[s] = 0.0;

    // visit vertices in toplogical order
    Topological topological = new Topological(G);
    if (!topological.hasOrder())
        throw new IllegalArgumentException("Digraph is not acyclic.");
    for (int v : topological.order()) {
        for (DirectedEdge e : G.adj(v))
            relax(e);
    }
}

// relax edge e
private void relax(DirectedEdge e) {
    int v = e.from(), w = e.to();
    if (distTo[w] &gt; distTo[v] + e.weight()) {
        distTo[w] = distTo[v] + e.weight();
        edgeTo[w] = e;
    }       
}

/**
 * Returns the length of a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;.
 * @param v the destination vertex
 * @return the length of a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;;
 *    &lt;tt&gt;Double.POSITIVE_INFINITY&lt;/tt&gt; if no such path
 */
public double distTo(int v) {
    return distTo[v];
}

/**
 * Is there a path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;?
 * @param v the destination vertex
 * @return &lt;tt&gt;true&lt;/tt&gt; if there is a path from the source vertex
 *    &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;, and &lt;tt&gt;false&lt;/tt&gt; otherwise
 */
public boolean hasPathTo(int v) {
    return distTo[v] &lt; Double.POSITIVE_INFINITY;
}

/**
 * Returns a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;.
 * @param v the destination vertex
 * @return a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;
 *    as an iterable of edges, and &lt;tt&gt;null&lt;/tt&gt; if no such path
 */
public Iterable&lt;DirectedEdge&gt; pathTo(int v) {
    if (!hasPathTo(v)) return null;
    Stack&lt;DirectedEdge&gt; path = new Stack&lt;DirectedEdge&gt;();
    for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {
        path.push(e);
    }
    return path;
}
</code></pre>

<p>}
```</p>

<p>上面这个算法的效率几乎已经没有提高的空间。<strong>在已知加权图是无环的情况下，它是找出最短路径的最好方法。</strong>而且它与边的权重是否非负无关，因此无环加权有向图不会受到任何限制。</p>

<h3>5.1 最长路径</h3>

<p><strong>无环加权有向图中的单点最长路径。</strong>给定一幅无环加权有向图（边的权重可能为负）和一个起点s，回答“是否存在一条从s到达给定的顶点v的路径？如果有，找出最长（总权重最大）的那条路径。”</p>

<p>最短路径的算法可以稍加改动就可以用于最长路径的计算。</p>

<ul>
<li>方法一：将无环加权有向图复制一份，将副本的所有边的权重取反数。这样副本中的最短路径即为原图中的最长路径。</li>
<li>方法二：改变AcyclicLP类中relax()方法中的不等式方向。这种方法更加简单。</li>
</ul>


<p>最长路径有什么意义？例如并行任务调度中的关键路径问题。关键路径是最长的任务序列，是任务调度中的关键手段。如何利用无环加权有向图计算关键路径？</p>

<blockquote><p>解决并行任务调度问题的关键路径方法的步骤如下：创建一幅无环加权有向图，其中包含一个起点s和一个终点t且每个任务都对应两个顶点（一个起点和一个结点顶点）。对于每个任务都有一条从它的起始顶点指向结束顶点的边，边的权重为任务所需的时间。对于每条优先级限制v->w，添加一条从v的结束顶点指向w的起始顶点的权重为零的边。为每个任务添加一条从起点指向该任务的起始顶点的权重为零的边以及一条从该任务的结束顶点到终点的权重为零的边。这样，每个任务预计的开始时间即为从起点到它的起始顶点的最长距离。</p></blockquote>

<p>下图展示了一个任务调度的无环加权有向图表示。共有0-9个任务，红线表示任务依赖关系（如任务1、7和9依赖于任务0）其权重为0，图形表示如下：</p>

<p><img src="/myresource/images/image_blog_2014-11-05-scheduling-reduction.png" alt="image" /></p>

<p>通过计算最长路径，得到任务的关键路径：</p>

<p><img src="/myresource/images/image_blog_2014-11-05-scheduling-critical-path.png" alt="image" /></p>

<p>最后期限是任务调度中常见的问题，即某个任务必须在指定的时间点之前开始，这种类型的问题如何解决？相对最后期限限制下的并行任务调度问题是一个加权有向图中的最短路径问题（可能存在环和负权重边）。这时可以为每条最后期限限制添加一条边：如果任务v必须在任务w启动后的d个时间单位内开始，则添加一条从v指向w的负权重为d的边。将所有边的权重取反即可将该问题转化为一个最短路径问题。</p>

<p>因此，负权重的边具有实际作用，但前面的算法Dijkstra只适用于非负权重的边，AcyclicSP要求有向图是无环的。它们都无法完成任务，因此需要一种更通用的方法。</p>

<h2>6. 一般加权有向图中的最短路径问题</h2>

<p>所谓一般加权有向图的最短路径问题，就是能够处理有环、负权重边的加权有向图最短路径问题。一幅加权有向图中包含环并不可怕，可怕的是这个环的总权重为负，这时候最短路径就会失去意义。因为无论何时绕这个环一圈都能得到权重更小的路径。<strong>负权重环</strong>就是这样一个总权重（环上的所有边的权重之和）为负的有向环。</p>

<blockquote><p>当且仅当加权有向图中至少存在一条从s到v的有向路径且所有从s到v的有向路径上的任意顶点都不存在于任何负权重环中时，s到v的最短路径才是存在的。</p></blockquote>

<p>Bellman-Ford算法，在任意含有V个顶点的加权有向图中给定起点s，从s无法到达任何负权重环，以下算法能够解决其中的单点最短路径问题：将distTo[s]初始化为0，其他distTo[]元素初始化为无穷大。以任意顺序放松有向图的所有边，重复V轮。</p>

<p>Bellman-Ford算法所需的时间和EV成正比，空间和V成正比。因为每一轮算法都会放松E条边，共重复了V轮。把这个算法稍加改进可以提高效率。每一轮放松所有边的过程中，许多边的放松都不会成功。只有上一轮中的distTo[]值发生变化的顶点指出的边才能够改变其他distTo[]元素的值。因此可以用FIFO队列记录这样的顶点，不需要放松所有边。代码实现如下（先忽略负权重环的代码）：</p>

<p>```
public class BellmanFordSP {</p>

<pre><code>private double[] distTo;               // distTo[v] = 从起点到某个顶点的路径长度
private DirectedEdge[] edgeTo;         // edgeTo[v] = 从起点到某个顶点的最后一条边
private boolean[] onQueue;             // onQueue[v] = 该顶点是否存在于队列中
private Queue&lt;Integer&gt; queue;          // 正在被放松的顶点
private int cost;                      // relax()的调用次数
private Iterable&lt;DirectedEdge&gt; cycle;  // edgeTo[]是否有负权重环

/**
 * Computes a shortest paths tree from &lt;tt&gt;s&lt;/tt&gt; to every other vertex in
 * the edge-weighted digraph &lt;tt&gt;G&lt;/tt&gt;.
 * @param G the acyclic digraph
 * @param s the source vertex
 * @throws IllegalArgumentException unless 0 &amp;le; &lt;tt&gt;s&lt;/tt&gt; &amp;le; &lt;tt&gt;V&lt;/tt&gt; - 1
 */
public BellmanFordSP(EdgeWeightedDigraph G, int s) {
    distTo  = new double[G.V()];
    edgeTo  = new DirectedEdge[G.V()];
    onQueue = new boolean[G.V()];
    for (int v = 0; v &lt; G.V(); v++)
        distTo[v] = Double.POSITIVE_INFINITY;
    distTo[s] = 0.0;

    // Bellman-Ford algorithm
    queue = new Queue&lt;Integer&gt;();
    queue.enqueue(s);
    onQueue[s] = true;
    while (!queue.isEmpty() &amp;&amp; !hasNegativeCycle()) {
        int v = queue.dequeue();
        onQueue[v] = false;
        relax(G, v);
    }
}

// relax vertex v and put other endpoints on queue if changed
private void relax(EdgeWeightedDigraph G, int v) {
    for (DirectedEdge e : G.adj(v)) {
        int w = e.to();
        if (distTo[w] &gt; distTo[v] + e.weight()) {
            //成功放松的边指向的所有顶点加入到FIFO队列
            distTo[w] = distTo[v] + e.weight();
            edgeTo[w] = e;
            if (!onQueue[w]) {
                queue.enqueue(w);
                onQueue[w] = true;
            }
        }
        //周期性地检查是否有负权重环，避免无限循环
        if (cost++ % G.V() == 0) 
            findNegativeCycle();
    }
}

/**
 * Is there a negative cycle reachable from the source vertex &lt;tt&gt;s&lt;/tt&gt;?
 * @return &lt;tt&gt;true&lt;/tt&gt; if there is a negative cycle reachable from the
 *    source vertex &lt;tt&gt;s&lt;/tt&gt;, and &lt;tt&gt;false&lt;/tt&gt; otherwise
 */
public boolean hasNegativeCycle() {
    return cycle != null;
}

/**
 * Returns a negative cycle reachable from the source vertex &lt;tt&gt;s&lt;/tt&gt;, or &lt;tt&gt;null&lt;/tt&gt;
 * if there is no such cycle.
 * @return a negative cycle reachable from the soruce vertex &lt;tt&gt;s&lt;/tt&gt; 
 *    as an iterable of edges, and &lt;tt&gt;null&lt;/tt&gt; if there is no such cycle
 */
public Iterable&lt;DirectedEdge&gt; negativeCycle() {
    return cycle;
}

// by finding a cycle in predecessor graph
private void findNegativeCycle() {
    int V = edgeTo.length;
    EdgeWeightedDigraph spt = new EdgeWeightedDigraph(V);
    for (int v = 0; v &lt; V; v++)
        if (edgeTo[v] != null)
            spt.addEdge(edgeTo[v]);

    EdgeWeightedDirectedCycle finder = new EdgeWeightedDirectedCycle(spt);
    cycle = finder.cycle();
}

/**
 * Returns the length of a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;.
 * @param v the destination vertex
 * @return the length of a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;;
 *    &lt;tt&gt;Double.POSITIVE_INFINITY&lt;/tt&gt; if no such path
 * @throws UnsupportedOperationException if there is a negative cost cycle reachable
 *    from the source vertex &lt;tt&gt;s&lt;/tt&gt;
 */
public double distTo(int v) {
    if (hasNegativeCycle())
        throw new UnsupportedOperationException("Negative cost cycle exists");
    return distTo[v];
}

/**
 * Is there a path from the source &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;?
 * @param v the destination vertex
 * @return &lt;tt&gt;true&lt;/tt&gt; if there is a path from the source vertex
 *    &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;, and &lt;tt&gt;false&lt;/tt&gt; otherwise
 */
public boolean hasPathTo(int v) {
    return distTo[v] &lt; Double.POSITIVE_INFINITY;
}

/**
 * Returns a shortest path from the source &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;.
 * @param v the destination vertex
 * @return a shortest path from the source &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;
 *    as an iterable of edges, and &lt;tt&gt;null&lt;/tt&gt; if no such path
 * @throws UnsupportedOperationException if there is a negative cost cycle reachable
 *    from the source vertex &lt;tt&gt;s&lt;/tt&gt;
 */
public Iterable&lt;DirectedEdge&gt; pathTo(int v) {
    if (hasNegativeCycle())
        throw new UnsupportedOperationException("Negative cost cycle exists");
    if (!hasPathTo(v)) return null;
    Stack&lt;DirectedEdge&gt; path = new Stack&lt;DirectedEdge&gt;();
    for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {
        path.push(e);
    }
    return path;
}
</code></pre>

<p>}
```</p>

<h3>6.1 负权重环的检测</h3>

<p>BellmanFordSP的实现会检测负权重环来避免陷入无限循环。当BellmanFordSP构造函数运行之后，将所有边放松V轮之后当且仅当队列非空时有向图中才存在从起点可达的负权重环。如果是这样，edgeTo[]数组中所表示的子图必然含有这个负权重环。因此nagativeCycle()的实现中，会根据edgeTo[]中的边构造一幅加权有向图并在该图中检测环。我们修改DirectedCycle类来在加权有向图中寻找环：</p>

<p>```
public class EdgeWeightedDirectedCycle {</p>

<pre><code>private boolean[] marked;             // marked[v] = has vertex v been marked?
private DirectedEdge[] edgeTo;        // edgeTo[v] = previous edge on path to v
private boolean[] onStack;            // onStack[v] = is vertex on the stack?
private Stack&lt;DirectedEdge&gt; cycle;    // directed cycle (or null if no such cycle)

/**
 * Determines whether the edge-weighted digraph &lt;tt&gt;G&lt;/tt&gt; has a directed cycle and,
 * if so, finds such a cycle.
 * @param G the edge-weighted digraph
 */
public EdgeWeightedDirectedCycle(EdgeWeightedDigraph G) {
    marked  = new boolean[G.V()];
    onStack = new boolean[G.V()];
    edgeTo  = new DirectedEdge[G.V()];
    for (int v = 0; v &lt; G.V(); v++)
        if (!marked[v]) dfs(G, v);
}

// check that algorithm computes either the topological order or finds a directed cycle
private void dfs(EdgeWeightedDigraph G, int v) {
    onStack[v] = true;
    marked[v] = true;
    for (DirectedEdge e : G.adj(v)) {
        int w = e.to();

        // short circuit if directed cycle found
        if (cycle != null) return;

        //found new vertex, so recur
        else if (!marked[w]) {
            edgeTo[w] = e;
            dfs(G, w);
        }

        // trace back directed cycle
        else if (onStack[w]) {
            cycle = new Stack&lt;DirectedEdge&gt;();
            while (e.from() != w) {
                cycle.push(e);
                e = edgeTo[e.from()];
            }
            cycle.push(e);
        }
    }

    onStack[v] = false;
}

/**
 * Does the edge-weighted digraph have a directed cycle?
 * @return &lt;tt&gt;true&lt;/tt&gt; if the edge-weighted digraph has a directed cycle,
 * &lt;tt&gt;false&lt;/tt&gt; otherwise
 */
public boolean hasCycle() {
    return cycle != null;
}

/**
 * Returns a directed cycle if the edge-weighted digraph has a directed cycle,
 * and &lt;tt&gt;null&lt;/tt&gt; otherwise.
 * @return a directed cycle (as an iterable) if the edge-weighted digraph
 *    has a directed cycle, and &lt;tt&gt;null&lt;/tt&gt; otherwise
 */
public Iterable&lt;DirectedEdge&gt; cycle() {
    return cycle;
}
</code></pre>

<p>}
```</p>

<h3>6.2 套汇</h3>

<p>前面的问题都是权重之和，而套汇问题演示了另一种方式。套汇是通过不同货币间进行兑换赚取利润。这也是一个加权有向图的应用。顶点是货币，s->t表示货币s到t的汇率。如何交易使得利润最大，就是找到各权重之<strong>积</strong>最大者。但我们之前所学的都是权重之和，那么如何解决这个问题呢？</p>

<p>套汇问题等价于加权有向图中的负权重环的检测问题：</p>

<blockquote><p>取每条边权重的自然对数并取反，这样在原始问题中所有边的权重之积的计算就转化为新图中所有边的权重之和的计算。任意权重之积 w<sub>1</sub>w<sub>2</sub>&hellip;w<sub>k</sub>即对应-ln(w<sub>1</sub>)-ln(w<sub>2</sub>)&ndash;&hellip;-ln(w<sub>k</sub>)之和。转换后边的权重可能为正也可能为负。一条从v到w的路径表示将货币v兑换为货币w，任意负权重环都是一次套汇的好机会。</p></blockquote>

<h2>7. 总结</h2>

<p>最短路径算法的性能特点如下表：</p>

<table>
<thead>
<tr>
<th>算法</th>
<th>局限</th>
<th>一般情况</th>
<th>最坏情况</th>
<th>所需空间</th>
<th> 优势</th>
</tr>
</thead>
<tbody>
<tr>
<td>Dijkstra算法（即时版本） </td>
<td> 边的权重必须为正 </td>
<td> ElogV </td>
<td> ElogV </td>
<td> V </td>
<td> 最坏情况下仍有较好的性能</td>
</tr>
<tr>
<td>拓扑排序</td>
<td> 只适用于无环加权有向图</td>
<td> E + V </td>
<td> E + V </td>
<td> V </td>
<td> 是无环图中的最优算法</td>
</tr>
<tr>
<td>Bellman-Ford算法（基于队列）</td>
<td>不能存在负权重环</td>
<td> E+V </td>
<td> EV </td>
<td> V</td>
<td> 适用领域广泛</td>
</tr>
</tbody>
</table>


<p>参考：<a href="http://algs4.cs.princeton.edu/44sp/">http://algs4.cs.princeton.edu/44sp/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最小生成树]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/31/zui-xiao-sheng-cheng-shu/"/>
    <updated>2014-10-31T22:38:49+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/31/zui-xiao-sheng-cheng-shu</id>
    <content type="html"><![CDATA[<p>加权图是一种为每条边关联一个权值或成本的图模型。这种图最令人感兴趣的是将成本最小化。本节学习加权无向图模型并找到它的一棵最小生成树。</p>

<p>图的生成树是它的一棵含有其所有顶点的无环连通子图。一幅加权图的最小生成树（MST）是它的一棵权值（树中所有边的权值之和）最小的生成树。</p>

<!--more-->


<h2>1. 一些约定</h2>

<p>为了方便说明，有以下这些约定：</p>

<ul>
<li>只考虑连通图。如果图是非连通的，只能计算它的所有连通分量的最小生成树，合并起来称为最小生成森林。</li>
<li>边的权重不一定表示距离。但为了看起来方便，示意图会用距离来表示权重。</li>
<li>边的权重可能是0或者负数。</li>
<li>所有边的权重都各不相同。如果权重可以相同，最小生成树就不一定唯一，算法证明会更复杂。但实际上算法也适用于存在权重相等的情况。</li>
</ul>


<h2>2. 原理</h2>

<p>图的一种<strong>切分</strong>是将图的所有顶点分为两个非空且不重叠的两个集合。<strong>横切边</strong>是一条连接两个属于不同集合的顶点的边。</p>

<blockquote><p>切分定理：在一幅加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图的最小生成树。</p></blockquote>

<p>切分定理会把加权图中的所有顶点分为两个集合，检查横跨两个集合的所有边并识别哪边边应属于图的最小生成树。</p>

<h2>3. 加权无向图的数据结构</h2>

<p>通过扩展无向图的邻接矩阵来表示加权无向图。在无向图的邻接表表示中，第v个顶点的列表中每个元素都是和顶点v相邻的顶点。在加权无向图中，我们将其替换为一个加权边Edge：</p>

<p><img src="/myresource/images/image_blog_2014-11-02-edge-api.png" alt="image" /></p>

<p>上图中，eaither()表示边的两个顶点中的某一个，而other()则返回另一个顶点。有了加权边Edge，加权无向图的API就与无向图非常接近，在实现上，只是在邻接表中用Edge对象替代了无向图Graph中的整数作为链表的结点：</p>

<p><img src="/myresource/images/image_blog_2014-11-02-edge-weighted-graph-api.png" alt="image" /></p>

<p>加权无向图的表示如下：</p>

<p><img src="/myresource/images/image_blog_2014-11-02-edge-weighted-graph-representation.png" alt="image" /></p>

<p>代码实现如下：</p>

<p>```java
public class Edge implements Comparable<Edge> {</p>

<pre><code>private final int v;
private final int w;
private final double weight;

public Edge(int v, int w, double weight) {
    if (v &lt; 0) throw new IndexOutOfBoundsException("Vertex name must be a nonnegative integer");
    if (w &lt; 0) throw new IndexOutOfBoundsException("Vertex name must be a nonnegative integer");
    if (Double.isNaN(weight)) throw new IllegalArgumentException("Weight is NaN");
    this.v = v;
    this.w = w;
    this.weight = weight;
}

public double weight() {
    return weight;
}

public int either() {
    return v;
}

public int other(int vertex) {
    if      (vertex == v) return w;
    else if (vertex == w) return v;
    else throw new IllegalArgumentException("Illegal endpoint");
}

public int compareTo(Edge that) {
    if      (this.weight() &lt; that.weight()) return -1;
    else if (this.weight() &gt; that.weight()) return +1;
    else                                    return  0;
}

public String toString() {
    return String.format("%d-%d %.5f", v, w, weight);
}
</code></pre>

<p>}  <br/>
```</p>

<p>```java
public class EdgeWeightedGraph {</p>

<pre><code>private final int V;
private int E;
private Bag&lt;Edge&gt;[] adj;

/**
 * Initializes an empty edge-weighted graph with &lt;tt&gt;V&lt;/tt&gt; vertices and 0 edges.
 * param V the number of vertices
 * @throws java.lang.IllegalArgumentException if &lt;tt&gt;V&lt;/tt&gt; &lt; 0
 */
public EdgeWeightedGraph(int V) {
    if (V &lt; 0) throw new IllegalArgumentException("Number of vertices must be nonnegative");
    this.V = V;
    this.E = 0;
    adj = (Bag&lt;Edge&gt;[]) new Bag[V];
    for (int v = 0; v &lt; V; v++) {
        adj[v] = new Bag&lt;Edge&gt;();
    }
}

/**
 * Initializes a random edge-weighted graph with &lt;tt&gt;V&lt;/tt&gt; vertices and &lt;em&gt;E&lt;/em&gt; edges.
 * param V the number of vertices
 * param E the number of edges
 * @throws java.lang.IllegalArgumentException if &lt;tt&gt;V&lt;/tt&gt; &lt; 0
 * @throws java.lang.IllegalArgumentException if &lt;tt&gt;E&lt;/tt&gt; &lt; 0
 */
public EdgeWeightedGraph(int V, int E) {
    this(V);
    if (E &lt; 0) throw new IllegalArgumentException("Number of edges must be nonnegative");
    for (int i = 0; i &lt; E; i++) {
        int v = (int) (Math.random() * V);
        int w = (int) (Math.random() * V);
        double weight = Math.round(100 * Math.random()) / 100.0;
        Edge e = new Edge(v, w, weight);
        addEdge(e);
    }
}

/**  
 * Initializes an edge-weighted graph from an input stream.
 * The format is the number of vertices &lt;em&gt;V&lt;/em&gt;,
 * followed by the number of edges &lt;em&gt;E&lt;/em&gt;,
 * followed by &lt;em&gt;E&lt;/em&gt; pairs of vertices and edge weights,
 * with each entry separated by whitespace.
 * @param in the input stream
 * @throws java.lang.IndexOutOfBoundsException if the endpoints of any edge are not in prescribed range
 * @throws java.lang.IllegalArgumentException if the number of vertices or edges is negative
 */
public EdgeWeightedGraph(In in) {
    this(in.readInt());
    int E = in.readInt();
    if (E &lt; 0) throw new IllegalArgumentException("Number of edges must be nonnegative");
    for (int i = 0; i &lt; E; i++) {
        int v = in.readInt();
        int w = in.readInt();
        double weight = in.readDouble();
        Edge e = new Edge(v, w, weight);
        addEdge(e);
    }
}

/**
 * Initializes a new edge-weighted graph that is a deep copy of &lt;tt&gt;G&lt;/tt&gt;.
 * @param G the edge-weighted graph to copy
 */
public EdgeWeightedGraph(EdgeWeightedGraph G) {
    this(G.V());
    this.E = G.E();
    for (int v = 0; v &lt; G.V(); v++) {
        // reverse so that adjacency list is in same order as original
        Stack&lt;Edge&gt; reverse = new Stack&lt;Edge&gt;();
        for (Edge e : G.adj[v]) {
            reverse.push(e);
        }
        for (Edge e : reverse) {
            adj[v].add(e);
        }
    }
}

//图的顶点数
public int V() {
    return V;
}

//图的边数
public int E() {
    return E;
}

//向图中添加一条边e
public void addEdge(Edge e) {
    int v = e.either();
    int w = e.other(v);
    if (v &lt; 0 || v &gt;= V) throw new IndexOutOfBoundsException("vertex " + v + " is not between 0 and " + (V-1));
    if (w &lt; 0 || w &gt;= V) throw new IndexOutOfBoundsException("vertex " + w + " is not between 0 and " + (V-1));
    adj[v].add(e);
    adj[w].add(e);
    E++;
}

//与v相关联的所有边
public Iterable&lt;Edge&gt; adj(int v) {
    if (v &lt; 0 || v &gt;= V) throw new IndexOutOfBoundsException("vertex " + v + " is not between 0 and " + (V-1));
    return adj[v];
}

//图中的所有边
public Iterable&lt;Edge&gt; edges() {
    Bag&lt;Edge&gt; list = new Bag&lt;Edge&gt;();
    for (int v = 0; v &lt; V; v++) {
        int selfLoops = 0;
        for (Edge e : adj(v)) {
            if (e.other(v) &gt; v) {
                list.add(e);
            }
            // only add one copy of each self loop (self loops will be consecutive)
            else if (e.other(v) == v) {
                if (selfLoops % 2 == 0) list.add(e);
                selfLoops++;
            }
        }
    }
    return list;
}

public String toString() {
    String NEWLINE = System.getProperty("line.separator");
    StringBuilder s = new StringBuilder();
    s.append(V + " " + E + NEWLINE);
    for (int v = 0; v &lt; V; v++) {
        s.append(v + ": ");
        for (Edge e : adj[v]) {
            s.append(e + "  ");
        }
        s.append(NEWLINE);
    }
    return s.toString();
}
</code></pre>

<p>}
```</p>

<h2>4. 最小生成树的API及实现</h2>

<p>下面API定义的构造函数接受加权无向图作为参数，并返回最小生成树和其权重。</p>

<p><img src="/myresource/images/image_blog_2014-11-02-mst-api.png" alt="image" /></p>

<p>Prim算法和Kruskal算法都可以实现最小生成树，它们都基于贪心算法，区别在于保存切分和判定权重最小的横切边的方式。</p>

<blockquote><p>贪心算法：初始状态下所有边均为灰色，找到一种切分，它产生的横切边均不为黑色。将权重最小的横切边标记为黑色。反复这个步骤直到标记了V-1条黑色边为止。</p></blockquote>

<h3>4.1 Prim算法</h3>

<p>Prim算法每一步都会为一棵生长中的树添加一条边。一开始这棵树只有一个顶点，然后会向它添加V-1条边，每次总是找到这样一条边并将其加入树中：这条边的一端在树中，另一端不在树中，并且权值最小。</p>

<p><img src="/myresource/images/image_blog_2014-11-02-prim-eager.png" alt="image" /></p>

<p>每当向树中添加一条边后，也向树中添加了一个顶点。要维护一个包含所有横切边的集合，可以将连接这个顶点和其他所有不在树中的顶点的边加入优先队列。这样就可以得到符合条件的权值最小的边。当一个顶点加入树中后，连接这个顶点与树中其它顶点的所有边就失效了，因为这些边的两个顶点都已经在树中，这些边不再是横切边。那么何时删除这些边就形成了Prim算法的两种实现：</p>

<ul>
<li>延时(Lazy)实现会先把它们留在队列中，等要删除时再检查边的有效性；</li>
<li>即时实现可以将它们从优先队列中删除。</li>
</ul>


<p>这两种实现所需的时间都与ElogE成正比（最坏情况下），延时实现所需的空间与E成正比，瓶颈在于优先队列的insert()和delMin()中比较边的权重次数。而即时实现所需空间的上限与V成正比，比延时实现有优势。两种实现代码如下：</p>

<p>```java
public class LazyPrimMST {</p>

<pre><code>private double weight;       // total weight of MST
private Queue&lt;Edge&gt; mst;     // edges in the MST
private boolean[] marked;    // marked[v] = true if v on tree
private MinPQ&lt;Edge&gt; pq;      // edges with one endpoint in tree

/**
 * Compute a minimum spanning tree (or forest) of an edge-weighted graph.
 * @param G the edge-weighted graph
 */
public LazyPrimMST(EdgeWeightedGraph G) {
    mst = new Queue&lt;Edge&gt;();
    pq = new MinPQ&lt;Edge&gt;();
    marked = new boolean[G.V()];
    for (int v = 0; v &lt; G.V(); v++)     // run Prim from all vertices to
        if (!marked[v]) prim(G, v);     // get a minimum spanning forest
}

// run Prim's algorithm
private void prim(EdgeWeightedGraph G, int s) {
    scan(G, s);
    while (!pq.isEmpty()) {                        // better to stop when mst has V-1 edges
        Edge e = pq.delMin();                      // smallest edge on pq
        int v = e.either(), w = e.other(v);        // two endpoints
        assert marked[v] || marked[w];
        if (marked[v] &amp;&amp; marked[w]) continue;      // lazy, both v and w already scanned
        mst.enqueue(e);                            // add e to MST
        weight += e.weight();
        if (!marked[v]) scan(G, v);               // v becomes part of tree
        if (!marked[w]) scan(G, w);               // w becomes part of tree
    }
}

//标记顶点v并将所有连接v和未被标记顶点的边加入pq
private void scan(EdgeWeightedGraph G, int v) {
    assert !marked[v];
    marked[v] = true;
    for (Edge e : G.adj(v))
        if (!marked[e.other(v)]) pq.insert(e);
}

//树的所有边
public Iterable&lt;Edge&gt; edges() {
    return mst;
}

//树的权重
public double weight() {
    return weight;
}
</code></pre>

<p>}
```</p>

<p>```java
public class PrimMST {</p>

<pre><code>private Edge[] edgeTo;        // 距离树最近的边，edgeTo[v] = shortest edge from tree vertex to non-tree vertex
private double[] distTo;      // distTo[v] = weight of shortest such edge
private boolean[] marked;     // marked[v] = true if v on tree, false otherwise
private IndexMinPQ&lt;Double&gt; pq;  //有效的横切边

/**
 * Compute a minimum spanning tree (or forest) of an edge-weighted graph.
 * @param G the edge-weighted graph
 */
public PrimMST(EdgeWeightedGraph G) {
    edgeTo = new Edge[G.V()];
    distTo = new double[G.V()];
    marked = new boolean[G.V()];
    pq = new IndexMinPQ&lt;Double&gt;(G.V());
    for (int v = 0; v &lt; G.V(); v++) distTo[v] = Double.POSITIVE_INFINITY;

    for (int v = 0; v &lt; G.V(); v++)      // run from each vertex to find
        if (!marked[v]) prim(G, v);      // minimum spanning forest
}

// run Prim's algorithm in graph G, starting from vertex s
private void prim(EdgeWeightedGraph G, int s) {
    distTo[s] = 0.0;
    pq.insert(s, distTo[s]); //用顶点0和权重0初始化pq
    while (!pq.isEmpty()) {
        int v = pq.delMin();  
        scan(G, v);          //将最近的顶点添加到树中
    }
}

// scan vertex v
private void scan(EdgeWeightedGraph G, int v) {
        //将顶点v添加到树中，更新数据
    marked[v] = true;
    for (Edge e : G.adj(v)) {
        int w = e.other(v);
        if (marked[w]) continue;         // v-w 已经失效
        if (e.weight() &lt; distTo[w]) {
                //连接w和树的最佳边Edge变为e
            distTo[w] = e.weight();
            edgeTo[w] = e;
            if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);
            else                pq.insert(w, distTo[w]);
        }
    }
}

//所有边
public Iterable&lt;Edge&gt; edges() {
    Queue&lt;Edge&gt; mst = new Queue&lt;Edge&gt;();
    for (int v = 0; v &lt; edgeTo.length; v++) {
        Edge e = edgeTo[v];
        if (e != null) {
            mst.enqueue(e);
        }
    }
    return mst;
}

//权重
public double weight() {
    double weight = 0.0;
    for (Edge e : edges())
        weight += e.weight();
    return weight;
}
</code></pre>

<p>}
```</p>

<h3>4.2 Kruskal算法</h3>

<p>Kruskal算法构造最小生成树时也是一条边一条边地构造，但它寻找的边会连接一片森林中的两棵树。我们从一片由V棵单顶点的树构成的森林开始并不断将两棵树合并（用可以找到的最短边）直到只剩下一棵树。其主要思想是按边的权重顺序处理它们，将边加入最小生成树中，加入的边不会与已经加入的边构成环，直到树中含有V-1条边为止。</p>

<p><img src="/myresource/images/image_blog_2014-11-02-kruskal.png" alt="image" /></p>

<p>实现时，采用优先队列将边按照权重排序，用一个union-find数据结构识别会形成环的边，以及一个队列来保存最小生成树的所有边。代码实现如下：</p>

<p>```
public class KruskalMST {</p>

<pre><code>private double weight;  // weight of MST
private Queue&lt;Edge&gt; mst = new Queue&lt;Edge&gt;();  // edges in MST

public KruskalMST(EdgeWeightedGraph G) {
    // more efficient to build heap by passing array of edges
    MinPQ&lt;Edge&gt; pq = new MinPQ&lt;Edge&gt;();
    for (Edge e : G.edges()) {
        pq.insert(e);
    }

    // run greedy algorithm
    UF uf = new UF(G.V());
    while (!pq.isEmpty() &amp;&amp; mst.size() &lt; G.V() - 1) {
        Edge e = pq.delMin();  //从pq得到权重最小的边和它的顶点
        int v = e.either();
        int w = e.other(v);
        if (!uf.connected(v, w)) { // v-w does not create a cycle
            uf.union(v, w);  // merge v and w components
            mst.enqueue(e);  // add edge e to mst
            weight += e.weight();
        }
    }
}

//树的所有边
public Iterable&lt;Edge&gt; edges() {
    return mst;
}

//树的权重
public double weight() {
    return weight;
}
</code></pre>

<p>}
```</p>

<p>Kruskal算法所需的空间与E成正比，所需时间与ElogE成正比（最坏情况下）。</p>

<p>Prim和Kruskal算法不能处理有向图。</p>

<p>参考：<a href="http://algs4.cs.princeton.edu/43mst/">http://algs4.cs.princeton.edu/43mst</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[有向图]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/30/you-xiang-tu/"/>
    <updated>2014-10-30T20:10:54+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/30/you-xiang-tu</id>
    <content type="html"><![CDATA[<p>有向图也就是有方向性的图，是由一组顶点和一组有方向的边组成，每条有方向的边都连接着有序的一对顶点。本文要解决的有向图问题：</p>

<ol>
<li>单点和多点的可达性</li>
<li>单点有向路径</li>
<li>单点最短有向路径</li>
<li>有向环检测</li>
<li>深度优先的顶点排序</li>
<li>优先级限制下的调度问题</li>
<li>拓扑排序</li>
<li>强连通性</li>
<li>顶点对的可达性</li>
</ol>


<!--more-->


<h2>1. 术语</h2>

<ul>
<li>出度：一个顶点指出的边的总数；</li>
<li>入度：指向该顶点的边的总数；</li>
<li>一条有向边的第一个顶点称为头，第二个顶点称为尾。</li>
<li>在一幅有向图中，有向路径由一系列顶点组成，对于其中的每个顶点都存在一条有向边从它指向序列中的下一个顶点。</li>
</ul>


<h2>2. 有向图的数据类型</h2>

<p>有向图的API与无向图本质相同，只是多了一个取反操作。如下图：</p>

<p><img src="/myresource/images/image_blog_2014-10-20-digraph-api.png" alt="image" /></p>

<p>其中，reverse()方向返回有向图的一个副本，但是将其中的方向反转。adj()返回的是每个顶点指出的边所连接的所有顶点。</p>

<p>Diagraph的实现与无向图Graph非常类似，也是采用邻接表实现，但由于边是有向的，所以假设7&mdash;>8的一条边，则在顶点7的邻接表中有8，而顶点8的邻接表却没有7. <a href="http://algs4.cs.princeton.edu/42directed/Digraph.java.html">实现代码</a>不再重复。</p>

<h2>3. 有向图中的可达性</h2>

<ul>
<li>单点可达性：是否存在一条从s到达给定顶点v的有向路径？</li>
<li>多点可达性：是否存在一条从集合中的任意顶点到达给定顶点v的有向路径？</li>
</ul>


<p>API定义和实现如下：</p>

<p>```
public class DirectedDFS {</p>

<pre><code>private boolean[] marked;

//在G中找到从s可达的所有顶点
public DirectedDFS(Digraph G, int s) {
    marked = new boolean[G.V()];
    dfs(G, s);
}

//在G中找到从sources中的所有顶点可达的所有顶点
public DirectedDFS(Digraph G, Iterable&lt;Integer&gt; sources) {
    marked = new boolean[G.V()];
    for(int s : sources) {
        if (! marked[s]) dfs(G, s);
    }
}

private void dfs(Digraph G, int v) {
    marked[v] = true;
    for(int w : G.adj(v)){
        if (!marked[w]) dfs(G, w);
    }
}

//v是可达的吗？
public boolean marked(int v) {
    return marked[v];
}
</code></pre>

<p>}
```</p>

<p><strong>标记-清除：</strong>多点可达性的一个重要典型应用就是内存管理，包括许多Java的实现。一个顶点表示一个对象，一条边表示一个对象对另一个对象的引用。在程序执行任何时候，都有某些对象是可以被直接访问的，而不能通过这些对象访问到的所有对象都应该被回收。标记-清除的垃圾回收策略会为每个对象保留一个位做垃圾收集之用。</p>

<p><strong>有向图的寻路：</strong></p>

<ul>
<li>单点有向路径：从s到给定的顶点v是否存在一条有向路径？如果有，找出这条路径。</li>
<li>单点最短有向路径：从s到给定的顶点v是否存在一条有向路径？如果有，找出最短的那边。</li>
</ul>


<p>这两个问题都可以通过深度优先和广度优先解决，它们仍是有向图的重要算法。API和代码也基本相同。</p>

<h2>4. 环和有向无环图</h2>

<h3>4.1 有向图中的环</h3>

<p>任务调度是一个典型的有向图用例，其限制条件包括任务的起始时间、时耗、优先级限制（某个任务是另一个任务的前置条件）等。如何进行正确的任务调度？这需要<strong>拓扑排序</strong>：给定一幅有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素。拓扑排序的例子还包括课程安排（先导课程限制）、继承（Java extends）、电子表格公式等等。</p>

<p>如果一个有优先级限制的问题中存在有向环，例如任务x必须在任务y之前完成，而y必须在z之前完成，但z又必须在x之前完成，那么这个问题就无解了！所以首先要解决<strong>有向环的检测</strong>：给定的有向图中包含有向环吗？</p>

<p><strong>有向无环图（DAG）是一幅不含有向环的有向图。</strong></p>

<p>有向环的检测可以通过深度优先搜索来解决。用一个栈表示正在遍历的有向路径，一旦找到一条有向边v->w且w已经在堆栈中，就找到了一个环。</p>

<p>```java
public class DirectedCycle {</p>

<pre><code>private boolean[] marked;        // marked[v] = 顶点v是否已经访问过?
private int[] edgeTo;            // edgeTo[v] = 指向v的前一个顶点
private boolean[] onStack;       // onStack[v] = 顶点v在递归调用的堆栈上吗？
private Stack&lt;Integer&gt; cycle;    // 有向环 (null表示不存在有向环)

public DirectedCycle(Digraph G) {
    marked  = new boolean[G.V()];
    onStack = new boolean[G.V()];
    edgeTo  = new int[G.V()];
    for (int v = 0; v &lt; G.V(); v++)
        if (!marked[v]) dfs(G, v);
}

private void dfs(Digraph G, int v) {
    onStack[v] = true;
    marked[v] = true;
    for (int w : G.adj(v)) {
        // 如果环已找到，退出
        if (cycle != null) {
               return;
        }
        //找到新顶点，继续
        else if (!marked[w]) {
            edgeTo[w] = v;
            dfs(G, w);
        }
        // 找到有向环，记录下路径
        else if (onStack[w]) {
            cycle = new Stack&lt;Integer&gt;();
            for (int x = v; x != w; x = edgeTo[x]) {
                cycle.push(x);
            }
            cycle.push(w);
            cycle.push(v);
        }
    }

    onStack[v] = false;
}

//是否含有有向环
public boolean hasCycle() {
    return cycle != null;
}

//有向环中的所有顶点（如果存在有向环的话）
public Iterable&lt;Integer&gt; cycle() {
    return cycle;
}
</code></pre>

<p>}
```</p>

<h3>4.2 顶点的深度优先次序与拓扑排序</h3>

<p>优先级限制下的调度问题等价于计算有向无环图中的所有顶点的拓扑排序。只需要在标准深度优先搜索中，将<code>dfs()</code>的顶点参数保存在一个数据结构中，遍历这个数据结构就能访问所有的顶点。遍历的顺序取决于这个数据结构的性质以及是在递归调用之前还是之后进行保存。主要有3种排序顺序：</p>

<ol>
<li>前序(pre)：在递归调用之前将顶点加入队列。</li>
<li>后序(post)：在递归调用之后将顶点加入队列。</li>
<li>逆后序(reversePost)：在递归调用之后将顶点压入堆栈。</li>
</ol>


<p>对于这样一张有向图，三种顺序遍历过程如下：</p>

<p><img src="/myresource/images/image_blog_2014-10-29-dag.png" alt="image" /></p>

<p><img src="/myresource/images/image_blog_2014-10-29-depth-first-orders.png" alt="image" /></p>

<p>下面实现的DepthFirstOrder实现了这三种排序：</p>

<p>```java
public class DepthFirstOrder {</p>

<pre><code>private boolean[] marked;          // marked[v] = has v been marked in dfs?
private Queue&lt;Integer&gt; pre;                 // pre[v]    = preorder  number of v
private Queue&lt;Integer&gt; post;                // post[v]   = postorder number of v
private Stack&lt;Integer&gt; reversePost;

public DepthFirstOrder(Digraph G) {
    pre    = new Queue&lt;Integer&gt;();
    post   = new Queue&lt;Integer&gt;();
    reversePost = new Stack&lt;Integer&gt;();
    marked    = new boolean[G.V()];

    for (int v = 0; v &lt; G.V(); v++)
        if (!marked[v]) dfs(G, v);
}

private void dfs(Digraph G, int v) {
    pre.enqueue(v);

    marked[v] = true;

    for (int w : G.adj(v)) {
        if (!marked[w]) {
            dfs(G, w);
        }
    }

    post.enqueue(v);
    reversePost.push(v);
}

public Iterable&lt;Integer&gt; pre() {
    return pre;
}
public Iterable&lt;Integer&gt; post() {
    return post;
}   
public Iterable&lt;Integer&gt; reversePost() {
    return reversePost;
}
</code></pre>

<p>}
```</p>

<p>DepthFirstOrder提供了三种排序的顶点列表：pre, post, reversePost，因此拓扑排序就非常简单了：</p>

<p>```java
public class Topological {</p>

<pre><code>private Iterable&lt;Integer&gt; order;    // topological order

public Topological(Digraph G) {
    DirectedCycle finder = new DirectedCycle(G);
    if (!finder.hasCycle()) {
        DepthFirstOrder dfs = new DepthFirstOrder(G);
        order = dfs.reversePost();
    }
}

//拓扑有序的所有顶点
public Iterable&lt;Integer&gt; order() {
    return order;
}

//G是有向无环图吗？
public boolean isDAG() {
    return order != null;
}
</code></pre>

<p>}  <br/>
```</p>

<p><strong>一幅有向无环图的拓扑顺序就是所有顶点的逆后序排列。</strong>这是一个重要结论！证明如下：对于任意边v->w, 在调用dfs(v)时，必有以下三种情况之一：</p>

<ol>
<li>dfs(w)已经被调用过且已经返回（w已经被标记）。</li>
<li>dfs(w)还没有被调用，因此v->会直接或间接调用并返回dfs(w)，且dfs(w)会在dfs(v)返回前返回。</li>
<li>dfs(w)已经被调用但未返回。</li>
</ol>


<p>第3种情况表示存在环，所以在有向无环图中是不可能出现的。第1、2种情况都证明了dfs(w)会先于dfs(v)完成。后序排列时w在v之前，只有逆后序时，w排在v之后。因此逆后序是有向无环图的拓扑顺序。</p>

<p>再次说明，拓扑排序和有向环的检测总是一起出现的，因为有向环的检测是排序的前提。</p>

<h2>5. 有向图的强连通性</h2>

<p>如果两个顶点v和w是互相可达的，也就是存在一条从v到w的有向路径，同时还存在一条从w到v的有向路径，那么v和w是<strong>强连通</strong>的。</p>

<p>强连通性将所有顶点分为一些等价类，每个等价类都由相互均为强连通的顶点的最大子集组成，这些子集称为<strong>强连通分量</strong>。强连通分量的典型应用包括：网络（网页和超链接）、软件（模块和调用）、食物链（物种和捕食关系）等。强连通分量的API:</p>

<p><img src="/myresource/images/image_blog_2014-10-30-scc-api.png" alt="image" /></p>

<h3>5.1 Kosaraju算法</h3>

<p>Kosaraju算法实现了SCC API：</p>

<ul>
<li>在给定的一幅有向图G中，使用DepthFirstOrder来计算它的反向图G<sup>R</sup>的逆后序排列。</li>
<li>在G中进行标准的深度优先搜索，但是要按照刚才计算得到的顺序而非标准的顺序来访问所有未被标记的顶点。</li>
<li>在构造函数中，所有在同一个递归dfs()调用中被访问到的顶点都在同一个强连通分量中，将它们按照和CC相同的方式识别出来。</li>
</ul>


<p>要证明Kosaraju算法的正确性，首先证明：“每个和s强连通的顶点v都会在构造函数调用的dfs(G,s)中被访问到。”这个毫无疑问。然后再证明：“构造函数调用的dfs(G,s)所到达的任意顶点v都必然是和s强连通的。”设v为dfs(G,s)到达的某个顶点。那么G中必然存在一条从s到v的路径，因此只需证明G中还存在一条从v到s的路径即可。也就等价于证明G<sup>R</sup>中存在一条从s到v的路径：</p>

<blockquote><p>按照逆后序进行的深度优先搜索意味着，在G<sup>R</sup>中进行的深度优先搜索中，dfs(G,v)必然在dfs(G,s)之前就已经结束了，这样dfs(G,v)的调用就只会出现两种情况：</p>

<ol>
<li>调用在dfs(G,s)的调用之前（并且也在dfs(G,s)的调用之前结束）</li>
<li>调用在dfs(G,s)的调用之后（并且也在dfs(G,s)的调用之前结束）</li>
</ol>


<p>第一种情况不可能出现，因为在G<sup>R</sup>中存在一条从v到s的路径；而第二种情况说明G<sup>R</sup>中存在一条从s到v的路径。证毕。</p></blockquote>

<p>```java
public class KosarajuSharirSCC {</p>

<pre><code>private boolean[] marked;     //已访问过的顶点
private int[] id;             //强连通分量的标识符
private int count;            //强连通分量的数量

public KosarajuSharirSCC(Digraph G) {

    // compute reverse postorder of reverse graph
    DepthFirstOrder dfs = new DepthFirstOrder(G.reverse());

    // run DFS on G, using reverse postorder to guide calculation
    marked = new boolean[G.V()];
    id = new int[G.V()];
    for (int v : dfs.reversePost()) {
        if (!marked[v]) {
            dfs(G, v);
            count++;
        }
    }
}

private void dfs(Digraph G, int v) { 
    marked[v] = true;
    id[v] = count;
    for (int w : G.adj(v)) {
        if (!marked[w]) dfs(G, w);
    }
}

//图中的强连通分量的总数
public int count() {
    return count;
}

//v和w是强连通的吗
public boolean stronglyConnected(int v, int w) {
    return id[v] == id[w];
}

//v所在的强连通分量的标识符（在0至count()-1之间）
public int id(int v) {
    return id[v];
}
</code></pre>

<p>}  <br/>
```</p>

<h3>5.2 顶点对的可达性</h3>

<p>给定一幅有向图，回答“是否存在一条从一个给定的顶点v到达另一个给定的顶点w的路径？”对于无向图，这个问题等价于连通性问题。而对有向图，有很大区别。看似简单的问题困难了专家数十年。如何大幅减少预处理所需的时间和空间，又保证常数的查询时间。这仍然是一个有待解决的问题。而且这个问题有重要的实际意义：处理互联网这样的巨型有向图。</p>

<p>下面的算法只是简单地实现了可达性，但不适用于处理大型有向图，因为它所需的空间与V<sup>2</sup>成正比，所需时间和V(V+E)成正比。但如果图小的话，仍然是一个理想的解决办法。</p>

<p>```
public class TransitiveClosure {</p>

<pre><code>private DirectedDFS[] tc;  // tc[v] = reachable from v

//预处理的构造方法
public TransitiveClosure(Digraph G) {
    tc = new DirectedDFS[G.V()];
    for (int v = 0; v &lt; G.V(); v++)
        tc[v] = new DirectedDFS(G, v);
}

//w是从v可达的吗？
public boolean reachable(int v, int w) {
    return tc[v].marked(w);
}
</code></pre>

<p>}
```</p>

<p>参考：<a href="http://algs4.cs.princeton.edu/42directed/">http://algs4.cs.princeton.edu/42directed/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[无向图]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/03/wu-xiang-tu/"/>
    <updated>2014-10-03T18:18:44+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/03/wu-xiang-tu</id>
    <content type="html"><![CDATA[<p>无向图由一组顶点(Vertex)和一组能够将两个顶点相连的边(Edge)组成。本章学习无向图的邻接表实现，以及相关的搜索和应用，例如深度优先和广度优先搜索，路径查找和最短路径计算，连通分量和符号图。本文要解决的无向图问题包括：</p>

<ol>
<li>单点连通性</li>
<li>单点路径</li>
<li>单点最短路径</li>
<li>连通性</li>
<li>检测环</li>
<li>双色问题（图的二分性）</li>
</ol>


<!--more-->


<h2>1. 术语</h2>

<p>v-w表示连接v和w的边。自环和平行边是两种特殊的图。<strong>自环</strong>即一条连接一个顶点和其自身的边；<strong>平行边</strong>是连接同一对顶点的两条边。含有平行边的图称为多重图，没有平行边和自环的图称为<strong>简单图</strong>。</p>

<p>当两个顶点通过一条边相连时，这两个顶点是<strong>相邻的</strong>。某个顶点的<strong>度数(Degree)</strong>即为依附于它的边的总数。<strong>子图</strong>是由一幅图的所有边的一个子集（以及它们所依附的所有顶点）组成的图。</p>

<p>在图中，<strong>路径</strong>是由边顺序连接的一系列顶点。<strong>简单路径</strong>是一条没有重复顶点的路径。<strong>环</strong>是一条至少含有一条边，并且起点和终点相同的路径。<strong>简单环</strong>是一条（除了起点和终点必须相同之外）不含有重复顶点和边的环。路径或环的<strong>长度</strong>为其中所包含的边数。</p>

<p>如果从任意一个顶点都存在一条路径到达另一个任意顶点，这幅图就是<strong>连通图</strong>。一幅非连通的图由若干连通的部分组成，它们都是其极大连通子图。</p>

<p>树是一幅无环(Acyclic)连通图。互不相连的树组成的集合称为<strong>森林</strong>。连通图的<strong>生成树</strong>是它的一幅子图，它含有图中的所有顶点且是一棵树。图的<strong>生成树森林</strong>是它的所有连通子图的生成树的集合。</p>

<p>当且仅当一幅含有V个顶点的图G满足下列5个条件之一时，它就是一棵树：</p>

<ul>
<li>G有V-1条边且不含有环；</li>
<li>G有V-1条边且是连通的；</li>
<li>G是连通的，但删除任意一条边都会使它不再连通；</li>
<li>G是无环图，但添加任意一条边都会产生一条环；</li>
<li>G中的任意一对顶点之间仅存在一条简单路径。</li>
</ul>


<h2>2. API</h2>

<p>先看一份定义了无向图的基本操作的API：</p>

<p><img src="/myresource/images/image_blog_2014-10-04_graph-api.png" alt="image" /></p>

<p>```java
//////////////////常用的图处理代码//////////////////</p>

<p>//计算v的度数
public static int degree(Graph G, int v) {</p>

<pre><code>int degree = 0;
for(int w: G.adj(v)) degree++;
return degree;
</code></pre>

<p>}</p>

<p>//计算所有顶点的最大度数
public static int maxDegree(Graph G) {</p>

<pre><code>int max = 0;
for(int v = 0; v &lt; G.V(); v++) 
    if (degree(G, v) &gt; max)
        max = degree(G, v);
return max;
</code></pre>

<p>}</p>

<p>//计算所有顶点的平均度数
public static double avgDegree(Graph G) {</p>

<pre><code>return 2.0 * G.E() / G.V(); 
</code></pre>

<p>}</p>

<p>//计算自环的个数
public static int numberOfSelfLoops(Graph G) {</p>

<pre><code>int count = 0;
for(int v = 0; v &lt; G.V(); v++)
    for(int w : G.adj(v))
        if (v == w) count++;
return count / 2; //每条边都被记过2次
</code></pre>

<p>}
```</p>

<h3>2.1 邻接表</h3>

<p>图有多种表示方法，包括邻接矩阵（V乘V的布尔矩阵，占用空间过大），边的数组（边类含有两个int实例变量，实现adj方法需要检查图中的所有边）和邻接表数组。</p>

<p>邻接表数组是以顶点为索引的列表数组，例如第0个顶点的列表中每个元素都是和顶点0相邻的顶点。示意图如下：</p>

<p><img src="/myresource/images/image_blog_2014-10-03_adjacency-lists.png" alt="image" /></p>

<p>它具有以下特点：</p>

<ul>
<li>使用的空间和V+E成正比；</li>
<li>添加一条边所需的时间为常数；</li>
<li>遍历顶点v的所有相邻顶点所需的时间和v的度数成正比。</li>
</ul>


<p>代码实现示意如下：</p>

<p>```java
public class Graph {</p>

<pre><code>private final int V;        //顶点数目
private int E;              //边的数目
private Bag&lt;Integer&gt;[] adj; //邻接表

public void addEdge(int v, int w) {
    adj[v].add(w);
    adj[w].add(v);
    E++;
}

public Iterable&lt;Integer&gt; adj(int v) {
    return adj[v];
}
</code></pre>

<p>}
```</p>

<h3>2.2 图的处理算法API</h3>

<p><img src="/myresource/images/image_blog_2014-10-04_search-api.png" alt="image" /></p>

<h2>3. 深度优先搜索(DFS)</h2>

<p>深度优先搜索一幅图，只需要一个递归方法来遍历所有顶点。在访问其中一个顶点时：</p>

<ul>
<li>将它标记为已访问；</li>
<li>递归地访问它的所有没有被标记过的邻居顶点。</li>
</ul>


<p>```java
//深度优先搜索
public class DepthFirstSearch {</p>

<pre><code>private boolean[] marked;
private int count;

public DepthFirstSearch(Graph G, int s) {
    marked = new boolean[G.V()];
    dfs(G, s);
}

private void dfs(Graph G, int v) {
    marked[v] = true;
    count++;
    for(int w : G.adj(v))
        if (!marked[w]) dfs(G, w);
}

public boolean marked(int w) {return marked[w];}

public int count() {return count;}
</code></pre>

<p>}
```</p>

<p>利用深度优先搜索很容易找到一些问题的答案。例如“两个给定的顶点是否连通？有多少个连通子图？从s到给定目的顶点v是否存在一条路径？如果有，找到这条路径。”</p>

<h2>4. 寻找路径</h2>

<p>路径的API:</p>

<p><img src="/myresource/images/image_blog_2014-10-04_paths-api.png" alt="image" /></p>

<p>```java
//使用深度优先搜索查找图的路径
public class DepthFirstPaths {</p>

<pre><code>private boolean[] marked;   //这个顶点上调用过dfs()吗？
private int[] edgeTo;       //从起点到一个顶点的已知路径上的最后一个顶点
private final int s;        //起点

public DepthFirstPaths(Graph G, int s) {
    marked = new boolean[G.V()];
    edgeTo = new int[G.V()];
    this.s = s;
    dfs(G, s);
}

private void dfs(Graph G, int v) {
    marked[v] = true;
    for(int w : G.adj(v))
        if (!marked[w]) {
            edgeTo[w] = v;
            dfs(G, w);
        }
}

public boolean hasPathTo(int v) {return marked[v];}

public Iterable&lt;Integer&gt; pathTo(int v) {
    if (!hasPathTo(v)) return null;
    Stack&lt;Integer&gt; path = new Stack&lt;Integer&gt;();
    for(int x = v; x != s; x = edgeTo[x])
        path.push(x);
    path.push(s);
    return path;
}
</code></pre>

<p>}
```</p>

<h2>5. 广度优先搜索(BFS)</h2>

<p>广度优先搜索可以解决单点最短路径的问题，即“从s到给定目的顶点v是否存在一条路径？如果有，找出其中最短的那条。”要找到从s到v的最短路径，从s开始，在所有由一条边就可以到达的顶点中寻找v，如果找不到就继续在与s距离两条边的所有顶点中找v，如此一直进行。实现广度优先搜索时，可以使用先进先出（FIFO）队列。代码示意如下：</p>

<p>```java
public class BreadthFirstPaths {</p>

<pre><code>private boolean[] marked;  //到达该顶点的最短路径已知吗？
private int[] edgeTo;      //到达该顶点的已知路径上的最后一个顶点
private final int s;       //起点

public BreadthFirstPaths(Graph G, int s) {
    marked = new boolean[G.V()];
    edgeTo = new int[G.v()];
    this.s = s;
    bfs(G, s);
}

private void bfs(Grapth G, int s) {
    Queue&lt;Integer&gt; queue = new Queue&lt;Integer&gt;();
    marked[s] = true;  //标记起点
    queue.enqueue(s);  //入列
    while (!queue.isEmpty()) {
        int v = queue.dequeue();
        for(int w : G.adj(v))
            if (!marked[w]) {
                edgeTo[w] = v;
                marked[w] = true;
                queue.enqueue(w);
            }
    }
}

public boolean hasPathTo(int v) {return marked[v];}

public Iterable&lt;Integer&gt; pathTo(int v) {//与深度优先实现相同}
</code></pre>

<p>}
```</p>

<h2>6. 连通分量</h2>

<p>所谓连通分量就是连通子图，深度优先搜索可用于找出一幅图的所有连通分量。其API定义如下：</p>

<p><img src="/myresource/images/image_blog_2014-10-04_cc-api.png" alt="image" /></p>

<p>递归的深度优先搜索第一次调用的参数是顶点0，它会标记所有与0连通的顶点。然后构造函数中的for循环会查找每个没有被标记的顶点并递归调用dfs()来标记和它相邻的所有顶点。代码如下：</p>

<p>```java
public class CC {</p>

<pre><code>private boolean[] marked;
private int[] id;
private int count = 0;

public CC(Graph G) {
    marked = new boolean[G.V()];
    id = new int[G.V()];
    for(int s = 0; s &lt; G.V(); s++)
        if (!marked[s]) {
            dfs(G, s);
            count++;
        }
}

private void dfs(Graph G, int v) {
    marked[v] = true;
    id[v] = count;
    for(int w : G.adj(v))
        if (!marked[w])
            dfs(G, w);
}

public boolean connected(int v, int w) { return id[v] == id[w]; }

public int id(int v) {return id[v]; }

public int count() {return count;}
</code></pre>

<p>}
```</p>

<p>深度优先搜索还可用于解决两个问题：1. 给定的图是无环图吗（假定不存在自环和平行边）？<a href="http://algs4.cs.princeton.edu/41undirected/Cycle.java.html">代码实现</a> 2. 这是一幅二分图吗？也就是说能够用两种颜色将图的所有顶点着色，使得任意一条边的两个端点的颜色都不相同。<a href="http://baike.baidu.com/view/501081.htm">二分图</a>，<a href="http://algs4.cs.princeton.edu/41undirected/Bipartite.java.html">代码实现</a></p>

<h2>7. 符号图</h2>

<p>在典型应用中，通常使用字符串而非整数来表示和指代顶点。为了适应这样的应用，需要符号图。符号图使用字符串代替整数索引。其API定义如下：</p>

<p><img src="/myresource/images/image_blog_2014-10-04_symbol-graph-api.png" alt="image" /></p>

<p>符号图的实现可以在无向图的基础上增加一个符号表和反向索引。符号表完成符号到邻接表索引的映射，键为String(顶点名)，值的类型为int(邻接表的索引)。反向索引是一个数组keys[]，保存每个顶点索引所对应的顶点名。结构如下图：</p>

<p><img src="/myresource/images/image_blog_2014-10-04_symbol-graph.png" alt="image" /></p>

<p>其实现较为简单，<a href="http://algs4.cs.princeton.edu/41undirected/SymbolGraph.java.html">查看代码</a>。</p>

<p><strong>利用符号图可以处理一个经典问题，找到一个社交网络中两个人间隔的度数。这其实就是用符号图+广度优先求最短路径的用例。</strong></p>

<h2>总结</h2>

<p>本文主要学习无向图的邻接表实现，以及深度、广度优先算法及其应用：</p>

<p>深度优先：</p>

<ol>
<li>两个顶点是否连通？如果有，给出路径。</li>
<li>有多少个连通子图？找出所有连通分量。</li>
<li>给定的图是无环图吗？</li>
<li>是一幅二分图吗？</li>
</ol>


<p>广度优先：</p>

<ol>
<li>找出两个顶点间的最短路径。</li>
</ol>


<p>参考：<a href="http://algs4.cs.princeton.edu/41undirected/">http://algs4.cs.princeton.edu/41undirected/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[散列表(HashTable)]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/03/san-lie-biao/"/>
    <updated>2014-10-03T10:03:40+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/03/san-lie-biao</id>
    <content type="html"><![CDATA[<p>散列表也是一种符号表，它通过算法将键转化为数组的索引来访问数组中的键值对。散列表查找的第一步是用散列函数将被查找的键转化为一数组索引，第二步是处理碰撞冲突。解决碰撞冲突的方法有拉链法和线性探测法。</p>

<!--more-->


<h2>1. 散列函数</h2>

<p>散列函数用于将键转化为数组的索引，它应该易于计算并且能够均匀分布所有的键。散列函数和键的类型有关，对于每种类型的键都需要一个与之对应的散列函数。</p>

<p>Java对正整数采用除留余数法计算散列值。选择大小为素数M的数组，对于任意正整数k，计算余数：<code>k%M</code>，能够有效地将键散布在0到M-1的范围内。素数又称为质数，是一个大于1的自然数，除了1和它本身外，不能被其他自然数整除（除0以外）的数。Java对浮点数会将键表示为二进制数然后再使用除留余数法。对字符串采用类似Homer方法，用N次乘法、加法和取余来计算散列值。</p>

<p>对Java程序，<code>hashCode()</code>和<code>equals()</code>方法必须一致。如果<code>equals()</code>返回<code>true</code>那么<code>hashCode()</code>返回值必须一致，反过来则可以不同。</p>

<h2>2. 基于拉链法的散列表</h2>

<p>当<code>hashCode()</code>返回值相同，但<code>equals()</code>为false时，就发生了碰撞。解决碰撞的一种方法是拉链法。拉链法是指数组中的每个元素都指向一个链表，链表中的每个结点都存储了散列值为该元素的索引的键值对。因此这样的散列表由数组+链表构成。查找时先根据散列值找到对应的链表，然后沿着链表顺序查找相应的键。</p>

<p><img src="/myresource/images/image_blog_2014-10-03_separate-chaining.png" alt="image" /></p>

<p>可以看出，散列表的查找性能与散列表的大小有很大关系，对N个元素来说，当散列表的大小M过小时，碰撞机率就会增加，链表的长度必然增加，从而降低了查找效率。因此在内存不紧张时，可以选择一个足够大的M，内存紧张时，选择尽量大的M。另一种方法是动态调整数据的大小以保持短小的链表。</p>

<p>执行删除操作时，先用散列值找到索引及对应的链表，然后调用链表的删除方法即可。</p>

<p>对于有序性相关的符号表操作，散列表都不是合适的选择，因为这些操作的运行时间都是线性的。</p>

<p>Java的TreeMap和HashMap分别是基于红黑树和拉链法的散列表的符号表实现。</p>

<h2>3. 基于线性探测法的散列表</h2>

<p>实现散列表的另一种方式是用大小为M的数组保存N个键值对，其中M>N。依靠数据中的空位解决碰撞冲突。基于这种策略的所有方法都统称为开放地址散列表。其中最简单的方法叫做线性探测法：当碰撞发生时，直接检查散列表的下一个位置（索引加1），可能产生三种结果：</p>

<ul>
<li>命中，该位置的键和被查找的键相同；</li>
<li>未命中，键为空（该位置没有键）；</li>
<li>继续查找，该位置的键和被查找的键不同。</li>
</ul>


<p>其核心思想是与其将内存用作链表，不如将它们作为散列表的空元素。即用散列函数找到索引，检查其中的键和被查找的键是否相同。如果不同则继续查找（增加索引，到达数组结尾后再折回数组开头），直到找到该键或者遇到一个空元素。过程如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10-03_linear-probing.png" alt="image" /></p>

<p>在基于线性探测法的散列表中执行删除操作比较复杂，如果将该键所在位置为为null是不行的。需要将簇中被删除键的右侧的所有键重新插入散列表。</p>

<p>这种散列表的性能也依赖于N/M，但在这里表示散列表的利用率。如果利用率达到1，即散列表满了，会造成未命中的查找无限循环。为了保证性能，要动态调整数组的大小来保证利用率在1/8到1/2之间。</p>

<h2>4. 数组的大小和内存使用</h2>

<p>对于线性探测法，调整数组的大小是必需的。对于拉链法，如果你能准确估计所需的散列表大小N，调整数据的工作不是必需的，只需要根据查找耗时和<code>(1+N/M)</code>成正比来选取一个适当的M即可。</p>

<p>符号表的内存使用：</p>

<table>
<thead>
<tr>
<th>方法 </th>
<th> N个元素所需的内存（引用类型）</th>
</tr>
</thead>
<tbody>
<tr>
<td>基于拉链法的散列表 </td>
<td> ~48N + 32M</td>
</tr>
<tr>
<td>基于线性探测的散列表 </td>
<td> 在~32N和~128N之间</td>
</tr>
<tr>
<td>各种二叉查找树 </td>
<td> ~56N</td>
</tr>
</tbody>
</table>


<h2>Q&amp;A</h2>

<p>Q: Java的Integer, Double和Long类型的hashCode()是如何实现的？</p>

<blockquote><p>Integer类型直接返回该整数的32位值。对Double和Long返回机器表示的前32位和后32位异或的结果。</p></blockquote>

<p>Q: 为什么不将<code>hash(x)</code>实现为<code>x.hashCode() % M</code>?</p>

<blockquote><p>Java中，取余的结果可能是负数。</p></blockquote>

<p>Q: 为什么不将<code>hash(x)</code>实现为<code>Math.abs(x.hashCode()) % M</code>?</p>

<blockquote><p>对于最大的整数<code>Math.abs()</code>会返回一个负值，这种溢出可能使程序崩溃。</p></blockquote>

<p>Q: 在拉链法中，链表是否可以使用二叉查找树或者红黑树？</p>

<blockquote><p>一般来说，散列表碰撞机率越少越好，因此链表越短越好。所以链表的初级实现的性能一般会更好，特殊情况下最好由专家进行这种调优。</p></blockquote>

<p>Q: 散列表的查找比红黑树更快吗？</p>

<blockquote><p>取决于键的类型，也就是hashCode()的计算成本是否大于compareTo()的比较成本。但通常散列表会比红黑树快得多。但散列表无法高效支持有序性相关的操作。</p></blockquote>
]]></content>
  </entry>
  
</feed>
