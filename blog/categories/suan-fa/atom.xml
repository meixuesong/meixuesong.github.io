<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 算法 | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/suan-fa/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2014-10-02T23:43:50+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[符号表]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/02/cha-zhao-suan-fa-fu-hao-biao/"/>
    <updated>2014-10-02T11:26:20+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/02/cha-zhao-suan-fa-fu-hao-biao</id>
    <content type="html"><![CDATA[<p>符号表就是用键和值的方式来存储和检索数据。其关键点在于如何快速检索和高效插入。本章介绍了符号表的简单实现、二叉查找树、红黑树的实现。</p>

<!--more-->


<p>首先还是来定义一下简单的符号表API：</p>

<p><img src="/myresource/images/image_blog_20141002_170641.jpg" alt="image" /></p>

<h2>1. API定义</h2>

<p>符号表遵循以下规则：</p>

<ul>
<li>每个键只对应一个值；</li>
<li>当存入的键值对和表中已有的键冲突时，新的值会替代旧的值；</li>
<li>键不能为空；</li>
<li>值不允许为空；</li>
</ul>


<p>在简单的符号表中，键的等价性由equals()方法保证。而很多典型应用中，键都是Comparable对象，因此有序符号表可以保持键的有序并扩展其API：</p>

<p><img src="/myresource/images/image_blog_20141002_170651.jpg" alt="image" /></p>

<ul>
<li>floor：向下取整，找出小于等于该键的最大键；</li>
<li>ceiling：向上取整，找出大于等于该键的最小键；</li>
<li>rank：小于key的键的数量；</li>
<li>select：获得排名为第k的键。</li>
</ul>


<p>对于0到size()-1的所有i都有：i == rank(select(i))，且所有键都满足：key == select(rank(key))。</p>

<h2>2. 实现</h2>

<h3>2.1 无序链表的顺序查找</h3>

<p>可以用链表来实现符号表，每个结点存储一个键值对，并保持一个链接指向下一个结点。这种方式非常简单，但是效率非常低。不论是get方法还是put方法，都需要从首节点开始一个一个地遍历。</p>

<h3>2.2 有序数组中的二分查找</h3>

<p>另一种实现方法是通过两个平行的数组来存储符号表。一个储存键，一个存储值。二分法可以用于保证数组中Comparable类型的键有序，并高效地实现get和其他操作(如select)。</p>

<p>对N个键的有序数组进行二分查找最多需要（lgN + 1）次比较。然而put方法却仍然很慢，向大小为N的有序数组插入一个新的元素，在最坏的情况下需要访问约2N次数组。因此向一个空的符号表插入N个元素时，最坏的情况下需要访问约N<sup>2</sup>次数组。</p>

<p>因此，我们需要一种结构，能够同时拥有二分法的查找效率和链表的插入效率。这就是二叉查找树。</p>

<h3>2.3 二叉查找树(BST)</h3>

<p>二叉查找树的定义：它是一棵二叉树，其中每个结点都含有一个Comparable的键以及相关联的值，每个结点的键都大于其左子树任意结点的键，同时小于右子树任意结点的键。</p>

<h4>2.3.1 基本实现</h4>

<p>如果将一棵二叉查找树的所有键投影到一条直线上，我们可以得到一条有序的键列，如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_15.10.37.png" alt="image" /></p>

<p>树结点的实现：</p>

<p>```java</p>

<pre><code>private class Node {
    private Key key;           // sorted by key
    private Value val;         // associated data
    private Node left, right;  // left and right subtrees
    private int N;             // number of nodes in subtree

    public Node(Key key, Value val, int N) {
        this.key = key;
        this.val = val;
        this.N = N;
    }
}
</code></pre>

<p>```</p>

<h5>查找</h5>

<p>可以使用递归算法在二叉查找树中查找一个键：如果树是空的，则查找未命中；如果被查找的键和根结点的键相等，查找命中；否则就（递归地）在某个子树中继续查找。如果被查找的键较小就选择左子树，较大则选择右子树。查找过程与二分查找一样简单，代码实现如下：</p>

<p>```java</p>

<pre><code>public Value get(Key key) {
    return get(root, key);
}

private Value get(Node x, Key key) {
    if (x == null) return null;
    int cmp = key.compareTo(x.key);
    if      (cmp &lt; 0) return get(x.left, key);
    else if (cmp &gt; 0) return get(x.right, key);
    else              return x.val;
}
</code></pre>

<p>```</p>

<h5>插入</h5>

<p>二叉查找树的插入实现难度和查找差不多。当查找到一个不存在于树中的结点并结束于一条空链接时，我们需要做的就是将链接指向一个含有被查找的键的新结点。代码实现如下：</p>

<p>```java</p>

<pre><code>public void put(Key key, Value val) {
    if (val == null) { delete(key); return; }
    root = put(root, key, val);
}

private Node put(Node x, Key key, Value val) {
    if (x == null) return new Node(key, val, 1);
    int cmp = key.compareTo(x.key);
    if      (cmp &lt; 0) x.left  = put(x.left,  key, val);
    else if (cmp &gt; 0) x.right = put(x.right, key, val);
    else              x.val   = val;
    x.N = 1 + size(x.left) + size(x.right);
    return x;
}
</code></pre>

<p>```</p>

<h5>分析</h5>

<p>二叉查找树的算法效率取决于树的形状。在最好的情况下，树是完全平衡的，此时查找和插入的效率都非常高。</p>

<p>但是，树的结构与结点插入的顺序是相关的。在最坏的情况下（例如升序队列中的元素按顺序插入）可能形成一条单边的树，就变成了链表的结构。这种不平衡的树完全失去了二分查找的效率。</p>

<p>因此，如何保持树的平衡是一个重要问题。要在二叉树动态插入中保证树的完美平衡，代价太高了。因此需要对结构进行一些调整，这就是平衡查找树。</p>

<h3>2.4 2-3查找树</h3>

<p>所谓2-3查找树，是指它或者为一棵空树，或者由以下结点组成：</p>

<ul>
<li>2-结点，含有一个键（及其对应的值）和两条链接，左链接指向的树的所有键都小于该结点，右链接指向的树的所有键都大于该结点。</li>
<li>3-结点，含有两个键（及其对应的值）和两条链接，左链接指向的树的所有键都小于该结点，中链接指向的树的所有键都位于该结点的两个键之间，右链接指向的树的所有键都大于该结点。</li>
</ul>


<p>利用2-3查找树，可以方便地实现完美平衡的查找树，2-3查找树示意图如下：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_17_49.png" alt="image" /></p>

<h4>2.4.1 查找</h4>

<p>查找的过程与二叉查找树类似，区别仅在于3-结点树多了一个中链接。</p>

<h4>2.4.2 插入</h4>

<p>2-3查找树实现平衡的关键是插入过程，插入时先进行查找，如果未命中，将根据结束位置的多种情况，采用不同的方法。详细说明如下：</p>

<h5>向2-结点插入新键</h5>

<p>如果查找结束于一个2-结点，只要把这个2-结点替换为一个3-结点，将要插入的键保存在其中即可。如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_23tree-insert2.png" alt="image" /></p>

<h5>向一棵只含有一个3-结点的树中插入新键</h5>

<p>向3-结点的树中插入新键，也有多种情况，先看最简单的这种。如下图所示，先将3-结点变成4-结点，然后再分解为2-3树。</p>

<p><img src="/myresource/images/image_blog_2014-10-02_23tree-insert3a.png" alt="image" /></p>

<h5>向一个父结点为2-结点的3-结点插入新键</h5>

<p>如果父结点为2-结点，则先把3-结点变成4-结点，然后将2-结点变成3-结点，如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_23tree-insert3b.png" alt="image" /></p>

<h5>向一个父结点为3-结点的3-结点插入新键</h5>

<p>跟前一步一样，先变成4-结点并分解它，然后再将它的中键插入它的父结点中。但其父结点也是3-结点，因此再用这个中键构造一个临时的4-结点，进行相同的变化，直到遇到一个2-结点将它变成3-结点。如果一直到根结点都是3-结点，则需要分解根结点。插入新键的过程如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10_02_23tree-insert3c.png" alt="image" /></p>

<h5>分解根结点</h5>

<p>在上一步中，根结点变成了一个临时的4-结点，此时我们按照向一棵只有一个3-结点的树中插入新键的方法处理此问题。将4-结点分解成3个2-结点，树高加1。如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_23tree-split.png" alt="image" /></p>

<h4>2.4.3 性能分析</h4>

<p>从上面这些情况可以看出，插入过程都是进行局部变换，除了相关的结点和链接之外不必修改或检查树的其他部分，因此效率非常高。经过变换后，保持了树的有序性和平衡性。因此在一棵大小为N的2-3树中，查找和插入操作访问的结点必然不超过lgN个！例如含有10亿个结点的一棵2-3树的高度仅在19-30之间，最多只需要访问30个结点就能够在10亿个键中进行任意查找和插入操作，这是多么惊人！这也是<a href="/blog/2014/08/25/cheng-xu-yuan-de-shu-zi/">程序员的数学</a>中提到的利用指数爆炸解决问题。</p>

<h3>2.5 红黑二叉查找树</h3>

<p>2-3查找树很容易理解，现在我们通过红黑二叉树来表达并实现它。其关键是3-结点如何实现。我们将树中的链接分为两种类型：红链接将两个2-结点连接起来构成一个3-结点，黑链接则是普通链接。如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_redblack-encoding.png" alt="image" /></p>

<p>红黑树是含有红黑链接并满足以下条件的二叉查找树：</p>

<ul>
<li>红链接均为左链接；</li>
<li>没有任何一个结点同时和两条红链接相连；</li>
<li>该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。</li>
</ul>


<p>因此在节点类（Node）中，增加一个属性color表示从父结点指向自己的链接是否为红链接，当：</p>

<p>```java</p>

<pre><code>private class Node {
    private Key key;           // sorted by key
    private Value val;         // associated data
    private Node left, right;  // left and right subtrees
    private int N;             // number of nodes in subtree
    boolean color;             //是否红链接    

    public Node(Key key, Value val, int N, boolean color) {
        this.key = key;
        this.val = val;
        this.N = N;
        this.color = color;
    }
}
</code></pre>

<p>```</p>

<p>在进一步实现红黑树之前，要了解几个基本的动作：左旋转、右旋转和颜色转换。</p>

<h4>2.5.1 旋转</h4>

<p>左旋转是将一条红色的右链接转化为左链接。转换的过程为：将两个键中的较小者作为根结点变为将较大者作为根结点。如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_redblack-left-rotate.png" alt="image" /></p>

<p>右旋转是将一条红色的左链接转化为右链接，实现过程与左旋转相似，只需要将left和right互换即可：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_redblack-right-rotate.png" alt="image" /></p>

<h4>2.5.2 颜色转换</h4>

<p>颜色转换是对一个结点的两个红色子结点的颜色进行转换。除了将子结点的颜色由红变黑外，还要同时将父结点的颜色由黑变红。如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-10-02_color-flip.png" alt="image" /></p>

<h4>2.5.3 插入处理过程</h4>

<p>插入新键时，都使用红链接与父结点相连，然后谨慎地使用左旋转、右旋转和颜色转换这三个简单的操作，就能够保证操作后的红黑树与2-3树一一对应的关系。在沿着插入点到根结点的路径向上移动时在所经过的每个结点中顺序完成以下操作，我们就能完成插入操作：</p>

<ol>
<li>如果右子结点是红色，而左子结点是黑色，进行左旋转；</li>
<li>如果左子结点是红色，且它的左子结点也是红色，进行右旋转；</li>
<li>如果左右子结点都是红色，进行颜色转换。</li>
</ol>


<p>下面是各种情况的示例：</p>

<p><img src="/myresource/images/IMG_20141002_222628.jpg" alt="image" /></p>

<p><img src="/myresource/images/IMG_20141002_222714.jpg" alt="image" /></p>

<h4>2.5.4 插入算法的实现</h4>

<p>以下为红黑树的插入算法：</p>

<p>```java
public class RedBlackBST<Key extends Comparable<Key>, Value> {</p>

<pre><code>private static final boolean RED   = true;
private static final boolean BLACK = false;

private Node root;     // root of the BST

// BST helper node data type
private class Node {
    private Key key;           // key
    private Value val;         // associated data
    private Node left, right;  // links to left and right subtrees
    private boolean color;     // color of parent link
    private int N;             // subtree count

    public Node(Key key, Value val, boolean color, int N) {
        this.key = key;
        this.val = val;
        this.color = color;
        this.N = N;
    }
}

// insert the key-value pair; overwrite the old value with the new value
// if the key is already present
public void put(Key key, Value val) {
    root = put(root, key, val);
    root.color = BLACK;
}

// insert the key-value pair in the subtree rooted at h
private Node put(Node h, Key key, Value val) { 
    if (h == null) return new Node(key, val, RED, 1);

    int cmp = key.compareTo(h.key);
    if      (cmp &lt; 0) h.left  = put(h.left,  key, val); 
    else if (cmp &gt; 0) h.right = put(h.right, key, val); 
    else              h.val   = val;

    // fix-up any right-leaning links
    if (isRed(h.right) &amp;&amp; !isRed(h.left))      h = rotateLeft(h);
    if (isRed(h.left)  &amp;&amp;  isRed(h.left.left)) h = rotateRight(h);
    if (isRed(h.left)  &amp;&amp;  isRed(h.right))     flipColors(h);
    h.N = size(h.left) + size(h.right) + 1;

    return h;
}
</code></pre>

<p>}
```</p>

<h4>2.5.5 删除操作</h4>

<h5>删除最小键</h5>

<p>先来看删除最小键。从树底部的3-结点删除键很简单，但2-结点则不然。为了保证我们不会删除一个2-结点，我们沿着左链接向下进行变换，确保当前结点不是2-结点。在沿着左链接向下的过程中，保证以下情况之一成立：</p>

<ul>
<li>如果当前结点的左子结点不是2-结点，完成；</li>
<li>如果当前结点的左子结点是2-结点而它的亲兄弟结点不是2-结点，将左子结点的兄弟结点中的一个键移到左子结点；</li>
<li>如果当前结点的左子结点和它的亲兄弟结点都是2-结点，将左子结点、父结点中的最小键和左子结点最近的兄弟结点合并为一个4-结点，使父结点由3-结点变为2-结点或者4-结点变为3-结点。</li>
</ul>


<p>在遍历的过程中执行这个过程，最后能够得到一个含有最小键的3-结点或者4-结点，然后我们就可以直接从中将其删除，将3-结点变为2-结点，或者将4-结点变为3-结点。然后我们再回头向上分解所有临时的4-结点。</p>

<p><img src="/myresource/images/IMG_20141002_232607.jpg" alt="image" /></p>

<h5>删除操作</h5>

<p>在查找路径上进行和删除最小键相同的变换同样可以保证在查找过程中任意当前结点均不是2-结点。如果被查找的键在树的底部，我们可以直接删除它。如果不在，我们需要将它和它的后续结点交换，就和二叉查找树一样。因为当前结点必然不是2-结点，问题已经转化为在一棵根结点不是2-结点的子树中删除最小键，我们可以在这棵子树中使用上面的算法。删除之后，同样需要向上回溯并分解余下的4-结点。</p>

<p><a href="/myresource/code/RedBlackBST.java">红黑树完整代码</a></p>

<h4>2.5.6 红黑树的性能</h4>

<p>一棵大小为N的红黑树的高度不会超过2lgN，根结点到任意结点的平均路径长度为1.00lgN，以下操作在最坏的情况下所需的时间是对数级别的：get, put, min, max, floor, ceiling, rank, select, deleteMin, deleteMax, delete, range。</p>

<h2>总结</h2>

<p>各种符号表实现的性能总结：</p>

<p><img src="/myresource/images/IMG_20141002_233353.jpg" alt="image" /></p>

<p>在信息世界的汪洋大海中，表的大小可能是上千亿，但我们仍然能够确保在几十次比较之内就完成这些操作！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[优先队列]]></title>
    <link href="http://blog.ubone.com/blog/2014/09/27/you-xian-dui-lie/"/>
    <updated>2014-09-27T23:08:56+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/09/27/you-xian-dui-lie</id>
    <content type="html"><![CDATA[<p>优先队列是广泛使用的一种抽象数据类型。例如如果你需要从10亿个元素中选出最大的十个，你不可能对10亿规模的数组排序。对于这些类似的场景，我们不一定要求它们全部有序，或者不一定要一次就将它们排序。我们会收集一些元素，处理当前键值最大的元素，然后再收集更多的元素，再处理当前键值最大的元素。例如应用程序的事件优先级，模拟系统，任务调度等。在这种情况下，优先队列应该支持两种操作：<strong>删除最大元素和插入元素。</strong></p>

<!--more-->


<h2>1. API</h2>

<p>先定义优先队列的API框架：</p>

<p>```java
public interface IMaxPQ<T extends Comparable<T>> {</p>

<pre><code>public void insert(T v);
public T max();
public T delMax();
public boolean isEmpty();
public int size();
</code></pre>

<p>}
```</p>

<h2>2. 实现方法</h2>

<p>优先队列可以使用有序或无序的数组或链表来实现。其思路非常简单，插入时，向数组或链表增加元素。如果数组或链表是有序的，新元素就应该在适当的位置。而删除时，找出最大的元素进行删除。</p>

<p>上面的实现方法性能非常差，在最坏的情况下，需要线性时间来完成。而基于堆的实现则能够保证更好的性能。</p>

<h3>2.1 堆的定义</h3>

<p>在二叉堆的数组中，每个元素都要保证大于等于另外两个特定位置的元素。如果把所有元素画成一棵二叉树，就是父结点要大于等于子结点，此时表示<strong>堆有序</strong>。</p>

<p>完全二叉树只用数组就可以表示。根结点在位置1，其子结点在位置2和3。位置k的结点的父结点的位置为k/2, 它的两个子结点的位置分别为2k和2k+1。</p>

<h3>2.2 堆的算法</h3>

<p>堆的有序化过程涉及上浮和下沉。当某个结点的优先级上升时，我们需要由下至上恢复堆的顺序（上浮）。当某个结点的优先级下降时，我们需要由上至下恢复堆的顺序（下沉）。</p>

<h4>2.2.1 上浮</h4>

<p>如果某个结点的优先级上升，比它的父结点更大，那么就需要交换它和它的父结点。交换后，还要继续判断是否比现在的父结点更大，一直到遇到更大的父结点。</p>

<h4>2.2.2 下沉</h4>

<p>下沉与上浮正好相反，当某个结点的优先级下降时，需要<strong>与它的两个结点中的较大者比较</strong>，如果比子结点小，就进行交换。交换后继续与子结点比较，直到比它的两个子结点都大。</p>

<h4>2.2.3 算法实现</h4>

<p>```java
public class MaxPQ<T extends Comparable<T>> implements IMaxPQ<T>{</p>

<pre><code>private T[] pq;
private int n = 0;

public MaxPQ(int maxN) {
    pq = (T[]) new Comparable[maxN + 1];
}

@Override
public void insert(T v) {
    pq[++n] = v;
    swim(n);
}

@Override
public T max() {
    if (n &gt; 0) {
        return pq[1];
    }

    return null;
}

@Override
public T delMax() {
    T max = pq[1];    //根结点最大
    exchange(1, n--); //与最后一个结点交换
    pq[n + 1] = null; //防止对象游离
    sink(1);          //恢复堆的有序性

    return max;
}

@Override
public boolean isEmpty() {
    return n == 0;
}

@Override
public int size() {
    return n;
}

private boolean less(int i, int j) {
    return pq[i].compareTo(pq[j]) &lt; 0;
}

private void exchange(int i, int j) {
    T t = pq[i]; pq[i] = pq[j]; pq[j] = t;
}

//上浮
private void swim(int k) {
    while (k &gt; 1 &amp;&amp; less(k / 2, k)) {
        exchange(k / 2, k);
        k = k / 2;
    }
}

//下沉
private void sink(int k) {
    while (2 * k &lt;= n) {
        int j = 2 * k;
        if (j &lt; n &amp;&amp; less(j, j + 1)) {
            j++;
        }

        if (!less(k, j)) {
            break;
        }

        exchange(k, j);
        k = j;
    }
}
</code></pre>

<p>}
```</p>

<p><strong>对于含有N个元素的基于堆的优先队列，插入元素操作只需不超过(lgN + 1)次比较，删除最大元素的操作需要不超过2lgN次比较！</strong></p>

<h4>2.2.4 多叉堆</h4>

<p>用数组表示的完全三叉树构造堆也很容易。位置k的结点大于等于3k-1, 3k, 3k+1的结点，小于等于位于(k+1)/3的结点。甚至任意的d叉树也不困难，只是需要平衡在树高和每个结点的d个子结点中找到最大值的代价。</p>

<h4>2.2.5 动态数组大小</h4>

<p>上面代码中的数组大小是固定的，如果要实现动态数组大小，只需要根据情况在insert中增加数组长度，在delMax中减少数组长度。</p>

<h2>3. 堆排序</h2>

<p>使用优先队列，我们有了一种新的排序方法：堆排序。把所有元素插入一个查找最小元素的优先队列，然后重复调用删除最小元素的操作来将它们按顺序删除。</p>

<p>堆排序分为两个阶段：构造堆和下沉排序。</p>

<h3>3.1 堆的构造</h3>

<p>对于N个给定元素的数组，最简单的堆构造方法是从左至右遍历数组，用swim()保证指针左侧的所有元素已经是一棵堆有序的完全树。但一个更聪明更高效的办法是从右至左用sink()函数构造子堆。如果一个结点的两个子结点都已经是堆了，那么在该结点上调用sink可以将它们变成一个堆。这个过程会递归地建立起堆的秩序。开始时我们只需要扫描数据中的一半元素，最后在位置1上调用sink方法，扫描结束。</p>

<h3>3.2 下沉排序</h3>

<p>当堆构造完成后，将堆中的最大元素删除，然后放到堆缩小后数组中空出的位置。</p>

<h3>3.3 算法实现</h3>

<p>```java
public class PQSort {</p>

<pre><code>public void sort(Comparable[] a) {
    int n = a.length;
    //构造堆
    for(int k = n/2; k &gt;= 1; k--) {
        sink(a, k, n);
    }

    //下沉排序
    while (n &gt; 1) {
        exchange(a, 1, n--);
        sink(a, 1, n);
    }
}

private void sink(Comparable[] a, int k, int n) {
    while (2 * k &lt;= n) {
        int j = 2 * k;
        if (j &lt; n &amp;&amp; less(a, j, j+1)) {
            j++;
        }

        if (!less(a, k, j)) {
            break;
        }

        exchange(a, k, j);
        k = j;
    }
}

private static boolean less(Comparable[] a, int i, int j) {
    //要减1
    return a[i - 1].compareTo(a[j - 1]) &lt; 0;
}

private static void exchange(Comparable[] a, int i, int j) {
    //要减1
    Comparable t = a[i - 1];
    a[i - 1] = a[j - 1];
    a[j - 1] = t;
}
</code></pre>

<p>}
```
对于一百万随机整数，排序时间大约在750ms。</p>

<p>用堆实现的优先队列在现代应用程序中越来越重要，因为它能在<strong>插入操作和删除最大元素操作</strong>混合的动态场景中保证对数级别的运行时间。</p>

<h2>小结</h2>

<p>学完了常用的算法，总结一下。各种算法的性能特点如下表：</p>

<p><img src="/myresource/images/IMG_20140928_224145.jpg" alt="image" /></p>

<p>快速排序是最快的通用排序算法。</p>

<p>Java中，java.util.Arrays.sort()方法会根据不同的参数类型选择排序方法。对于原始数据类型使用（三向切分）快速排序，对引用类型使用归并排序。这种选择实际上暗示着用速度和空间（对于原始数据类型）来换取稳定性（对于引用类型）。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快速排序算法]]></title>
    <link href="http://blog.ubone.com/blog/2014/09/27/kuai-su-pai-xu-suan-fa/"/>
    <updated>2014-09-27T10:38:32+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/09/27/kuai-su-pai-xu-suan-fa</id>
    <content type="html"><![CDATA[<p>快速排序可能是应用最广泛的算法，原因是它实现简单、速度快。它完美地实现了原地排序（只需要一个很小的辅助栈），并且时间与NlgN成正比。它的内循环比大多数排序算法都要短小，因此理论上要更快。但它的主要缺点是非常脆弱，实现时要非常小心才能避免低劣的性能。</p>

<!--more-->


<h2>1. 算法理论</h2>

<p>快速算法也是一种分治的排序算法，它将一个数组分成两个子数组，将两部份独立地排序。但与归并排序将两个子数组分别排序再归并到整个数组排序不同，快速排序时，当两个子数组都有序时整个数组也就自然有序了。</p>

<p>快速排序算法的关键是切分，通过切分使数组满足下面三个条件：</p>

<ol>
<li>对于某个j, a[j]已经排定;</li>
<li>a[lo]到a[j-1]中的所有元素都不大于a[j];</li>
<li>a[j+1]到a[hi]中的所有元素都不小于a[j];</li>
</ol>


<p>因为切分过程总能排定一个元素，因此递归调用切分过程就能够正确地将数组排序。切分实现方法如下：先随意取a[lo]作为切分元素，然后从数组的左端开始向右扫描直到找到一个大于等于它的元素，再从数组右端向左扫描直到找到一个小于等于它的元素，交换它俩的位置。如此继续，当两个指针相遇时，只需要将切分元素和左子数组最右侧的元素a[j]交换然后返回j即可。j即满足上述三个条件。</p>

<h2>2. 算法实现</h2>

<p>下面是排序算法的实现。需要注意的是还有几个细节需要完善，它们可能导致错误或影响性能。</p>

<p>```java
public class Quick extends AbstractSort {</p>

<pre><code>@Override
public void sort(Comparable[] a) {
    StdRandom.shuffle(a); //打乱数组，消除对输入的依赖
    sort(a, 0, a.length - 1);
}

private static void sort(Comparable[] a, int lo, int hi) {
    if (hi &lt;= lo) return;

    int j = partition(a, lo, hi);
    sort(a, lo, j - 1);
    sort(a, j + 1, hi);
}

private static int partition(Comparable[] a, int lo, int hi) {
    //i, j分别代表左右扫描指针
    int i = lo, j = hi + 1;
    Comparable v = a[lo]; //选择切分元素

    while(true) {
        //从左往右扫描
        while (less(a[++i], v)) {
            if (i == hi) break; //冗余，可以去除。
        }

        //从右往左扫描
        while (less(v, a[--j])) {
            if (j == lo) break; //冗余，可以去除。
        }

        //检查两指针是否相遇
        if (i &gt;= j) break; 

        exchange(a, i, j);
    }

    //与切分元素交换
    exchange(a, lo, j);

    //现在满足：a[lo .. j-1] &lt;= a[j] &lt;= a[j+1 .. hi]
    return j;
}
</code></pre>

<p>}
//对一百万个随机整数排序，时间大致在350ms，但加上shuffle后，时间在600多ms.
```</p>

<h2>3. 性能特点</h2>

<p>快速排序算法的内循环用一个递增的索引将数组元素和一个定值比较，因此内循环非常短。归并和希尔排序需要在内循环中移动数据，所以它们通常比快速排序要慢一些。</p>

<p>快速排序算法的另一个优势是比较的次数很少。其效率最终还是依赖切分数组的效果。最好的情况下，每次都正好能将数组对半分。尽管事情并不总会这么顺利，但平均而言切分元素都能落在数组的中间。如果将切分位置的概率考虑到算法中，将使递归更复杂，而结果还是类似的。</p>

<p>它有一个潜在的缺点，切分不平衡时效率会相当低效。例如第一次从最小的元素切分，第二次从第二小的元素切分。。。这样每次调用只会移除一个元素。这也是快速排序前先随机排序(shuffle)的主要原因。</p>

<h2>4. 算法改进</h2>

<p>如果排序代码会执行很多次或者将用在大型数组上，那么就需要进行一些改进。</p>

<h3>4.1 切换到插入排序</h3>

<p>由于小数组的快速排序比插入排序慢，并且小数组时的递归调用也会消耗资源，因此在排序小数组时应该切换到插入排序。</p>

<p>可以在sort方法中，将<code>if (hi &lt;= lo) return;</code>替换为：<code>if (hi &lt;= lo + M) {Insertion.sort(a, lo, hi); return;}</code>。M的最佳值和系统相关，但一般在5~15之间在大多数情况下都能令人满意。</p>

<h3>4.2 三取样切分</h3>

<p>第二个改进的方法是使用子数组的一小部分元素的中位数来切分数组。人们发现将取样大小设为3并用大小居中的元素切分效果最好。</p>

<h3>4.3 熵最优的排序</h3>

<p>对于有大量重复元素的数组，快速排序算法仍然会递归调用，而三向切分的快速排序算法可以更好地处理这种情况。</p>

<p>```
public class Quick3way extends AbstractSort {</p>

<pre><code>@Override
public void sort(Comparable[] a) {
    StdRandom.shuffle(a); //打乱数组，消除对输入的依赖
    sort(a, 0, a.length - 1);
}

private static void sort(Comparable[] a, int lo, int hi) {
    if (hi &lt;= lo) return;

    int lt = lo, i = lo + 1, gt = hi;
    Comparable v = a[lo];
    while (i &lt;= gt) {
        int cmp = a[i].compareTo(v);
        if (cmp &lt; 0) {
            exchange(a, lt++, i++);
        } else if (cmp &gt; 0) {
            exchange(a, i, gt--);
        } else {
            i++;
        }
    }//现在a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi]

    sort(a, lo, lt - 1);
    sort(a, gt + 1, hi);
}
</code></pre>

<p>}</p>

<p>//（不含shuffle的时间）对于一百万随机整数，排序时间也在350ms左右。但如果存在大量重复时，时间将降到250ms左右。
```</p>

<p>对有大量重复元素的数组排序时，三向切分算法具有更高的效率。而在最差的情况下，也就是没有重复元素时，它的效率与标准快速排序算法相当。因此，三向切分的快速排序成为排序函数的最佳算法选择。</p>

<p>在基于比较的排序算法中，经过精心调优的快速排序算法性能最好。但它不是终点，还有完全不需要比较的排序算法！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[归并排序算法]]></title>
    <link href="http://blog.ubone.com/blog/2014/09/25/gui-bing-pai-xu/"/>
    <updated>2014-09-25T21:07:58+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/09/25/gui-bing-pai-xu</id>
    <content type="html"><![CDATA[<p>所谓归并排序，是先把待排序数组分成两半，分别排序，然后将结果归并起来。归并排序最吸引人的地方是它能够保证将任意长度为N的数组排序所需时间和NlogN成正比。但其缺点是所需的额外空间和N成正比。</p>

<!--more-->


<h2>1. 原地归并的抽象方法</h2>

<p>实现归并是将两个不同的有序数组归并到第三个数组中。当归并一个大数组时，需要进行很多次归并，因此如果每次都创建一个新数组会有性能问题。所以要实现原地归并。下面的代码借助一个辅助数组，先将所有元素复制到辅助数组中，然后再把归并结果放回原数组。</p>

<p>```java
public abstract class AbstractMerge extends AbstractSort {</p>

<pre><code>//归并所需的辅助数组
protected Comparable[] aux;
/**
 * 将a[lo..mid]和a[mid+1..hi]合并
 * @param a
 * @param lo
 * @param mid
 * @param hi
 */
public void merge(Comparable[] a, int lo, int mid, int hi) {
    int i = lo, j = mid + 1;

    //将a[lo..hi]复制到aux[lo..hi]
    for(int k = lo; k&lt;= hi; k++) {
        aux[k] = a[k];
    }

    //再从aux归并到a[lo..hi]
    for(int k = lo; k &lt;= hi; k++) {
        if (i &gt; mid) {
            //左半边用尽，取右半边的元素
            a[k] = aux[j];
            j++;
        } else if (j &gt; hi) {
            //右半边用尽，取左半边的元素
            a[k] = aux[i];
            i++;
        } else if (less(aux[j], aux[i])) {
            //右半边元素小于左半边元素，取右半边
            a[k] = aux[j];
            j++;
        } else {
            //左半边元素小于右半边元素，取左半边
            a[k] = aux[i];
            i++;
        }
    }
}
</code></pre>

<p>}
```</p>

<p>有了这个归并方法，下面开始实现归并排序。</p>

<h2>2. 自顶向下的归并排序</h2>

<h3>2.1 算法实现</h3>

<p>下面的代码采用分治思想，通过递归实现两个子数组排序，并通过归并两个子数组完成整个数组的排序。</p>

<p>```java
public class Merge extends AbstractMerge {</p>

<pre><code>@Override
public void sort(Comparable[] a) {
    aux = new Comparable[a.length];
    sort(a, 0, a.length - 1);
}

private void sort(Comparable[] a, int lo, int hi) {
    if (hi &lt;= lo) return;

    int mid = lo + (hi - lo) / 2;
    //将左边排序
    sort(a, lo, mid);
    //将右边排序
    sort(a, mid + 1, hi);
    //归并结果
    merge(a, lo, mid, hi);
}
</code></pre>

<p>}
```</p>

<p>性能：对于长度为N的任意数组，自顶向下的归并排序需要(&frac12;)NlgN至NlogN次比较。最多需要访问数组6NlgN次。将初级排序算法中的测试数组改为100万个随机整数，Shell排序耗时1217ms，而自顶向下的归并排序算法耗时为611ms。</p>

<h3>2.2 算法优化</h3>

<p>上述的归并算法还有优化的空间。例如对于小规模的子数组（如长度小于15），改用插入排序，一般可以将运行时间缩短10%~15%。</p>

<p>还可以添加一个判断条件，如果a[mid]小于等于a[mid+1]，就认为数组已经是有序的并跳过merge()方法。</p>

<p>另一种优化是不将元素复制到辅助数组，节省元素复制到辅助所用的时间（但空间不行）。实现这一点要调用两种排序方法，一种将数据从输入数组排序到辅助数组，一种将数据从辅助数组排序到输入数组。在递归调用的每个层次交换输入数组和辅助数组的角色。</p>

<p>实现上述三种优化的MergeX如下：</p>

<p>```java
public class MergeX {</p>

<pre><code>private static final int CUTOFF = 7;  // cutoff to insertion sort

private MergeX() { }

private static void merge(Comparable[] src, Comparable[] dst, int lo, int mid, int hi) {
    int i = lo, j = mid+1;
    for (int k = lo; k &lt;= hi; k++) {
        if      (i &gt; mid)              dst[k] = src[j++];
        else if (j &gt; hi)               dst[k] = src[i++];
        else if (less(src[j], src[i])) dst[k] = src[j++];   // to ensure stability
        else                           dst[k] = src[i++];
    }
}

private static void sort(Comparable[] src, Comparable[] dst, int lo, int hi) {
    if (hi &lt;= lo + CUTOFF) { 
        //优化1，改用插入排序算法
        insertionSort(dst, lo, hi);
        return;
    }
    int mid = lo + (hi - lo) / 2;
    sort(dst, src, lo, mid);
    sort(dst, src, mid+1, hi);

    // if (!less(src[mid+1], src[mid])) {
    //    for (int i = lo; i &lt;= hi; i++) dst[i] = src[i];
    //    return;
    // }

    // using System.arraycopy() is a bit faster than the above loop
    if (!less(src[mid+1], src[mid])) {
        //优化2，跳过merge
        System.arraycopy(src, lo, dst, lo, hi - lo + 1);
        return;
    }

    merge(src, dst, lo, mid, hi);
}

public static void sort(Comparable[] a) {
    Comparable[] aux = a.clone();
    sort(aux, a, 0, a.length-1);  
}

private static void insertionSort(Comparable[] a, int lo, int hi) {
    for (int i = lo; i &lt;= hi; i++)
        for (int j = i; j &gt; lo &amp;&amp; less(a[j], a[j-1]); j--)
            exch(a, j, j-1);
}

private static void exch(Comparable[] a, int i, int j) {
    Comparable swap = a[i];
    a[i] = a[j];
    a[j] = swap;
}

private static boolean less(Comparable a, Comparable b) {
    return (a.compareTo(b) &lt; 0);
}

private static boolean isSorted(Comparable[] a) {
    return isSorted(a, 0, a.length - 1);
}

private static boolean isSorted(Comparable[] a, int lo, int hi) {
    for (int i = lo + 1; i &lt;= hi; i++)
        if (less(a[i], a[i-1])) return false;
    return true;
}

public static void main(String[] args) {
    //测试100万个随机整数的排序
    int len = 1000000;
    Integer[] array = new Integer[len];
    Random random = new java.util.Random();
    for(int i = 0; i &lt; len; i++) {
        array[i] =  random.nextInt(1000000);
    }

    long from = System.nanoTime();
    MergeX.sort(array);
    System.out.format("Merge sort, totoalTime: %dms \n", (System.nanoTime() - from) / 1000000);
    MergeX.isSorted(array);
}
</code></pre>

<p>}</p>

<p>//output: MergeX sort, totoalTime: 361ms，比Merge的611ms又进步不少。
```</p>

<h3>3. 自底向上的归并排序</h3>

<p>自顶向下的归并排序，在排序过程中，会先递归排序完左边，然后再递归排序右边，最后再归并到一起。而自底向上的归并排序，则是另一种思路。</p>

<p>它的思路是先归并微型数组，然后再归并得到的子数组，如此这般，直到将整个数组归并在一起。具体来说，就是两两归并（每个元素是大小为1的数组），然后四四归并（两个大小为2的数组）、八八归并。。。代码实现如下：</p>

<p>```java
public class MergeBU extends AbstractMerge {</p>

<pre><code>@Override
public void sort(Comparable[] a) {
    int N = a.length;
    aux = new Comparable[N];
    for(int sz = 1; sz &lt; N; sz = sz + sz) {
        for(int lo = 0; lo &lt; N - sz; lo += sz + sz) {
            merge(a, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, N - 1));
        }
    }
}
</code></pre>

<p>}
```</p>

<p>性能：自底向上和自顶向上的归并排序所用的比较次数、数组访问次数正好相同，只是顺序不同。测试耗时：536ms</p>

<p>自底向上的归并排序比较适合用链表组织的数据。想象一下将链表先按大小为1的子链表进行排序，然后是大小为2的子链表。。。这种方法只需要重新组织链表链接，就能将链表原地排序。</p>

<p>在最坏的情况下，没有任何基于比较的排序算法能够将比较次数做到小于NlgN。也就是说，在最坏的情况下，归并排序算法的比较次数是最小的算法之一。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初级排序算法]]></title>
    <link href="http://blog.ubone.com/blog/2014/09/25/chu-ji-pai-xu-suan-fa/"/>
    <updated>2014-09-25T20:25:11+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/09/25/chu-ji-pai-xu-suan-fa</id>
    <content type="html"><![CDATA[<p>即使只使用类库提供的排序函数，学习排序算法仍然具有实际意义。因为排序算法是解决其他问题的第一步，类似的技术能够有效解决其它类型的问题。本文学习一些初级的排序算法，包括选择排序、插入排序和希尔排序。</p>

<!--more-->


<h2>1. 排序模板</h2>

<p>不同的排序程序只是在排序算法上不同，但排序的框架是相同的。因此先建立一个排序模板，在此基础上实现各种算法。</p>

<p>```java
public abstract class AbstractSort {</p>

<pre><code>protected final Logger logger = LoggerFactory.getLogger(getClass());

//待实现的算法
public abstract void sort(Comparable[] a);

//进行比较
protected static boolean less(Comparable v, Comparable w) {
    return v.compareTo(w) &lt; 0;
}

//交换位置
protected static void exchange(Comparable[] a, int i, int j) {
    Comparable t = a[i];
    a[i] = a[j];
    a[j] = t;
}

//打印数组
protected static void show(Comparable[] a) {
    for (int i = 0; i &lt; a.length; i++) {
        System.out.print(a[i] + " ");
    }
    System.out.println();
}

//验证是否为有序状态
public static boolean isSorted(Comparable[] a) {
    for (int i = 1; i &lt; a.length; i++) {
        if (less(a[i], a[i-1]))
            return false;
    }

    return true;
}
</code></pre>

<p>}
```</p>

<p>为了粗略验证各种算法的效率，以10万的随机整数数组为对象进行排序，测试代码如下：</p>

<p>```java
public class SortTest extends TestCase {</p>

<pre><code>Integer[] array;

@Override
public void setUp() {
    int len = 1000000;
    array = new Integer[len];
    Random random = new java.util.Random();
    for(int i = 0; i &lt; len; i++) {
        array[i] =  random.nextInt(100000000);
    }
}

public void testSort() {
    long from = System.nanoTime();
    AbstractSort sorter = new Selection();//或其它算法
    sorter.sort(array);
    System.out.format("totoalTime: %dms \n", (System.nanoTime() - from) / 1000000);     
    Assert.assertTrue(AbstractSort.isSorted(array));
}
</code></pre>

<p>}
```</p>

<h2>2. 选择排序(Selection)</h2>

<p>选择排序是最简单的排序算法，即<strong>不断地选择剩余元素中的最小者</strong>：先找到数组中最小的元素，然后跟第一个元素交换。接下来在剩下的元素中找最小的元素，跟第二个元素交换。如此往复，直到整个数组遍历结束。代码实现如下：</p>

<p>```java
public class Selection extends AbstractSort{</p>

<pre><code>@Override
public void sort(Comparable[] a) {
    int len = a.length;
    for(int i = 0; i &lt; len; i ++) {
        int min = i;
        for (int j = i + 1; j &lt; len; j++) {
            if (less(a[j], a[min])) {
                min = j;
            }
        }

        exchange(a, i, min);
    }
}
</code></pre>

<p>}
```</p>

<p>性能：对于长度为N的数组，需要进行大约N<sup>2</sup>/2次比较和N次交换。运行上面的测试代码，耗时：11424ms</p>

<h2>3. 插入排序(Insertion)</h2>

<p>与选择排序一样，当前索引左边的所有元素都是有序的，但它们的最终位置还不确定，后续元素将会跟前面的元素比较，并插入适当的位置。当索引到达数组的最右端时，排序完成。代码实现如下：</p>

<p>```java
public class Insertion extends AbstractSort {</p>

<pre><code>@Override
public void sort(Comparable[] a) {
    int len = a.length;
    for(int i = 1; i &lt; len; i++) {
        for(int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j-1]); j--) {
            exchange(a, j, j-1);
        }
    }
}
</code></pre>

<p>}
```</p>

<p>性能：插入排序的性能取决于数组的初始顺序。对于一个很大且其中的元素已经有序或接近有序的数组进行排序效率很高。插入排序平均需要大约N<sup>2</sup>/4次比较和N<sup>2</sup>/4次交换。最坏的情况下则需要N<sup>2</sup>次比较和N<sup>2</sup>/2次交换。也就是说最坏的情况下（如初始排序是倒序的），插入排序比选择排序还要慢。运行上面的测试代码，耗时：15208ms，由于是随机数组，因此比选择排序还要慢。</p>

<h2>4. 希尔排序(Shell)</h2>

<p>希尔排序其实是基于插入排序。既然插入排序对有序数组效率很高，但对于乱序数组，元素只能一点一点地从一端移动到另一端。那么希尔排序就改进这一点，交换不相邻的元素，最终用插入排序将局部有序的数组排序。</p>

<p>其思想是使任意间隔为h的元素有序，称为h有序数组。排序时，如果h很大，我们就能将元素移动到很远的地方，为实现更小的h有序创造方便。代码实现如下：</p>

<p>```java
public class Shell extends AbstractSort {</p>

<pre><code>@Override
public void sort(Comparable[] a) {
    int n = a.length;
    int h = 1;
    while (h &lt; n/3) {
        h = 3 * h + 1;
    }
    //h:1, 4, 13, 40, 121, 364, 1093, ...

    while (h &gt;= 1) {
        //这部分就是插入排序，但将位移由1变为了h
        for (int i = h; i &lt; n; i++) {
            for (int j = i; j &gt;= h &amp;&amp; less(a[j], a[j-h]); j -= h) {
                exchange(a, j, j-h);
            }
        }

        h = h / 3;
    }

    draw();
}
</code></pre>

<p>}
```</p>

<p>性能：此算法的性能不仅取决于h，还取决于h之间的数学性质，比如它们的公因子。有很多论文研究不同的递增序列，但上面的代码似乎已经相当好，更优的递增序列有待发现。希尔排序对任意排序的数组表现也很好。运行上面的测试代码，耗时：160ms</p>

<p>希尔排序对于中等大小的数组运行时间是可以接受的。它的代码量很小，不需要额外的内存空间。其它更高效的算法除了对于很大的N，它们可能只会比希尔排序快最多两倍，而且更复杂。</p>
]]></content>
  </entry>
  
</feed>
