<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 移动开发 | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/yi-dong-kai-fa/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2016-01-01T19:42:52+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Titanium UI及最佳实践]]></title>
    <link href="http://blog.ubone.com/blog/2015/01/13/titanium-uiji-zui-jia-shi-jian/"/>
    <updated>2015-01-13T21:05:37+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/01/13/titanium-uiji-zui-jia-shi-jian</id>
    <content type="html"><![CDATA[<p>学习Titanium的UI，以及Titanium相关的最佳实践。</p>

<!--more-->


<h2>1. User Interface</h2>

<h3>1.1 基础</h3>

<p>布局属性：</p>

<ul>
<li>width</li>
<li>height</li>
<li>left</li>
<li>right</li>
<li>top</li>
<li>bottom</li>
<li>center: 其属性x和y，表示view中心相对父容器的left, top</li>
<li>layout: &ldquo;vertical&rdquo;, &ldquo;horizontal&rdquo; or &ldquo;composite"，默认为composite，值absolute也是composite</li>
<li>size: 只读，当自己与下级渲染完后才有值。</li>
<li>rect: 只读</li>
<li>zIndex: 整数，值大的位于上层</li>
</ul>


<p>Titanium.UI.FILL and Titanium.UI.SIZE</p>

<table>
<thead>
<tr>
<th>Name </th>
<th> Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>width </td>
<td> If width is defined, it takes precedence and the positioning pins are not used to determine the view&rsquo;s width. If width is not defined, and at least two horizontal positioning pins are defined, the width is calculated implicitly from the pins. For example, left and right or left and center.x. If all three horizontal pins are defined, the width is determined by the left and center.x pins. If width cannot be implicitly calculated it follows the view&rsquo;s default sizing behavior.</td>
</tr>
<tr>
<td>left </td>
<td> If left is defined, it always takes precedence for positioning the view horizontally.</td>
</tr>
<tr>
<td>center.x </td>
<td> Used to position the view horizontally if left is not set. If left is set, this property is not used to position the view, although it may be used to determine its width.</td>
</tr>
<tr>
<td>right </td>
<td> Used to position the view horizontally when neither left or center.x is set. If either left or center.x is set, this property is not used to position the view, although it may be used to determine its width.</td>
</tr>
<tr>
<td>height </td>
<td> If height is defined, it takes precedence and the positioning pins are not used to determine the view&rsquo;s height. If height is not defined, and at least two vertical positioning pins are defined, the height is determined implicitly from the pins. If all three vertical pins are defined, the height is determined by the top and center.y pins. If height cannot be implicitly calculated it follows the view&rsquo;s default sizing behavior.</td>
</tr>
<tr>
<td>top </td>
<td> If specified, always takes precedence for positioning the view horizontally.</td>
</tr>
<tr>
<td>center.y </td>
<td> Used to position the view vertically if top is not set. If top is defined, this property is not used to position the view, although it may be used to determine its height.</td>
</tr>
<tr>
<td>bottom </td>
<td> Used to position the view vertically if neither top or center.y is set. If either top or center.y is set, this property is ignored. this property is not used to position the view, although it may be used to determine its height.</td>
</tr>
</tbody>
</table>


<p>为了防止重新布局影响性能，可以使用批量操作：</p>

<p><code>javascript
myView.applyProperties({
  top: 50,
  left: 50,
  width: 200
});
</code></p>

<p>使用rect属性可以获取控件的位置、大小。由于布局是异步发生，因此可能需要在postlayout事件之后去获取rect。示例如下：</p>

<p><code>javascript
var postLayoutCallback  = function(e){
  Ti.API.info(String.format("Layout done, left: %f, width: %f", myView.rect.x, myView.rect.width));
  myView.removeEventListener('postlayout', postLayoutCallback);
}
myView.addEventListener('postlayout', postLayoutCallback);
myView.updateLayout({
  left: '25%',
  width: '25%'
});
</code></p>

<p>注意！如果在postlayout事件中修改view的大小，会导致死循环！此外，为了性能，只监听特定view的postlayout事件，而不是整个窗口。一些非布局的参数变化也可能导致触发此事件，例如设置label的text。</p>

<p><strong>尺寸单位</strong></p>

<table>
<thead>
<tr>
<th>Unit </th>
<th> Abbreviation </th>
<th> Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>pixels </td>
<td> px </td>
<td></td>
</tr>
<tr>
<td>density-independent pixels </td>
<td> dip or dp </td>
<td> Equivalent to Apple &ldquo;points.&rdquo;</td>
</tr>
<tr>
<td>inches  </td>
<td> in </td>
<td></td>
</tr>
<tr>
<td>millimeters </td>
<td> mm</td>
<td> Android, iOS only</td>
</tr>
<tr>
<td>centimeters </td>
<td> cm </td>
<td> Android, iOS only</td>
</tr>
<tr>
<td>points </td>
<td> pt</td>
<td> 1/72 of an inch. Android only. Not to be confused with Apple &ldquo;points.&rdquo;</td>
</tr>
</tbody>
</table>


<p>On Android, a density-independent pixel (DIP) corresponds to one pixel on a 160DPI display.</p>

<p>On iOS, a DIP corresponds to one pixel on a non-Retina display, which is 163DPI for iPhone/iPod touch and 132DPI for the iPad. A DIP corresponds to 2 pixels of width or height on a Retina display.</p>

<p>如果未指定，系统默认为：Android(pixels), iOS(DIP), WEB(DIP)</p>

<p><strong>Horizontal and Vertical Layouts</strong></p>

<p>对于垂直布局，child.width = FILL时，充满父容器的width; child.height = FILL时，充满父容器剩余的高度，后续加入的child将超出父容器高度，因此不可见。</p>

<p>对于水平布局，child一个一个往右排。如果horizontalWrap=true, 排不下时会换行，否则只会排成一行。</p>

<p>这两种情况，left和right都用于水平padding, top和bottom用于垂直位置。</p>

<p><strong>冲突时的解决办法：</strong></p>

<ul>
<li>当控件使用SIZE，而计算出来的尺寸超过父容器，则以父容器边界为准。</li>
<li>当控件使用FILL，父容器使用SIZE，则父容器按控件FILL走，不停扩大，直到遇到边界限制（例如祖父有限制）。</li>
<li>当控件使用百分比，而父容器使用SIZE，结果不确定。</li>
</ul>


<p>查看<a href="http://docs.appcelerator.com/titanium/latest/#!/guide/Transitioning_to_the_New_UI_Layout_System-section-30088148_TransitioningtotheNewUILayoutSystem-BehaviorChangesinRelease2.0">布局示例</a>。</p>

<h3>1.2 事件处理</h3>

<p>常用事件：click、swipe、scroll、dblclick、doubletap、touchstart, touchmove, touchend等等。一些模块还有自己的事件。</p>

<p>```
element.addEventListener(&lsquo;event_type&rsquo;, function(e) {
 // code here is run when the event is fired
 // properties of the event object &lsquo;e&rsquo; describe the event and object that received it</p>

<pre><code>Ti.API.info('The '+e.type+' event happened');
</code></pre>

<p>});
```</p>

<p>回调方法的e通常包含以下信息：</p>

<ul>
<li>x和y，事件（如touch）发生时，在view内的坐标。</li>
<li>globalPoint: （仅iOS）事件发生时，在屏幕中的坐标。</li>
<li>type: 事件类型名</li>
<li>source: 事件主体</li>
</ul>


<p>事件可以从当前View往parent View bubbling。Titanium.Event有两个参数控制bubbling: bubbles(boolean)表示事件是否能buggle，只读；cancelBubble(boolean)，如果设置为true则停止bubble。此外，所有View类组件还有一个属性bubbleParent，是可改的。用于表示事件是否bubble给上级。需要注意的是，当手指拿起时，可能触发了touchup, click, tap事件，在touchup事件中设置cancelBubble=true并不会阻止tap或click事件触发和bubble. 在代码中也可以触发事件：</p>

<p>```
someButton.fireEvent(&lsquo;click&rsquo;);
//或者传参
someButton.fireEvent(&lsquo;click&rsquo;, {kitchen: &lsquo;sink&rsquo;});
//注意获取kitchen的代码
someButton.addEventListener(&lsquo;click&rsquo;, function(e){</p>

<pre><code>Ti.APP.info('The value of kitchen is '+e.kitchen);
</code></pre>

<p>});
```</p>

<p><strong>自定义事件</strong>：</p>

<p>```
deleteButton.addEventListener(&lsquo;click&rsquo;, function(e){
 // when something happens in your app</p>

<pre><code>database.doDelete(e.whichRecord);
</code></pre>

<p> // fire an event so components can react</p>

<pre><code>theTable.fireEvent('db_updated');
</code></pre>

<p>});
// &hellip; elsewhere in your code
theTable.addEventListener(&lsquo;db_updated&rsquo;, function(e){</p>

<pre><code>theTable.setData(database.getCurrentRecords());
</code></pre>

<p>});
```</p>

<p><strong>全局事件</strong>，使用Ti.APP。<strong>注意尽量避免使用全局事件</strong>，因为很容易导致内存无法正确释放。</p>

<p>```
deleteButton.addEventListener(&lsquo;click&rsquo;, function(e){
 // when something happens in your app</p>

<pre><code>database.doDelete(e.whichRecord);
</code></pre>

<p> // fire a global event so components can react</p>

<pre><code>Ti.App.fireEvent('db_updated');
</code></pre>

<p>});
// &hellip; elsewhere in your code
Ti.App.addEventListener(&lsquo;db_updated&rsquo;, function(e){</p>

<pre><code>theTable.setData(database.getCurrentRecords());
someOtherComponent.doSomethingElse();
</code></pre>

<p>});
```</p>

<p><strong>移除事件监听：</strong></p>

<p><code>
function doSomething(e) {
 // do something
}
deleteButton.addEventListener('click', doSomething);
// ... elsewhere in your code ...
deleteButton.removeEventListener('click', doSomething);
});
</code></p>

<p><strong>特殊事件：</strong></p>

<table>
<thead>
<tr>
<th>Event </th>
<th> Fired when &hellip;</th>
</tr>
</thead>
<tbody>
<tr>
<td>androidback </td>
<td> The back button is released</td>
</tr>
<tr>
<td>androidhome </td>
<td> The home button is released</td>
</tr>
<tr>
<td>androidsearch </td>
<td> The search button is released</td>
</tr>
<tr>
<td>androidcamera </td>
<td> The camera button is released</td>
</tr>
<tr>
<td>androidfocus </td>
<td> Fired when the camera button is pressed halfway and then released.</td>
</tr>
<tr>
<td>androidvolup </td>
<td> The volume-up rocker button is released</td>
</tr>
<tr>
<td>androidvoldown </td>
<td> The volume-down rocker button is released</td>
</tr>
</tbody>
</table>


<p>所有涉及Ti.的事件都需要在JavaScript与Native之间进行转换，因此尽量使用Underscore的事件处理。另外，将事件监听尽可能地延后，有助于提高系统响应速度。所有全局事件监听一直是活着的，因此监听中引用的局域变量也一直活着，这将可能导致内存泄露。</p>

<h2>2. Titanium最佳实践</h2>

<h3>2.1 JavaScript建议</h3>

<p>避免使用全局变量，Objects are placed in the global scope when:</p>

<ul>
<li>You declare a variable outside of a function or CommonJS module. Using a modular pattern will alleviate this problem.</li>
<li>You omit the var keyword when declaring a variable (within or outside of a function). So always use var when declaring variables.</li>
</ul>


<p>避免在全局事件监听中引用局部对象，下面的代码是个坏例子：</p>

<p>```
var someFunction = function() {</p>

<pre><code>var table = Ti.UI.createTableView(),
    label = Ti.UI.createLabel(),
    view = Ti.UI.createView();
Ti.App.addEventListener('bad:move', function(e) {
    table.setData(e.data);
});
view.add(table);
view.add(label);
</code></pre>

<p> return view;
};
```</p>

<p>所有Ti命名空间都与Native相关，因此应避免通过prototype扩展，同时使用缓存来避免多次调用Native方法。如下例：</p>

<p><code>
var isAndroid = (Ti.Platform.osname=='android') ? true : false;
if(isAndroid) {
 // do Android specific stuff
} else {
 // do iOS stuff
}
</code></p>

<p>多个Controller以及CommonJS Module之间，可以使用trigger， on等方法实现事件触发和监听。不要使用Ti相关fireEvent，因为只要涉及Ti都会产生Native与Javascript之间的接口。</p>

<p>变量、属性和方法等不要使双下划线，这是Alloy内部使用的。不要使用JavaScript保留关键字。</p>

<p>Wrap self-calling functions in parenthesis， 这种模式有利于包装局部变量。</p>

<p>```
var myValue = function() {
 //do stuff
 return someValue;
}();</p>

<p>//这样写更容易明白返回的是值，而不是一个方法。
var myValue = (function() {
 //do stuff
 return someValue;
})();
```</p>

<p><strong>提高遍历的效率</strong>，通过保存数组的length:</p>

<p>```
var names = [&lsquo;Jeff&rsquo;,&lsquo;Nolan&rsquo;,&lsquo;Marshall&rsquo;,&lsquo;Don&rsquo;];
for(var i=0;i&lt;names.length;i++){</p>

<pre><code>process(names[i]);
</code></pre>

<p>}</p>

<p>// I can check the array length only once
var names = [&lsquo;Jeff&rsquo;,&lsquo;Nolan&rsquo;,&lsquo;Marshall&rsquo;,&lsquo;Don&rsquo;];
for(var i=0,j=names.length;i&lt;j;i++){</p>

<pre><code>process(names[i]);
</code></pre>

<p>}
```</p>

<h3>2.2 CommonJS Module</h3>

<p>主要有两种方式来创建CommonJS Module。方式一采用exports方法：</p>

<p>```
exports.sayHello = function(name) {</p>

<pre><code>Ti.API.info('Hello '+name+'!');
</code></pre>

<p>};
exports.version = 1.4;
exports.author = &lsquo;Don Thorp&rsquo;;
```</p>

<p>另一种方式公开的方法主要以对象构造器的方式：</p>

<p><code>
function Person(firstName,lastName) {
 this.firstName = firstName;
 this.lastName = lastName;
}
Person.prototype.fullName = function() {
 return this.firstName+' '+this.lastName;
};
//注意是module.exports
module.exports = Person;
</code></p>

<p>前者使用<code>exports.xxx</code>，后者使用<code>module.exports</code>，这两种方式不要在同一个module中混合使用！</p>

<p>每个module都有自己的scope，只有export的方法才是公开的。注意如果exports属性，该值可能不会改变：</p>

<p>```
//statefulModule.js
var <em>stepVal = 5; // default
exports.setPointStep = function(value) {
  </em>stepVal = value;
};
exports.getPointStep = function() {
 return <em>stepVal;
};
exports.stepVal = </em>stepVal;</p>

<p>//app.js
var stateful = require(&lsquo;statefulModule&rsquo;);
stateful.setPointStep(10);
stateful.getPointStep(); //10
stateful.stepVal //值永远是初始值5.
```</p>

<h3>2.3 数据库</h3>

<p><strong>每次操作都打开并关闭数据库和resultset</strong></p>

<p><code>
cityWeatherRS.close(); // close the resultset when you're done reading from it
db.close(); // and close the database connection
</code></p>

<p><strong>批量操作时，使用事务</strong></p>

<p>```
var db = Ti.Database.open(&lsquo;myDatabase&rsquo;);
db.execute(&lsquo;BEGIN&rsquo;); // begin the transaction
for(var i=0, var j=playlist.length; i &lt; j; i++) {</p>

<pre><code>var item = playlist[i];
db.execute('INSERT INTO albums (disc, artist, rating) VALUES (?, ?, ?)', item.disc, item.artist, item.comment);
</code></pre>

<p>}
db.execute(&lsquo;COMMIT&rsquo;);
db.close();
```</p>

<h3>2.4 图片</h3>

<blockquote><ul>
<li>PNG – PNG images are in a lossless-compressed format that can support high-color images. This format is best suited to line-art, text, and icons. It is a better choice than GIF in almost all cases.</li>
<li>JPG – JPG (or JPEG) is lossy-compressed file format best suited for photographs. It is not well-suited for text, line drawings, or icons because of visual artifacts created during the compression process that will reduce quality and readability.</li>
<li>因此：</li>
<li>Photos? Use JPG</li>
<li>Text, line drawings, icons, button graphics? Use PNG</li>
<li>Flip-book style animations (for which animated GIFs would be the traditional choice)? Use the ImageView&rsquo;s images property and pass to it an array of PNG or optimized JPG files.</li>
</ul>
</blockquote>

<p>注意：显示JPG图片时，会在内存中解压缩，因此不要一次创建太多的JPG ImageView，否则将耗尽内存。将imageView从view中移除并不会回收内存，还要将imageView设置为null.</p>

<p>为了减少ipa/apk的大小，需要对图片进行优化。见<a href="http://docs.appcelerator.com/titanium/latest/#!/guide/Image_Best_Practices">Titanium文档</a>。</p>

<p>ImageView已经能够显示本地和远程的图片。显示远程图片时，可以先设置defaultImage，下载成功后会自动显示远程图片。这些图片会缓存，对于Android会缓存到应用退出。要自己控制缓存到本地目录，参考<a href="http://docs.appcelerator.com/titanium/latest/#!/guide/Image_Best_Practices">文档</a>。</p>

<h3>2.5 管理内存</h3>

<p>除了把View移除外，还需要将它设置为null.</p>

<p><code>
var button = Ti.UI.createButton({
 // parameters go here...
});
var view = Ti.UI.createView({
 // some parameters here...
});
view.add(button);
// ... later
win.remove(view);  // view &amp; button still exist
view = null; // deletes the view and its proxy, but not the button!
// compare that to:
var view = Ti.UI.createView({
 // some parameters here...
});
view.add(Ti.UI.createButton({
 // parameters go here...
}));
// ... later
win.remove(view);
view = null; // deletes the view, button, and their proxies
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Titanium Alloy MVC]]></title>
    <link href="http://blog.ubone.com/blog/2015/01/11/titanium-alloy-mvc/"/>
    <updated>2015-01-11T19:25:14+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/01/11/titanium-alloy-mvc</id>
    <content type="html"><![CDATA[<p>这是一篇学习笔记，主要内容是Alloy的Controller, Model, Collection, View以及Widget.</p>

<!--more-->


<h2>1. Alloy Controllers</h2>

<p>创建Controller和获得View: Alloy.createController and Controller.getView.</p>

<p>可以继承：exports.baseController = &lsquo;baseControllerName'，子类继承父类export的方法，并可以重写。</p>

<p>可以在Controller中判断当前平台：OS_ANDROID, OS_BLACKBERRY, OS_IOS, OS_MOBILEWEB, ENV_DEV, ENV_TEST, ENV_PRODUCTION, DIST_ADHOC, DIST_STORE:</p>

<p><code>if (OS_IOS) {...}</code></p>

<p>传参：</p>

<p>```javascript
//index.js
var arg = {</p>

<pre><code>    title: source[i].postTitle,
    url: source[i].postLink
};
data.push(Alloy.createController('row', arg).getView());
</code></pre>

<p>//row.js
var args = arguments[0] || {};
$.rowView.title = args.title || &lsquo;&rsquo;;
$.rowView.url = args.url || &lsquo;&rsquo;;</p>

<p>```</p>

<p>使用Alloy.Globals命名空间可以保存全局变量：<code>Alloy.Globals.xxx = ...</code></p>

<p>alloy.js运行于应用的生命周期之前，会在index.js加载之前调用，也就是任何UI加载之前。</p>

<p>lib文件夹用于类库，也可以建立平台子文件夹（如ios）。但require时，不需要指定平台名。</p>

<p>当前，Controller已经默认加载了Alloy, Underscore.js和Backbone.js，但以后可能需要自己加载：</p>

<p><code>javascript
var Alloy = require('alloy'), _ = require("alloy/underscore")._, Backbone = require("alloy/backbone");
</code></p>

<h2>2. Alloy Models</h2>

<h3>2.1 Alloy Collection and Model Objexts</h3>

<h4>2.1.1 Models</h4>

<p>In Alloy, models inherit from the <a href="http://docs.appcelerator.com/backbone/0.9.2/#Model">Backbone.Model</a> class.</p>

<p>```javascript
exports.definition = {</p>

<pre><code>config : {
</code></pre>

<p> // table schema and adapter information</p>

<pre><code>},
extendModel: function(Model) {      
    _.extend(Model.prototype, {
</code></pre>

<p> // Extend, override or implement Backbone.Model</p>

<pre><code>    });
</code></pre>

<p> return Model;</p>

<pre><code>},
extendCollection: function(Collection) {        
    _.extend(Collection.prototype, {
</code></pre>

<p> // Extend, override or implement Backbone.Collection</p>

<pre><code>    });
</code></pre>

<p> return Collection;</p>

<pre><code>}
</code></pre>

<p>}
```</p>

<p>在Controller中访问Model:</p>

<p><code>javascript
var book = Alloy.createModel('book', {title:'Green Eggs and Ham', author:'Dr. Seuss'});
var title = book.get('title');
var author = book.get('author');
// Label object in the view with id = 'label'
$.label.text = title + ' by ' + author;
</code></p>

<p>全局Model单例：</p>

<p><code>javascript
// This will create a singleton if it has not been previously created,
// or retrieves the singleton if it already exists.
var book = Alloy.Models.instance('book');
</code></p>

<h5>2.1.1.1 定义表结构</h5>

<p>config对象有三部分：columns, defaults和adapter.</p>

<p>columns定义表结构。对应SQLite，支持以下类型：string, varchar, int, tinyint, smallint, bigint, double, float, decimal, number, date, datetime and boolean，其它未知类型将视为TEXT。</p>

<p>defaults对象用于设置默认值。</p>

<p>adapter对象定义存储接口。</p>

<p>```
exports.definition = {</p>

<pre><code>config: {
</code></pre>

<p> &ldquo;columns&rdquo;: {
 &ldquo;title&rdquo;: &ldquo;String&rdquo;,
 &ldquo;author&rdquo;: &ldquo;String&rdquo;,
 &ldquo;book_id&rdquo;: &ldquo;INTEGER PRIMARY KEY AUTOINCREMENT&rdquo; //自增长</p>

<pre><code>    },
</code></pre>

<p> &ldquo;defaults&rdquo;: { //默认值
 &ldquo;title&rdquo;: &ldquo;&ndash;&rdquo;,
 &ldquo;author&rdquo;: &ldquo;&ndash;&rdquo;</p>

<pre><code>    },
</code></pre>

<p> &ldquo;adapter&rdquo;: {
 &ldquo;type&rdquo;: &ldquo;sql&rdquo;, //存储类型SQLite
 &ldquo;collection_name&rdquo;: &ldquo;books&rdquo;, //表名
  &ldquo;idAttribute&rdquo;: &ldquo;book_id&rdquo; //主键</p>

<pre><code>    }
}
</code></pre>

<p>}
```</p>

<h5>2.1.1.2 Extending the Backbone.Model Class</h5>

<p>在extendModel中扩展方法，例如validate方法.</p>

<h4>2.1.2 Collections</h4>

<p>在Controller中创建Collection，作用域为本Controller:</p>

<p><code>
var library = Alloy.createCollection('book');
library.fetch(); // Grab data from persistent storage
</code></p>

<p>创建全局单例Collection:</p>

<p><code>
// This will create a singleton if it has not been previously created,
// or retrieves the singleton if it already exists.
var library = Alloy.Collections.instance('book');
</code></p>

<p>在extendCollection中定义扩展Backbone的方法，例如：</p>

<p>```
// Implement the comparator method.
comparator : function(book) {</p>

<pre><code>return book.get('title');
</code></pre>

<p>}
```</p>

<p>Backbone.Collection继承了underscore的一些集合操作方法，例如迭代：</p>

<p>```
var data = [];
library.map(function(book) {
 // The book argument is an individual model object in the collection</p>

<pre><code>var title = book.get('title');
var row = Ti.UI.createTableViewRow({"title":title});
data.push(row);
</code></pre>

<p>});
// TableView object in the view with id = &lsquo;table&rsquo;
$.table.setData(data);
```</p>

<p>事件处理：use the Backbone.Events on, off and trigger methods</p>

<p>```
var library = Alloy.createCollection(&lsquo;book&rsquo;);
function event_callback (context) {</p>

<pre><code>var output = context || 'change is bad.';
Ti.API.info(output);
</code></pre>

<p>};
// Bind the callback to the change event of the collection.
library.on(&lsquo;change&rsquo;, event_callback);
// Trigger the change event and pass context to the handler.
library.trigger(&lsquo;change&rsquo;, &lsquo;change is good.&rsquo;);
// Passing no parameters to the off method unbinds all event callbacks to the object.
library.off();
// This trigger does not have a response.
library.trigger(&lsquo;change&rsquo;);
```</p>

<p>注意：如果事件名称不要使用空格。因为Backbone使用了空格来处理多事件。</p>

<h3>2.2 Alloy Data Binding</h3>

<p>当Collection或Model变化时，View也跟随变化，这就是绑定.</p>

<p><strong>注意：如果使用绑定，必须在controller关闭时，调用<code>$.destroy()</code>方法，以避免内存泄露:</strong></p>

<p>```
$.win.addEventListener(&ldquo;close&rdquo;, function(){</p>

<pre><code>$.destroy();
</code></pre>

<p>}
```</p>

<h4>2.2.1 Collection-View Binding</h4>

<p>以下View对象支持Collection绑定：</p>

<table>
<thead>
<tr>
<th>View Object </th>
<th> Add data binding attributes to&hellip; </th>
<th> Repeater Object</th>
</tr>
</thead>
<tbody>
<tr>
<td>ButtonBar </td>
<td> <code>&lt;Labels&gt;</code> </td>
<td> <code>&lt;Label/&gt;</code></td>
</tr>
<tr>
<td>CoverFlowView </td>
<td> <code>&lt;Images&gt;</code> </td>
<td> <code>&lt;Image/&gt;</code></td>
</tr>
<tr>
<td>ListView </td>
<td> <code>&lt;ListSection&gt;</code> </td>
<td> <code>&lt;ListItem/&gt;</code></td>
</tr>
<tr>
<td>Map Module </td>
<td> <code>&lt;Module module="ti.map" method="createView"&gt;</code>  </td>
<td> <code>&lt;Annotation/&gt;</code></td>
</tr>
<tr>
<td>Picker </td>
<td> <code>&lt;PickerColumn&gt;</code> or <code>&lt;Column&gt;</code> </td>
<td> <code>&lt;PickerRow/&gt;</code> or <code>&lt;Row/&gt;</code></td>
</tr>
<tr>
<td>ScrollableView </td>
<td> <code>&lt;ScrollableView&gt;</code> </td>
<td> <code>&lt;View/&gt;</code></td>
</tr>
<tr>
<td>TableView </td>
<td> <code>&lt;TableView&gt;</code> </td>
<td> <code>&lt;TableViewRow/&gt;</code></td>
</tr>
<tr>
<td>TabbedBar </td>
<td> <code>&lt;Labels&gt;</code> </td>
<td> <code>&lt;Label/&gt;</code></td>
</tr>
<tr>
<td>Toolbar </td>
<td> <code>&lt;Items&gt;</code> </td>
<td> <code>&lt;Item/&gt;</code></td>
</tr>
<tr>
<td>View </td>
<td> <code>&lt;View&gt;</code> </td>
<td> 除了Window和TabGroup之外的View对象</td>
</tr>
</tbody>
</table>


<p>在XML中定义以下元素，其中只有dataCollection是必须的：</p>

<ul>
<li>dataCollection: 指定一个Collection</li>
<li>dataTransform: 回调方法，传入model，返回修改的JSON对象</li>
<li>dataFilter: 过滤collection, 传入collection, 返回model数组</li>
<li>dataFunction: 指定一个方法名，controller使用这个方法来更新view。这个方法不是controller中声明的方法。该属性创建一个别名访问内在的绑定方法。（<a href="http://docs.appcelerator.com/titanium/latest/#!/guide/Alloy_Data_Binding-section-36739592_AlloyDataBinding-BackboneBinding">没搞懂</a>）</li>
</ul>


<p>对于Collection中的model，xml中可以使用<code>{}</code>来获取model的值，例如：<code>&lt;Label text="{title} by {author}" /&gt;</code>。</p>

<p>在repeater对象的controller中，可以使用<code>$model</code>来引用当前model。如<code>$model.title</code></p>

<p>Collection绑定示例：</p>

<p>```
app/views/index.xml
<Alloy></p>

<pre><code>&lt;Collection src="book"/&gt;
&lt;Window backgroundColor="white" onClose="cleanup"&gt;
    &lt;ScrollableView dataCollection="book"&gt;
        &lt;View layout="vertical"&gt;
            &lt;ImageView image="{cover}" /&gt;
            &lt;Label text="{title} by {artist}" /&gt;
        &lt;/View&gt;
    &lt;/ScrollableView&gt;   
&lt;/Window&gt;
</code></pre>

<p></Alloy></p>

<p>app/controllers/index.js
$.index.open();
Alloy.Collections.album.fetch();</p>

<p>function cleanup() {</p>

<pre><code>$.destroy();
</code></pre>

<p>}</p>

<p>```</p>

<h4>2.2.2 Model-View Binding</h4>

<p>```
<Alloy></p>

<pre><code>&lt;Model src="settings"/&gt;
&lt;Window backgroundColor="white" onClose="cleanup"&gt;
    &lt;View layout="vertical"&gt;
        &lt;Label text="Text Size" /&gt;
        &lt;Slider value="{settings.textsize}" max="5" min="1"/&gt;
        &lt;Label text="Bold"/&gt;
        &lt;Switch value="{settings.bold}" /&gt;
        &lt;Label text="Italics"/&gt;
        &lt;Switch value="{settings.italics}" /&gt;
    &lt;/View&gt;
&lt;/Window&gt;
</code></pre>

<p></Alloy>
```</p>

<p>上例中，获取值使用的格式为：<code>{modelName.attrName}</code></p>

<h4>2.2.3 Collection方法示例</h4>

<p>```
app/views/index.xml
<Alloy></p>

<pre><code>&lt;Collection src="book" /&gt;
&lt;Window class="container"&gt;
    &lt;TableView dataCollection="book"
               dataTransform="transformFunction"
               dataFilter="filterFunction"
               dataFunction="updateUI"
               onDragEnd="refreshTable"&gt;
        &lt;!-- Also can use Require --&gt;
        &lt;TableViewRow title="{title}" /&gt;
    &lt;/TableView&gt;
&lt;/Window&gt;
</code></pre>

<p></Alloy></p>

<p>app/controllers/index.js
$.index.open();</p>

<p>// Encase the title attribute in square brackets
function transformFunction(model) {
 // Need to convert the model to a JSON object</p>

<pre><code>var transform = model.toJSON();
transform.title = '[' + transform.title + ']';
</code></pre>

<p> // Example of creating a custom attribute, reference in the view using {custom}</p>

<pre><code>transform.custom = transform.title + " by " + transform.author;
</code></pre>

<p> return transform;
}
// Show only book models by Mark Twain
function filterFunction(collection) {
 return collection.where({author:&lsquo;Mark Twain&rsquo;});
}</p>

<p>function refreshTable(){
 // Trigger the binding function identified by the dataFunction attribute</p>

<pre><code>updateUI();
</code></pre>

<p>}
// Trigger the synchronization
var library = Alloy.Collections.book;
library.fetch();</p>

<p>// Free model-view data binding resources when this view-controller closes
$.index.addEventListener(&lsquo;close&rsquo;, function() {</p>

<pre><code>$.destroy();
</code></pre>

<p>});
```</p>

<p>当数据变化时，上面的例子中的界面会跟着变化。如果想避免发生变化，可以在调用Backbone方法修改model数据时指定参数：<code>{silent:true}</code>.</p>

<h3>2.3 Alloy数据持久化与升级</h3>

<p>Model数据可以同步到本地或远程服务器。这项功能使用的是Backbone sync方法。</p>

<h4>2.3.1 Backbone同步方式</h4>

<p>Backbone sync时，默认会执行RESTful JSON请求到Model.urlRoot或者Collection.url。读操作使用GET方法，写操作使用POST方法。不论Model是否定义了自己的主键，Backbone都会创建Client ID(cid)。在未保存前，可以使用Model.cid或者Collection.getByCid方法来存取数据。Backbone同步示例：</p>

<p>```
// Since the urlRoot attribute is defined, all HTTP commands are to /library
var Book = Backbone.Model.extend({urlRoot:&lsquo;/library&rsquo;})
var book = new Book();</p>

<p>// Performs a POST on /library with the arguments as a payload and the server returns the id as 1
book.save({title:&lsquo;Bossypants&rsquo;,author:&lsquo;Tina Fey&rsquo;,checkout:false})</p>

<p>// Performs a GET on /library/1
book.fetch({id:1});</p>

<p>// Performs a PUT on /library/1 with the entire modified object as a payload.
book.save({checkout:true});</p>

<p>// Performs a DELETE on /library/1
book.destroy();
```</p>

<h4>2.3.2Alloy的同步方式</h4>

<p>Alloy支持SQLite或者properties来保存数据。Alloy查询SQLite时，可以使用简单查询或者prepared statement:</p>

<p>```javascript
var library = Alloy.createCollection(&lsquo;book&rsquo;);
// The table name is the same as the collection_name value from the &lsquo;config.adapter&rsquo; object. This may be different from the model name.
var table = library.config.adapter.collection_name;
// use a simple query
library.fetch({query:&lsquo;SELECT * from &rsquo; + table + &lsquo; where author=&ldquo;&rsquo; + searchAuthor + &lsquo;&rdquo;&rsquo;});
// or a prepared statement
library.fetch({query: { statement: &lsquo;SELECT * from &rsquo; + table + &lsquo; where author = ?&rsquo;, params: [searchAuthor] }});</p>

<p>//查询1条记录：
myModel.fetch({id: 123});
// is equivalent to
myModel.fetch({query: &lsquo;select * from &hellip; where id = &rsquo; + 123 });
```</p>

<h4>2.3.3 数据库迁移（升级或降级）</h4>

<p>Alloy采用migration对象来迁移数据库。首先，要将相应的JavaScript文件放在app/migrations文件夹下。文件名采用以下格式：<code>YYYYMMDDHHmmss_MODELNAME.js</code>，例如20150120160155_book.js。Alloy将升序执行js文件以完成数据库迁移。</p>

<p>JavaScript文件中要实现两个方法：migration.up(migrator) 和 migration.down(migrator)。migrator对象的值如下：</p>

<table>
<thead>
<tr>
<th>Key </th>
<th> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>db </td>
<td> Ti.Database实例，可以调用db.execute方法执行SQL。<strong>注意不要关闭或打开另一个实例。</strong></td>
</tr>
<tr>
<td>dbname </td>
<td> 数据库名</td>
</tr>
<tr>
<td>table </td>
<td> table名，也就是Model的config.adapter.collection_name值</td>
</tr>
<tr>
<td>idAttribute </td>
<td> 主键字段名</td>
</tr>
<tr>
<td>createTable </td>
<td> 创建表的方法，参数为Model config.columns</td>
</tr>
<tr>
<td>dropTable </td>
<td> 删除表</td>
</tr>
<tr>
<td>insertRow </td>
<td> 插入行, 参数为待插入的数据对象</td>
</tr>
<tr>
<td>deleteRow </td>
<td> 删除行，参数为待删除的数据对象</td>
</tr>
</tbody>
</table>


<p>下面的示例先创建表将初始数据，之后进行了升级:</p>

<p>```
app/migrations/20120610049877_book.js
var preload_data = [</p>

<pre><code>{title: 'To Kill a Mockingbird', author:'Harper Lee'}
</code></pre>

<p>];</p>

<p>migration.up = function(migrator)
{</p>

<pre><code>migrator.createTable({
</code></pre>

<p> &ldquo;columns&rdquo;:</p>

<pre><code>    {
</code></pre>

<p> &ldquo;book&rdquo;: &ldquo;TEXT&rdquo;,
 &ldquo;author&rdquo;: &ldquo;TEXT&rdquo;</p>

<pre><code>    }
});
</code></pre>

<p> for (var i = 0; i &lt; preload_data.length; i++) {</p>

<pre><code>    migrator.insertRow(preload_data[i]);
}
</code></pre>

<p>};</p>

<p>migration.down = function(migrator)
{</p>

<pre><code>migrator.dropTable();
</code></pre>

<p>};</p>

<p>//升级app/migrations/20130118069778_book.js
migration.up = function(migrator) {</p>

<pre><code>migrator.db.execute('ALTER TABLE ' + migrator.table + ' ADD COLUMN isbn INT;');
</code></pre>

<p>};
migration.down = function(migrator) {</p>

<pre><code>var db = migrator.db;
var table = migrator.table;
db.execute('CREATE TEMPORARY TABLE book_backup(title,author,alloy_id);')
db.execute('INSERT INTO book_backup SELECT title,author,alloy_id FROM ' + table + ';');
migrator.dropTable();
migrator.createTable({
    columns: {
        title:"TEXT",
        author:"TEXT",
    },
});
db.execute('INSERT INTO ' + table + ' SELECT title,author,alloy_id FROM book_backup;');
db.execute('DROP TABLE book_backup;');
</code></pre>

<p>};
```</p>

<h2>3. Alloy Widgets</h2>

<p>在Alloy XML Markup中已经介绍了如何使用Widgets，这里主要介绍如何创建Widgets。</p>

<p>Widgets应放在app/Widgets文件夹下，与app文件夹一相，每个Widget也有自己的views, controllers, models, styles and assets等。在Widget中不能访问除了i18n之外的文件。其它主要区别如下：</p>

<ul>
<li>使用WPATH()来自动处理assets和libs的路径总是。例如要在Widget中require <code>app/widgets/foo/lib/helper.js</code>，可以<code>require(WPATH('helper'))</code>。对于<code>app/widgets/foo/assets/images/foo.png</code>使用<code>WPATH('images/foo.png')</code>。</li>
<li>Widgets使用自己的配置文件widget.json</li>
<li>Widgets的主controller是widget.js，而不是index.js。创建widget内的另一个controller需要使用Widget.createController方法。</li>
<li>所有Widget控制器中的方法均为私有方法，除非使用$，例如<code>$.init=function(){...}</code>，然后就可以在项目中调用：<code>$.fooWidget.init()</code>.</li>
<li>Widget中也可以创建Model和Collection, 但要使用Widget.createModel和Widget.createCollection方法。</li>
<li>样式文件为widget.tss</li>
<li>Widget同样可以有Theme, 相关样式和资源要放到：<code>app/themes/&lt;THEME_NAME&gt;/&lt;WIDGET_NAME&gt;</code>。</li>
<li>Widget的主View是widget.xml而不是index.xml。当Widget中的某个view指定了id(eg. buttonId)时，在项目中可以这样引用：<code>$.fooWidget.buttonId.xxx</code></li>
<li>Widget可以包含其它Widget。需要在widget.json中定义依赖。在controller中可以调用：<code>Widget.createWidget(widget_name, [controller_name])</code></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Titanium Alloy基础]]></title>
    <link href="http://blog.ubone.com/blog/2015/01/10/titaniumxue-xi-bi-ji/"/>
    <updated>2015-01-10T20:32:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/01/10/titaniumxue-xi-bi-ji</id>
    <content type="html"><![CDATA[<p>这是一篇学习笔记，主要内容是Alloy的基础概念。</p>

<!--more-->


<h2>1. Alloy框架</h2>

<h3>1.1 Alloy相关概念</h3>

<p><strong>Alloy models</strong> are built on top of <a href="http://backbonejs.org/">Backbone.js</a>, taking advantage of Backbone&rsquo;s rich Model and Collection APIs.</p>

<p><strong>Alloy views</strong> are built from Titanium UI components.</p>

<p><strong>Alloy controllers</strong> generally have a one-to-one relationship with Alloy views.</p>

<p>Additionally, Alloy provides built-in support for <a href="http://underscorejs.org/">Underscore.js</a>, which provides a set of utility functions, such as array and iterative helpers.</p>

<p>资源文件放于app/assets/android or app/assets/iphone folder.</p>

<p>Titanium代码与Alloy XML:</p>

<p>```javascript
var button = Titanium.UI.createButton({</p>

<pre><code>text: "Foobar",
top: 0,
width: Ti.UI.SIZE
</code></pre>

<p>});</p>

<p>button.addEventListener(&lsquo;click&rsquo;, doClick);
```</p>

<p>等价于：</p>

<p><code>
&lt;Button title="Foobar" top="0" width="Ti.UI.SIZE"  onClick="doClick"/&gt;
</code></p>

<p>Alloy项目文件夹：</p>

<table>
<thead>
<tr>
<th>文件夹</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>app </td>
<td> Contains the models, views, controllers and assets of the application. All work should be done here. See folder descriptions below.</td>
</tr>
<tr>
<td><code>app/alloy.jmk</code> </td>
<td> Build configuration file.</td>
</tr>
<tr>
<td><code>app/alloy.js</code> </td>
<td> Initializer file used to preconfigure components or override Alloy methods before the main controller is executed. </td>
</tr>
<tr>
<td><code>app/config.json</code> </td>
<td> Project configuration file.</td>
</tr>
<tr>
<td><code>app/assets</code> </td>
<td> Contains image assets and other files that need to be copied into the Resources directory. Reference these files in the code without the &lsquo;app/assets&rsquo; path and without the platform-specific if it is inside one.</td>
</tr>
<tr>
<td><code>app/controllers</code> </td>
<td> Contains controllers in the format filename.js to a corresponding view file <code>app/views/filename.xml</code>.</td>
</tr>
<tr>
<td><code>app/lib</code> </td>
<td> Contains application-specific library code, typically in the CommonJS format.</td>
</tr>
<tr>
<td>app/migrations </td>
<td> Contains database migration files in the format <code>&lt;DATETIME&gt;_filename.js</code>.</td>
</tr>
<tr>
<td><code>app/models</code> </td>
<td> Contains model files in the format filename.js.</td>
</tr>
<tr>
<td><code>app/styles</code> </td>
<td> Contains view styling in the format filename.tss, which is applied to a corresponding view file <code>app/views/filename.xml</code>.</td>
</tr>
<tr>
<td><code>app/themes</code> </td>
<td> Contains themes to customize the assets and styles of the entire GUI.</td>
</tr>
<tr>
<td><code>app/views</code> </td>
<td> Contains views in the format filename.xml with the optional corresponding files <code>app/controllers/filename.js</code> and <code>app/styles/filename.tss</code>.</td>
</tr>
<tr>
<td><code>app/widgets</code> </td>
<td> Contains widget files. Each widget will have its own app-like directory structure.</td>
</tr>
<tr>
<td>i18n </td>
<td> Contains internationalization and localization files. Same usage as with a Titanium application.</td>
</tr>
<tr>
<td>Resources </td>
<td> Contains the Titanium files generated by the Alloy interface from the app directory. All files will be overwritten each time the application is built. Since Alloy 1.3.0, Alloy creates a separate Titanium project for each platform you build for in the <code>Resources/&lt;platform&gt;</code> folder.</td>
</tr>
</tbody>
</table>


<p><strong>Widgets</strong> are self-contained components that can be easily dropped into Alloy-powered Titanium projects.</p>

<p>Alloy comes with additional utilities used to simplify certain functions, such as animations, string manipulation, and display unit conversion. These utilities are referred to as &lsquo;<strong>builtins</strong>.&rsquo;</p>

<p>```javascript
var animation = require(&lsquo;alloy/animation&rsquo;);
$.shake.addEventListener(&lsquo;click&rsquo;, function(e) {</p>

<pre><code>animation.shake($.view);
</code></pre>

<p>});
```</p>

<h3>1.2 Alloy Views</h3>

<h4>1.2.1 XML Markup</h4>

<p>```
//app/views/index.xml
<Alloy></p>

<pre><code>&lt;Window class="container"&gt;
    &lt;Label id="labelId" onClick="doClick"&gt;Hello, World&lt;/Label&gt;
&lt;/Window&gt;
</code></pre>

<p></Alloy>
```</p>

<p>可以使用<code>$.labelId</code>引用上面的label，对于根视图可以使用<code>$.index</code>（文件名）。</p>

<p>XML中可以使用的属性：</p>

<table>
<thead>
<tr>
<th>属性名 </th>
<th> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>id </td>
<td> Identifies UI elements in the controller (prefixed with &lsquo;$.&rsquo;) and style sheet (prefixed with &lsquo;#&rsquo;).</td>
</tr>
<tr>
<td>class </td>
<td> Applies additional styles (prefixed with &lsquo;.&rsquo; in the TSS file)</td>
</tr>
<tr>
<td>autoStyle </td>
<td> 是否动态样式，当class动态变化时，控件样式动态变化。对性能有影响</td>
</tr>
<tr>
<td>formFactor </td>
<td> handheld or tablet</td>
</tr>
<tr>
<td>if </td>
<td> 使用条件表达式。See <a href="http://docs.appcelerator.com/titanium/latest/#!/guide/Alloy_XML_Markup-section-35621528_AlloyXMLMarkup-ConditionalCode">Conditional Code</a> and <a href="http://docs.appcelerator.com/titanium/latest/#!/guide/Alloy_Styles_and_Themes-section-35621526_AlloyStylesandThemes-CustomQueryStyles">Alloy Styles and Themes: Custom Query Styles</a> for more details.</td>
</tr>
<tr>
<td>module </td>
<td> Requires in a CommonJS module </td>
</tr>
<tr>
<td>ns </td>
<td> Overrides the default Titanium.UI namespace. See Namespace for more details.</td>
</tr>
<tr>
<td>platform </td>
<td> android, blackberry, ios, or mobileweb。如果多个可以使用逗号分隔。</td>
</tr>
</tbody>
</table>


<p>除了上述属性，各组件还可以包括自己特有的属性和事件。另外还有一些特殊的元素：</p>

<table>
<thead>
<tr>
<th>Element </th>
<th> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alloy </td>
<td>Root element for all view XML files. Required in all views.</td>
</tr>
<tr>
<td>Collection </td>
<td> Creates a singleton or instance of the specified collection. </td>
</tr>
<tr>
<td>Model </td>
<td> Creates a singleton or instance of the specified model. </td>
</tr>
<tr>
<td>Module </td>
<td> Imports a module view inside this view (since Alloy 1.2.0). </td>
</tr>
<tr>
<td>Require </td>
<td> Imports a widget or includes another view inside this view. </td>
</tr>
<tr>
<td>Widget </td>
<td> Imports a widget inside this view. Same as the Require Element with the type specified to &lsquo;widget&rsquo;. </td>
</tr>
</tbody>
</table>


<p>index.xml是一个特殊情况，只接受以下根节点：</p>

<ul>
<li>Ti.UI.Window or <code>&lt;Window&gt;</code></li>
<li>Ti.UI.TabGroup or <code>&lt;TabGroup&gt;</code></li>
<li>Ti.UI.iOS.NavigationWindow or <code>&lt;NavigationWindow&gt;</code></li>
<li>Ti.UI.iPad.SplitWindow or <code>&lt;SplitWindow&gt;</code></li>
</ul>


<p><strong>XML中的Collection节点</strong></p>

<p>The Collection XML element creates a singleton or instance of a collection.</p>

<p>```
<Alloy></p>

<pre><code>&lt;Collection src="book" /&gt;
&lt;Window&gt;
    &lt;TableView id="table" /&gt;
&lt;/Window&gt;
</code></pre>

<p></Alloy>
```</p>

<p>上面的代码创建了一个单例集合，对应的model为book.js。在controller中可以这样访问：</p>

<p><code>javascript
var library = Alloy.Collections.book;
library.fetch();
</code></p>

<p>上面的例子 Alloy.Collections.book是全局的，但也可以创建只用于一个Controller的Collection：</p>

<p>```
<Alloy></p>

<pre><code>&lt;Collection id="localLibrary" src="book" instance="true"/&gt;
&lt;Window&gt;
    &lt;TableView id="table" /&gt;
&lt;/Window&gt;
</code></pre>

<p></Alloy>
```</p>

<p>注意上面的src和instance。在代码中通过id来引用：</p>

<p><code>javascript
var library = $.localLibrary;
library.fetch();
</code></p>

<p><strong>Model Element</strong>
与Collection类似，XML中也可以创建Model单例，或者用于某个Controller的一个实例。</p>

<p>单例：</p>

<p>```
<Alloy></p>

<pre><code>&lt;Model src="book" /&gt;
&lt;Window&gt;
    &lt;TableView id="table" /&gt;
&lt;/Window&gt;
</code></pre>

<p></Alloy></p>

<p>var drama = Alloy.Models.book;
drama.set(&lsquo;title&rsquo;, &lsquo;Hamlet&rsquo;);
drama.set(&lsquo;author&rsquo;, &lsquo;William Shakespeare&rsquo;);
```</p>

<p>某个Controller的实例：</p>

<p>```
<Alloy></p>

<pre><code>&lt;Model id="myBook" src="book" instance="true"/&gt;
&lt;Window&gt;
    &lt;TableView id="table" /&gt;
&lt;/Window&gt;
</code></pre>

<p></Alloy></p>

<p>var drama = $.myBook;
drama.set(&lsquo;title&rsquo;, &lsquo;Hamlet&rsquo;);
drama.set(&lsquo;author&rsquo;, &lsquo;William Shakespeare&rsquo;);
```</p>

<p>注意前述的Collection和Model都要放在Alloy节点下。</p>

<p><strong>Module Attribute</strong>
XML中可以引入CommonJS module。首先，module要放入<code>app/lib</code>，并且有一个public方法createXXX，返回一个UI对象。然后，将XXX用于xml节点元素，并设置module路径(基于<code>app/lib</code>)，元素的其它属性将作为参数传入createXXX方法。示例如下：</p>

<p>```
//app/lib/foo.js
// XML attributes are passed to the function
exports.createFoo = function (args) {</p>

<pre><code>var viewArgs = {
    backgroundColor: args.color || 'white',
    width: '100dp',
    height: '100dp'
};
var view = Ti.UI.createView(viewArgs);
var labelArgs = {
    color: args.textColor || 'black',
    text: args.text || 'Foobar' 
};
var label = Ti.UI.createLabel(labelArgs);
view.add(label);
</code></pre>

<p> // Return a UI object that can be added to a view
 return view;
};</p>

<p>//app/views/index.xml
<Alloy></p>

<pre><code>&lt;Window backgroundColor="white"&gt;
    &lt;!-- Requires in the lib/foo.js module and calls the createFoo method --&gt;
    &lt;Foo module="foo" color="blue" textColor="orange" text="Hello, World!"/&gt;
&lt;/Window&gt;
</code></pre>

<p></Alloy>
```</p>

<p>对于Native开发的Module，也可以引入XML中，分为5步：</p>

<ol>
<li>将module引入项目</li>
<li>在XML中的View或Window的下级加入Module</li>
<li>设置属性module为module名称</li>
<li>设置属性method为创建方法名称，如果没设置则默认为createView</li>
<li>如果方法参数只需要一个简单的Javascript对象，则可以将值inline写入或者使用TSS文件。</li>
</ol>


<p>Paint Module的示例如下：</p>

<p>```
<Alloy></p>

<pre><code>&lt;Window&gt;
    &lt;Module id="paint" module="ti.paint" method="createPaintView"
        eraseMode="false" strokeWidth="1.0" strokeColor="red" strokeAlpha="100" /&gt;
    &lt;Button onClick="eraseMe" bottom="0"&gt;Erase&lt;/Button&gt;
&lt;/Window&gt;
</code></pre>

<p></Alloy></p>

<p>function eraseMe(){</p>

<pre><code>$.paint.clear();
</code></pre>

<p>}
```</p>

<p><strong>Require Element</strong>
require元素主要有两个用途：including external views and importing widgets into the current view.</p>

<p>including external views示例：</p>

<p>```
//index.xml
<Alloy></p>

<pre><code>&lt;TabGroup&gt;
    &lt;Tab id="leftTab"&gt;
        &lt;Require type="view" src="rss" id="rssTab"/&gt;
    &lt;/Tab&gt;
&lt;/TabGroup&gt;
</code></pre>

<p></Alloy></p>

<p>//rss.xml
<Alloy></p>

<pre><code>&lt;Window id='rssWindow'&gt;
    &lt;WebView id='rssView' /&gt;
&lt;/Window&gt;
</code></pre>

<p></Alloy></p>

<p>var rssView = $.rssTab.getView(&lsquo;rssView&rsquo;);
rssView.url = &lsquo;<a href="http://www.google.com">http://www.google.com</a>&rsquo;;
```</p>

<p><strong>Importing Widgets，</strong>引入Widgets只需要三步：</p>

<ol>
<li>将Widget放入app/widgets文件夹</li>
<li>在config.json中添加依赖</li>
<li>在XML中加入<code>&lt;Widget&gt;</code>，可以设置id和name属性。id属性用于引用并调用方法，name属性用于指定view对应的Controller，而不是使用默认的widget.js。</li>
</ol>


<p>```
app/views/index.xml
<Alloy></p>

<pre><code>&lt;Window&gt;
    &lt;Widget src="mywidget" id="foo" name="foo" /&gt;
&lt;/Window&gt;
</code></pre>

<p></Alloy></p>

<p>$.foo.myMethod();
```</p>

<p>config.json中的依赖：</p>

<p>```
 &ldquo;dependencies&rdquo;: {</p>

<pre><code>"mywidget":"1.0"
</code></pre>

<p>  }
```</p>

<p>可以直接在XML中设置属性，用于传参。与代码具有等同效果：</p>

<p>```
<Require id="foobar" src="foo" customTitle="Hello" customImage="hello.png"/></p>

<p>var foobar = Alloy.createController(&lsquo;foo&rsquo;, {</p>

<pre><code>id: "foobar", 
customTitle: "Hello", 
customImage: "hello.png" 
</code></pre>

<p>});
```</p>

<p>对于required view，可以<strong>绑定事件</strong>。下面的例子中，parent视图引入了button视图，并绑定了回调方法：</p>

<p>```
//Parent View:
<Require id="fooButton" src="button" onClick="doClick" /></p>

<p>function doClick(e) {&hellip;}</p>

<p>//Button View:
<Alloy></p>

<pre><code>&lt;Button id="button"&gt;Click Me!&lt;/Button&gt;
</code></pre>

<p></Alloy></p>

<p>//在子视图中trigger click事件
$.button.addEventListener(&lsquo;click&rsquo;, function(e) {</p>

<pre><code>$.trigger('click', e); 
</code></pre>

<p>});
```</p>

<p><strong>Adding Children Views。</strong>用于将parent view中的数据传给required view。下面的例子实现了这样一个场景：index.xml require info.xml，index.xml可以将子元素传给info.xml展示，info.js可以通过<code>arguments[0].children</code>访问这些子元素。</p>

<p>```
//app/views/info.xml
<Alloy></p>

<pre><code>&lt;View backgroundColor="yellow" borderWidth="0.5" borderColor="brown"/&gt;
</code></pre>

<p></Alloy></p>

<p>//controllers/info.js
var args = arguments[0] || {};
// add children if there are any
_.each(args.children || [], function(child) {</p>

<pre><code>$.info.add(child);
</code></pre>

<p>});
$.info.height = Ti.UI.SIZE;</p>

<p>//app/views/index.xml
<Alloy></p>

<pre><code>&lt;Window class="container"&gt;
    &lt;Require src="info"&gt;
        &lt;Label&gt;I am an info box.&lt;/Label&gt;
    &lt;/Require&gt;
&lt;/Window&gt;
</code></pre>

<p></Alloy>
```</p>

<p><strong>Namespace</strong></p>

<p>XML中的控件默认为Titanium.UI，如果组件不是这个命名空间，可以设置ns属性：</p>

<p><code>&lt;View ns="Ti.Map" id="map"/&gt;</code></p>

<h4>1.2.2 Alloy Styles and Themes</h4>

<h5>Titanium Style Sheets (TSS)</h5>

<p>Titanium Style Sheets (TSS) file uses a JSON-like syntax. the class name prefixed with a period (.), or the id name prefixed with a hash tag (#) 。也可以使用条件表达式。值可以是以下类型：</p>

<ul>
<li>JSON values, that is, Strings, Numbers, Objects, Array, Booleans and null</li>
<li>undefined to unset a property (do not place undefined in quotes) (since Alloy 1.4.0)</li>
<li>Titanium SDK constants, for example, Ti.UI.SIZE</li>
<li>Localization functions, either Ti.Locale.getString() and its shorthand L()</li>
<li>Variables from the Alloy.CFG or Alloy.Globals namespaces</li>
<li>Bitwise operators, which includes bit shifting (&lsquo;>>&rsquo;, &lsquo;&lt;&lt;&rsquo;, and &lsquo;>>>&rsquo;), bitwise AND (&lsquo;&amp;&rsquo;), bitwise OR (&lsquo;|&rsquo;) and bitwise XOR (&lsquo;^&rsquo;) (since Alloy 1.3.0)</li>
</ul>


<p>注释方法： //comment and multiline comments <code>/* comment */</code></p>

<p>Alloy不支持：Alloy does not support the CSS concept of child or descendent selectors</p>

<p>```
// 如果不使用.和#，这表示适用于所有Lable
&ldquo;Label&rdquo;: {</p>

<pre><code>width: Ti.UI.SIZE,
height: Ti.UI.SIZE,
color: "#000", // black
transform: Alloy.Globals.rotateLeft // value is defined in the alloy.js file      
</code></pre>

<p>},
```</p>

<p>注意上面的transform使用了全局方法：<code>Alloy.Globals.rotateLeft = Ti.UI.create2DMatrix().rotate(-90);</code></p>

<p>app.tss中定义的是全局样式。样式的优先权：XML中输入的 <code>&gt;</code> 当前View对应的TSS <code>&gt;</code> 全局样式。</p>

<p>样式可以加平台条件，用中括号，注意中括号和平台代码间<strong>不要用空格！</strong>:</p>

<p>```
// iPad and iPad mini
&ldquo;Label[platform=ios formFactor=tablet]&rdquo;: {</p>

<pre><code>backgroundColor: "#0f0",
text: 'iPad'
</code></pre>

<p>},</p>

<p>还可以：
[platform=ios,android] //android, blackberry, ios, or mobileweb
[platform=!ios]</p>

<p>```</p>

<p><strong>Custom Query Styles</strong>
Custom query styles override all styles, that is, class, id, and markup element styles, except the ones defined as attributes in the XML file.</p>

<ol>
<li>使用Alloy.Globals定义一个返回boolean的方法，或者通过Alloy.createController中传入boolean属性，然后在xml或tss文件中使用。</li>
<li>在xml和tss中使用if属性。</li>
</ol>


<p>```
apps/controllers/index.js
function openBar (e) {</p>

<pre><code>Alloy.createController('win2', {'fooBar': true}).getView().open();
</code></pre>

<p>};</p>

<p>app/styles/win2.tss
&ldquo;#label[if=$.args.fooBar]&rdquo; : {
 &lsquo;text&rsquo; : &lsquo;Foobar&rsquo;,
 &lsquo;color&rsquo; : &lsquo;blue&rsquo;
}</p>

<p>app/views/win2.xml
<Alloy></p>

<pre><code>&lt;Window&gt;
    &lt;Label if="$.args.fooBar" color="blue"&gt;Foobar&lt;/Label&gt;
&lt;/Window&gt;
</code></pre>

<p></Alloy>
```</p>

<p>另一个例子：</p>

<p>```
Alloy.Globals.isIos7Plus = (OS_IOS &amp;&amp; parseInt(Ti.Platform.version.split(&ldquo;.&rdquo;)[0]) >= 7);</p>

<p>//index.tss
// Query styles
&ldquo;#info[if=Alloy.Globals.isIos7Plus]&rdquo; : {</p>

<pre><code>font : { textStyle : Ti.UI.TEXT_STYLE_FOOTNOTE }
</code></pre>

<p>},
```</p>

<h5>Themes</h5>

<p>使用Theme的方法。首先在app下建立themes文件夹，并在其下级以各主题名建立子文件夹，如:app-themes-mytheme, 在mytheme下分别建立assets(放图片资源)和styles(放tss文件，还可以再包含平台子文件夹)。在config.json设置当前主题：</p>

<p>```
{
 &ldquo;global&rdquo;: {
 &ldquo;theme&rdquo;:&ldquo;mytheme&rdquo;</p>

<pre><code>}, 
</code></pre>

<p> &ldquo;env:development&rdquo;: {},
 &ldquo;env:test&rdquo;: {},
 &ldquo;env:production&rdquo;: {},
 &ldquo;os:ios&rdquo;: {
 &ldquo;theme&rdquo;:&ldquo;green&rdquo;</p>

<pre><code>}, 
</code></pre>

<p> &ldquo;os:android&rdquo;: {
 &ldquo;theme&rdquo;:&ldquo;blue&rdquo;</p>

<pre><code>}, 
</code></pre>

<p> &ldquo;dependencies&rdquo;: {}
}
```</p>

<p>打包时，主题下的assets资源和样式将覆盖app下的资源与样式。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android应用打破65K方法数限制]]></title>
    <link href="http://blog.ubone.com/blog/2014/11/12/androidying-multidex/"/>
    <updated>2014-11-12T16:52:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/11/12/androidying-multidex</id>
    <content type="html"><![CDATA[<p>普通Android应用的方法总数不能超过65536，这是开发者长期以来非常头疼的一个问题。最近Google发布了新的Multidex支持库，为方法总数超过65K的Android应用提供官方支持。</p>

<p>本文已经发表在<a href="http://www.infoq.com/cn/news/2014/11/android-multidex">InfoQ</a>。</p>

<!--more-->


<p>近日，<a href="https://plus.google.com/108967384991768947849">Android Developers</a>在Google+上宣布了<a href="http://developer.android.com/tools/support-library/features.html#multidex">新的Multidex支持库</a>，为方法总数超过65K的Android应用提供官方支持。</p>

<p>如果你是一名幸运的Android应用开发者，正在开发一个前景广阔的应用，不断地加入新功能、添加新的类库，那么终有一天，你会不幸遇到这个错误：</p>

<p><code>
Conversion to Dalvik format failed:
Unable to execute dex: method ID not in [0, 0xffff]: 65536
</code></p>

<p>这个错误是Android应用的方法总数限制造成的。Android平台的Java虚拟机Dalvik在执行DEX格式的Java应用程序时，使用原生类型short来索引DEX文件中的方法。这意味着单个DEX文件可被引用的方法总数被限制为65536。通常APK包含一个classes.dex文件，因此Android应用的方法总数不能超过这个数量，这包括Android框架、类库和你自己开发的代码。</p>

<p>这个问题可以通过将一个DEX文件分拆成多个DEX文件解决。Facebook介绍了为Android应用开发的<a href="https://www.facebook.com/notes/facebook-engineering/under-the-hood-dalvik-patch-for-facebook-for-android/10151345597798920">Dalvik补丁</a>；Android Developers博客介绍了通过<a href="http://android-developers.blogspot.com/2011/07/custom-class-loading-in-dalvik.html">自定义类加载过程</a>的方法来解决此问题。但这些方法有些复杂而且并不优雅。</p>

<p>随着<a href="http://developer.android.com/tools/support-library/features.html#multidex">新的MultiDex支持库发布</a>，Google正式为解决此问题提供官方支持。<a href="http://developer.android.com/tools/building/multidex.html">构建超过65K方法数的应用</a>介绍了如何使用Gradle构建多DEX应用。</p>

<p>首先使用Android SDK Manager升级到最新的Android SDK Build Tools和Android Support Library R21。然后进行以下两步操作：</p>

<p>1.修改Gradle配置文件，启用MultiDex并包含MultiDex支持：</p>

<p>```
android {</p>

<pre><code>compileSdkVersion 21
buildToolsVersion "21.1.0"

defaultConfig {
    ...
    minSdkVersion 14
    targetSdkVersion 21
    ...

    // Enabling multidex support.
    multiDexEnabled true
}
...
</code></pre>

<p>}</p>

<p>dependencies {
  compile &lsquo;com.android.support:multidex:1.0.0&rsquo;
}
```</p>

<p>2.让应用支持多DEX文件。在<a href="http://developer.android.com/reference/android/support/multidex/MultiDexApplication.html">MultiDexApplication JavaDoc</a>中描述了三种可选方法：</p>

<ul>
<li>在AndroidManifest.xml的application中声明android.support.multidex.MultiDexApplication；</li>
<li>如果你已经有自己的Application类，让其继承MultiDexApplication；</li>
<li>如果你的Application类已经继承自其它类，你不想/能修改它，那么可以重写attachBaseContext()方法：</li>
</ul>


<p>```
@Override
protected void attachBaseContext(Context base) {</p>

<pre><code>super.attachBaseContext(base);
MultiDex.install(this);
</code></pre>

<p>}
```</p>

<p>经过以上步骤，你的应用已经可以实现多个DEX文件了。当应用构建时，构建工具会分析哪些类必须放在第一个DEX文件，哪些类可以放在附加的DEX文件中。当它创建了第一个DEX文件（classes.dex）后，如果必要会继续创建附加的DEX文件，如classes2.dex, classes3.dex。Multidex的支持类库将被包含在应用的第一个DEX文件中，帮助实现对其它DEX文件的访问。</p>

<p>文中还介绍了在开发多DEX应用时，通过设置productFlavors提高开发效率以及多DEX应用的测试方法。</p>

<p>Android 5.0和更高版本使用名为ART的运行时，它原生支持从APK文件加载多个DEX文件。在应用安装时，它会执行预编译，扫描classes(..N).dex文件然后将其编译成单个.oat文件用于执行。<a href="https://source.android.com/devices/tech/dalvik/art.html">了解更多关于ART的信息</a>。</p>

<p>虽然Google解决了应用总方法数限制的问题，但并不意味着开发者可以任意扩大项目规模。Multidex仍有一些限制：</p>

<ol>
<li>DEX文件安装到设备的过程非常复杂，如果第二个DEX文件太大，可能导致应用无响应。此时应该使用<a href="http://developer.android.com/tools/help/proguard.html">ProGuard</a>减小DEX文件的大小。</li>
<li>由于Dalvik linearAlloc的<a href="http://b.android.com/22586">Bug</a>，应用可能无法在Android 4.0之前的版本启动，如果你的应用要支持这些版本就要多执行测试。</li>
<li>同样因为Dalvik linearAlloc的限制，如果请求大量内存可能导致崩溃。Dalvik linearAlloc是一个固定大小的缓冲区。在应用的安装过程中，系统会运行一个名为dexopt的程序为该应用在当前机型中运行做准备。dexopt使用LinearAlloc来存储应用的方法信息。Android 2.2和2.3的缓冲区只有5MB，Android 4.x提高到了8MB或16MB。当方法数量过多导致超出缓冲区大小时，会造成dexopt崩溃。</li>
<li>Multidex构建工具还不支持指定哪些类必须包含在首个DEX文件中，因此可能会导致某些类库（例如某个类库需要从原生代码访问Java代码）无法使用。</li>
</ol>


<p>避免应用过大、方法过多仍然是Android开发者要注意的问题。Mihai Parparita的开源项目<a href="https://github.com/mihaip/dex-method-counts">dex-method-counts</a>可以用于统计APK中每个包的方法数量。</p>

<p>通常开发者自己的代码很难达到这样的方法数量限制，但随着第三方类库的加入，方法数就会迅速膨胀。因此选择合适的类库对Android开发者来说尤为重要。</p>

<p>开发者应该避免使用Google Guava这样的类库，它包含了13000多个方法。尽量使用专为移动应用设计的Lite/Android版本类库，或者使用小类库替换大类库，例如用<a href="https://code.google.com/p/google-gson/">Google-gson</a>替换Jackson JSON。而对于Google Protocol Buffers这样的数据交换格式，其标准实现会自动生成大量的方法。采用<a href="https://github.com/square/wire">Square Wire</a>的实现则可以很好地解决此问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Titanium vs Worklight]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/27/titanium-vs-worklight/"/>
    <updated>2014-07-27T13:52:25+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/27/titanium-vs-worklight</id>
    <content type="html"><![CDATA[<p>因工作需要，对两个跨平台移动开发工具（Titanium，Worklight）进行比较的。本文主要从跨平台特性、性能、社区等进行比较。实际上，本文同样适用于Titanium VS Phonegap。</p>

<!--more-->


<h2>Workligt简介</h2>

<p>Worklight是IBM公司的产品，支持HTML5，Hybrid、Native开发方式，涵盖完整的移动应用生命周期，包括开发、运行、安全和管理。</p>

<p>Worklight以Cordova为核心。因此它与Phonegap是非常类似的产品，基于HTML5、CSS3和JavaScript，通过Adapter集成后台REST、SOA等服务。在其PPT中说提供了以下移动开发模式：</p>

<p><img src="/myresource/images/image_blog_2014-07-27_15.16.22.jpg" alt="image" /></p>

<p><strong>但找遍其资料也未找到Worklight如何使用第4种开发模式。</strong></p>

<p>几乎支持所有移动设备：iOS, Android, BlackBerry, Windows Phone。基于Dojo的可视化UI构造。充分利用现有Javascript框架，如jQuery, dojo, Sencha等。</p>

<p>通过Worklight Server提供对企业数据和系统的安全访问：
<img src="/myresource/images/image_blog_2014-07-27_15.10.37.jpg" alt="image" /></p>

<h3>Worklight的工作方式</h3>

<p>开发人员采用HTML、CSS和JavaScript在本地开发，就像开发静态Web网站一样。每种移动应用平台都提供了一个嵌入式的Web浏览器，Worklight应用就运行在这样一个浏览器中，因此，Worklight实质上是拥有原生外壳的Html Web应用。</p>

<p>Worklight基于Cordova提供设备的接口，相当于在JavaScript与移动设备的传感器、摄像头间建立了一连接层，使得JavaScript可以访问这些原生接口。</p>

<h3>Worklight的优势</h3>

<p>由于其本质是Web应用，因此只要原生平台有Web view，就可以移植到该平台。因此Worklight几乎支持所有移动平台。</p>

<p>采用Html、CSS和JavaScript的技术门槛比较低，同时也有现成的框架可用，如jQuery, dojo, Sencha等。</p>

<h3>Worklight的劣势</h3>

<p>Worklight应用的UI性能取决于系统的浏览器性能。iOS平台的基于Webkit引擎的浏览器性能更好，而Android平台则有一些限制。对于其它平台，可能跟OS版本有关系。</p>

<p>同时，与Web开发相似，存在一些跨平台的问题要处理。即使是基于Webkit的环境，<a href="http://westcoastlogic.com/slides/debug-mobile/#/17">也存在一些明显的区别</a>。在IBM Worklight介绍的PPT中，一个应用示例在移植到Android时仍然使用了4周的时间，见下图：</p>

<p><img src="/myresource/images/image_blog_2014-07-27_18.46.36.jpg" alt="image" /></p>

<p>现代浏览器已经越来越强大，但即使如此，要在浏览器中达到原生的UI性能，几乎是不可能的。</p>

<p>Cordova提供的原生API非常有限，主要集中在摄像头、加速传感器、定位传感器等，因此平台集成是很有限的。当然有一些插件来填补这一空白，但是它们的质量和可维护性并不稳定。</p>

<p>移动端不支持Sqlite数据库，保存本地数据比较困难。</p>

<h2>Titanium简介</h2>

<p>Titanium是Appcelerator推出的跨平台移动应用开发工具，支持Android、Blackberry、iOS和Tizen。</p>

<p>Titanium同样采用JavaScript作为主要开发语言，支持Web应用、混合型应用和原生应用开发。</p>

<p>Titanium也同样提供了相应的云服务，包括推送、同步、企业安全认证和数据安全等。</p>

<p>当开发者开发Titanium应用时，可以用JavaScript编写原生应用，而不只是Web应用。但是，为了充分使用原生API的性能，Titanium并不是“一次编写、到处运行”的平台。Titanium可以让开发者充分利用那些平台特定的特性，它对移动开发的支持包括两部分：</p>

<ul>
<li>移动开发核心部分API，是支持跨平台的，因此这部分代码可以复用。</li>
<li>平台特定的API、UI和特性，存在于特定平台中。</li>
</ul>


<p>例如，你可以在Titanium的iOS应用中，使用某个iOS平台特有的组件，而在Android平台，采用其它方案。</p>

<h3>Titanium的工作方式</h3>

<p>Titanium开发的应用在运行时，包括三大组件：</p>

<ul>
<li>JavaScript代码</li>
<li>Titanium的系统原生API</li>
<li>JavaScript解析器（Android: V8或Rhino；iOS：JavaScriptCore）</li>
</ul>


<p>当我们用JavaScript创建一个窗口时，会发生什么呢，见下图：</p>

<p><img src="/myresource/images/images_download_attachments_35621751_create_proxy.jpg" alt="image" /></p>

<p>可以看到，JavaScript代码会调用原生API，创建的是原生的Window，而不是浏览器中的Web对象！因此所有UI与Java或Objective-c开发的原生应用没有区别，它们就是Native UI。</p>

<p>这就是为什么说Titanium是用JavaScript开发原生应用。它不需要浏览器来执行JavaScript代码，JavaScript代码也不会被编译成Java或者Objective-C。JavaScript是在运行时执行，并且在需要时调用原生的UI组件和方法。</p>

<p>开发者可以以原生的方式，自由地扩展Titanium，包括UI和其它不可见的特性。</p>

<h3>Titanium的优势</h3>

<p>Titanium提供了广泛的原生特性和功能，包括原生UI组件、网络接口、数据库和系统通知等等。因此Titnaium应用的UI是真正的原生组件，具有与原生应用相同的性能。</p>

<p>Titanium具有广泛的原生应用API。提供了90%以上常用的原生平台API，而剩余不常用的10%可以由用户自己实现。</p>

<p>Titanium应用具有更好的外观，它不需要CSS等来模拟原生界面，因为它自己就是原生界面。例如当你创建了NavigationGroup，在iOS上会创建UINavigationController，它的行为和动画效果都是原生的，更符合用户的预期。</p>

<p>具有非常好的扩展性。开发者能够针对指定平台，实现任何原生的UI，并集成到Titanium应用中。例如，你可以实现一个TableView，滚动时以每秒60帧显示。也可以无缝集成一个OpenGL绘图的游戏，并在JavaScript中执行循环。你可以将这些扩展的UI直接集成到应用中。</p>

<p>原生支持Sqlite数据库。</p>

<p>Titanium基于Apache 2.0开源协议，具有广泛的社区支持。</p>

<h3>Titanium的劣势</h3>

<p>Titanium的API范围，使得它在增加一种新的原生平台时，比较困难。这也是为什么现在Titanium只支持iOS、Android、BlackBerry、Tizen和Web的原因。<a href="http://www.appcelerator.com/blog/2014/01/windows-8-support-whats-going-on/">Titanium对Windows Phone的支持预计在2014年第4季度实现。</a></p>

<h2>谁比谁更好？</h2>

<p>从1万米高空看，两者没有太大区别，它们都提供了跨平台的移动应用开发能力。而两者间其实不存在谁比谁更好的问题，只看谁比谁更合适！</p>

<p>对于企业移动应用来说，谁更合适？我们先看看企业移动应用有哪些特点：</p>

<ul>
<li>界面以稳健风格为主</li>
<li>应用稳定可靠</li>
<li>安全性要求高</li>
<li>数据量一般比较大</li>
<li>性能要求高</li>
</ul>


<p>对于前面三点，两者没有太多区别，而关于后面两点，Titanium的性能更占优势，而SQLite数据库的支持也有利于部分企业数据（如通讯录）的本地缓存，提升用户体验。下表总结了两者的一些对比：</p>

<p><img src="/myresource/images/image_blog_2014-07-27_18.41.36.jpg" alt="image" /></p>

<h3>参考：</h3>

<p><a href="http://www.appcelerator.com/blog/2012/05/comparing-titanium-and-phonegap/">Comparing titanium and phonegap</a></p>
]]></content>
  </entry>
  
</feed>
