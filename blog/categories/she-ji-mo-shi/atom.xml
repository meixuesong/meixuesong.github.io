<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 设计模式 | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/she-ji-mo-shi/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2014-08-10T23:57:24+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式:责任链模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-ze-ren-lian-mo-shi/"/>
    <updated>2014-08-10T23:24:28+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-ze-ren-lian-mo-shi</id>
    <content type="html"><![CDATA[<p>多个对象和下家的引用连接起来形成一条链。请求在这个链上传递，直到链上的某个对象处理此请求。类图如下：</p>

<p><img src="/myresource/images/image_blog_20140810_235454.jpg" alt="image" /></p>

<!--more-->


<p>一个纯的责任链模式要求具体的处理者对象只能在两个行为中选择一个：一是处理请求；二是把责任传给下家。不允许出现一个对象即处理请求，又把责任往下传。纯的责任链很难找到，一般看到的例子都是不纯的。</p>

<p>Java 1.0版的AWT事件处理机制就是责任链模式。事件触发后，可以一直浮升，直到有容器处理事件。容器可以选择继续传下去或者处理事件。</p>

<p>针对DHTML的事件处理，Netscape与IE是不一样的。Netscape是从Window->Document往下，最后到达事件产生的对象。而IE则相反，事件产生的对象是链的第一个。</p>

<p>责任链模式并不负责创建责任链，责任链的创建必须由系统的其它部分完成。一个链可以是一条线、树甚至环。责任链模式并不指定链的拓扑结构，但要求在同一时间里，命令只可以被传给一个下家（或者处理请求），不可以同时传给多个下家。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:迭代子模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-die-dai-zi-mo-shi/"/>
    <updated>2014-08-10T12:18:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-die-dai-zi-mo-shi</id>
    <content type="html"><![CDATA[<p>迭代子模式是最常见的几个设计模式之一，Java Collection广泛使用迭代子来遍历其元素。之所以需要迭代子模式，是因为它将迭代逻辑与聚集对象分离，两者可以自由演变。其结构示意图如下：</p>

<p><img src="/myresource/images/image_blog_20140810_163841.jpg" alt="image" /></p>

<!--more-->


<ol>
<li>Iterator：定义遍历元素所需的接口。</li>
<li>ConcreteIterator：实现Iterator接口，维护迭代过程中的游标位置。</li>
<li>Aggregate：给出创建迭代子对象的接口。</li>
<li>ConcreteAggregate：实现创建迭代子对象的接口，返回一个合适的具体迭代子实例。</li>
<li>Client：拥有对聚集和迭代子对象的引用，调用迭代子对象的迭代接口。</li>
</ol>


<h3>宽接口与窄接口</h3>

<p>宽接口是指聚集提供了可以用来修改聚集元素的方法；否则就是窄接口。宽接口的典型示例是公开了类的一个List，因此破坏了聚集对象的封装。</p>

<p>聚集对象可以提供两个接口，对迭代子公开宽接口，而对外提供窄接口。因此，可以将迭代子类设计成聚集类的内部成员类。</p>

<h3>Java Iterator和ListIterator</h3>

<p>Java Collection接口方法iterator()返回Iterator，而Java的List接口的listIterator()返回ListIterator类型。</p>

<p><img src="/myresource/images/image_blog_20140810_163856.jpg" alt="image" /></p>

<p>ListIterator提供了安全的修改方法add, remove和set。它们能够在迭代的过程中安全地修改List的内容。</p>

<ul>
<li>add()方法，在List当前位置插入一个对象。所谓当前位置就是：add方法增加对象后，调用previous()方法将返回这个对象。</li>
<li>remove()方法，将当前元素删除。所谓当前元素就是：如果刚调用了next()或previous()方法，当前元素就是它们返回的元素。<strong>注：每调用一次remove()，都需要先调用一次next()或者previous()，如果刚调用了add()，也必须先调用一次next()或者previous()。</strong></li>
<li>set()方法，更新当前元素。当前元素的定义与remove()方法相同。每次set()之前，也必须调用next()或previous()。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:观察者模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-guan-cha-zhe-mo-shi/"/>
    <updated>2014-08-10T11:36:40+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-guan-cha-zhe-mo-shi</id>
    <content type="html"><![CDATA[<p>观察者模式也称为发布-订阅模式，它定义了一种一对多的依赖关系，让多个观察者同时监听一个主题对象。当主题对象的状态发生变化时，会通知观察者对象，使它们能够自动更新自己。它的类图如下所示：</p>

<p><img src="/myresource/images/image_blog_20140810_115301.jpg" alt="image" /></p>

<p>在实际应用中，如果有多个ConcreteSubject，也可以将Subject变成抽象类，将observers和notifyObservers方法上移到抽象Subject。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:模板方法模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-mo-ban-fang-fa-mo-shi/"/>
    <updated>2014-08-10T09:52:25+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-mo-ban-fang-fa-mo-shi</id>
    <content type="html"><![CDATA[<p>模板方法（Template Method）模式是最常见的模式，几乎每个人都用过。它将部分逻辑以具体方法以及具体构造子的形式实现。抽象类定义顶级逻辑，具体类实现具体方法。类图如下：</p>

<p><img src="/myresource/images/image_blog_20140810_095857.jpg" alt="image" /></p>

<ol>
<li>抽象模板角色：定义一个或多个抽象操作，以便让子类实现。定义并实现一个模板方法，给出顶级逻辑的骨架。</li>
<li>具体模板角色：实现父类的抽象方法。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:策略模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/09/she-ji-mo-shi-ce-lue-mo-shi/"/>
    <updated>2014-08-09T22:55:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/09/she-ji-mo-shi-ce-lue-mo-shi</id>
    <content type="html"><![CDATA[<p>策略模式把行为和环境分割开。环境类负责维持和查询行为类，各种算法则在具体策略类中提供。由于算法和环境独立开来，算法的增减、修改都不会影响环境和客户端。准备一组算法，并将每一个算法封装起来，使得它们可以互换。策略模式的类图如下：</p>

<p><img src="/myresource/images/image_blog_20140809_230502.jpg" alt="image" /></p>

<!--more-->


<p>各角色如下：</p>

<ol>
<li>环境角色：持有一个Strategy类的引用。</li>
<li>抽象策略角色：抽象角色，通常是接口或者抽象类，给出接口。</li>
<li>具体策略角色：包装相关的算法或行为。通常具体策略角色会有多个。</li>
</ol>


<p>从策略模式中是看不出具体策略适用于哪一种情况的，应当由客户端自己决定在什么情况下使用什么具体策略角色。策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中退出。</p>

<p>策略模式适合于在多个算法中选择一种的情形，不适用于需要多个算法或者嵌套多于一个算法的情形。</p>

<p>什么情况下使用策略模式？</p>

<ol>
<li>如果系统有很多类，它们之间的区别仅在于它们的行为，策略模式可动态地让一个对象在许多行为中选择一种行为。</li>
<li>系统需要动态地在几种算法中选择一种。</li>
</ol>


<p>策略模式的缺点：客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</p>
]]></content>
  </entry>
  
</feed>
