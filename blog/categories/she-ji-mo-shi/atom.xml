<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 设计模式 | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/she-ji-mo-shi/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2014-08-03T12:44:58+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式:代理模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-dai-li-mo-shi/"/>
    <updated>2014-08-03T11:56:48+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-dai-li-mo-shi</id>
    <content type="html"><![CDATA[<p>代理模式是对象的结构模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。代理模式的结构如下图：</p>

<p><img src="/myresource/images/image_blog_20140803_120304.jpg" alt="image" /></p>

<!--more-->


<p>各角色说明如下：</p>

<ul>
<li>抽象主题角色：是真实主题和代理主题的共同接口，任何可以使用真实主题的地方都可以使用代理主题。</li>
<li>代理主题角色：内部含有对真实主题的引用，可以在任何时候操作真实主题对象。</li>
<li>真实主题角色：真实的对象。</li>
</ul>


<p><strong>常见的代理种类：</strong></p>

<ul>
<li>远程(Remote)代理：位于不同地址空间的代理对象。</li>
<li>虚拟(Virtual)代理：当创建真实对象需要消耗较大资源时，通过虚拟代理实现只有真正需要时才创建资源。例如加载图像。</li>
<li>Copy-on-Write代理：虚拟代理的一种，把复制拖延到只有客户端需要时才执行。</li>
<li>保护(Protect or Access)代理：控制对一个对象的访问，可以为不同的客户端提供不同级别的权限。</li>
<li>Cache代理：为真实对象操作的结果提供临时的存储空间，以便多个客户端可共享该结果。</li>
<li>防火墙(Firewall)代理：保护目标，不让恶意用户接近。</li>
<li>同步化(Synchronization)代理：使多个用户能够同时使用一个对象而没有冲突。</li>
<li>智能(Smart Reference)引用：当一个对象被引用时，提供一些额外的操作，例如记录调用次数。</li>
</ul>


<p>反射与代理常常一起使用，<a href="/blog/2014/06/28/li-yong-fan-zhang-hao/">这篇博文</a>就是代理模式的一个例子。</p>

<p>代理模式与适配器模式的区别是，后者的用意是改变接口，而前者不能改变接口。代理模式与装饰模式都保持接口不变，但它们区别是，后者应当提供增加的功能/性能，而前者是对原对象施加控制，并不提供增强功能。</p>

<h3>虚拟代理的例子</h3>

<p>为了更好的用户体验，在应用中显示网络图片时，先显示“加载中”或者占位符，等待图片下载完成后再替换成图片。这就是虚拟代理的真实例子。对于客户端仍然是创建图片并显示，但实际创建的是图片代理，图片代理先显示“加载中”，然后启动另一线程去下载图片，当下载完成后，才真正显示图片。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:装饰模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/01/she-ji-mo-shi-zhuang-shi-mo-shi/"/>
    <updated>2014-08-01T20:00:16+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/01/she-ji-mo-shi-zhuang-shi-mo-shi</id>
    <content type="html"><![CDATA[<p>装饰模式以对客户端透明的方式扩展对象的功能。客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。其类图所下：</p>

<p><img src="/myresource/images/image_blog_2014-08-01_20.13.33.jpg" alt="image" /></p>

<!--more-->


<p>图中4个角色说明如下：</p>

<ol>
<li>Component角色，一个抽象接口，被装饰对象和装饰对象都遵循的接口。在实际中可以是接口、抽象或具体类。</li>
<li>Concrete Component角色，被装饰的具体对象。</li>
<li>Decorator角色，持有Component对象的实例，可以是抽象类。</li>
<li>ConcreteDecorator角色，负责给构件对象贴上附加的责任。</li>
</ol>


<h3>什么情况下使用装饰模式？</h3>

<ol>
<li>需要扩展一个类的功能，或给一个类增加附加责任。</li>
<li>需要动态给一个对象增加功能，这些功能可以再动态地撤销。</li>
<li>需要增加由一些基本功能的排列组合而产生的非常大量的功能，而继承关系就变得不现实。</li>
</ol>


<h3>装饰模式的优缺点</h3>

<p>装饰模式的优点包括：</p>

<ol>
<li>可以动态地贴上一个需要的装饰，或者除掉一个不需要的装饰。</li>
<li>通过使用不同的具体装饰类，以及这些装饰类的排列组合，可以创造出很多不同行为的组合。</li>
</ol>


<p>装饰模式的缺点是比继承要使用更多的对象，更多的对象会使得查错变得困难。</p>

<h3>装饰模式的简化</h3>

<p>不论如何简化，必须保证：</p>

<ol>
<li>ConcreteDecorator类必须继承自一个共同的父类Component。</li>
<li>尽量保持Component作为一个“轻”类。</li>
</ol>


<p>常见的简化包括：</p>

<ol>
<li>没有Component，只有ConcreteComponent，此时，Decorator可以是ConcreteComponent的子类，ConcreteComponent扮演双重角色。</li>
<li>没有Decorator，只有ConcreteDecorator，但如果有两个以上的。</li>
</ol>


<h3>其它</h3>

<p>纯粹的装饰模式对客户端的要求是不要声明ConcreteDecorator类型的变量，而应当声明Component类型的变量。这也就是针对抽象编程。因此，ConcreteDecorator不能有Component接口之外的方法。但现实中的装饰模式允许改变接口，增加新方法，即客户端可以声明ConcreteDecorator类型的变量。这就有点像是适配器模式。</p>

<p>装饰模式与适配器模式其实是不一样的。适配器模式的目的是改变接口，常常改写或者增加新的方法来适配接口。而装饰模式是保持接口不变，增强或增加功能。它们的类图是不一样的。</p>

<p>以Java的IO库为例，Reader类型的对象读入字符(Character)流，而InputStreamReader是一种Reader类型，把InputStream类型对象包装起来，从而把byte的API转换成字符流的API。这就是适配器模式的例子。即InputStreamReader把InputStream的API适配成Reader的API。</p>

<p>而BufferredReader则是一个装饰类，因为它实现Reader，并且包装一个Reader，接口未变，但提供更优的性能。但它不是一个100％的装饰类，因为它提供了一个readLine()的新方法。</p>

<p>以InputStream相关类为例，如下所示：</p>

<p><img src="/myresource/images/image_blog_20140803_002859.jpg" alt="image" /></p>

<p>图中，红色类为适配器模式，将其它类型（如Byte数组）接口转换成InputStream接口。而绿色及其子类为适配器模式，各角色：</p>

<ol>
<li>Component角色：InputStream</li>
<li>Concrete Component角色：红色的类</li>
<li>Decorator角色：绿色的类</li>
<li>ConcreteDecorator角色：最下面的四个类。</li>
</ol>


<p>附各类的主要用途：</p>

<ol>
<li>ByteArrayInputStream: 为多线程的通信提供缓冲区操作功能，接收Byte数组作为流的源。</li>
<li>FileInputStream：接收一个File对象作为流的源。</li>
<li>PipedInputStream：与PipedOutputStream配合使用，用于读入一个数据管道的数据，接收PipedOutputStream作为源。</li>
<li>StringBufferInputStream：接收一个String对象作为流的源。</li>
<li>FilterInputStream：过滤输入流，将另一个输入流作为流的源。</li>
<li>BufferInputStream：内部提供内存缓冲区，从此缓冲区提供数据。</li>
<li>DataInputStream：提供多字节的读取方法，读取原始数据类型的数据。</li>
<li>LineNumberInputStream: 提供带有行计数功能和按行号读取数据的过滤输入流。不常用，主要用于编译器。</li>
<li>PushbackInputStream：提供特殊功能，将已经读取的字节“推回”到输入流中。不常用，主要用于编译器。</li>
<li>ObjectInputStream：读取使用ObjectOutputStream序列化的流，将其反序列化。</li>
<li>SequenceInputStream：将两个已有的输入流连接起来，形成一个输入流。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:组合（Composite）模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/31/she-ji-mo-shi-zu-he-mo-shi/"/>
    <updated>2014-07-31T21:08:30+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/31/she-ji-mo-shi-zu-he-mo-shi</id>
    <content type="html"><![CDATA[<p>组合模式将对象以树状结构组织起来，达成“部分－整体”的层次结构，使得客户端对单个对象和组合对象的使用具有一致性。结构示意图：</p>

<p><img src="/myresource/images/image_blog_2014-07-31_21.14.15.jpg" alt="image" /></p>

<!--more-->


<p>此模式涉及三个角色：</p>

<ol>
<li>Component角色：定义共有的接口及其默认行为。</li>
<li>Leaf角色：叶节点，不能有下级子对象。</li>
<li>Composite角色：树枝节点，可以有下级子对象的节点。</li>
</ol>


<p>组合模式根据实现方式的不同，分为安全方式和透明方式。区别主要在于接口的定义。Composite角色拥有add、remove、getChild等方法，这些方法对于Leaf角色完全没有用处。因此Component角色是否定义这些方法，就形成了两种实现方式。</p>

<h3>透明方式</h3>

<p>这种方式在Component中定义所有的方法，不管这些方法对于Leaf角色是否有用。这样做的好处是所有角色都有相同的接口，客户端可以统一的方式对待所有对象。缺点是不够安全，因为Leaf角色的add方法没有意义，可能在运行期出错。透明方式的组合模式结构图如下：</p>

<p><img src="/myresource/images/image_blog_2014-07-31_21.29.20.jpg" alt="image" /></p>

<p>可以看出，这种方式的Leaf和Composite没有什么区别，都实现了Component的所有接口方法。但Leaf角色的add, remove等方法都是平庸实现。</p>

<h3>安全方式</h3>

<p>这种方式的Component只定义公共的接口，不包括Composite角色的add, remove等方法。结构如下图：</p>

<p><img src="/myresource/images/image_blog_2014-07-31_22.11.35.jpg" alt="image" /></p>

<p>不论采用哪种方式，其中composite属性都是指向父节点的引用。这样就可以很容易地遍历所有的父对象。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:缺省适配模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/31/she-ji-mo-shi-que-sheng-gua-pei-mo-shi/"/>
    <updated>2014-07-31T20:31:57+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/31/she-ji-mo-shi-que-sheng-gua-pei-mo-shi</id>
    <content type="html"><![CDATA[<p>缺省适配模式其实很简单，就是一个接口有很多方法，通过一个抽象类为这些方法提供默认实现，而具体的类继承这个抽象类，实现自己关心的方法即可。其结构如下：</p>

<p><img src="/myresource/images/image_blog_2014-07-31_20.37.12.jpg" alt="image" /></p>

<p>什么情况下用缺省适配模式？如果不准备实现一个接口的所有方法时，可以通过一个抽象类，给出所有方法的实现。有用的方法要有实现，没用的方法也要有空的、平庸的实现。这样子类就不必实现所有方法了。对应适配器模式的三个角色：</p>

<ul>
<li>Adapter：子类</li>
<li>Adaptee：抽象类</li>
<li>Target：接口</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:适配器模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/30/she-ji-mo-shi-gua-pei-qi-mo-shi/"/>
    <updated>2014-07-30T22:31:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/30/she-ji-mo-shi-gua-pei-qi-mo-shi</id>
    <content type="html"><![CDATA[<p>适配器模式分为类的适配器和对象的适配器。它们都是把被适配类的API转换成目标类的API。但前者使用继承关系，而后者使用委派关系。它们的结构如下图：</p>

<p><img src="/myresource/images/image_blog_2014-07-30_22.38.26.jpg" alt="image" /> <img src="/myresource/images/image_blog_2014-07-30_22.40.21.jpg" alt="image" /></p>

<!--more-->


<p>上图中的三个角色：</p>

<ol>
<li>Target接口，这是目标接口，表示要适配成这个接口。</li>
<li>Adaptee，这是被适配的对象，表示要将它适配成Target。</li>
<li>Adapter，适配器，将Adaptee适配成Target。</li>
</ol>


<p>第一张图对应的是类的适配器，第二张图是对象的适配器。从图上看，区别主要是Adapter到Adaptee的连线不一样，一个是继承，一个是依赖。</p>

<h2>类的适配器</h2>

<p>先看类的适配器，即第一张图。Adapter继承自Adaptee，因此继承了方法operation1，再加上它自己实现的方法operation2，从而实现了Target接口，完成适配。由于是继承关系，因此Adaptee必须是一个类，不能是接口。</p>

<h2>对象的适配器</h2>

<p>对第二张图，Adaptee是被适配的接口，可以是接口或者类。Adapter包含一个对Adaptee的引用。Adapter的operation1方法，只需调用Adaptee.operation1，同时增加operation2，从而实现Target接口，完成适配。</p>

<p>因为没有了继承关系，因此一个适配器可以把多种不同的源适配到同一个目标。</p>

<h2>什么情况下使用适配器模式</h2>

<ol>
<li>系统需要使用现有类，而此类的接口不符合系统需要。</li>
<li>建立一个可重复使用的类，用于与一些彼此没有太大关联的一些类一起工作。</li>
<li>对象的适配器可用于改变多个已有的子类的接口。</li>
</ol>

]]></content>
  </entry>
  
</feed>
