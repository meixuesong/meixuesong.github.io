<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 设计模式 | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/she-ji-mo-shi/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2014-07-29T22:47:53+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式:Builder模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/29/she-ji-mo-shi-buildermo-shi/"/>
    <updated>2014-07-29T22:28:54+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/29/she-ji-mo-shi-buildermo-shi</id>
    <content type="html"><![CDATA[<p>Builder模式感觉没什么特别的，甚至都不值得称为一种模式。无非就是由Director构建部分，然后再使用一个方法完成构建过程。但Builder模式对于参数太多的构造器却非常有用。先看Builder模式的类图：</p>

<p><img src="/myresource/images/image_blog_2014-07-29_22.38.17.png" alt="image" /></p>

<p><a href="/blog/2014/06/27/effective-java-chuang-jian-he-xiao-hui-dui-xiang/">这篇博客</a>建议当构造器参数比较多时，考虑使用Builder模式。这是一种非常优雅的方式。</p>

<p>我觉得Builder模式的好处一是使客户端的代码很清晰，不需要那么多的set方法；二是实现了产品构建的原子性，也就是可以在build时，确保产品构建是有效的，如果某些部分或者参数有问题、冲突，就能够在build时失败，避免残次的半成品出现。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式在序列生成器的应用]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/28/she-ji-mo-shi-zai-xu-lie-sheng-cheng-qi-de-ying-yong/"/>
    <updated>2014-07-28T22:21:23+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/28/she-ji-mo-shi-zai-xu-lie-sheng-cheng-qi-de-ying-yong</id>
    <content type="html"><![CDATA[<p>序列生成器是常见的一个应用组件。Oracle数据库有Sequence，但不是所有数据库都有序列。本文尝试将单例模式、多例模式应用于序列生成器。采用了以下方式实现：</p>

<ol>
<li>没有数据库的单例实现</li>
<li>有数据库的单例实现</li>
<li>有缓存的单例实现</li>
<li>有缓存的多序列实现</li>
<li>多序列的多例实现。</li>
</ol>


<!--more-->


<h2>1. 没有数据库的单例实现</h2>

<p>当没有数据库时，使用单例实现序列生成器非常简单，示例代码如下，注意<code>synchronized</code>关键字：</p>

<p>```java
/<em>*
 * 没有数据库的序列键生成器
 * @author mxs
 *
 </em>/
public class KeyGenerator {</p>

<pre><code>private long key = 0;
private static KeyGenerator instance = new KeyGenerator();

private KeyGenerator() {}

public static KeyGenerator getInstance() {
    return instance;
}

public synchronized long getNextKey() {
    return key++;
}
</code></pre>

<p>}
```</p>

<p>单元测试代码：</p>

<p>```java
public class KeyGeneratorTest extends TestCase {</p>

<pre><code>public void testKey() {
    KeyGenerator keyGenerator = KeyGenerator.getInstance();

    for(int i = 0; i &lt; 100; i++) {
        Assert.assertEquals(i, keyGenerator.getNextKey());
    }
}
</code></pre>

<p>}
```</p>

<p>这种实现没有持久化，一旦重启，序列又从0开始。因此我们需要一个有数据库持久化的方案。</p>

<h2>2. 有数据库的单例实现</h2>

<p>当有数据库时，每次获取序列都从数据库读取。</p>

<p>```java
/<em>*
 * 有数据库的序列键生成器
 * @author mxs
 *
 </em>/
public class KeyGenerator {</p>

<pre><code>private static KeyGenerator instance = new KeyGenerator();

private KeyGenerator() {}

public static KeyGenerator getInstance() {
    return instance;
}

public synchronized long getNextKey() {
    return getNextKeyFromDB();
}

private long getNextKeyFromDB() {
    //update t_sequence set seq_value = seq_value + 1
    //select seq_value from t_sequence
    //返回结果
    return 1000;
}
</code></pre>

<p>}</p>

<p>```</p>

<h2>3. 有缓存的单例实现</h2>

<p>第2种方法每次都要访问数据库，影响了性能，可以一次多取一些序列放到缓存中，只有缓存都取完时，才访问数据库。</p>

<p>```java
/<em>*
 * 有数据库、带缓存的序列键生成器
 * @author mxs
 *
 </em>/
public class KeyGenerator {</p>

<pre><code>private static KeyGenerator instance = new KeyGenerator();
private static final int cacheSize = 20;
private KeyInfo keyInfo;

private KeyGenerator() {
    keyInfo = new KeyInfo(cacheSize);
}

public static KeyGenerator getInstance() {
    return instance;
}

public synchronized long getNextKey() {
    return keyInfo.getNext();
}
</code></pre>

<p>}</p>

<p>public class KeyInfo {</p>

<pre><code>private long max;
private long min;
private long nextKey;
private int poolSize;

public KeyInfo(int poolSize) {
    this.poolSize = poolSize;
    retrieveFromDB();
}

public long getNext() {
    if (nextKey &gt;= max) {
        retrieveFromDB();
    }

    return nextKey++;
}

private void retrieveFromDB() {
    // update t_sequence set seq_value = seq_value + poolSize
    // select seq_value from t_sequence
    //以下为模拟数据库操作
    long value = dbvalue[dbIndex ++];
    min = value - poolSize;
    max = value;
    nextKey = min;
}

private int[] dbvalue = {20, 40, 60, 80, 100};
private int dbIndex = 0;
</code></pre>

<p>}</p>

<p>```</p>

<h2>4. 有缓存的多序列实现</h2>

<p>要实现多序列，只需要用HashMap改造第3种方法，保持KeyInfo不变，KeyGenerator修改为：</p>

<p>```java
/<em>*
 * 有数据库、带缓存的多序列键生成器
 * @author mxs
 *
 </em>/
public class KeyGenerator {</p>

<pre><code>private static KeyGenerator instance = new KeyGenerator();
private static final int cacheSize = 20;

private Map&lt;String, KeyInfo&gt; map;

private KeyGenerator() {
    map = new HashMap&lt;String, KeyInfo&gt;();
}

public static KeyGenerator getInstance() {
    return instance;
}

public synchronized long getNextKey(String key) {
    KeyInfo keyInfo;
    if (map.containsKey(key)) {
        keyInfo = map.get(key);
    } else {
        keyInfo = new KeyInfo(cacheSize);
        map.put(key, keyInfo);
    }

    return keyInfo.getNext();
}
</code></pre>

<p>}
```</p>

<h2>5. 多序列的多例实现</h2>

<p>前面所有实现方案都是基于单例模式，其实还可以使用多例模式。多例模式允许一个类有多个实例，这些实例有自己的状态。保持KeyInfo不变，KeyGenerator修改为：</p>

<p>```java
/<em>*
 * 有数据库、带缓存的多序列键生成器，采用多例模式
 * @author mxs
 *
 </em>/
public class KeyGenerator {</p>

<pre><code>private static final int cacheSize = 20;
private KeyInfo keyInfo;
private static Map&lt;String, KeyGenerator&gt; instances = new HashMap&lt;String, KeyGenerator&gt;(10);

private KeyGenerator() {
    keyInfo = new KeyInfo(cacheSize);
}

public static synchronized KeyGenerator getInstance(String key) {
    if (! instances.containsKey(key)) {
        KeyGenerator generator = new KeyGenerator();
        instances.put(key, generator);
    }

    return instances.get(key);
}

public synchronized long getNextKey() {
    return keyInfo.getNext();
}
</code></pre>

<p>}</p>

<p>//测试代码：
public class KeyGeneratorTest extends TestCase {</p>

<pre><code>public void testKey() {
    for(int j = 0; j &lt; 10; j ++) {
        String key = "" + j;
        KeyGenerator keyGenerator = KeyGenerator.getInstance(key);
        for(int i = 0; i &lt; 90; i++) {
            long ii = keyGenerator.getNextKey();
            Assert.assertEquals(i, ii);
        }
    }       
}
</code></pre>

<p>}</p>

<p>```</p>

<p>参考：
Java与模式</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:抽象工厂方法模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/28/she-ji-mo-shi-chou-xiang-gong-han-fang-fa-mo-shi/"/>
    <updated>2014-07-28T19:45:29+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/28/she-ji-mo-shi-chou-xiang-gong-han-fang-fa-mo-shi</id>
    <content type="html"><![CDATA[<p>简单工厂方法模式采用静态方法创建产品，工厂方式模式通过多层级的工厂方法创建一种产品等级结构。而抽象工厂方法模式则可以用于创建多个产品等级结构。因此，其类图示意如下：</p>

<p><img src="/myresource/images/image_blog_2014-07-28_20.03.46.png" alt="image" /></p>

<!--more-->


<p>从上图可见，有两个产品等级：ProductA和ProductB。抽象工厂模式与工厂方法模式的最大区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则需要面对多个产品等级结构。那么对于多个等级结构的产品，为什么要采用抽象工厂模式呢？</p>

<p>如果采用工厂模式，就要N个独立的工厂等级结构来应对N个产品等级结构。由于这些产品等级结构的相似性，会导致N个平等的工厂等级结构。随着产品等级结构数目的增加，工厂方式模式所给出的工厂等级结构数目也会随之增加。</p>

<p>所以，抽象工厂方法模式的好处是，同一个工厂等级结构应对N个这些相似的产品等级结构。例如上图中的ConcreteCreator1负责创建ProductA1和ProductB1。显然，这种方式更有效率。</p>

<p>什么情况下应当使用抽象工厂模式？</p>

<ol>
<li>满足工厂模式的条件，即：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节时。</li>
<li>多于一个的产品族，而系统只消费其中某一族的产品。如上图中有2个族（1，2），同时只消费其中一个族。</li>
<li>同属于一个产品族的产品是一起使用的。</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。</li>
</ol>


<p>举一个实际例子就很容易理解为什么需要，以及什么时候需要抽象工厂模式：</p>

<p><img src="/myresource/images/image_blog_2014-07-28_21.41.37.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:工厂方法模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/27/she-ji-mo-shi-gong-han-fang-fa/"/>
    <updated>2014-07-27T22:11:04+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/27/she-ji-mo-shi-gong-han-fang-fa</id>
    <content type="html"><![CDATA[<p>前文说到简单工厂方法的工厂类，对“开－闭”原则支持不够，当有新产品时，需要修改工厂类。而工厂方法模式可以解决这个问题。工厂方法模式的用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。其结构可表示为：</p>

<p><img src="/myresource/images/image_blog_2014-07-27_22.10.30.png" alt="image" /></p>

<!--more-->


<p>上图中，Factory和SomeProduct可以是接口或者抽象类，工厂方法factory的返回类型必须是SomeProduct，这也是针对接口编程的一个体现。</p>

<p>在实际项目中，产品类可能有多个层级，对应工厂类也有多个层级。当使Factory为抽象类时，可以将公共代码尽量往上层抽象。</p>

<p>工厂方法返回的对象不一定是新建的，有可能是之前新建的对象，缓存在那里。但一定是自己创建的，不可以是别的对象传入的对象。</p>

<p>ConcreteFactory1示例代码：</p>

<p>```java
public class ConcreteFactory1 implements Factory {</p>

<pre><code>public SomeProduct factory() {
    return new SomeConcreteProduct1();
}  
</code></pre>

<p>}
```</p>

<p>Client代码示例：</p>

<p>```java
public class Client {</p>

<pre><code>private static Factory concreteFactory1,concreteFactory2;
private static SomeProduct concreteProduct1, concreteProduct2;

public static void main(String[] args) {
    concreteFactory1 = new ConcreteFactory1();
    concreteProduct1 = concreteFactory1.factory();
    concreteFactory2 = new ConcreteFactory2();
    concreteProduct2 = concreteFactory2.factory();
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:简单工厂模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/27/she-ji-mo-shi-jian-dan-gong-han-mo-shi/"/>
    <updated>2014-07-27T09:44:35+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/27/she-ji-mo-shi-jian-dan-gong-han-mo-shi</id>
    <content type="html"><![CDATA[<p>简单工厂模式其实就是静态工厂方法模式，即通过静态工厂方法来创建对象。其结构可表示为：</p>

<p><img src="/myresource/images/image_blog_2014-07-27_1.png" alt="image" /></p>

<!--more-->


<p>来看个实际的例子，下图中，有多种水果。客户端不关心具体的水果是如何创建的，只需要告诉工厂方法，需要哪种水果类型，工厂方法负责具体水果的创建工作。</p>

<p><img src="/myresource/images/image_blog_2014-07-27_2.png" alt="image" /></p>

<p>工厂方法返回的是水果接口。水果接口也可以换成抽象类。这是针对抽象编程的一种体现。</p>

<p>```java
public class FruitFactory {</p>

<pre><code>public static Fruit getFruit(String type) {
    if (type.equalsIgnoreCase("apple")) {
        return new Apple();
    } else if (type.equalsIgnoreCase("orange")) {
        return new Orange();
    } else {
        throw new FruitFactoryException();
    }
}
</code></pre>

<p>}
```</p>

<h3>省略抽象产品角色</h3>

<p>如果具体产品只有一个（即只有一种水果）时，可以省略掉抽象产品角色，变成：</p>

<p><img src="/myresource/images/image_blog_2014-07-27_3.png" alt="image" /></p>

<h3>合并工厂角色与抽象产品角色</h3>

<p>有些情况下，工厂角色可以由抽象产品角色扮演，例如java.text.DateFormat类，如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-07-27_4.png" alt="image" /></p>

<h3>三个角色全部合并</h3>

<p><img src="/myresource/images/image_blog_2014-07-27_5.png" alt="image" /></p>

<p>```java
public class ConcreteProduct {</p>

<pre><code>public ConcreteProduct() {}

public static ConcreteProduct factory() {
    return new ConcreteProduct();
}
</code></pre>

<p>}
```</p>

<h3>多个工厂方法</h3>

<p>工厂类可以有一个或多个工厂方法，分别负责创建不同的产品对象。例如java.text.DateFormat类：</p>

<p>```java</p>

<pre><code>public final static DateFormat getDateInstance();
public final static DateFormat getDateInstance(int style);
public final static DateFormat getDateInstance(int style, Local locale);
</code></pre>

<p>```</p>

<h3>总结</h3>

<p>简单工厂模式是非常基本的设计模式，会在较为复杂的设计模式中出现。它的核心是工厂类，客户端完全不关心构建的细节，只需消费产品。因此，简单工厂模式实现了对责任的分割。</p>

<p>但其缺点是当产品结构变得复杂时，工厂类将变得非常复杂。由于静态方法无法继承，因此工厂角色无法形成基于继承的等级结构。</p>

<p>在这种模式中，消费者(Client)和产品（Product）都满足“开－闭原则”，都能在引进新产品时，无需对现有代码进行修改。而工厂（Factory）则必须知道每一种产品以及如何创建它们，因此必须修改这个工厂的代码，不满足“开－闭”原则。</p>
]]></content>
  </entry>
  
</feed>
