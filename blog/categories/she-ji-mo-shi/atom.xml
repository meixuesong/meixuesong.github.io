<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 设计模式 | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/she-ji-mo-shi/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2014-08-18T23:06:42+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式:状态模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/18/she-ji-mo-shi-zhuang-tai-mo-shi/"/>
    <updated>2014-08-18T20:22:06+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/18/she-ji-mo-shi-zhuang-tai-mo-shi</id>
    <content type="html"><![CDATA[<p>状态模式把对象的行为包装在不同的状态对象里，所有状态对象都属于抽象状态类的子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。类图示意如下：</p>

<p><img src="/myresource/images/image_blog_20140818_224041.jpg" alt="image" /></p>

<!--more-->


<ol>
<li>State角色：定义接口，用于封装Context对象的一个特定的状态所对应的行为。</li>
<li>ConcreteState角色：每个具体状态类实现Context的一个状态所对应的行为。</li>
<li>Context角色：定义客户端所感兴趣的接口，并且保留一个具体状态类的实例，即当前的状态。上图中Context.someOperation的行为是委派给具体State类来执行的。当Context.state变化时，动态地将具体类指向另一个具体状态类，从而改变改变其行为。</li>
</ol>


<h3>什么情况下使用状态模式</h3>

<ol>
<li>对象的行为依赖于它所处的状态，对象的行为必须随着其状态的改变而改变。</li>
<li>对象在某个方法里依赖于一重或多重的条件转移语句，其中有大量的代码。状态模式可以把条件转移语句的每一个分支包装到一个状态类中。</li>
</ol>


<p>TcpConnection就是一个状态模式的经典例子，TCP连接的三个状态（Established, Listening, Closed）分别对应三个状态类（TcpEstablished, TcpListen, TcpClosed）。</p>

<p>在绘图软件中，状态模式广泛用于建立编辑器框架。使客户端能够轻易地挂接新工具。</p>

<h3>模式实现</h3>

<p>状态的变化由谁来定义？状态模式并没有对此进行规定。可以由外部事件、Context控制或者具体State自行决定。</p>

<p>状态对象的创建和销毁，可以按需创建或者预先创建。</p>

<h3>与其它模式的关系</h3>

<p>状态模式与策略模式很相似，类图也很相似。但是策略模式的特点是，一旦环境类选择了一个具体策略，那么在其生命周期内就不会改变这个具体策略类。而状态模式在环境类的生命周期中会有多个不同的状态对象被使用。</p>

<p>——《Java与模式》读书笔记</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:备忘录模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/13/she-ji-mo-shi-bei-wang-lu-mo-shi/"/>
    <updated>2014-08-13T23:00:58+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/13/she-ji-mo-shi-bei-wang-lu-mo-shi</id>
    <content type="html"><![CDATA[<p>备忘录(Memento)模式又叫做快照模式。备忘录对象是一个用来存储另外一个对象内部状态快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态存储在外部，从而在合适的时候把这个对象还原到原来的状态。通常系统不止存储一个状态，而是存储多个状态（快照）。每一个快照所处的位置就是Check Point。其结构如下图：</p>

<p><img src="/myresource/images/image_blog_20140813_231854.jpg" alt="image" /></p>

<!--more-->


<ol>
<li>备忘录(Memento)角色：一是将发起人(Originator)对象的内部状态存储起来；二是保护其内容不被发起人以外的任何对象所读取，即图中宽接口和窄接口的作用。</li>
<li>发起人(Originator)角色：创建备忘录对象，并使用该对象存储其内部状态。</li>
<li>负责人(Caretaker)角色：负责保存备忘录对象，不管备忘录对象的内容。</li>
</ol>


<h3>白箱实现</h3>

<p>在Java中实现宽、窄两个接口并不容易，白箱实现就是只提供宽接口。类图示意如下：</p>

<p><img src="/myresource/images/image_blog_20140813_235928.jpg" alt="image" /></p>

<p>上面的发起人只有一个状态“state”，发起人创建备忘录对象，并传入state，而负责人可以保存和获得备忘录对象。上图中备忘录对负责人也是宽接口，因此负责人可以访问到state值。<strong>所以，白箱实现的缺点是破坏了对发起人状态的封闭。</strong>下面的Client的示意代码：</p>

<p>```java
Originator o = new Originator();
Caretaker c = new Caretaker();</p>

<p>o.setState(&ldquo;On&rdquo;);
Memento m = o.createMemento();
c.saveMemento(m);</p>

<p>o.setState(&ldquo;Off&rdquo;);
o.restoreMemento(c.retrieveMemento());
//此时o.state = &ldquo;On&rdquo;
```</p>

<h3>双重接口实现（黑盒实现）</h3>

<p>如何用Java实现宽、窄两个接口呢？也就是对发起人是宽接口，对其它任何对象都是窄接口。可以将备忘录对象作为发起人的内部类，因此发起人可以访问备忘录的所有属性和方法。而窄接口，是备忘录对象实现一个标识接口(MementoIF，没有任何方法的接口)，同时备忘录对象的方法为私有方法，所有其它对象都通过标识接口获得备忘录对象的引用，却无法访问备忘录对象的状态和方法。这就是双重接口的实现。如下图所示：</p>

<p><img src="/myresource/images/image_blog_20140814_220438.jpg" alt="image" /></p>

<p>客户端的代码与白盒实现完全相同，但是Caretaker再也无法访问备忘录对象的状态了。</p>

<p>上面的两种实现，都由客户端持有发起人和负责人的引用。实际上也可以由负责人完成备忘录对象的创建和必要时恢复发起人状态。</p>

<h3>多重检查点</h3>

<p>前面的例子都只存储一个状态，在实际业务中，常需要存储多个状态，也就是多个检查点。实现方式可以在备忘录对象中建立<code>List&lt;String&gt; states</code>存储多个检查点。</p>

<h3>“自述历史”模式</h3>

<p>自述历史模式其实是指发起人角色兼任负责人角色时的备忘录模式。类图如下：</p>

<p><img src="/myresource/images/image_blog_20140815_221228.jpg" alt="image" /></p>

<p>Memento类是发起人的内部类。</p>

<h3>“假如”协议模式</h3>

<p>备忘录的操作过程是，先创建备忘录对象保存发起人状态，然后修改发起人状态，如果需要的话，可以撤消这一步。也就是通过备忘录对象恢复发起人的状态。简单地说，就是先保存状态，然后执行修改，如果需要则恢复原状态。</p>

<p>而“假如”协议则是将发起人对象做一个拷贝，然后再拷贝上执行备忘录操作，如果成功并且状态有效，则在原对象上执行这个操作。如果失败或者状态无效，则扔掉拷贝并触发异常处理。</p>

<p>“假如”协议的优点是安全，相当于先试验没总是后才在原始对象上执行。缺点是同一个操作要执行两遍。因此“假如”协议适合于成功率较低的场景。</p>

<h3>备忘录模式的优点</h3>

<ol>
<li>有时一些发起人对象的内部信息必须保存在发起人对象以外的地方，但是必须要由发起人对象自己读取，这时，使用备忘录模式可以把复杂的发起人内部信息对其他的对象屏蔽起来，从而可以恰当地保持封装的边界。</li>
<li>本模式简化了发起人。发起人不再需要管理和保存其内部状态的一个个版本，客户端可以自行管理他们所需要的这些状态的版本。</li>
<li>当发起人角色的状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原。</li>
</ol>


<h3>备忘录模式的缺点：</h3>

<ol>
<li>如果发起人角色的状态需要完整地存储到备忘录对象中，那么在资源消耗上面备忘录对象会很昂贵。</li>
<li>当负责人角色将一个备忘录存储起来的时候，负责人可能并不知道这个状态会占用多大的存储空间，从而无法提醒用户一个操作是否很昂贵。</li>
<li>当发起人角色的状态改变的时候，有可能这个协议无效。如果状态改变的成功率不高的话，不如采取“假如”协议模式。</li>
</ol>


<p>——《Java与模式》读书笔记。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:命令模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/11/she-ji-mo-shi-ming-ling-mo-shi/"/>
    <updated>2014-08-11T22:58:11+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/11/she-ji-mo-shi-ming-ling-mo-shi</id>
    <content type="html"><![CDATA[<p>命令模式将发出命令和执行命令的责任分割开，委派给不同的对象。类图如下：</p>

<p><img src="/myresource/images/image_blog_20140811_233515.jpg" alt="image" /></p>

<!--more-->


<ol>
<li>Client角色：创建具体命令对象，并确定接收者。</li>
<li>Command角色：声明抽象接口，通常是接口或抽象类。</li>
<li>ConcreteCommand角色：定义一个接收者和行为之间的弱耦合；负责调用接收者的相应操作。</li>
<li>Invoker角色：负责调用命令对象执行请求。</li>
<li>Reciever角色：负责具体实施和执行一个请求。任何一个类都可以成为接收者。</li>
</ol>


<p>Client的示例代码：</p>

<p>```java
public static void main(String[] args) {</p>

<pre><code>Receiver receiver = new Receiver();
Command command = new ConcreteCommand(receiver);
Invoker invoker = new Invoker(command);
invoker.action();
</code></pre>

<p>}
```</p>

<p>上面的代码中，invoker.action调用command.execute，execute方法调用receiver.action，receiver.action是真正实施命令的方法。</p>

<p>模式实现时，可以考虑命令是“重”还是“轻”。如果轻，则命令只是提供请求者与接收者之间的耦合。如果是重，则命令执行也可放在命令中，接收者可以省略。更常见的是中间情况，由命令类动态决定调用哪一个接收者类。如果要支持undo, redo，则命令类要存储状态信息。</p>

<p>可以把命令对象集合在一起，实现宏命令。命令模式的缺点是命令可能会非常多。命令模式可用于：</p>

<ol>
<li>需要在不同的时间指定请求，将请求排队。命令对象可以在序列化之后发送到另一台机器上。</li>
<li>支持undo, redo操作。</li>
<li>从日志中读回所有命令，重新执行execute方法，恢复系统数据。</li>
<li>需要支持交易的系统，一个交易结构封装了一组数据更新命令。命令模式可以使系统增加新的交易类型。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:责任链模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-ze-ren-lian-mo-shi/"/>
    <updated>2014-08-10T23:24:28+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-ze-ren-lian-mo-shi</id>
    <content type="html"><![CDATA[<p>多个对象和下家的引用连接起来形成一条链。请求在这个链上传递，直到链上的某个对象处理此请求。类图如下：</p>

<p><img src="/myresource/images/image_blog_20140810_235454.jpg" alt="image" /></p>

<!--more-->


<p>一个纯的责任链模式要求具体的处理者对象只能在两个行为中选择一个：一是处理请求；二是把责任传给下家。不允许出现一个对象即处理请求，又把责任往下传。纯的责任链很难找到，一般看到的例子都是不纯的。</p>

<p>Java 1.0版的AWT事件处理机制就是责任链模式。事件触发后，可以一直浮升，直到有容器处理事件。容器可以选择继续传下去或者处理事件。</p>

<p>针对DHTML的事件处理，Netscape与IE是不一样的。Netscape是从Window->Document往下，最后到达事件产生的对象。而IE则相反，事件产生的对象是链的第一个。</p>

<p>责任链模式并不负责创建责任链，责任链的创建必须由系统的其它部分完成。一个链可以是一条线、树甚至环。责任链模式并不指定链的拓扑结构，但要求在同一时间里，命令只可以被传给一个下家（或者处理请求），不可以同时传给多个下家。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:迭代子模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-die-dai-zi-mo-shi/"/>
    <updated>2014-08-10T12:18:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-die-dai-zi-mo-shi</id>
    <content type="html"><![CDATA[<p>迭代子模式是最常见的几个设计模式之一，Java Collection广泛使用迭代子来遍历其元素。之所以需要迭代子模式，是因为它将迭代逻辑与聚集对象分离，两者可以自由演变。其结构示意图如下：</p>

<p><img src="/myresource/images/image_blog_20140810_163841.jpg" alt="image" /></p>

<!--more-->


<ol>
<li>Iterator：定义遍历元素所需的接口。</li>
<li>ConcreteIterator：实现Iterator接口，维护迭代过程中的游标位置。</li>
<li>Aggregate：给出创建迭代子对象的接口。</li>
<li>ConcreteAggregate：实现创建迭代子对象的接口，返回一个合适的具体迭代子实例。</li>
<li>Client：拥有对聚集和迭代子对象的引用，调用迭代子对象的迭代接口。</li>
</ol>


<h3>宽接口与窄接口</h3>

<p>宽接口是指聚集提供了可以用来修改聚集元素的方法；否则就是窄接口。宽接口的典型示例是公开了类的一个List，因此破坏了聚集对象的封装。</p>

<p>聚集对象可以提供两个接口，对迭代子公开宽接口，而对外提供窄接口。因此，可以将迭代子类设计成聚集类的内部成员类。</p>

<h3>Java Iterator和ListIterator</h3>

<p>Java Collection接口方法iterator()返回Iterator，而Java的List接口的listIterator()返回ListIterator类型。</p>

<p><img src="/myresource/images/image_blog_20140810_163856.jpg" alt="image" /></p>

<p>ListIterator提供了安全的修改方法add, remove和set。它们能够在迭代的过程中安全地修改List的内容。</p>

<ul>
<li>add()方法，在List当前位置插入一个对象。所谓当前位置就是：add方法增加对象后，调用previous()方法将返回这个对象。</li>
<li>remove()方法，将当前元素删除。所谓当前元素就是：如果刚调用了next()或previous()方法，当前元素就是它们返回的元素。<strong>注：每调用一次remove()，都需要先调用一次next()或者previous()，如果刚调用了add()，也必须先调用一次next()或者previous()。</strong></li>
<li>set()方法，更新当前元素。当前元素的定义与remove()方法相同。每次set()之前，也必须调用next()或previous()。</li>
</ul>

]]></content>
  </entry>
  
</feed>
