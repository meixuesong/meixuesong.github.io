<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 设计模式 | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/she-ji-mo-shi/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2014-08-09T21:30:31+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式:不变模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/09/she-ji-mo-shi-bu-bian-mo-shi/"/>
    <updated>2014-08-09T18:08:28+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/09/she-ji-mo-shi-bu-bian-mo-shi</id>
    <content type="html"><![CDATA[<p>从这个模式开始学习行为模式。行为模式是对在不同的对象之间划分责任和算法的抽象化。行为模式不仅仅是关于类和对象的，而且是关于它们之间的相互作用的。行为模式分为类的行为模式（使用继承在几个类之间分配行为）和对象的行为模式（使用对象的聚合来分配行为）。</p>

<p>不变（Immutable）模式是指一个对象创建之后，它的状态将不再变化。不变模式不需要类图描述，它分为弱不变模式和强不变模式。</p>

<p>不变与只读的区别：只读表示值不能直接修改，但可能随其它变量改变而发生改变。例如出生日期是不变的，但年龄是只读的，因为它会随着时间而改变。</p>

<!--more-->


<h3>弱不变模式</h3>

<p>类的实例状态是不可变化的，但其子类的实例可能会变化，这就是弱不变模式。要实现弱不变模式，必须满足以下条件：</p>

<ol>
<li>类没有任何方法会修改对象的状态；</li>
<li>所有属性都应当是私有的；</li>
<li>如果引用了其它可变对象，必须设法限制外界对可变对象的访问。应当尽量避免在客户端初始化可变对象，否则应该复制一份，而不要直接使用客户端传入的引用。</li>
</ol>


<h3>强不变模式</h3>

<p>类的实例状态是不可变化的，同时它的子类也是不可变化的状态，这就是强不变模式。一个类在满足弱不变模式的前提下，需要满足以下条件之一才是强不变模式：</p>

<ol>
<li>类的所有方法都应当是final，因此子类不能置换掉此类的方法。</li>
<li>这个类本身就是final的，因此不可能会有子类。</li>
</ol>


<h3>不变模式的优缺点</h3>

<p>一个不变的对象比可变的对象更加容易维护。不变对象天生就是线程安全的，可以省掉同步化的开销。不变模式唯一的缺点是如果需要频繁地修改不变对象，会创建出大量的对象，这是一种资源的浪费。</p>

<p>在设计任何一个类时，除非有变化的必要，不然就应该将它设计成不变类。</p>

<p>与享元模式的区别：不变模式可以用于实现享元模式，但享元对象并不一定非得是不变对象，只要它的内部状态与环境无关就不会影响享元对象的共享。</p>

<p>几个问题：</p>

<ol>
<li>构造方法需不需要同步化？（不需要，对象创建只可能发生在一个纯种中）</li>
<li>子类是否可以置换掉父类的同步方法，它是同步还是不同步？（可以置换，但父类的同步特性没有改变，如果明显地调用父类的同步方法，那么这个方法将是同步调用的）</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:桥梁模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-qiao-liang-mo-shi/"/>
    <updated>2014-08-03T22:09:23+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-qiao-liang-mo-shi</id>
    <content type="html"><![CDATA[<p>桥梁模式的用意是“将抽象化与实现化解耦，使二者可以独立变化。”这里的解耦就是将它们之间的强关联改变成弱关联。所谓强关联就是继承关系，在编译期就已经确定。而弱关联就是动态确定并且可以在运行期动态改变的关联。因此对于Java，继承是强关联，而聚合关系是弱关联。因此桥梁模式中的解耦，就是指将抽象化与实现化之间的继承关系换成组合/聚合关系，使两者可以独立变化。桥梁模式的结构图如下：</p>

<p><img src="/myresource/images/image_blog_20140803_233716.jpg" alt="image" /></p>

<!--more-->


<ol>
<li>抽象化角色（Abstraction）：抽象化给出的定义，并保存一个对实现化对象的引用。</li>
<li>修正抽象化角色（Refined Abstraction）：扩展抽象化角色，改变和修正父类的定义。</li>
<li>实现化角色（Implementor）：给出实现化角色的接口，但不给出具体实现。这个接口不一定与抽象化角色接口相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。</li>
<li>具体实现化角色（Concrete Implementor）：给出实现化角色接口的具体实现。当具体实现化类只有一个ConcreteImplementor的情况下，实现化角色就可以省略了。</li>
</ol>


<p>抽象化等级结构中的方法通过向对应的实现化对象的委派实现自己的功能。一般来说，实现化角色中的每一个方法都应当有一个抽象化角色中的某一个方法与之对应，但反过来则不一定。即抽象化角色的接口比实现化角色的接口宽，抽象化角色还可能提供其它的商业方法。而实现化角色则仅仅为实现抽象化角色的相关行为而存在。</p>

<p>桥梁模式是为了分享抽象化与实现，使两者的接口可以不同。而适配器模式是为了改变已有接口，使它们相容。因此这两种模式是不一样的。</p>

<p>什么情况下应当使用桥梁模式？</p>

<ul>
<li>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的联系。</li>
<li>设计要求实现化角色的任何改变不应当影响客户端。</li>
<li>一个构件有多个抽象化角色和实现化角色，系统需要它们之间进行动态耦合。</li>
<li>虽然在系统中使用继承没有问题，但由于抽象化角色和具体角色需要独立变化，设计要求需要独立管理这两者。</li>
</ul>


<p>桥梁模式的一个例子是Java AWT的Peer架构。Java应用在不同的操作系统上有不同的Look and Feel。Java为AWT中的每一个GUI构件都提供了一个Peer构件。Java程序员只需要关心Button对象提供的接口，当运行时，Button对象动态地与一个本地环境的底层Peer对象联系起来，这个Peer对象会按照指令执行正确的操作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:门面模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-men-mian-mo-shi/"/>
    <updated>2014-08-03T21:59:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-men-mian-mo-shi</id>
    <content type="html"><![CDATA[<p>门面(Facade)模式的作用是屏蔽众多子系统的复杂性，为客户端提供一个统一的门面(Facade)对象，方便客户端调用。门面模式没有统一的结构。一般是一个子系统提供一个门面。要注意的是门面只负责协调子系统去服务客户端的请求，不能在门面类中增加功能和职责。</p>

<p>什么情况下使用门面模式？如果子系统演化得越来越复杂，客户端的调用变得很复杂，产生很大的依赖性，则可以引入门面模式将一个子系统与它的客户端以及其他子系统分离。</p>

<p>这与迪米特法则也是相符的，该法则要求不要与陌生人说话，只与你直接朋友通信。采用门面模式，客户端只要与门面打交道，不需要去协调多个子系统。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:享元模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-xiang-yuan-mo-shi/"/>
    <updated>2014-08-03T19:10:40+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-xiang-yuan-mo-shi</id>
    <content type="html"><![CDATA[<p>享元模式以共享的方式支持大量的细粒度对象。Java的String类型其实就使用了享元模式。享元对象具有内部状态(Internal State)和外部状态(External State)。内部状态是享元对象内部的，一旦创建就不会再改变，因此具有内部状态的享元对象可以进行共享。外部状态是随环境改变而改变的，是不可以共享的状态。享元对象的外部状态必须由客户端保存，通常以方法参数的方式传给享元对象，以改变方法的行为，但不会改变内在状态。享元模式可以分为单纯享元模式和复合享元模式。结构图如下：</p>

<p><img src="/myresource/images/image_blog_20140803_193842.jpg" alt="image" /></p>

<!--more-->


<p>左边为单纯享元模式，右边为复合享元模式。复合享元模式只多了一个ConcreteCompositeFlyweight，它们的角色如下：</p>

<ul>
<li>抽象享元角色(Flyweight)：定义公共接口。</li>
<li>具体享元角色(ConcreteFlyweight)：实现抽象享元角色接口，维护内部状态。内部状态必须与外部环境元关，一旦创建就不能修改。</li>
<li>享元工厂角色(FlyweightFactory)：负责创建和管理享元角色，保证享元对象可以被系统共享。当客户端调用工厂方法时，通常会判断是否有符合要求的享元对象，如果有就返回，如果没有则创建。此角色一般只有一个，可以使用单例模式。</li>
<li>客户端角色(Client)：调用享元工厂创建享元对象，维护享元对象的外部状态。</li>
<li>复合享元角色(ConcreteCompositeFlyweight)：由单纯的享元对象复合而成，因此提供了add这样的方法。由于聚焦元素是在复合享元对象创建之后加入的，因此复合享元对象的状态是可以改变的，所以此角色<strong>不可以共享</strong>。</li>
</ul>


<p><strong>一些例子</strong></p>

<p>一个咖啡摊所售的咖啡只有固定的几种口味，一坏咖啡一旦生产出来它的口味就不会改变，其内部状态就是口味。因此系统不用为每一杯咖啡创建一个对象，可以使用享元模式为每种口味创建一个对象，然后进行共享。</p>

<p>又例如一个文字编辑器，输入的内部是固定的A..Z，但字母所处的位置、字体是变化的。如果用享元模式，内部状态就是字母，外部状态是位置和字体。</p>

<p><strong>什么情况下使用享元模式</strong></p>

<p>当以下条件都满足时，可以考虑使用享元模式：</p>

<ol>
<li>系统有大量的对象。</li>
<li>这些对象耗费大量的内存。</li>
<li>这些对象的大部分状态都可以外部化。</li>
<li>这些对象可以按照内部状态分成很多组，剔除外部状态后，每一组都可以仅用一个对象代替。</li>
<li>系统不依赖于这些对象的身份，即这些对象可以是不可分辨的。</li>
<li>系统需要记录所有已有的享元对象，这需要消耗资源，因此应当在只有足够多的享元实例可供共享时才值得使用享元模式。</li>
</ol>


<p>享元模式的优点是大幅降低内存中对象的数量，但享元模式可能使系统更复杂，需要将一些状态外部化，这可能使逻辑变得复杂。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:代理模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-dai-li-mo-shi/"/>
    <updated>2014-08-03T11:56:48+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-dai-li-mo-shi</id>
    <content type="html"><![CDATA[<p>代理模式是对象的结构模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。代理模式的结构如下图：</p>

<p><img src="/myresource/images/image_blog_20140803_120304.jpg" alt="image" /></p>

<!--more-->


<p>各角色说明如下：</p>

<ul>
<li>抽象主题角色：是真实主题和代理主题的共同接口，任何可以使用真实主题的地方都可以使用代理主题。</li>
<li>代理主题角色：内部含有对真实主题的引用，可以在任何时候操作真实主题对象。</li>
<li>真实主题角色：真实的对象。</li>
</ul>


<p><strong>常见的代理种类：</strong></p>

<ul>
<li>远程(Remote)代理：位于不同地址空间的代理对象。</li>
<li>虚拟(Virtual)代理：当创建真实对象需要消耗较大资源时，通过虚拟代理实现只有真正需要时才创建资源。例如加载图像。</li>
<li>Copy-on-Write代理：虚拟代理的一种，把复制拖延到只有客户端需要时才执行。</li>
<li>保护(Protect or Access)代理：控制对一个对象的访问，可以为不同的客户端提供不同级别的权限。</li>
<li>Cache代理：为真实对象操作的结果提供临时的存储空间，以便多个客户端可共享该结果。</li>
<li>防火墙(Firewall)代理：保护目标，不让恶意用户接近。</li>
<li>同步化(Synchronization)代理：使多个用户能够同时使用一个对象而没有冲突。</li>
<li>智能(Smart Reference)引用：当一个对象被引用时，提供一些额外的操作，例如记录调用次数。</li>
</ul>


<p>反射与代理常常一起使用，<a href="/blog/2014/06/28/li-yong-fan-zhang-hao/">这篇博文</a>就是代理模式的一个例子。</p>

<p>代理模式与适配器模式的区别是，后者的用意是改变接口，而前者不能改变接口。代理模式与装饰模式都保持接口不变，但它们区别是，后者应当提供增加的功能/性能，而前者是对原对象施加控制，并不提供增强功能。</p>

<h3>虚拟代理的例子</h3>

<p>为了更好的用户体验，在应用中显示网络图片时，先显示“加载中”或者占位符，等待图片下载完成后再替换成图片。这就是虚拟代理的真实例子。对于客户端仍然是创建图片并显示，但实际创建的是图片代理，图片代理先显示“加载中”，然后启动另一线程去下载图片，当下载完成后，才真正显示图片。</p>
]]></content>
  </entry>
  
</feed>
