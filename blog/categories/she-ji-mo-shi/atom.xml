<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 设计模式 | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/she-ji-mo-shi/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2014-07-31T22:30:20+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式:组合（Composite）模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/31/she-ji-mo-shi-zu-he-mo-shi/"/>
    <updated>2014-07-31T21:08:30+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/31/she-ji-mo-shi-zu-he-mo-shi</id>
    <content type="html"><![CDATA[<p>组合模式将对象以树状结构组织起来，达成“部分－整体”的层次结构，使得客户端对单个对象和组合对象的使用具有一致性。结构示意图：</p>

<p><img src="/myresource/images/image_blog_2014-07-31_21.14.15.jpg" alt="image" /></p>

<!--more-->


<p>此模式涉及三个角色：</p>

<ol>
<li>Component角色：定义共有的接口及其默认行为。</li>
<li>Leaf角色：叶节点，不能有下级子对象。</li>
<li>Composite角色：树枝节点，可以有下级子对象的节点。</li>
</ol>


<p>组合模式根据实现方式的不同，分为安全方式和透明方式。区别主要在于接口的定义。Composite角色拥有add、remove、getChild等方法，这些方法对于Leaf角色完全没有用处。因此Component角色是否定义这些方法，就形成了两种实现方式。</p>

<h3>透明方式</h3>

<p>这种方式在Component中定义所有的方法，不管这些方法对于Leaf角色是否有用。这样做的好处是所有角色都有相同的接口，客户端可以统一的方式对待所有对象。缺点是不够安全，因为Leaf角色的add方法没有意义，可能在运行期出错。透明方式的组合模式结构图如下：</p>

<p><img src="/myresource/images/image_blog_2014-07-31_21.29.20.jpg" alt="image" /></p>

<p>可以看出，这种方式的Leaf和Composite没有什么区别，都实现了Component的所有接口方法。但Leaf角色的add, remove等方法都是平庸实现。</p>

<h3>安全方式</h3>

<p>这种方式的Component只定义公共的接口，不包括Composite角色的add, remove等方法。结构如下图：</p>

<p><img src="/myresource/images/image_blog_2014-07-31_22.11.35.jpg" alt="image" /></p>

<p>不论采用哪种方式，其中composite属性都是指向父节点的引用。这样就可以很容易地遍历所有的父对象。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:缺省适配模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/31/she-ji-mo-shi-que-sheng-gua-pei-mo-shi/"/>
    <updated>2014-07-31T20:31:57+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/31/she-ji-mo-shi-que-sheng-gua-pei-mo-shi</id>
    <content type="html"><![CDATA[<p>缺省适配模式其实很简单，就是一个接口有很多方法，通过一个抽象类为这些方法提供默认实现，而具体的类继承这个抽象类，实现自己关心的方法即可。其结构如下：</p>

<p><img src="/myresource/images/image_blog_2014-07-31_20.37.12.jpg" alt="image" /></p>

<p>什么情况下用缺省适配模式？如果不准备实现一个接口的所有方法时，可以通过一个抽象类，给出所有方法的实现。有用的方法要有实现，没用的方法也要有空的、平庸的实现。这样子类就不必实现所有方法了。对应适配器模式的三个角色：</p>

<ul>
<li>Adapter：子类</li>
<li>Adaptee：抽象类</li>
<li>Target：接口</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:适配器模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/30/she-ji-mo-shi-gua-pei-qi-mo-shi/"/>
    <updated>2014-07-30T22:31:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/30/she-ji-mo-shi-gua-pei-qi-mo-shi</id>
    <content type="html"><![CDATA[<p>适配器模式分为类的适配器和对象的适配器。它们都是把被适配类的API转换成目标类的API。但前者使用继承关系，而后者使用委派关系。它们的结构如下图：</p>

<p><img src="/myresource/images/image_blog_2014-07-30_22.38.26.jpg" alt="image" /> <img src="/myresource/images/image_blog_2014-07-30_22.40.21.jpg" alt="image" /></p>

<!--more-->


<p>上图中的三个角色：</p>

<ol>
<li>Target接口，这是目标接口，表示要适配成这个接口。</li>
<li>Adaptee，这是被适配的对象，表示要将它适配成Target。</li>
<li>Adapter，适配器，将Adaptee适配成Target。</li>
</ol>


<p>第一张图对应的是类的适配器，第二张图是对象的适配器。从图上看，区别主要是Adapter到Adaptee的连线不一样，一个是继承，一个是依赖。</p>

<h2>类的适配器</h2>

<p>先看类的适配器，即第一张图。Adapter继承自Adaptee，因此继承了方法operation1，再加上它自己实现的方法operation2，从而实现了Target接口，完成适配。由于是继承关系，因此Adaptee必须是一个类，不能是接口。</p>

<h2>对象的适配器</h2>

<p>对第二张图，Adaptee是被适配的接口，可以是接口或者类。Adapter包含一个对Adaptee的引用。Adapter的operation1方法，只需调用Adaptee.operation1，同时增加operation2，从而实现Target接口，完成适配。</p>

<p>因为没有了继承关系，因此一个适配器可以把多种不同的源适配到同一个目标。</p>

<h2>什么情况下使用适配器模式</h2>

<ol>
<li>系统需要使用现有类，而此类的接口不符合系统需要。</li>
<li>建立一个可重复使用的类，用于与一些彼此没有太大关联的一些类一起工作。</li>
<li>对象的适配器可用于改变多个已有的子类的接口。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式: 原型（Prototype）模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/30/she-ji-mo-shi-prototypemo-shi/"/>
    <updated>2014-07-30T20:58:15+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/30/she-ji-mo-shi-prototypemo-shi</id>
    <content type="html"><![CDATA[<p>原型（Prototype）模式的用处是：对于给定的原型对象，用复制的方法创建出更多的同类型对象。之前学习的工厂方法模式常常需要有一个与产品等级相同的等级结构，而原型模式则不需要这样。Java语言天生就支持原型模式。原型模式的结构图如下：</p>

<p><img src="/myresource/images/image_blog_2014-07-30_21.10.50.jpg" alt="image" /></p>

<!--more-->


<h2><code>clone()</code>方法</h2>

<p>Java的Object类提供了<code>protected Object clone()</code>方法，用于复制对象。而<code>Cloneable</code>接口用于在运行期告诉JVM可以安全地使用<code>clone()</code>方法，否则JVM将会抛出<code>CloneNotSupportedException</code>异常。</p>

<p><code>java
//复制一个pandaA
pandaB = pandaA.clone();
</code></p>

<p>一般而言，clone方法满足以下描述：</p>

<ol>
<li><code>x.clone() != x</code>，也就是说复制出来后，不是同一个对象。</li>
<li>复制对象与被复制对象是同一种类型。</li>
<li>在Java的API中，<code>x.clone().equals(x)</code>是成立的，因此建议要遵守这一条。</li>
</ol>


<h2>深复制和浅复制</h2>

<ul>
<li>浅复制：对象所有的变量与原来的对象值相同，所有对其它对象的引用仍然指向原来的对象。</li>
<li>深复制：对象所有的变量与原来的对象值相同，所有对其它对象的引用也指向被复制的新对象。</li>
</ul>


<p><code>clone()</code>方法是浅复制，而深复制可以通过序列化实现。例如：</p>

<p>```java
public class DeepCloneDemo implements Serializable {</p>

<pre><code>private String name;

public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}

public DeepCloneDemo deepClone() throws IOException, ClassNotFoundException {
    ByteArrayOutputStream bo = new ByteArrayOutputStream();
    ObjectOutputStream oo = new ObjectOutputStream(bo);
    oo.writeObject(this);

    ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
    ObjectInputStream oi = new ObjectInputStream(bi);

    return (DeepCloneDemo) oi.readObject();
}

@Override
public int hashCode() {
    //...
}

@Override
public boolean equals(Object obj) {
    //...
}
</code></pre>

<p>}</p>

<p>//测试代码
public class DeepCloneDemoTest extends TestCase{</p>

<pre><code>public void testDeepClone() {
    DeepCloneDemo demo = new DeepCloneDemo();
    demo.setName("Demo");

    try {
        DeepCloneDemo demo2 = demo.deepClone();
        Assert.assertFalse(demo2 == demo);
        Assert.assertEquals(demo, demo2);

    } catch (ClassNotFoundException | IOException e) {
        e.printStackTrace();
        Assert.assertFalse(true);
    }
}
</code></pre>

<p>}
```</p>

<p>注意要实现Serializable接口。如果不希望某个属性被序列化，可以使用<code>transient</code>关键字，例如：<code>private transient int age;</code>。</p>

<h2>什么时候用原型模式</h2>

<p>如果类是动态加载的，给每个类配备clone方法，就可以在运行时创建。</p>

<p>原型模式的优点是：允许动态地增加或减少产品类；提供简化的创建结构，不需要工厂方法那样的等级结构；为软件提供动态加载新功能的能力；</p>

<p>原型模式的缺点是：每个类都必须有clone方法，这对新类来说很容易，但已有的类就不一定，例如引用了不支持序列化的间接对象时，或者含有循环结构的时候。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:Builder模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/29/she-ji-mo-shi-buildermo-shi/"/>
    <updated>2014-07-29T22:28:54+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/29/she-ji-mo-shi-buildermo-shi</id>
    <content type="html"><![CDATA[<p>Builder模式感觉没什么特别的，甚至都不值得称为一种模式。无非就是由Director构建部分，然后再使用一个方法完成构建过程。但Builder模式对于参数太多的构造器却非常有用。先看Builder模式的类图：</p>

<p><img src="/myresource/images/image_blog_2014-07-29_22.38.17.png" alt="image" /></p>

<p><a href="/blog/2014/06/27/effective-java-chuang-jian-he-xiao-hui-dui-xiang/">这篇博客</a>建议当构造器参数比较多时，考虑使用Builder模式。这是一种非常优雅的方式。</p>

<p>我觉得Builder模式的好处一是使客户端的代码很清晰，不需要那么多的set方法；二是实现了产品构建的原子性，也就是可以在build时，确保产品构建是有效的，如果某些部分或者参数有问题、冲突，就能够在build时失败，避免残次的半成品出现。</p>
]]></content>
  </entry>
  
</feed>
