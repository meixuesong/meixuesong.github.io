<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 设计模式 | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/she-ji-mo-shi/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2014-07-27T11:50:55+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式:简单工厂模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/27/she-ji-mo-shi-jian-dan-gong-han-mo-shi/"/>
    <updated>2014-07-27T09:44:35+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/27/she-ji-mo-shi-jian-dan-gong-han-mo-shi</id>
    <content type="html"><![CDATA[<p>简单工厂模式其实就是静态工厂方法模式，即通过静态工厂方法来创建对象。其结构可表示为：</p>

<p><img src="/myresource/images/image_blog_2014-07-27_1.png" alt="image" /></p>

<!--more-->


<p>来看个实际的例子，下图中，有多种水果。客户端不关心具体的水果是如何创建的，只需要告诉工厂方法，需要哪种水果类型，工厂方法负责具体水果的创建工作。</p>

<p><img src="/myresource/images/image_blog_2014-07-27_2.png" alt="image" /></p>

<p>工厂方法返回的是水果接口。水果接口也可以换成抽象类。这是针对抽象编程的一种体现。</p>

<p>```java
public class FruitFactory {</p>

<pre><code>public static Fruit getFruit(String type) {
    if (type.equalsIgnoreCase("apple")) {
        return new Apple();
    } else if (type.equalsIgnoreCase("orange")) {
        return new Orange();
    } else {
        throw new FruitFactoryException();
    }
}
</code></pre>

<p>}
```</p>

<h3>省略产品角色</h3>

<p>如果具体产品只有一个（即只有一种水果）时，可以省略掉抽象产品角色，变成：</p>

<p><img src="/myresource/images/image_blog_2014-07-27_3.png" alt="image" /></p>

<h3>合并工厂角色与抽象产品角色</h3>

<p>有些情况下，工厂角色可以由抽象产品角色扮演，例如java.text.DateFormat类，如下图所示：</p>

<p><img src="/myresource/images/image_blog_2014-07-27_4.png" alt="image" /></p>

<h3>三个角色全部合并</h3>

<p><img src="/myresource/images/image_blog_2014-07-27_5.png" alt="image" /></p>

<p>```java
public class ConcreteProduct {</p>

<pre><code>public ConcreteProduct() {}

public static ConcreteProduct factory() {
    return new ConcreteProduct();
}
</code></pre>

<p>}
```</p>

<h3>多个工厂方法</h3>

<p>工厂类可以有一个或多个工厂方法，分别负责创建不同的产品对象。例如java.text.DateFormat类：</p>

<p>```java</p>

<pre><code>public final static DateFormat getDateInstance();
public final static DateFormat getDateInstance(int style);
public final static DateFormat getDateInstance(int style, Local locale);
</code></pre>

<p>```</p>

<h3>总结</h3>

<p>简单工厂模式是非常基本的设计模式，会在较为复杂的设计模式中出现。它的核心是工厂类，客户端完全不关心构建的细节，只需消费产品。因此，简单工厂模式实现了对责任的分割。</p>

<p>但其缺点是当产品结构变得复杂时，工厂类将变得非常复杂。由于静态方法无法继承，因此工厂角色无法形成基于继承的等级结构。</p>

<p>在这种模式中，消费者(Client)和产品（Product）都满足“开－闭原则”，都能在引进新产品时，无需对现有代码进行修改。而工厂（Factory）则必须知道每一种产品以及如何创建它们，因此必须修改这个工厂的代码，不满足“开－闭”原则。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一些设计原则]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/25/yi-xie-she-ji-yuan-ze/"/>
    <updated>2014-07-25T21:01:51+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/25/yi-xie-she-ji-yuan-ze</id>
    <content type="html"><![CDATA[<p>关于设计，有一些原则。本文总结一些常见的原则。包括：</p>

<ul>
<li>(S)单一职责原则</li>
<li>(O)开闭原则</li>
<li>(L)里氏替换原则</li>
<li>(I)接口隔离原则</li>
<li>(D)依赖反转原则</li>
<li>迪米特法则</li>
<li>组合/聚合复用原则</li>
</ul>


<!--more-->


<h2>S.单一职责原则</h2>

<p>单一职责原则（Single responsibility principle）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。</p>

<h2>O.开闭原则</h2>

<p>简单地说，就是软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的。这一原则由Bertrand Meyer提出：</p>

<blockquote><p>Software entities should be open for extension, but closed for modification.</p></blockquote>

<p>实现开闭原则的关键是抽象。找到一个系统的可变因素，将它封闭起来，这就是“对可变性的封闭原则”。</p>

<h2>L.里氏替换原则</h2>

<p>派生类（子类）对象能够替换其基类（父类）对象被使用。</p>

<h2>I.接口隔离原则</h2>

<p>接口隔离原则（Interface-segregation principles，ISP）简单地说，就是：使用多个专门的接口比使用单一的总接口要好。</p>

<p>没有客户(client)应该被迫依赖于它不使用方法。接口隔离原则(ISP)拆分非常庞大臃肿的接口成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。这种缩小的接口也被称为角色接口（role interfaces）。接口隔离原则(ISP)的目的是系统解开耦合，从而容易重构，更改和重新部署。</p>

<p>准确而恰当地划分角色以及角色所对应的接口，是面向对象的设计的一个重要的组成部分。</p>

<h2>D.依赖反转原则</h2>

<p>简单地说，就是依赖于抽象，不要依赖于具体。</p>

<p>为什么叫“反转”呢？？看看下面是怎么反转的：</p>

<p><img src="/myresource/images/img_blog_20140725_1.png" alt="image" /></p>

<p><img src="/myresource/images/img_blog_20140725_2.png" alt="image" /></p>

<p>两种表述:</p>

<ol>
<li>抽象不应当依赖于细节；细节应该依赖于抽象。</li>
<li>要针对接口编程，不要针对实现编程。</li>
</ol>


<p>针对接口编程是指，应该使用接口和抽象类进行变量的类型声明、参数和方法返回类型的声明，以及数据类型的转换等。</p>

<p>不要针对实现编程是指，不应当使用具体Java类进行变量的类型声明、参数和方法返回类型的声明，以及数据类型的转换等。</p>

<p>如果希望遵循“开－闭原则”，那么依赖反转原则便是达到目标的途径。</p>

<h2>迪米特法则</h2>

<p>迪米特法则又叫做最少知识原则，就是说，一个对象应当对其他对象尽可能少的了解。</p>

<h3>狭义的迪米特法则</h3>

<p>如果两个类不必彼此直接通信，那么这两个类就不应该发生直接的相互作用。就是说如果某人可以通过朋友去调用陌生人的方法，那么就不用直接调用陌生人的方法，而是通过朋友去调用转发。</p>

<p>什么是朋友呢？满足任一条件都是朋友：</p>

<ul>
<li>当前对象本身</li>
<li>以参量形式传入到当前对象方法的对象</li>
<li>当前对象的实例变量直接引用的对象</li>
<li>当前对象的实例变量如果是聚集，那么其中的元素都是朋友</li>
<li>当前对象所创建的对象。</li>
</ul>


<p>狭义的迪米特法则的缺点是：产生大量小方法，与商务逻辑无关；不同模块之间的通信效率降低。</p>

<h3>广义迪米特法则在类的设计上的体现</h3>

<ul>
<li>优先考虑将一个类设置成不变类</li>
<li>尽量降低一个类的访问权限</li>
<li>尽量降低成员的访问权限</li>
</ul>


<h2>组合/聚合复用原则</h2>

<p>实际上说的就是尽量使用聚合/组合，尽量不要使用继承。这在Effective-Java中也有描述。<a href="/blog/2014/07/08/effective-java-lei-he-jie-kou/">Java类与接口</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一张图看懂UML类图的关系]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/23/yi-zhang-tu-kan-dong/"/>
    <updated>2014-07-23T23:37:18+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/23/yi-zhang-tu-kan-dong</id>
    <content type="html"><![CDATA[<p>在UML类图中，类之间的关系包括：继承、关联、聚合、组合和依赖关系。如何分辨这些关系呢？每种关系使用什么样的连线呢？</p>

<!--more-->


<p><strong>继承关系</strong>，这个太简单，不说了。</p>

<p><strong>关联关系</strong>，在Java中，使用实例变量来实现关系关系。如图中的Driver类有car变量。</p>

<p><strong>聚合关系</strong>，是更强的关联关系。聚合是整体与个体的关系。也需要通过实例变量实现。如果不是很确定是否聚合关系，可以使用关联关系。从Java语法是无法分辨出关联或聚合关系的区别的。</p>

<p><strong>组合关系</strong>，是比聚合关系更强的关系关系。当聚合关系中的整体需要负责个体的生命周期时，就变成了组合关系。例如公司与部门的关系，当公司不存在时，部门也不存在了。</p>

<p><strong>依赖关系</strong>，当A中有个局域变量、方法的参数是B，或者调用了B的静态方法，就是A依赖于B。</p>

<p>下面这张图演示了各种关系：</p>

<p><img src="/myresource/images/img_blog_20140723.jpg" alt="image" /></p>
]]></content>
  </entry>
  
</feed>
