<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 设计模式 | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/she-ji-mo-shi/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2014-07-30T23:06:25+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式:适配器模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/30/she-ji-mo-shi-gua-pei-qi-mo-shi/"/>
    <updated>2014-07-30T22:31:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/30/she-ji-mo-shi-gua-pei-qi-mo-shi</id>
    <content type="html"><![CDATA[<p>适配器模式分为类的适配器和对象的适配器。它们都是把被适配类的API转换成目标类的API。但前者使用继承关系，而后者使用委派关系。它们的结构如下图：</p>

<p><img src="/myresource/images/image_blog_2014-07-30_22.38.26.jpg" alt="image" /> <img src="/myresource/images/image_blog_2014-07-30_22.40.21.jpg" alt="image" /></p>

<!--more-->


<p>上图中的三个角色：</p>

<ol>
<li>Target接口，这是目标接口，表示要适配成这个接口。</li>
<li>Adaptee，这是被适配的对象，表示要将它适配成Target。</li>
<li>Adapter，适配器，将Adaptee适配成Target。</li>
</ol>


<p>第一张图对应的是类的适配器，第二张图是对象的适配器。从图上看，区别主要是Adapter到Adaptee的连线不一样，一个是继承，一个是依赖。</p>

<h2>类的适配器</h2>

<p>先看类的适配器，即第一张图。Adapter继承自Adaptee，因此继承了方法operation1，再加上它自己实现的方法operation2，从而实现了Target接口，完成适配。由于是继承关系，因此Adaptee必须是一个类，不能是接口。</p>

<h2>对象的适配器</h2>

<p>对第二张图，Adaptee是被适配的接口，可以是接口或者类。Adapter包含一个对Adaptee的引用。Adapter的operation1方法，只需调用Adaptee.operation1，同时增加operation2，从而实现Target接口，完成适配。</p>

<p>因为没有了继承关系，因此一个适配器可以把多种不同的源适配到同一个目标。</p>

<h2>什么情况下使用适配器模式</h2>

<ol>
<li>系统需要使用现有类，而此类的接口不符合系统需要。</li>
<li>建立一个可重复使用的类，用于与一些彼此没有太大关联的一些类一起工作。</li>
<li>对象的适配器可用于改变多个已有的子类的接口。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式: 原型（Prototype）模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/30/she-ji-mo-shi-prototypemo-shi/"/>
    <updated>2014-07-30T20:58:15+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/30/she-ji-mo-shi-prototypemo-shi</id>
    <content type="html"><![CDATA[<p>原型（Prototype）模式的用处是：对于给定的原型对象，用复制的方法创建出更多的同类型对象。之前学习的工厂方法模式常常需要有一个与产品等级相同的等级结构，而原型模式则不需要这样。Java语言天生就支持原型模式。原型模式的结构图如下：</p>

<p><img src="/myresource/images/image_blog_2014-07-30_21.10.50.jpg" alt="image" /></p>

<!--more-->


<h2><code>clone()</code>方法</h2>

<p>Java的Object类提供了<code>protected Object clone()</code>方法，用于复制对象。而<code>Cloneable</code>接口用于在运行期告诉JVM可以安全地使用<code>clone()</code>方法，否则JVM将会抛出<code>CloneNotSupportedException</code>异常。</p>

<p><code>java
//复制一个pandaA
pandaB = pandaA.clone();
</code></p>

<p>一般而言，clone方法满足以下描述：</p>

<ol>
<li><code>x.clone() != x</code>，也就是说复制出来后，不是同一个对象。</li>
<li>复制对象与被复制对象是同一种类型。</li>
<li>在Java的API中，<code>x.clone().equals(x)</code>是成立的，因此建议要遵守这一条。</li>
</ol>


<h2>深复制和浅复制</h2>

<ul>
<li>浅复制：对象所有的变量与原来的对象值相同，所有对其它对象的引用仍然指向原来的对象。</li>
<li>深复制：对象所有的变量与原来的对象值相同，所有对其它对象的引用也指向被复制的新对象。</li>
</ul>


<p><code>clone()</code>方法是浅复制，而深复制可以通过序列化实现。例如：</p>

<p>```java
public class DeepCloneDemo implements Serializable {</p>

<pre><code>private String name;

public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}

public DeepCloneDemo deepClone() throws IOException, ClassNotFoundException {
    ByteArrayOutputStream bo = new ByteArrayOutputStream();
    ObjectOutputStream oo = new ObjectOutputStream(bo);
    oo.writeObject(this);

    ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
    ObjectInputStream oi = new ObjectInputStream(bi);

    return (DeepCloneDemo) oi.readObject();
}

@Override
public int hashCode() {
    //...
}

@Override
public boolean equals(Object obj) {
    //...
}
</code></pre>

<p>}</p>

<p>//测试代码
public class DeepCloneDemoTest extends TestCase{</p>

<pre><code>public void testDeepClone() {
    DeepCloneDemo demo = new DeepCloneDemo();
    demo.setName("Demo");

    try {
        DeepCloneDemo demo2 = demo.deepClone();
        Assert.assertFalse(demo2 == demo);
        Assert.assertEquals(demo, demo2);

    } catch (ClassNotFoundException | IOException e) {
        e.printStackTrace();
        Assert.assertFalse(true);
    }
}
</code></pre>

<p>}
```</p>

<p>注意要实现Serializable接口。如果不希望某个属性被序列化，可以使用<code>transient</code>关键字，例如：<code>private transient int age;</code>。</p>

<h2>什么时候用原型模式</h2>

<p>如果类是动态加载的，给每个类配备clone方法，就可以在运行时创建。</p>

<p>原型模式的优点是：允许动态地增加或减少产品类；提供简化的创建结构，不需要工厂方法那样的等级结构；为软件提供动态加载新功能的能力；</p>

<p>原型模式的缺点是：每个类都必须有clone方法，这对新类来说很容易，但已有的类就不一定，例如引用了不支持序列化的间接对象时，或者含有循环结构的时候。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:Builder模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/29/she-ji-mo-shi-buildermo-shi/"/>
    <updated>2014-07-29T22:28:54+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/29/she-ji-mo-shi-buildermo-shi</id>
    <content type="html"><![CDATA[<p>Builder模式感觉没什么特别的，甚至都不值得称为一种模式。无非就是由Director构建部分，然后再使用一个方法完成构建过程。但Builder模式对于参数太多的构造器却非常有用。先看Builder模式的类图：</p>

<p><img src="/myresource/images/image_blog_2014-07-29_22.38.17.png" alt="image" /></p>

<p><a href="/blog/2014/06/27/effective-java-chuang-jian-he-xiao-hui-dui-xiang/">这篇博客</a>建议当构造器参数比较多时，考虑使用Builder模式。这是一种非常优雅的方式。</p>

<p>我觉得Builder模式的好处一是使客户端的代码很清晰，不需要那么多的set方法；二是实现了产品构建的原子性，也就是可以在build时，确保产品构建是有效的，如果某些部分或者参数有问题、冲突，就能够在build时失败，避免残次的半成品出现。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式在序列生成器的应用]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/28/she-ji-mo-shi-zai-xu-lie-sheng-cheng-qi-de-ying-yong/"/>
    <updated>2014-07-28T22:21:23+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/28/she-ji-mo-shi-zai-xu-lie-sheng-cheng-qi-de-ying-yong</id>
    <content type="html"><![CDATA[<p>序列生成器是常见的一个应用组件。Oracle数据库有Sequence，但不是所有数据库都有序列。本文尝试将单例模式、多例模式应用于序列生成器。采用了以下方式实现：</p>

<ol>
<li>没有数据库的单例实现</li>
<li>有数据库的单例实现</li>
<li>有缓存的单例实现</li>
<li>有缓存的多序列实现</li>
<li>多序列的多例实现。</li>
</ol>


<!--more-->


<h2>1. 没有数据库的单例实现</h2>

<p>当没有数据库时，使用单例实现序列生成器非常简单，示例代码如下，注意<code>synchronized</code>关键字：</p>

<p>```java
/<em>*
 * 没有数据库的序列键生成器
 * @author mxs
 *
 </em>/
public class KeyGenerator {</p>

<pre><code>private long key = 0;
private static KeyGenerator instance = new KeyGenerator();

private KeyGenerator() {}

public static KeyGenerator getInstance() {
    return instance;
}

public synchronized long getNextKey() {
    return key++;
}
</code></pre>

<p>}
```</p>

<p>单元测试代码：</p>

<p>```java
public class KeyGeneratorTest extends TestCase {</p>

<pre><code>public void testKey() {
    KeyGenerator keyGenerator = KeyGenerator.getInstance();

    for(int i = 0; i &lt; 100; i++) {
        Assert.assertEquals(i, keyGenerator.getNextKey());
    }
}
</code></pre>

<p>}
```</p>

<p>这种实现没有持久化，一旦重启，序列又从0开始。因此我们需要一个有数据库持久化的方案。</p>

<h2>2. 有数据库的单例实现</h2>

<p>当有数据库时，每次获取序列都从数据库读取。</p>

<p>```java
/<em>*
 * 有数据库的序列键生成器
 * @author mxs
 *
 </em>/
public class KeyGenerator {</p>

<pre><code>private static KeyGenerator instance = new KeyGenerator();

private KeyGenerator() {}

public static KeyGenerator getInstance() {
    return instance;
}

public synchronized long getNextKey() {
    return getNextKeyFromDB();
}

private long getNextKeyFromDB() {
    //update t_sequence set seq_value = seq_value + 1
    //select seq_value from t_sequence
    //返回结果
    return 1000;
}
</code></pre>

<p>}</p>

<p>```</p>

<h2>3. 有缓存的单例实现</h2>

<p>第2种方法每次都要访问数据库，影响了性能，可以一次多取一些序列放到缓存中，只有缓存都取完时，才访问数据库。</p>

<p>```java
/<em>*
 * 有数据库、带缓存的序列键生成器
 * @author mxs
 *
 </em>/
public class KeyGenerator {</p>

<pre><code>private static KeyGenerator instance = new KeyGenerator();
private static final int cacheSize = 20;
private KeyInfo keyInfo;

private KeyGenerator() {
    keyInfo = new KeyInfo(cacheSize);
}

public static KeyGenerator getInstance() {
    return instance;
}

public synchronized long getNextKey() {
    return keyInfo.getNext();
}
</code></pre>

<p>}</p>

<p>public class KeyInfo {</p>

<pre><code>private long max;
private long min;
private long nextKey;
private int poolSize;

public KeyInfo(int poolSize) {
    this.poolSize = poolSize;
    retrieveFromDB();
}

public long getNext() {
    if (nextKey &gt;= max) {
        retrieveFromDB();
    }

    return nextKey++;
}

private void retrieveFromDB() {
    // update t_sequence set seq_value = seq_value + poolSize
    // select seq_value from t_sequence
    //以下为模拟数据库操作
    long value = dbvalue[dbIndex ++];
    min = value - poolSize;
    max = value;
    nextKey = min;
}

private int[] dbvalue = {20, 40, 60, 80, 100};
private int dbIndex = 0;
</code></pre>

<p>}</p>

<p>```</p>

<h2>4. 有缓存的多序列实现</h2>

<p>要实现多序列，只需要用HashMap改造第3种方法，保持KeyInfo不变，KeyGenerator修改为：</p>

<p>```java
/<em>*
 * 有数据库、带缓存的多序列键生成器
 * @author mxs
 *
 </em>/
public class KeyGenerator {</p>

<pre><code>private static KeyGenerator instance = new KeyGenerator();
private static final int cacheSize = 20;

private Map&lt;String, KeyInfo&gt; map;

private KeyGenerator() {
    map = new HashMap&lt;String, KeyInfo&gt;();
}

public static KeyGenerator getInstance() {
    return instance;
}

public synchronized long getNextKey(String key) {
    KeyInfo keyInfo;
    if (map.containsKey(key)) {
        keyInfo = map.get(key);
    } else {
        keyInfo = new KeyInfo(cacheSize);
        map.put(key, keyInfo);
    }

    return keyInfo.getNext();
}
</code></pre>

<p>}
```</p>

<h2>5. 多序列的多例实现</h2>

<p>前面所有实现方案都是基于单例模式，其实还可以使用多例模式。多例模式允许一个类有多个实例，这些实例有自己的状态。保持KeyInfo不变，KeyGenerator修改为：</p>

<p>```java
/<em>*
 * 有数据库、带缓存的多序列键生成器，采用多例模式
 * @author mxs
 *
 </em>/
public class KeyGenerator {</p>

<pre><code>private static final int cacheSize = 20;
private KeyInfo keyInfo;
private static Map&lt;String, KeyGenerator&gt; instances = new HashMap&lt;String, KeyGenerator&gt;(10);

private KeyGenerator() {
    keyInfo = new KeyInfo(cacheSize);
}

public static synchronized KeyGenerator getInstance(String key) {
    if (! instances.containsKey(key)) {
        KeyGenerator generator = new KeyGenerator();
        instances.put(key, generator);
    }

    return instances.get(key);
}

public synchronized long getNextKey() {
    return keyInfo.getNext();
}
</code></pre>

<p>}</p>

<p>//测试代码：
public class KeyGeneratorTest extends TestCase {</p>

<pre><code>public void testKey() {
    for(int j = 0; j &lt; 10; j ++) {
        String key = "" + j;
        KeyGenerator keyGenerator = KeyGenerator.getInstance(key);
        for(int i = 0; i &lt; 90; i++) {
            long ii = keyGenerator.getNextKey();
            Assert.assertEquals(i, ii);
        }
    }       
}
</code></pre>

<p>}</p>

<p>```</p>

<p>参考：
Java与模式</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:抽象工厂方法模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/28/she-ji-mo-shi-chou-xiang-gong-han-fang-fa-mo-shi/"/>
    <updated>2014-07-28T19:45:29+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/28/she-ji-mo-shi-chou-xiang-gong-han-fang-fa-mo-shi</id>
    <content type="html"><![CDATA[<p>简单工厂方法模式采用静态方法创建产品，工厂方式模式通过多层级的工厂方法创建一种产品等级结构。而抽象工厂方法模式则可以用于创建多个产品等级结构。因此，其类图示意如下：</p>

<p><img src="/myresource/images/image_blog_2014-07-28_20.03.46.png" alt="image" /></p>

<!--more-->


<p>从上图可见，有两个产品等级：ProductA和ProductB。抽象工厂模式与工厂方法模式的最大区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则需要面对多个产品等级结构。那么对于多个等级结构的产品，为什么要采用抽象工厂模式呢？</p>

<p>如果采用工厂模式，就要N个独立的工厂等级结构来应对N个产品等级结构。由于这些产品等级结构的相似性，会导致N个平等的工厂等级结构。随着产品等级结构数目的增加，工厂方式模式所给出的工厂等级结构数目也会随之增加。</p>

<p>所以，抽象工厂方法模式的好处是，同一个工厂等级结构应对N个这些相似的产品等级结构。例如上图中的ConcreteCreator1负责创建ProductA1和ProductB1。显然，这种方式更有效率。</p>

<p>什么情况下应当使用抽象工厂模式？</p>

<ol>
<li>满足工厂模式的条件，即：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节时。</li>
<li>多于一个的产品族，而系统只消费其中某一族的产品。如上图中有2个族（1，2），同时只消费其中一个族。</li>
<li>同属于一个产品族的产品是一起使用的。</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。</li>
</ol>


<p>举一个实际例子就很容易理解为什么需要，以及什么时候需要抽象工厂模式：</p>

<p><img src="/myresource/images/image_blog_2014-07-28_21.41.37.png" alt="image" /></p>
]]></content>
  </entry>
  
</feed>
