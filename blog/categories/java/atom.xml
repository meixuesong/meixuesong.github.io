<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2014-09-16T00:19:45+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java I/O]]></title>
    <link href="http://blog.ubone.com/blog/2014/09/14/java-i-slash-o/"/>
    <updated>2014-09-14T21:22:58+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/09/14/java-i-slash-o</id>
    <content type="html"><![CDATA[<h2>1. File类</h2>

<h3>1.1 目录列表器</h3>

<p>下面的代码示例，通过正则表达式过滤并返回指定文件的下级列表：</p>

<p>```java</p>

<pre><code>public static String[] dirList(String path, final String ptn) {
    File file = new File(path);
    if (ptn == null || "".equals(ptn.trim())) {
        return file.list();
    }

    FilenameFilter fnf = new FilenameFilter() {
        private Pattern pattern = Pattern.compile(ptn);
        @Override
        public boolean accept(File dir, String name) {
            return pattern.matcher(name).matches();
        }
    };

    return file.list(fnf);
}
</code></pre>

<p>```</p>

<h3>1.2 目录实用工具</h3>

<p>```java</p>

<pre><code>public static File[] local(File dir, final String regex) {
    return dir.listFiles(new FilenameFilter() {
        private Pattern pattern = Pattern.compile(regex);

        public boolean accept(File dir, String name) {
            return pattern.matcher(new File(name).getName()).matches();
        }
    });
}
</code></pre>

<p>以及File类的exists(), isDirectory(), isFile(), mkdirs(), delete(), renameTo()等方法。
```</p>

<h2>2. I/O流的典型使用方式</h2>

<h3>2.1 缓冲输入文件</h3>

<p>下面的例子适用于字符输入：</p>

<p>```java
public class BufferedInputFile {</p>

<pre><code>// Throw exceptions to console:
public static String read(String filename) throws IOException {
    // Reading input by lines:
    BufferedReader in = new BufferedReader(new FileReader(filename));
    String s;
    StringBuilder sb = new StringBuilder();
    while ((s = in.readLine()) != null)
        sb.append(s + "\n");
    in.close();
    return sb.toString();
}

public static void main(String[] args) throws IOException {
    System.out.print(read("BufferedInputFile.java"));
}
</code></pre>

<p>}
```</p>

<h3>2.2 从内存输入</h3>

<p>在下面的示例中，从BufferedInputFile.read()读入的String结果被用来创建一个StringReader。然后调用read()每次读取一个字符：</p>

<p>```java
public static class MemoryInput {</p>

<pre><code>public static void main(String[] args) throws IOException {
    StringReader in = new StringReader(
            BufferedInputFile.read("MemoryInput.java"));
    int c;
    while ((c = in.read()) != -1)
        System.out.print((char) c);
}
</code></pre>

<p>}
```</p>

<h3>2.3 格式化的内存输入</h3>

<p>```java
DataInputStream in = new DataInputStream(</p>

<pre><code>    new ByteArrayInputStream(
            BufferedInputFile.read("FormattedMemoryInput.java")
            .getBytes()));
</code></pre>

<p>in.readInt();
in.readChar();</p>

<p>DataInputStream in2 = new DataInputStream(</p>

<pre><code>    new BufferedInputStream(
            new FileInputStream("TestEOF.java")));                          
</code></pre>

<p>while (in.available() != 0)</p>

<pre><code>System.out.print((char) in.readByte());
</code></pre>

<p>/<em>注意available()的工作方式会随着媒介类型的不同而不同。
  表示“在没有阻塞的情况下所能读取的字节数”，
  对于文件，这意味着整个文件，但不同类型的流可能不是这样。
</em>/
```</p>

<h3>2.4 基本的文件输出</h3>

<p>FileWriter可用于向文件写入数据，通常会用BufferedWriter将其包装。下例写入文本文件：</p>

<p>```java
PrintWriter out = new PrintWriter(</p>

<pre><code>    new BufferedWriter(
            new FileWriter("something.out")));
</code></pre>

<p>out.println(&ldquo;Hello!&rdquo;);
out.close();</p>

<p>//对于文本文件有快捷方式：
PrintWriter out = new PrintWriter(file);
out.println(&ldquo;Hello!&rdquo;);
out.close();
```</p>

<h3>2.5 存储和恢复数据</h3>

<p>```java
public class StoringAndRecoveringData {
  public static void main(String[] args)
  throws IOException {</p>

<pre><code>DataOutputStream out = new DataOutputStream(
  new BufferedOutputStream(
    new FileOutputStream("Data.txt")));
out.writeDouble(3.14159);
out.writeUTF("That was pi");
out.writeDouble(1.41413);
out.writeUTF("Square root of 2"); 
out.close();
DataInputStream in = new DataInputStream(
  new BufferedInputStream(
    new FileInputStream("Data.txt")));
System.out.println(in.readDouble());
// Only readUTF() will recover the
// Java-UTF String properly:
System.out.println(in.readUTF());
System.out.println(in.readDouble());
System.out.println(in.readUTF());
</code></pre>

<p>  }
}
```</p>

<h3>2.6 读写随机访问文件</h3>

<p>使用RandomAccessFile，类似于组合使用DataInputStream和DataOutputStream。它不支持装饰，所以不能与InputStream和OutputStream子类的任何部分组合起来。可以假定其已经被正确地缓冲。</p>

<p>```java
public class UsingRandomAccessFile {
  static String file = &ldquo;rtest.dat&rdquo;;
  static void display() throws IOException {</p>

<pre><code>RandomAccessFile rf = new RandomAccessFile(file, "r");
for(int i = 0; i &lt; 7; i++)
  System.out.println(
    "Value " + i + ": " + rf.readDouble());
System.out.println(rf.readUTF());
rf.close();
</code></pre>

<p>  }
  public static void main(String[] args)
  throws IOException {</p>

<pre><code>RandomAccessFile rf = new RandomAccessFile(file, "rw");
for(int i = 0; i &lt; 7; i++)
  rf.writeDouble(i*1.414);
rf.writeUTF("The end of the file");
rf.close();
display();
rf = new RandomAccessFile(file, "rw");
rf.seek(5*8);
rf.writeDouble(47.0001);
rf.close();
display();
</code></pre>

<p>  }
}
```</p>

<h2>3. NIO</h2>

<p>新的I/O速度提升来自于所使用的结构更接近于操作系统执行I/O的方式：通道和缓冲器。我们只和缓冲器交互，并把缓冲器派送到通道。通道要么从缓冲器获得数据，要么向缓冲器发送数据。以下示例演示了三种类型的流，用以产生可写、可读可写以及可读的通道。</p>

<p>```java
public class GetChannel {</p>

<pre><code>private static final int BSIZE = 1024;

public static void main(String[] args) throws Exception {
    // Write a file:
    FileChannel fc = new FileOutputStream("/Users/mxs/Desktop/data.txt")
            .getChannel();
    fc.write(ByteBuffer.wrap("Some text ".getBytes()));
    fc.close();
    // Add to the end of the file:
    fc = new RandomAccessFile("/Users/mxs/Desktop/data.txt", "rw")
            .getChannel();
    fc.position(fc.size()); // Move to the end
    fc.write(ByteBuffer.wrap("Some more".getBytes()));
    fc.close();
    // Read the file:
    fc = new FileInputStream("/Users/mxs/Desktop/data.txt").getChannel();
    ByteBuffer buff = ByteBuffer.allocate(BSIZE);
    fc.read(buff);
    buff.flip();
    while (buff.hasRemaining())
        System.out.print((char) buff.get());
}
</code></pre>

<p>} /<em>
 * Output: Some text Some more
 </em>/// :~</p>

<p>```</p>

<h3>3.1 转换数据</h3>

<p>```java
public class BufferToText {</p>

<pre><code>private static final int BSIZE = 1024;

public static void main(String[] args) throws Exception {
    FileChannel fc = new FileOutputStream("/Users/mxs/Desktop/data2.txt").getChannel();
    fc.write(ByteBuffer.wrap("Some text".getBytes()));
    fc.close();
    fc = new FileInputStream("/Users/mxs/Desktop/data2.txt").getChannel();
    ByteBuffer buff = ByteBuffer.allocate(BSIZE);
    fc.read(buff);
    buff.flip();
    // Doesn't work:
    System.out.println(buff.asCharBuffer());
    // Decode using this system's default Charset:
    buff.rewind();
    String encoding = System.getProperty("file.encoding");
    System.out.println("Decoded using " + encoding + ": "
            + Charset.forName(encoding).decode(buff));
    // Or, we could encode with something that will print:
    fc = new FileOutputStream("/Users/mxs/Desktop/data2.txt").getChannel();
    fc.write(ByteBuffer.wrap("Some text".getBytes("UTF-16BE")));
    fc.close();
    // Now try reading again:
    fc = new FileInputStream("/Users/mxs/Desktop/data2.txt").getChannel();
    buff.clear();
    fc.read(buff);
    buff.flip();
    System.out.println(buff.asCharBuffer());
    // Use a CharBuffer to write through:
    fc = new FileOutputStream("/Users/mxs/Desktop/data2.txt").getChannel();
    buff = ByteBuffer.allocate(24); // More than needed
    buff.asCharBuffer().put("Some text");
    fc.write(buff);
    fc.close();
    // Read and display:
    fc = new FileInputStream("/Users/mxs/Desktop/data2.txt").getChannel();
    buff.clear();
    fc.read(buff);
    buff.flip();
    System.out.println(buff.asCharBuffer());
}
</code></pre>

<p>}
/<em>
 * Output: ???? Decoded using Cp1252: Some text Some text Some text
 </em>/// :~
```</p>

<h3>3.2 获取基本类型</h3>

<p>下面的示例演示了怎样插入和抽取各种数值：</p>

<p>```java
public class GetData {</p>

<pre><code>private static final int BSIZE = 1024;

public static void main(String[] args) {
    ByteBuffer bb = ByteBuffer.allocate(BSIZE);
    // Allocation automatically zeroes the ByteBuffer:
    int i = 0;
    while (i++ &lt; bb.limit())
        if (bb.get() != 0)
            print("nonzero");
    print("i = " + i);
    bb.rewind();
    // Store and read a char array:
    bb.asCharBuffer().put("Howdy!");
    char c;
    while ((c = bb.getChar()) != 0)
        printnb(c + " ");
    print();
    bb.rewind();
    // Store and read a short:
    bb.asShortBuffer().put((short) 471142);
    print(bb.getShort());
    bb.rewind();
    // Store and read an int:
    bb.asIntBuffer().put(99471142);
    print(bb.getInt());
    bb.rewind();
    // Store and read a long:
    bb.asLongBuffer().put(99471142);
    print(bb.getLong());
    bb.rewind();
    // Store and read a float:
    bb.asFloatBuffer().put(99471142);
    print(bb.getFloat());
    bb.rewind();
    // Store and read a double:
    bb.asDoubleBuffer().put(99471142);
    print(bb.getDouble());
    bb.rewind();
}
</code></pre>

<p>}</p>

<p>/<em> Output:
i = 1025
H o w d y !
12390
99471142
99471142
9.9471144E7
9.9471142E7
</em>///:~
```</p>

<h3>3.3 视图缓冲器</h3>

<p>视图缓冲器（View buffer）可以让我们通过某个特定的基本数据类型的视窗查看其底层的ByteBuffer。</p>

<p>```java
public class IntBufferDemo {
  private static final int BSIZE = 1024;
  public static void main(String[] args) {</p>

<pre><code>ByteBuffer bb = ByteBuffer.allocate(BSIZE);
IntBuffer ib = bb.asIntBuffer();
// Store an array of int:
ib.put(new int[]{ 11, 42, 47, 99, 143, 811, 1016 });
// Absolute location read and write:
System.out.println(ib.get(3));
ib.put(3, 1811);
// Setting a new limit before rewinding the buffer.
ib.flip();
while(ib.hasRemaining()) {
  int i = ib.get();
  System.out.println(i);
}
</code></pre>

<p>  }
} /<em> Output:
99
11
42
47
1811
143
811
1016
</em>///:~
```</p>

<p>```java
public class ViewBuffers {
  public static void main(String[] args) {</p>

<pre><code>ByteBuffer bb = ByteBuffer.wrap(
  new byte[]{ 0, 0, 0, 0, 0, 0, 0, 'a' });
bb.rewind();
printnb("Byte Buffer ");
while(bb.hasRemaining())
  printnb(bb.position()+ " -&gt; " + bb.get() + ", ");
print();
CharBuffer cb =
  ((ByteBuffer)bb.rewind()).asCharBuffer();
printnb("Char Buffer ");
while(cb.hasRemaining())
  printnb(cb.position() + " -&gt; " + cb.get() + ", ");
print();
FloatBuffer fb =
  ((ByteBuffer)bb.rewind()).asFloatBuffer();
printnb("Float Buffer ");
while(fb.hasRemaining())
  printnb(fb.position()+ " -&gt; " + fb.get() + ", ");
print();
IntBuffer ib =
  ((ByteBuffer)bb.rewind()).asIntBuffer();
printnb("Int Buffer ");
while(ib.hasRemaining())
  printnb(ib.position()+ " -&gt; " + ib.get() + ", ");
print();
LongBuffer lb =
  ((ByteBuffer)bb.rewind()).asLongBuffer();
printnb("Long Buffer ");
while(lb.hasRemaining())
  printnb(lb.position()+ " -&gt; " + lb.get() + ", ");
print();
ShortBuffer sb =
  ((ByteBuffer)bb.rewind()).asShortBuffer();
printnb("Short Buffer ");
while(sb.hasRemaining())
  printnb(sb.position()+ " -&gt; " + sb.get() + ", ");
print();
DoubleBuffer db =
  ((ByteBuffer)bb.rewind()).asDoubleBuffer();
printnb("Double Buffer ");
while(db.hasRemaining())
  printnb(db.position()+ " -&gt; " + db.get() + ", ");
</code></pre>

<p>  }
}
/<em> Output:
Byte Buffer 0 &ndash;> 0, 1 &ndash;> 0, 2 &ndash;> 0, 3 &ndash;> 0, 4 &ndash;> 0, 5 &ndash;> 0, 6 &ndash;> 0, 7 &ndash;> 97,
Char Buffer 0 &ndash;>  , 1 &ndash;>  , 2 &ndash;>  , 3 &ndash;> a,
Float Buffer 0 &ndash;> 0.0, 1 &ndash;> 1.36E-43,
Int Buffer 0 &ndash;> 0, 1 &ndash;> 97,
Long Buffer 0 &ndash;> 97,
Short Buffer 0 &ndash;> 0, 1 &ndash;> 0, 2 &ndash;> 0, 3 &ndash;> 97,
Double Buffer 0 &ndash;> 4.8E-322,
</em>///:~
```</p>

<h3>3.4 用缓冲器操纵数据</h3>

<p><img src="/myresource/images/image_blog_20140916_001220.jpg" alt="image" /></p>

<h3>3.5 缓冲器的细节</h3>

<p>Buffer由数据和四个索引组成：mark, position, limit, capacity。相关的方法：</p>

<ul>
<li>capacity() 返回缓冲区容量。</li>
<li>clear() 清空缓冲区，position设置为0，limit设置为容量。</li>
<li>flip() 将limit设置为position, position设置为0.用于准备从缓冲区读取已经写入的数据。</li>
<li>limit() 返回limit值。</li>
<li>limit(int lim) 设置limit值。</li>
<li>mark() 将mark设置为position。</li>
<li>position() 返回position值。</li>
<li>position(int pos) 设置position值。</li>
<li>remaining() 返回（limit &ndash; position）。</li>
<li>hasRemaining() 若有介于position和limit之间的元素，则返回true。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java并发编程(三)]]></title>
    <link href="http://blog.ubone.com/blog/2014/09/02/javabing-fa-bian-cheng-san/"/>
    <updated>2014-09-02T23:13:06+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/09/02/javabing-fa-bian-cheng-san</id>
    <content type="html"><![CDATA[<p>本文是《Java编程思想》第21章并发的读书笔记。<a href="/blog/2014/08/30/javabing-fa-bian-cheng/">Java并发编程（一）</a>、<a href="/blog/2014/09/02/javabing-fa-er/">Java并发编程（二）</a></p>

<!--more-->


<h2>6. 新类库中的构件</h2>

<p>java.util.concurrent引入的新类库，有助于编写更简单和健壮的并发程序。</p>

<h2>6.1 CountDownLatch</h2>

<p>用于同步一个或多个任务，强制它们等待由其他任务执行的一组操作完成。可以向CountDownLatch对象设置一初始值，任务在这个对象上调用wait()方法都将阻塞，直到计数值为0。其它任务结束工作时，可以调用countDown()来减少这个计数值。</p>

<p>示例代码：</p>

<p>```java
public class LatchDemo {</p>

<pre><code>private static class Latch implements Runnable {
    private CountDownLatch latch;
    Latch(CountDownLatch latch) {
        this.latch = latch;
    }

    @Override
    public void run() {
        try {
            doSomething();
            System.out.println("Latch runing...");
            TimeUnit.SECONDS.sleep(3);
            System.out.println("Latch sleeped 3 seconds.");
            //2. 当完成后，调用countDown()，将计数减1
            latch.countDown();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private void doSomething() {}
}

private static class LatchWaiter implements Runnable {
    private CountDownLatch latch;
    LatchWaiter(CountDownLatch latch) {
        this.latch = latch;
    }

    @Override
    public void run() {
        try {
            System.out.println("LatchWaiter waiting...");
            //3. 一直等到latch的计数变为0
            latch.await();
            System.out.println("LatchWaiter exit wait...");
        } catch (InterruptedException e) {
            //todo
        }
    }

    private void doOtherthing() {}
}

public static void main(String[] args) {
    //1. 先赋一个值，例如1
    CountDownLatch latch = new CountDownLatch(1);
    ExecutorService exec = Executors.newCachedThreadPool();
    exec.execute(new Latch(latch));
    exec.execute(new LatchWaiter(latch));
    exec.shutdown();
}
</code></pre>

<p>}
```</p>

<p>注意：CountDownLatch只会触发一次，计数值不能重置。</p>

<h3>6.2 CyclicBarrier</h3>

<p>CyclicBarrier适用于有一组任务，它们并行工作，直到它们全部完成后，才一起向前移动。与CountDownLatch只会触发一次不同，CyclicBarrier可以多次重用。</p>

<p>```java
public class CyclicBarrierDemo {</p>

<pre><code>private static class Horse implements Runnable {
    private CyclicBarrier barrier;
    private String id;
    private int stepCount = 0;
    private static Random rand = new Random(5000);

    Horse(String id, CyclicBarrier barrier) {
        this.id = id;
        this.barrier = barrier;
    }

    @Override
    public void run() {
        doSomething();
        try {
            while (!Thread.interrupted()) {
                synchronized (this) {
                    System.out.println(String.format("Thread %s is doing.",
                            id));
                    stepCount++;
                    TimeUnit.MILLISECONDS.sleep(rand.nextInt(5000));
                    System.out.println(String.format("Thread %s has done.",
                            id));
                }
                // await：待所有线程都在这一步调用await方法。
                barrier.await();
            }
        } catch (InterruptedException e) {
            // ...
        } catch (BrokenBarrierException e) {
            // ...
        }
    }

    private void doSomething() {
    }

    private int getStepCount() {
        return stepCount;
    }
}

public static void main(String[] args) {
    final ExecutorService exec = Executors.newCachedThreadPool();
    int threadCount = 3;
    final Counter cycleCount = new Counter();

    // 注意构造方法的参数
    CyclicBarrier barrier = new CyclicBarrier(threadCount, new Runnable() {
        @Override
        public void run() {
            // 当所有threadCount线程结束时，执行到这里。
            System.out.println("All Thread has done." + cycleCount.count);
            cycleCount.count++;
            if (cycleCount.count == 2) {
                exec.shutdownNow();
            }
        }
    });
    for (int i = 0; i &lt; threadCount; i++) {
        exec.execute(new Horse(String.valueOf(i), barrier));
    }
}

private static class Counter {
    int count = 0;
}
</code></pre>

<p>}</p>

<p>/<em>output:
Thread 1 is doing.
Thread 2 is doing.
Thread 0 is doing.
Thread 1 has done.
Thread 2 has done.
Thread 0 has done.
All Thread has done.0
Thread 0 is doing.
Thread 1 is doing.
Thread 2 is doing.
Thread 2 has done.
Thread 1 has done.
Thread 0 has done.
All Thread has done.1
</em>/
```</p>

<h3>6.3 DelayQueue</h3>

<p>DelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。队列是有序的，延迟时间最长的对象最先取出。可以使用多种获取方法：poll(取出并从队列删除，不等待), take(取出并从队列删除，如果队列中还没有则等待), peek(取出但不从队列删除，不等待，可能会返回未过期的)，详细区别见JavaDoc。</p>

<p>DelayQueue适合的场景包括：</p>

<ol>
<li>关闭空闲连接。服务器中，有很多客户端的连接，空闲一段时间之后需要关闭之。</li>
<li>缓存。缓存中的对象，超过了空闲时间，需要从缓存中移出。</li>
<li>任务超时处理。在网络协议滑动窗口请求应答式交互时，处理超时未响应的请求。</li>
</ol>


<h3>6.4 PriorityBlockingQueue</h3>

<p>这是一个很基础的优先级队列，具有可阻塞的读取操作。放入该队列的对象实现Comparable接口就可以轻松实现优先级调度了，优先级越小则优先级越高。代码示例：</p>

<p>```java
PriorityBlockingQueue<Runnable> queue =</p>

<pre><code>    new PriorityBlockingQueue&lt;Runnable&gt;();
</code></pre>

<p>ExecutorService exec = Executors.newCachedThreadPool();
exec.execute(new Producer(queue, exec));
exec.execute(new Consumer(queue));
```</p>

<h3>6.5 ScheduledExecutor</h3>

<p>通过使用ScheduledExecutor.schedule()（运行一次任务）或者scheduleAtFixedRate()（每隔规则的时间重复执行任务），你可以将Runnable对象设置为在将来的某个时刻执行。代码示例：</p>

<p>```java
public class SheduledThreadDemo {</p>

<pre><code>ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor(10);

public void repeat(Runnable event, long initialDelay, long period) {
    scheduler.scheduleAtFixedRate(event, initialDelay, period, TimeUnit.SECONDS);
}

public void schedule(Runnable event, long delay) {
    scheduler.schedule(event, delay, TimeUnit.SECONDS);
}
</code></pre>

<p>}
```</p>

<h3>6.6 Semaphore</h3>

<p>普通的锁（concurrent.locks或synchronized锁）在任何时刻都只允许一个任务访问一项资源，而<strong>计数信号量</strong>允许n个任务同时访问这个资源。作为一个示例，Pool是一个对象池，管理者数量有限的对象，要使用对象可以先签出，用完后再签入。</p>

<p>Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。比如在Windows下可以设置共享文件的最大客户端访问个数。</p>

<p>Semaphore实现的功能就类似厕所有5个坑，假如有10个人要上厕所，那么同时只能有多少个人去上厕所呢？同时只能有5个人能够占用，当5个人中 的任何一个人让开后，其中等待的另外5个人中又有一个人可以占用了。另外等待的5个人中可以是随机获得优先机会，也可以是按照先来后到的顺序获得机会，这取决于构造Semaphore对象时传入的参数选项。单个信号量的Semaphore对象可以实现互斥锁的功能，并且可以是由一个线程获得了“锁”，再由另一个线程释放“锁”，这可应用于死锁恢复的一些场合。</p>

<p>```java
public class Pool<T> {</p>

<pre><code>private int size;
private List&lt;T&gt; items = new ArrayList&lt;T&gt;();
private volatile boolean[] checkedOut; //跟踪被签出的对象
private Semaphore available;

public Pool(Class&lt;T&gt; classObject, int size) {
    this.size = size;
    checkedOut = new boolean[size];
    available = new Semaphore(size, true); //size个许可，先进先出:true
    for(int i = 0; i &lt; size; ++i) {
        try {
            //Assums a default constructor
            items.add(classObject.newInstance());
        } catch(Exception e) {
            throw new RuntimeException(e);
        }
    }
}

public T checkOut() throws InterruptedException {
    available.acquire(); //从Semaphore获取一个许可，如果没有将阻塞
    return getItem();
}

public void checkIn(T x) {
    if (releaseItem(x))
        //释放一个permit，返回到Semaphore， 可用许可加1
        available.release();
}

private synchronized T getItem() {
    for(int i=0; i &lt; size; ++i) {
        if (! checkedOut[i]) {
            checkedOut[i] = true;
            return items.get(i);
        }
    }

    return null;
}

private synchronized boolean releaseItem(T item) {
    int index = items.indexOf(item);
    if (index == -1) return false;
    if (checkedOut[index]) {
        checkedOut[index] = false;
        return true;
    }

    return false;
}
</code></pre>

<p>}
```</p>

<h3>6.7 Exchanger</h3>

<p>Exchanger用于实现两个人之间的数据交换，每个人在完成一定的事物后想与对方交换数据，第一个先拿出数据的人将一直等待第二个人拿着数据到来时，才能彼此交换数据。</p>

<p>好比两个毒贩要进行交易，一手交money，一手交drug，不管谁先来到接头地点后，就处于等待状态了，当另外一方也到达接头地点时，两者的数据就立即交换了，然后就可以各忙各的了。</p>

<p>示例代码如下和运行结果如下：</p>

<p>```java
public class ExchangerTest {</p>

<pre><code>public static void main(String[] args) {
    ExecutorService service = Executors.newCachedThreadPool();
    final Exchanger&lt;String&gt; exchanger = new Exchanger&lt;String&gt;();
    service.execute(new Runnable() {
        public void run() {
            try {
                String data1 = "money";
                System.out.println("线程"
                        + Thread.currentThread().getName() 
                        + "正在把数据" + data1 + "换出去");
                Thread.sleep((long) (Math.random() * 10000));
                String data2 = (String) exchanger.exchange(data1);
                System.out.println("线程"
                        + Thread.currentThread().getName() 
                        + "换回数据为" + data2);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    });
    service.execute(new Runnable() {
        public void run() {
            try {
                String data1 = "drug";
                System.out.println("线程"
                        + Thread.currentThread().getName() + "正在把数据"
                        + data1 + "换出去");
                Thread.sleep((long) (Math.random() * 10000));
                String data2 = (String) exchanger.exchange(data1);
                System.out.println("线程"
                        + Thread.currentThread().getName() + "换回数据为"
                        + data2);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    });
}
</code></pre>

<p>}</p>

<p>/<em>* output:
线程pool-1-thread-1正在把数据money换出去
线程pool-1-thread-2正在把数据drug换出去
线程pool-1-thread-2换回数据为money
线程pool-1-thread-1换回数据为drug
</em>/
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java并发编程（二）]]></title>
    <link href="http://blog.ubone.com/blog/2014/09/02/javabing-fa-er/"/>
    <updated>2014-09-02T21:03:49+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/09/02/javabing-fa-er</id>
    <content type="html"><![CDATA[<p>本文是《Java编程思想》第21章并发的读书笔记。<a href="/blog/2014/08/30/javabing-fa-bian-cheng/">Java并发编程（一）</a></p>

<!--more-->


<h2>3. 终结任务</h2>

<h3>3.1 阻塞</h3>

<p>一个任务进入阻塞状态，可能有如下原因：</p>

<ol>
<li>调用sleep(milliseconds)</li>
<li>调用wait()挂起线程，直到线程得到了notify()或notifyAll()（Java5中的signal或signalAll）</li>
<li>等待某个输入/输出完成</li>
<li>试图在某个对象上调用同步控制方法，但对象锁不可用。</li>
</ol>


<p>早期代码中还有suspend()和resume()来阻塞和唤醒线程，但现在已经被废止了（可能导致死锁），还有stop()也已经废止了（因为不释放线程获得的锁）。</p>

<h3>3.2 中断</h3>

<p>有几种方法中断线程。</p>

<p>一是声明一个变量canceled，然后正常的run方法中循环检查它的值，从而决定是否跳出循环，退出run方法。</p>

<p>二是调用Thread类的interrupt()方法，该方法提供了离开run()循环而不抛出异常的第二种方式。这种方式必须持有Thread对象。</p>

<p>如果调用Executor的shutdownNow()，那么它将发送一个interrupt()调用给它启动的所有线程。如果想只中断某一个线程，可以使用Future的cancel方法。下面是各种中断的示例：</p>

<h4>中断Sleep Runnable</h4>

<p>```java
public class ThreadInterrupt {</p>

<pre><code>public static void main(String[] args) {
    ExecutorService exec = Executors.newCachedThreadPool();
    Future f = exec.submit(new SleepInterruptThread());
    try {
        TimeUnit.SECONDS.sleep(1);
        f.cancel(true);

    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println("退出主程序");
}
</code></pre>

<p>}</p>

<p>public class SleepInterrupt implements Runnable {</p>

<pre><code>@Override
public void run() {
    try {
        TimeUnit.SECONDS.sleep(10);
        System.out.println("end sleep 10s");
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    System.out.println("exit SleepInterrupt run");
}
</code></pre>

<p>}
```</p>

<p>上面的代码可以正常中断Sleep线程，捕获了InterruptedException异常。</p>

<h4>中断Sleep Thread</h4>

<p>```java
public class ThreadInterrupt {</p>

<pre><code>public static void main(String[] args) {
    Thread f = new SleepInterruptThread();
    f.start();
    try {
        TimeUnit.SECONDS.sleep(1);
        f.interrupt();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println("退出主程序");
}
</code></pre>

<p>}</p>

<p>public class SleepInterruptThread extends Thread {</p>

<pre><code>@Override
public void run() {
    try {
        TimeUnit.SECONDS.sleep(5);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    System.out.println("exit SleepInterrupt run");
}
</code></pre>

<p>}</p>

<p>```</p>

<p>上面的代码可以正常中断Sleep线程，捕获了InterruptedException异常。</p>

<h4>中断IO线程</h4>

<p>```java
public class ThreadInterrupt {</p>

<pre><code>public static void main(String[] args) {
    ExecutorService exec = Executors.newCachedThreadPool();
    Future f = exec.submit(new IOInterrupt(System.in));
    try {
        TimeUnit.SECONDS.sleep(1);
        f.cancel(true);

    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println("退出主程序");
}
</code></pre>

<p>}</p>

<p>public class IOInterrupt implements Runnable {</p>

<pre><code>private InputStream in;

public IOInterrupt(InputStream is) {
    in = is;
}

@Override
public void run() {
    try {
        in.read();
    } catch (IOException e) {
        e.printStackTrace();
    }

    System.out.println("exit run");
}
</code></pre>

<p>}</p>

<p>```
<strong>对于IO阻塞线程，则无法进行中断！从catch语句中没有InterruptedException也可以看出。</strong>同样无法中断的还有SynchronizedBlocked，也就是如果线程进入synchronized方法或临界区中后，将无法中断。</p>

<p>对于网络访问这样的IO阻塞，如果不能中断有时挺烦人的。一个较笨的办法是关闭底层资源（例如关闭连接。）示例如下：</p>

<p><code>java
InputStream socketInput = new Socket("localhost", 8080).getInputStream();
exec.execute(new IOBlocked(socketInput));
//...
exec.shutdownNow(); //无法中断线程
//...
socketInput.close(); //关闭后，解除阻塞。
</code></p>

<p><strong>Java提供的各种nio类具有更人性化的I/O中断，被阻塞的nio通道会自动地响应中断。</strong></p>

<p><strong>synchronized方法或临界区上的阻塞，存在锁住程序的可能。而ReentrantLock上的阻塞则具备被中断的能力。</strong>例如当线程1 lock后，线程2也请求lock，在等待的过程中将产生阻塞，调用Thread.interrupt或Future.cancel可以将其中断。</p>

<h3>3.3 检查中断</h3>

<p>当你在线程上调用interrupt()时，如何保证安全地退出run方法，释放该释放的资源？</p>

<p>如果类必须响应interrupt()，那么就必须建立一种策略。当创建了需要清理的对象后，就必须紧跟try-finally子句，使得无论run()循环如何退出，都能正常清理。</p>

<h2>4. 线程之间的协作</h2>

<h3>4.1 wait()与notifyAll()</h3>

<p>调用sleep()和yield()时，锁并没有被释放。而调用wait()时，线程的执行被挂起，对象上的锁被释放。wait()表示无限期等待下去，直到notify或notifyAll，它也可以传入参数表示时间到期后恢复。当wait恢复时，会首先重新获取进入wait时释放的锁，在这个锁变为可用之前，是不会被唤醒的。</p>

<p><strong>只能在同步控制方法或者同步控制块里调用wait(), notify()和notifyAll()！</strong>否则虽然能够编译通过，但运行时将报异常：IllegalMonitorStateException。为什么要这样设计？<a href="http://javarevisited.blogspot.sg/2011/05/wait-notify-and-notifyall-in-java.html">这篇博客</a>作了解释。如果不这样做，就没有锁，就可能导致下一节中的“错失的信号”。</p>

<p>当从wait唤醒时，往往需要判断特定条件是否满足，如果不满足就返回到wait中，惯用的方法就是使用while来编写这种代码。下例是一个汽车打蜡抛光的示例，其它两个线程未列出。</p>

<p>```java
class Car {
private boolean waxOn = false;
public synchronized void waxed() {
waxOn = true;
notifyAll();
}
public synchronized void buffed() {
waxOn = false;
notifyAll();
}
public synchronized void waitForWaxing() throws InterruptedException {
while (waxOn == false) {
wait();
}
}
public synchronized void waitForBuffing() throws InterruptedException {
while (waxOn == true) {
wait();
}
}
}</p>

<p>```</p>

<h4>错失的信号</h4>

<p>当两个线程协作时，要特别注意可能会错过某个信号，例如下例T1通知T2，但是有可能T2收不到这个信号：</p>

<p>```java
T1:
synchronized(shareMonitor) {</p>

<pre><code> //&lt;setup condition for T2&gt;
 shareMonitor.notify();
</code></pre>

<p>}</p>

<p>T2:
while(someCondition) {</p>

<pre><code> //Point 1
 synchronized(shareMonitor) {
      shareMonitor.wait();
 }
</code></pre>

<p>}
```</p>

<p>以上代码运行到Point1时，如果调度到了T1，则T2收不到通知，就会永远在那里等待。T2正确的做法是：</p>

<p>```java
synchronized(shareMonitor) {</p>

<pre><code> while(someCondition) {
      shareMonitor.wait();
 }
</code></pre>

<p>}
```</p>

<h3>4.2 notify()与notifyAll()</h3>

<p>两者的不同之处在于，前者只唤醒一个线程，而后者唤醒同一锁定的所有线程。当有多个等待线程时，notify唤醒哪一个线程由调度决定。notifyAll唤醒多个线程后，它们将先为锁而战，先取得锁的线程先执行。</p>

<p>什么情况下使用notify或者notifyAll？在多个等待的线程中，如果它们都在等同一个条件，并且当条件变为真时，只有一个线程从中受益，那么用notify比notifyAll更好，因为它避免浪费CPU循环。 notify()只唤醒其中一个。因此当你使用notify时要确保只唤醒正确的那个。</p>

<p>notifyAll并不是唤醒所有等待线程，而是等待某个特定锁的所有线程。</p>

<h3>4.3 生产者和消费者</h3>

<p>除了wait()、notify()和notifyAll()方法用于同步方法或者同步代码块外，也可以使用Lock、Condition、await()、signal()和signalAll()方法。示例如下：</p>

<p>```java
class Car {</p>

<pre><code>private Lock lock = new ReentrantLock();
private Condition condition = lock.newCondition();
private boolean waxOn = false;
public void waxed() {
    lock.lock();
    try {
        waxOn = true;
        condition.signalAll();
    } finally {
        lock.unlock();
    }
}

public void waitForWaxing() throws InterruptedException {
    lock.lock();
    try {
        while (waxOn == false) 
            condition.await();
    } finally {
        lock.unlock();
    }
}

//...
</code></pre>

<p>}
```</p>

<p>注意，每个lock()的调用都必须紧跟一个try-finally子句，以保证所有情况都可以释放锁。在await()、signal()或signalAll()之前，必须拥有这个锁。</p>

<p>使用wait()和notifyAll()这样的方法来解决任务互操作的问题比较复杂。在典型的生产者-消费者实现中，常使用先进先出队列来存储被生产和消费的对象。BlockingQueue接口提供了这样的同步队列，该接口有多种实现，常见的是LinkedBlockingQueue和ArrayBlockingQueue(固定尺寸)。</p>

<p>如果消费者试图从队列中获取对象，而此时该队列为空，那么消费者将挂起，直到队列中有可消费的内容。阻塞队列可以解决很多问题，比wait()和notifyAll()相比，要简单得多，也更加可靠。示例如下：</p>

<p>```java
class LiftOffRunner implements Runnable {</p>

<pre><code>private BlockingQueue&lt;LiftOff&gt; rockets;
public LiftOffRunner(BlockingQueue&lt;LiftOff&gt; queue) {
    rockets = queue;
}

public void add(LiftOff lo) {
    try {
        rockets.put(lo);
    } catch(InterruptedException e) {
        print("Interrupted during put");
    }
}

public void run() {
    try {
        while(! Thread.interrupted)) {
            LiftOff rocket = rockets.take(); //阻塞直至rockets中有东西
            rocket.run();
        }
    } catch(InterruptedException e) {
        print("Exiting LiftOffRunner");
    }
}
</code></pre>

<p>}</p>

<p>//其它线程可以往rockets中添加内容，无需同步方法或者锁。
```</p>

<h3>4.4 任务间使用管道进行输入/输出</h3>

<p>通过输入/输出在线程间进行通信也很有用。这种管道在Java IO库中的对应物就是PipedWriter类和PipedReader类。这也是“生产者-消费者”的变体。示例如下：</p>

<p>```java
class Sender implements Runnable {</p>

<pre><code>private PipedWriter out = new PipedWriter();
public PipedWriter getWriter() { return out;}
public void run() {
    try {
        while (true) {
            for(char c = 'A'; c &lt;= 'z'; c++) {
                out.write(c);
                TimeUnit.MILLISECONDS.sleep(rand.nextInt(500));
            }
        }
    } catch(IOException e) {
        //...
    } catch(InterruptedException e ) {
        //...
    }
}
</code></pre>

<p>}</p>

<p>class Receiver implements Runnable {</p>

<pre><code>private PipedReader in;
public Receiver(Sender sender) {
    in = new PipedReader(sender.getWriter());
}

public void run() {
    try {
        while (true) {
            print("read: " + (char) in.read());
        }
    } catch (IOException e) {
        //...
    }
}
</code></pre>

<p>}</p>

<p>//与普通I/O不能interrupt不同，PipedReader是可以中断的。</p>

<p>```</p>

<p>相比之下，BlockingQueue使用起来更加健壮而容易。</p>

<h2>5. 死锁</h2>

<p>当以下四个条件同时满足时，就会发生死锁：</p>

<ol>
<li>互斥条件。任务使用的资源中至少有一个是不能共享的。</li>
<li>至少有一个任务必须持有一个资源且正在等待获取一个当前被别的任务持有的资源。</li>
<li>资源不能被任务抢占，任务必须把资源释放当作普通事件。</li>
<li>必须有循环等待。A等待B持有的资源，B又等待C持有的资源，这样一直下去之后，直到X在等待A所持有的资源。</li>
</ol>


<p>要防止死锁，只需破坏上述四条中的任意一条。破坏第4条是最容易的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java并发编程（一）]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/30/javabing-fa-bian-cheng/"/>
    <updated>2014-08-30T21:58:15+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/30/javabing-fa-bian-cheng</id>
    <content type="html"><![CDATA[<p>本文是《Java编程思想》第21章并发的读书笔记。</p>

<!--more-->


<p>操作系统：抢占式（调度机制会周期性地中断线程，将上下文切换到另一个线程）、协作式（每个任务自己放弃控制）。</p>

<h2>1. 基本线程机制</h2>

<h3>1.1 定义任务</h3>

<p>```java
public class LiftOff implements Runnable {</p>

<pre><code> public void run() {
      //...
      Thread.yield(); //声明，我已经干完重要的事，可以把CPU让给其他任务了。
 }
</code></pre>

<p>}
```</p>

<h3>1.2 Thread类</h3>

<p><code>java
Thread t = new Thread(new LiftOff());
t.start();
</code></p>

<h3>1.3 使用Executor</h3>

<p>```java
ExecutorService exec = Executors.newCachedThreadPool(); //or newFixedThreadPool, newSingleThreadExecutor
exec.execute(new LiftOff());</p>

<p>exec.shutdown(); //防止加入新任务。
```</p>

<h3>1.4 从任务中产生返回值</h3>

<p>Runnable不返回任何值，Callable接口可以返回值。两者的区别只是后者的方法是call()而不是run()。</p>

<p>```java
class TaskWithResult implements Callable<String> {</p>

<pre><code> public String call() {
      return "result";
 }
</code></pre>

<p>}</p>

<p>ExecutorService exec = Executors.newSingleThreadExecutor();
Future<String> future = exec.submit(new TaskWithResult());
String result = future.get(); //get方法会一直等线程结束后返回结果。isDone()查询Future是否已经完成。
```</p>

<h3>1.5 休眠</h3>

<p>```java
public class SleepingTask extends LiftOff {</p>

<pre><code> public void run() {
      try {
           while(countDown-- &gt; 0) {
                //...
                TimeUnit.MILLISECONDS.sleep(100);
           }
      } catch(InterruptedException e) {
           //...
      }
 }
</code></pre>

<p>}
```</p>

<h3>1.6 优先级</h3>

<p>```java</p>

<pre><code> public void run() {
      Thread.currentThread().setPriority(Thread.MAX_PRIORITY);
 }
</code></pre>

<p>```</p>

<p>Windows有7个优先级， Solaris有2<sup>31</sup>个优先级。各操作系统不一致，因此建议只使用三个优先级：Thread.MAX_PRIORITY, NORM_PRIORITY, MIN_PRIORITY。</p>

<h3>1.7 后台线程</h3>

<p>后台线程指程序运行时在后台提供通用服务的线程，并且不属性程序中不可或缺的部分。<strong>当所有非后台线程结束时，程序就终止了，同时会杀死所有后台线程。</strong>如果有非后台线程还在运行，则程序不会终止。</p>

<p>要设置为后台线程，必须在线程启动之前调用setDaemon()方法。</p>

<p>```java</p>

<pre><code> Thread daemon = new Thread(new LiftOff() );
 daemon.setDaemon(true); //必须在start()方法前调用
 daemon.start(); 
</code></pre>

<p>```</p>

<p>可以通过定制的ThreadFactory创建后台线程，例如：</p>

<p>```java
public class DaemonThreadFactory implements ThreadFactory {</p>

<pre><code> public Thread newThread(Runnable r) {
      Thread t = new Thread(r);
      t.setDaemon(true);
      //还可以设置优先级、名称等，这些将成为新线程的默认值。

      return t;
 }
</code></pre>

<p>}</p>

<p>ExecutorService exec = Executors.newCachedThreadPool(new DaemonThreadFactory()); //这个Factory将用于创建新的线程。
exec.execute(new LiftOff());
```</p>

<p><code>isDaemon()</code>方法用于判断是否后台线程。后台线程创建的任何线程都将自动设置为后台线程。</p>

<p>注意！对于后台线程，在不会执行<code>finally</code>子句的情况下就会终止其<code>run()</code>方法：</p>

<p>```java
class ADaemon implements Runnable {</p>

<pre><code>public void run() {
    try {
        //...
        TimeUnit.SECONDS.sleep(1);
    } catch(InterruptedException e) {
        //...
        //注意，此时已经是false, 因为异常被捕获时将清理这个标志
        print("isInterrupted(): " + isInterrupted()); 
    } finally {
        print("会运行到这吗？")
    }
}
</code></pre>

<p>}</p>

<p>public class DaemonsDontRunFinally {</p>

<pre><code>public static void main(String[] args) {
    Thread t = new Thread(new ADaemon());
    t.setDaemon(true);
    t.start();
}
</code></pre>

<p>}
```</p>

<p>一旦<code>setDaemon(true)</code>，finally并没有被执行。因为一旦main结束，所有后台线程就立即终止了。</p>

<h3>1.8 编码的变体</h3>

<p>除了实现Runnable，也可以直接继承Thread类。但是由于Java不支持多重继承，所以继承自Thread适应的场景要少一些。</p>

<p>```java
private class SampleThread extends Thread{</p>

<pre><code>public SampleThread() {
    super("线程名称");  //线程名称可通过getName()获取。
}

public void run() {
    //...
}
</code></pre>

<p>}
```</p>

<p>自管理的Runnable</p>

<p>```java
public class SelfManaged implements Runnable {</p>

<pre><code>private Thread t = new Thread(this);
public SelfManaged() {
    t.start();  //注，不建议在构造器中启动线程，可能会有问题，建议使用Executor
}

public void run() {
    //...
}

public static void main(String[] args) {
    new SelfManaged();
}
</code></pre>

<p>}
```</p>

<h3>1.9 加入一个线程</h3>

<p>某个线程在另一个线程t上调用<code>t.join()</code>方法，此线程被挂起，直到t线程结束（即<code>t.isActive() == false</code>）。join方法也可以加超时参数，表示如果时间到期还未结束的话，join()方法总能返回。</p>

<h3>1.10 捕获异常</h3>

<p>线程中的未捕获的异常会导致系统不稳定，但常规方法并不能在外面捕获这些异常，因此需要借助特殊处理。下面的例子创建了一个新类型的ThreadFactory，它将在每个新创建的Thread对象上附着一个Thread.UncaughtExceptionHandler。</p>

<p>```java
class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {</p>

<pre><code>@Override
public void uncaughtException(Thread t, Throwable e) {
    // TODO Auto-generated method stub
}
</code></pre>

<p>}</p>

<p>class HandlerThreadFactory implements ThreadFactory {</p>

<pre><code>@Override
public Thread newThread(Runnable r) {
    Thread t = new Thread(r);
    t.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());

    return t;
}
</code></pre>

<p>}</p>

<p>ExecutorService exec = Executors.newCachedThreadPool(new HandlerThreadFactory());
exec.execute(new SomeThread());
```</p>

<p>如果你知道将要在代码中处处使用相同的异常处理器，那么更简单的方式是在Thread类中设置一个表态域，示例如下：</p>

<p><code>
Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandler());
</code></p>

<h2>2. 共享受限资源</h2>

<h3>2.1  解决共享资源竞争</h3>

<p>Java提供了关键字synchronized，为防止资源冲突提供支持。如果某个线程处于一个对synchronized方法的调用中，那么这个线程在从该方法返回之前，其它所有调用类中任何synchronized方法的线程都会被阻塞。也就是说，对于某个特定对象来说，其所有synchronized方法共享同一个锁。</p>

<p>线程可以多次获得对象的锁，例如先调用synchronized方法获得锁后，又调用该类的其它方法获得锁。JVM会跟踪对象加锁的计数，每次调用加1，离开synchronized方法时减1。当计数变为0则锁被完全释放。</p>

<p>synchronized static方法可以在类的范围内防止对static数据的并发访问。</p>

<p>如果你正在写一个变量，它可能接下来被另一个线程读取，或者在读取一个上一次已经被另一个线程写过的变量，那么你必须使用同步，并且，读写线程都必须用相同的监视器锁同步。</p>

<p>Lock对象也用于解决共享资源竞争。它必须被显式地创建、锁定和释放。</p>

<p>```java
public class MutexEvenGenerator extends IntGenerator {</p>

<pre><code>private Lock lock = new ReentrantLock();
public int next() {
    lock.lock();
    try {
        //...

        //注意！必须在try中返回值，以避免lock.unlock之后将数据暴露给其它线程。
        return someValue; 
    } finally {
        lock.unlock();
    }

    //不要在这里返回值
}
</code></pre>

<p>}
```</p>

<p>Lock提供了更细粒度的控制能力。使用Lock，可以更加自由地控制锁。例如尝试获得锁，如果获取不到，可以先干点别的事：</p>

<p>```java
boolean captured = lock.tryLock();</p>

<p>//设置超时时间，超时则触发异常。
try {</p>

<pre><code>boolean captured = lock.tryLock(2, TimeUnit.SECONDS);
</code></pre>

<p>} catch(InterruptedException e) {
}</p>

<p>```</p>

<h3>2.2 原子性和易变性</h3>

<p>原子性可用于除long、double之外的所有基本类型上的“简单操作”（读取和写入）。可以保证它们会被当作不可分（原子）的操作来操作内存。但JVM在读取和写入64位（long和double变量）时，可以拆成两个32位操作。因此可能导致“字撕裂”。作为普通开发者，<strong>不要依赖原子操作而移除了同步，那会得不偿失。</strong></p>

<p>关键字<code>volatile</code>可以帮助获得原子性。<code>volatile</code>还确保了数据的可视性。当一个域声明为<code>volatile</code>时，那么只要对它进行了写操作，即使使用了本地缓存，其它读操作也可以看到这个修改。因为<code>volatile</code>域会被立即写入主内存中，而读取操作就发生在主存中。</p>

<p>非<code>volatile</code>域上的原子操作不必刷新到主存，因此其它任务读取该域时可能看不到新值（修改操作的任务可以看到新值）。如果多个任务(线程)在同时访问某个域，那么这个域就应该是<code>volatile</code>的，否则这个域就应该经由同步来访问。同步也会导致向主存刷新。</p>

<h3>2.3 原子类</h3>

<p>Java引入了AtomicInteger, AtomicLong, AtomicReference等特殊的原子性变量类，它们提供机器级别上的原子性。常规编程很少派上用场，但在涉及性能调优时，会有用武之地。</p>

<p>需要强调的是，Atomic类被设计用来构建java.util.concurrent中的类，因此只有在特殊情况下才在自己的代码中使用它们。通常依赖于锁（Lock, synchronized）更安全一些。</p>

<h3>2.4 临界区(Critical section)</h3>

<p>以下同步控制块就是临界区：</p>

<p>```java
synchronized(synObject) {</p>

<pre><code>//这部分代码一次只能被一个线程访问
</code></pre>

<p>}
```</p>

<p>使用同步控制块，可以防止整个方法都同步，显著提高性能。但要注意，上面例子中，只要没有退出同步控制块，那么被同步对象synObject的所有同步方法都无法被其它线程调用。</p>

<h3>2.5 线程本地存储</h3>

<p>去除变量共享，在线程本地存储也是防止共享资源冲突的一种方法。如果你有5个线程都要使用变量x所表示的对象，那么线程本地存储就会生成5个用于x的不同的存储块。ThreadLocal对象用于线程本地存储。</p>

<p>ThreadLocal对象通常当作静态域存储。示例如下：</p>

<p>```java
public class ThreadLocalVariableHolder {</p>

<pre><code>private static final ThreadLocal&lt;Integer&gt; value = new ThreadLocal&lt;Integer&gt;() {
    @Override
    protected synchronized Integer initialValue() {
        return 10;
    }
};

public static int get() {
    return value.get();
}

public static void increment() {
    value.set(value.get() + 1);
}
</code></pre>

<p>}</p>

<p>public class Accessor implements Runnable {</p>

<pre><code>@Override
public void run() {
    ThreadLocalVariableHolder.increment();
    //..
}
</code></pre>

<p>}
```</p>

<h2>慎用延迟初始化</h2>

<p>在并发编程时，延迟初始化可能导致问题。除非绝对必要，否则就不要使用延迟初始化。</p>

<p><code>java
//正常的初始化
private final FieldType field = computeFieldValue();
</code></p>

<p>如果要使用延迟初始化，就要使用同步方法，例如：</p>

<p>```java
private FieldType field;</p>

<p>synchronized FieldType getField() {</p>

<pre><code> if (field == null) {
      field = computeFieldValue();
 }

 return field;
</code></pre>

<p>}
```</p>

<p>如果出于性能考虑，需要对静态域使用延迟初始化，就使用<strong>Lazy initialization holder class</strong>模式：</p>

<p>```java
private static Class FieldHolder {</p>

<pre><code> static final FieldType field = computefieldValue();
</code></pre>

<p>}</p>

<p>static FieldType getField() { return FieldHolder.field; }
```</p>

<p>如果出于性能考虑，需要对实例域使用延迟初始化，就使用双重检查模式(Double check idiom)：
<code>java
private volatile FieldType field;
FieldType getField() {
FieldType result = field;
if (result == null) {
synchronized(this) {
result = field;
if (result == null) {
field = result = computeFieldValue();
}
}
}
return result;
}
</code></p>

<p>注意上面的代码：</p>

<ol>
<li>使用volatile很重要；</li>
<li>使用局域变量result可以提高性能。据称在作者的机器上使用局域变量要快25%。</li>
<li>对于静态域，没有必要使用双重检查，<strong>Lazy initialization holder class</strong>是更好的选择。</li>
<li>如果延迟初始化可以接受重复初始化的实例域，则可以省去第二次检查。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Java - 异常]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/28/effective-java-yi-chang/"/>
    <updated>2014-08-28T23:15:18+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/28/effective-java-yi-chang</id>
    <content type="html"><![CDATA[<p>Effective Java 通用程序设计，读书笔记：</p>

<ol>
<li>只对异常情况才使用异常</li>
<li>对可恢复的情况使用受检异常，对编程错误使用运行时异常</li>
<li>避免不必要地使用受检的异常</li>
<li>优先使用标准的异常</li>
<li>抛出与抽象相对应的异常</li>
<li>每个方法抛出的异常都要有文档</li>
<li>在细节消息中包含能捕获失败的消息</li>
<li>努力使失败保持原子性</li>
<li>不要忽略异常</li>
</ol>


<!--more-->


<h2>57 只对异常情况才使用异常</h2>

<p>永远不要将异常用于正常的控制流。下面的代码试图使用异常退出循环，这是有问题的：</p>

<p>```java
//有问题的代码
try {</p>

<pre><code> int i = 0;
 while(true)
      range[i++].climb();
</code></pre>

<p>} catch (ArrayIndexOutOfBoundsException e) {
}
```</p>

<p>设计良好的API不应该强迫客户端为了正常的控制流而使用异常。可以考虑提供“状态测试”方法，例如Iterator的next()方法有一个对应的“状态测试方法” hasNext()。</p>

<h2>58 对可恢复的情况使用受检异常，对编程错误使用运行时异常</h2>

<p>如果期望调用者能够适当地恢复，应该使用受检的异常。对于程序错误，则使用运行时异常。对于受检异常，可以提供一些辅助方法，通过这些方法调用者可以获得一些有助于恢复的信息。例如用户取款时余额不足，可以提供一个方法获取余额。</p>

<h2>59 避免不必要地使用受检的异常</h2>

<p>当以下两个条件都成立时，才使用受检异常：</p>

<ol>
<li>正确地使用API并不能阻止这种异常条件的产生（例如网络、文件）。</li>
<li>一旦产生异常，使用API的程序员可以立即采取有用的动作，这种负担被认为是正当的。</li>
</ol>


<p>把受检异常变成运行时异常的一种方法是，把这个抛出异常的方法分成两个方法，其中一个返回boolean，表明是否应该抛出异常。例如前述的hasNext()。</p>

<h2>60 优先使用标准的异常</h2>

<p>使用标准的异常至少有以下好处：</p>

<ol>
<li>API更加易于学习和使用</li>
<li>可读性更好</li>
<li>异常类越少，内存印迹（footprint）就越少，装载这些类的时间开销也越少。</li>
</ol>


<p>常见的可重用异常包括：</p>

<ol>
<li>IllegalArgumentException 非Null的参数值不正确</li>
<li>IllegalStateException 对于方法调用而言，对象状态不合适。</li>
<li>NullPointException</li>
<li>IndexOutOfBoundsException</li>
<li>ConcurrentModificationException 禁止并修改时，检测到对象的并发修改</li>
<li>UnsupportedOperationException</li>
</ol>


<h2>61 抛出与抽象相对应的异常</h2>

<p>更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常。这种做法也就是<strong>异常转译</strong>。</p>

<p>如果低层的异常对于调试导致高层异常的问题非常有帮助，使用异常链就很合适。大多数标准异常都支持链的构造器，如果不支持，可以利用Throwable的initCause方法设置原因。下面代码展示了异常转译和异常链：</p>

<p>```java
try{
&hellip;
} catch(LowerLevelException cause) {</p>

<pre><code> throw new HigherLevelException(cause);
</code></pre>

<p>}</p>

<p>class HigherLevelException extends Exception {</p>

<pre><code> HigherLevelException(Throwable cause) {
      super(cause);
 }
</code></pre>

<p>}
```</p>

<h2>62 每个方法抛出的异常都要有文档</h2>

<p>始终要单独地声明受检的异常，并利用Javadoc的<code>@throws</code>标记，准确地记录下抛出每个异常的条件 。如果一个方法可能抛出多个异常，不要使用“快捷方式”，声明它们的某个父类。永远不要声明一个方法“throws Exception”，因为它不仅没有提供任何有用的信息，而且掩盖了其它可能抛出的异常。</p>

<p>对于接口中的方法，在文档中记录下它可能抛出的未受检异常也很重要。也就是用Javadoc的<code>@throws</code>标记进行说明，但在方法的声明中不使用throws关键字。</p>

<h2>63 在细节消息中包含能捕获失败的消息</h2>

<p>为了捕获失败，异常的细节信息应该包含所有“对该异常有贡献”的参数和域的值。例如IndexOutOfBoundsException就包括了三个信息：上界、下界以及不在界内的下标值。但是包含大量的描述信息也没有什么意义，因为堆栈轨迹的用途是与源文件结合起来使用的。</p>

<p>异常的细节消息不应该与“用户层次的错误信息”混为一谈。</p>

<p>为了确保异常的细节消息中包含足够的能捕获失败的消息，通常在异常的构造器中引入这些信息。如：</p>

<p>```java
public IndexOutOfBoundsException(int lowerBound, int upperBound, int index) {</p>

<pre><code> ...
</code></pre>

<p>}
```</p>

<h2>64 努力使失败保持原子性</h2>

<p>一般而言，失败的方法调用应该使对象保持在被调用之前的状态。具有这种属性的方法称为具有失败原子性。</p>

<p>要实现失败原子性，最简单的办法是设计不可变对象。对于可变对象，可采取的办法包括：</p>

<ol>
<li>执行操作前，检查参数的有效性。</li>
<li>调整计算处理的顺序，使任何可能会失败的计算部分在对象状态被修改之前发生。</li>
<li>编写一段恢复代码。（这种办法主要用于永久性的数据结构，如磁盘）</li>
<li>在对象的一份临时拷贝上执行操作，操作完成后再用临时拷贝中的结果替换对象的内容。</li>
</ol>


<h2>65 不要忽略异常</h2>

<p>空的catch块会使异常达不到应有的目的。如果确实需要空catch块，至少也要包含一条说明，为什么可以忽略此异常。</p>

<p>如果在finally中return，将会丢失异常：</p>

<p>```java
public class LostException {</p>

<pre><code>public static void main(String[] args) {
    try {
        throw new RuntimeException("afsd");
    } finally {
        //将会隐藏前面抛出的异常
        return;
    }
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
