<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2014-08-26T22:22:10+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Effective Java-通用程序设计]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/22/effective-java-tong-yong-cheng-xu-she-ji/"/>
    <updated>2014-08-22T20:06:07+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/22/effective-java-tong-yong-cheng-xu-she-ji</id>
    <content type="html"><![CDATA[<p>Effective Java 通用程序设计，读书笔记：</p>

<ol>
<li>将局部变量的作用域最小化</li>
<li>for-each循环优先于传统的for循环</li>
<li>使用类库</li>
<li>如果需要精确值，就避免使用float和double</li>
<li>基本类型优先于装箱基本类型</li>
<li>如果其它类型更合适，则尽量避免使用字符串</li>
<li>小心字符串拼接的性能问题</li>
<li>通过接口引用对象</li>
<li>接口优先于反射机制</li>
<li>谨慎使用本地方法</li>
<li>谨慎进行优化</li>
<li>遵守普遍接受的命名惯例</li>
</ol>


<!--more-->


<h2>45 将局部变量的作用域最小化</h2>

<p>局部变量只在第一次使用它的地方声明。每个局部变量的声明都应该包含一个初始化表达式。</p>

<h2>46 for-each循环优先于传统的for循环</h2>

<p><code>for(String str : list)</code>这样的for-each语句在简洁性和预防Bug方面有着传统for循环无法比拟的优势，并且没有性能损失。但如果在遍历时删除、替换、前移等操作时，无法使用for-each语句。</p>

<h2>47 使用类库</h2>

<p>不要重新发明轮子，尽量使用标准类库。例如随机数应该使用Random.nextInt(int)，而不是自己去写一个生成随机数的类。Java程序员应该精通java.lang, java.util包中的内容，还应该熟悉java.io, Collection, concurrent类库。</p>

<h2>48 如果需要精确值，就避免使用float和double</h2>

<p>要计算精确的结果，可以使用BigDecimal，它还包括8种舍入模式。但是它的缺点是不太方便并且有性能上的损失。也可以自己处理小数点和舍入，使用int, long。数据数值没有超过9位十进制数字，可以使用int，如果不超过18位数字，可以使用long。如果可能超过18位，就必须使用BigDecimal</p>

<h2>49 基本类型优先于装箱基本类型</h2>

<p>也就是int，boolean等优先于Integer和Boolean等。下面方法的返回值是多少？</p>

<p>```java
public int compare(Integer first, Integer second) {</p>

<pre><code> return first &lt; second ? -1 : (first == second ? 0 : 1);
</code></pre>

<p>}</p>

<p>compare(new Integer(42), new Integer(42));  //结果为1
```</p>

<p>原因是装箱类型是对象引用，<code>first == second</code> 为false。除此之外，需要注意的是装箱类型可能是null，可能因此引起一些潜在隐患。而装箱类型的性能也可能是个问题（如创建和销毁对象中第5条“避免创建不必要的对象”中提到的循环累计时的Long性能不如long）/blog/2014/06/27/effective-java-chuang-jian-he-xiao-hui-dui-xiang/</p>

<h2>50 如果其它类型更合适，则尽量避免使用字符串</h2>

<ol>
<li>字符串不适合代替其它的值类型，例如从文件中的int值以字符串存在，读出后就应该还原成int类型。</li>
<li>字符串不适合代替枚举类型</li>
<li>字符串不适合代替聚集类型。如用001_003代表两个东西，更好的办法是用一个私有静态成员类。</li>
</ol>


<h2>51 小心字符串拼接的性能问题</h2>

<h2>52 通过接口引用对象</h2>

<p>养成用接口作为类型的习惯。如果没有合适的接口存在，完全可以用（基）类来引用对象。</p>

<h2>53 接口优先于反射机制</h2>

<p>反射机制是一种功能强大的机制，对于特定的复杂系统编程任务，它是非常必要的，但它也有一些缺点：</p>

<ol>
<li>丧失了编译时类型检查的好处</li>
<li>执行反射访问所需的代码笨拙而冗长</li>
<li>性能损失</li>
</ol>


<p>因此，如果你编写的程序必须要与编译时未知的类一起工作，如有可能，就应该仅仅使用反射机制来实例化对象，而访问对象时则使用编译时已知的某个接口或者父类。例如未知的类实现了Set，则可以用反射机制实例化它，但访问它的方法时，使用Set的方法。</p>

<h2>54 谨慎使用本地方法</h2>

<p>Java Native Interface(JNI)允许Java调用本地方法（指本地程序设计语言如C, C++编写的特殊方法）。Java早期时，本地方法的用途是访问特定平台的能力（如注册表）、访问遗留代码库和提高性能。但现在已经没有太大必要了。</p>

<h2>55 谨慎进行优化</h2>

<p>不要费力去编写快速的程序，应该努力编写好的程序。在设计API、数据格式时，一定要考虑性能的因素。例如API，如果后期将公有的类型变成可变的（mutable），可能会导致大量不必要的保护性拷贝，影响性能。同样地，在适合使用复合模式的公有类使用了继承，会把这个类永远与父类绑在一起，人为地限制了子类的性能。如果在API中使用实现类型而不是接口，就会被束缚在一个具体的实现上，即使将来出现了更快的实现你也无法使用。</p>

<h2>56 遵守普遍接受的命名惯例</h2>

<p>对于类型参数：</p>

<ul>
<li>T表示任意类型</li>
<li>E表示集合的元素类型</li>
<li>K和V表示Map的键和值</li>
<li>X表示异常</li>
<li>任何类型的序列可以是T, U, V或者T1, T2, T3</li>
</ul>


<p>对于转换对象的方法，返回不同类型的独立对象的方法，通常被称为toType，如toString, toArray。返回视图的方法通常称为asType，如asList。静态工厂的常用名称为valueOf, of, getInstance, newInstance, getType和newType。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Java-方法]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/20/effective-java-fang-fa/"/>
    <updated>2014-08-20T19:32:51+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/20/effective-java-fang-fa</id>
    <content type="html"><![CDATA[<p>读书笔记：</p>

<ol>
<li>检查参数的有效性</li>
<li>必要时进行保护性拷贝</li>
<li>谨慎设计方法签名</li>
<li>慎用重载</li>
<li>慎用可变参数</li>
<li>返回零长度的数组或者集合，而不是null
44. 为所有导出的API元素编写文档注释</li>
</ol>


<!--more-->


<h2>38 检查参数的有效性</h2>

<p>检查方法参数的有效性，以便更早地发现问题。对于公有方法，要用Javadoc的@throw标签在文档中说明违反参数限制时会抛出的异常。例如：IllegalArgumentException, IndexOutOfBundsException或NullPointerException。对于非公有方法，一般采用断言来检查参数。</p>

<p>通常在计算过程之前，应该进行有效性检查。但如果有效性检查工作成本较高，或者有效性检查已经隐含在计算过程中，那么就不用先进行检查。但计算过程中由于参数的问题造成的异常可能不是方法文档中标明的那个异常，此时可以使用异常转译（第61条）技术，将其转换为正确的异常。</p>

<h2>39 必要时进行保护性拷贝</h2>

<p>如果类的内部状态使用了客户端传入的对象，而该对象是可变的，那么尽量不要直接引用这个外部对象，而是将其复制一份。对于构造器的每个可变参数进行保护性拷贝是必要的。而且保护性拷贝应该在有效性检查之前进行。如果参数类型可以被不可信任方子类化，那么不要使用clone方法进行保护性拷贝。</p>

<p>对于访问方法(如get)，为了防御类似的攻击，可以返回内部属性的保护性拷贝。例如对于Date类属性，在返回时，可以新建一个Date对象返回。另一种方式是返回Date.getTime()，即返回long基本类型的时间。访问方法在进行保护性拷贝时，允许使用clone方法，原因是我们知道返回类型时什么，只要它不会是其他某个潜在不可信子类，就可以使用clone方法。</p>

<p>对于内部长度非零的数组，在返回给客户端之前，应该总是进行保护性拷贝。另一种解决方案是，返回数组的不可变视图。（见第13条）</p>

<p>如果类信任它的调用者不会修改内部组件，例如在同一个包中，那么不进行保护性拷贝也是可以的，但类文档中应该清楚说明，调用者绝不能修改受到影响的参数或返回值。</p>

<h2>40 谨慎设计方法签名</h2>

<ol>
<li>谨慎选择方法的名称。</li>
<li>不要过于追求提供便利的方法。每个方法都应该尽其所能，方法太多会使类难以学习。只有某一项操作经常使用时，才考虑为其提供快捷方式。</li>
<li>避免过长的参数列表。解决方法：一是将方法分解成多个方法；二是创建辅助类（一般为静态成员类），保存这些参数。三是使用Builder模式。</li>
</ol>


<p>对于参数类型，优先使用接口。</p>

<p>对于boolean参数，优先使用两个元素的枚举类型。它使代码更易于阅读和编写。而且未来扩展时，可以轻易增加更多状态。</p>

<h2>41 慎用重载</h2>

<p>下面的代码执行结果可能与预期不同：
```java
public static String classify(List&lt;?> list) {</p>

<pre><code> return "List";
</code></pre>

<p>}</p>

<p>public static String classify(Collection&lt;?> c) {</p>

<pre><code> return "Collection";
</code></pre>

<p>}</p>

<p>public static void main(String[] args) {</p>

<pre><code> Collection&lt;?&gt; c = new ArrayList&lt;BigInteger&gt;();
 System.out.println(classify(c));
 //结果是Collection
</code></pre>

<p>}
```</p>

<p>原因是重载(overload)方法的选择是静态的，即在编译期决定。而被覆盖(override)的方法的选择是动态的，即在运行时决定。在上面的例子中，程序编译时，参数的类型是Collection，所以打印的结果是Collection。正如<a href="/blog/2014/08/19/she-ji-mo-shi-fang-wen-zhe-mo-shi">访问者模式</a>提到的：</p>

<blockquote><p>Java语言支持静态的多分派和动态的单分派。对于Java方法重载（Overload），在编译期会根据方法的接收者类型和方法的所有参量类型进行分派，因此是静态多分派。而方法覆盖（Override），是在运行时仅仅根据方法的接收者类型进行分派。</p></blockquote>

<p>因此，安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法。如果方法使用了可变参数，最好是不要重载它。例如ObjectOutputStream类中，没有使用重载方法，而是对于每种类型都提供了read和write方法: writeBoolean(boolean), writeInt(int)。对于构造器，没有办法使用不同的方法名称，但可以使用静态工厂方法或者Builder模式。</p>

<p>Java 1.5的自动装箱出现之后，重载也导致了一些麻烦。例如下面的代码：</p>

<p>```java
List<Integer> list = new ArrayList<Integer>();
for(int i = -3; i &lt; 3; i++) {</p>

<pre><code> list.add(i);
</code></pre>

<p>}</p>

<p>for(int i= 0; i &lt; 3; i++) {</p>

<pre><code> list.remove(i);
</code></pre>

<p>}</p>

<p>System.out.println(&ldquo;list: &rdquo; + list);
//打印结果：list: [-2, 0, 2]
```</p>

<p>原因是List.remove是重载方法：<code>remove(int i); remove(Object o);</code> 所以为了达到预期效果，要改为：<code>list.remove((Integer)i);</code></p>

<p>因此，能够重载方法并不意味着就应该重载方法。请慎用重载方法。</p>

<h2>42 慎用可变参数</h2>

<p>可变参数接受0或多个指定类型的参数。如果希望参数最少要1个，则可以这样定义方法：</p>

<p><code>java
public void someOperation(int a, int... otherArgs) {
}
</code></p>

<h2>43 返回零长度的数组或者集合，而不是null</h2>

<p>如果返回null，那么客户端始终要进行null判断。返回零长度的数组或集合时，不用在这个级别担心性能问题。</p>

<h2>44 为所有导出的API元素编写文档注释</h2>

<p>其中要注意的是，文档注释也应该描述类或者方法的线程安全性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式系统的基础知识]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/22/fen-bu-shi-xi-tong-de-ji-chu-zhi-shi/"/>
    <updated>2014-07-22T20:04:40+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/22/fen-bu-shi-xi-tong-de-ji-chu-zhi-shi</id>
    <content type="html"><![CDATA[<p>这是一篇学习笔记，内容为《大型网站系统与Java中间件实践》的第一章。</p>

<p>组成计算机的5要素为：输入、输出、运算器、控制器、存储器（内存、外存）。分布式系统也一样，可以分为这5个要素。因此这本书会对分布式系统中，这5个要素的变化进行说明。</p>

<!--more-->


<p>阿姆达尔定律（Amdahl&rsquo;s law）说明程序中可以并行的代码的比例，决定了你增加处理器能带来的速度提升的上限。</p>

<p>```
S(N) = 1 / ((1 &ndash; P) + P / N)</p>

<p>P: 可并行的程序在单核上执行时间的占比
N: 处理器的个数
S(N): 程序在N个处理器（总核心数）相对于单个处理器中的速度提升比。</p>

<p>当P=0.2, S(N)的上限为1.25
当P=0.5, S(N)的上限为2
```</p>

<p>根据阿姆达尔定律，提升P非常的重要！</p>

<h2>1.多线程模式</h2>

<p>这里所说的多线程，是指单进程内的多线程。</p>

<h3>1.1互不通信的多线程模式</h3>

<p>线程之间没有交集，各自执行各自的任务和逻辑。这种模式的编程最简单，与单线程差不多。</p>

<h3>1.2基于共享容器的多线程模式</h3>

<p>例如多个线程共用一个队列。对于存储数据的容器或者对象，分为线程安全和线程不安全。</p>

<ul>
<li>如果是线程不安全的，一般可以通过加锁或者Copy On Write（COW）的方式控制并发。对于加锁的情况，如果是读多写少，可以用读写锁而不是互斥锁。</li>
<li>如果是线程安全的，就可以直接使用。</li>
</ul>


<h3>1.3通过事件协同的多线程模式</h3>

<p>某个线程需要等到某个状态或者事件发生后才能继续自己的工作，而这个状态或者事件与另一个线程有关，这时候就需要完成线程间的协调。<strong>为了防止死锁，一般要原子性地获取所需的多个锁，或者注意以相同的顺序获取多个锁。</strong></p>

<p>```java
//原子性地获取多个锁
Thread 1
GetLocks(A, B); //伪代码，一次性获取两个锁，不同平台支持不同。</p>

<p>Thread 2
GetLocks(A, B);</p>

<p>//或者同样的顺序获取多个锁
Thread 1
A.lock();</p>

<pre><code>B.lock();
</code></pre>

<p>Thread 2
A.lock();</p>

<pre><code>B.lock();
</code></pre>

<p>//两个线程的加锁顺序一致，如果Thread 2中的顺序反过来，则很可能造成锁死。</p>

<p>```</p>

<h2>2.多进程模式</h2>

<p>进程之间的内存空间是独立的，因此多进程相对会容易一些。但也正因为内存空间独立，因此数据共享就涉及序列化和反序列化。</p>

<p>对于多进程，单个进程的问题不会造成整体的不可用。</p>

<h2>3.网络基础</h2>

<h3>3.1 OSI七层模型</h3>

<p>OSI七层模型还记得？从上到下依次是：</p>

<ul>
<li>应用层：为应用程序（如Email）提供网络服务。</li>
<li>表示层：确保一个应用层发送的信息可被另一个系统的应用层读取。</li>
<li>会话层：通过传输层建立数据传输的通路。</li>
<li>传输层：定义传输数据的协议和端口。</li>
<li>网络层：在位于不同位置的网络中的两个主机系统之间提供连接和路径选择。</li>
<li>数据链路层：定义如何让格式化数据以进行传输。</li>
<li>物理层：定义物理设备标准，传输比特流。</li>
</ul>


<h3>3.2 网络IO实现方式</h3>

<ul>
<li>BIO（Blocking IO），阻塞方式，一个Socket需要一个线程来处理。</li>
<li>NIO（Nonblocking IO），基于事件驱动思想，采用Reactor模式。</li>
<li>AIO (Asynchronous IO)，异步IO，采用Proactor模式。</li>
</ul>


<p>Reactor模式和Proactor模式，后续要再研究一下。</p>

<h2>4.从单机到分布式</h2>

<h3>4.1 输入、输出设备的变化</h3>

<p>除了传统意义的人机交互输入、输出设备，分布式环境中的其它节点也可以看作是输入或输出设备。</p>

<h3>4.2 控制器的变化</h3>

<p>在单机中，控制器是CPU中的控制器。在分布式系统中，控制器是控制方式。</p>

<ol>
<li>使用硬件负载均衡</li>
<li>使用软件负载均衡，如LVS</li>
<li>通过名称服务器</li>
<li>通过规则服务器</li>
<li>Master + Worker的方式</li>
</ol>


<p>前面两种一般称为透明代理。有两种缺点，一是增加了流量，即代理服务器与请求处理服务器之间多了一次发送和返回。当然，LVS通过配置，可以将请求的处理结果直接返回给客户端，不通过中间代理。二是如果代理出现问题，会影响到所有请求。</p>

<p>第三、四种控制方式，都是客户端先访问名称服务器或者规则服务器，得到真正的请求处理服务器地址，然后直接与该地址进行连接。</p>

<p>第五种一般用来管理任务，由Master把任务分给不同的Worker处理。</p>

<h3>4.3 运算器的变化</h3>

<p>分布式系统中的运算器包括多个节点的计算能力。</p>

<ol>
<li>通过DNS解析，实现调度和控制</li>
<li>使用负载均衡设备或软件</li>
<li>使用Master+Worker方式</li>
<li>使用规则服务器等。</li>
</ol>


<h3>4.4 存储器的变化</h3>

<p>与前面的类似，也可以通过：</p>

<ol>
<li>直接访问存储服务器</li>
<li>通过代理服务器访问存储服务器</li>
<li>使用名称服务</li>
<li>使用规则服务</li>
<li>使用Master控制。但没有Worker了。与规则服务不同，这里的Master根据请求返回存储服务器的地址，而不是返回所有地址。</li>
</ol>


<h2>5. 分布式系统的难点</h2>

<ol>
<li>缺乏全局时钟</li>
<li>面对故障独立性。故障独立性指整个系统的一部分有问题，而其他部分正常。</li>
<li>处理单点故障。如果某个功能或角色只有一台单机在支撑，这个节点就称为单点。它发生的故障就是单点故障（SPoF, Single Point of Failure）</li>
<li>事务的挑战。即ACID和CAP。</li>
</ol>


<p>后续将研究文中提到的COW、读写锁、互斥锁，以及Reactor模式和Proactor模式。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java注解]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/09/javazhu-jie/"/>
    <updated>2014-07-09T22:22:10+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/09/javazhu-jie</id>
    <content type="html"><![CDATA[<p>本文记录Java注解的基本用法。</p>

<!--more-->


<p>注解类型声明与接口声明的唯一区别是，在interface之前增加了一个@符：</p>

<p><code>java
public @interface TestMethod {
}
</code></p>

<p>判断方法是否有某个注解：</p>

<p>```java</p>

<pre><code>for(Method method: testClass.getDeclaredMethods())
    if (method.isAnnotationPresent(TestMethod.class)) {
        ...
    }           
</code></pre>

<p>```</p>

<h3>保留(Retention)</h3>

<p>注解信息的保留策略：</p>

<ul>
<li>RetentionPolicy.SOURCE 在编译时丢弃。</li>
<li>RetentionPolicy.CLASS（缺省） 保存在类文件中，运行时可被VM丢弃。</li>
<li>RetentionPolicy.RUNTIME 保存在类文件中，运行时由VM保留。</li>
</ul>


<p><code>java
@Retention(RetentionPolicy.RUNTIME)
public @interface TestMethod {
}
</code></p>

<h3>注解的目标（Annotation Target）</h3>

<p><code>java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface TestMethod {
}
</code></p>

<p>目标的类别包括：TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, ANNOTATION_TYPET和PACKAGE。如果没有指定目标，则注解可以修饰任何Java元素。</p>

<h3>单值注解</h3>

<p>为了在注解类型中支持单个参数，需要提供一个名为value的方法，返回适当的类型并且没有任何参数。</p>

<p>```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Ignore {</p>

<pre><code>String value();
</code></pre>

<p>}</p>

<p>//使用示例
@Ignore(&ldquo;忽略&rdquo;)
public void testC() {}
```</p>

<p>不能将null作为注解的值（value）。</p>

<h3>数组参数</h3>

<p>可指定value方法的返回值为数组：</p>

<p>```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Ignore {</p>

<pre><code>String[] value();
</code></pre>

<p>}</p>

<p>//使用示例
@Ignore({&ldquo;忽略&rdquo;, &ldquo;房价涨了&rdquo;})
public void testC() {}</p>

<p>//如果数组只有一个成员，也可以这样写：
@Ignore(&ldquo;房价涨了&rdquo;)
public void testC() {}
```</p>

<h3>多个参数的注解</h3>

<p>注解有多个参数时，注解类型的成员名与注解声明的名称一致，如下例中的reasons和initials：</p>

<p>```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Ignore {</p>

<pre><code>String[] reasons();
String initials();
</code></pre>

<p>}</p>

<p>//使用示例
@Ignore(reasons={&ldquo;just because&rdquo;, &ldquo;and why not&rdquo;}, initials=&ldquo;jjl&rdquo;)
```</p>

<h3>缺省值</h3>

<p>```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Ignore {</p>

<pre><code>String[] reasons() default "房价涨了";
String initials();
</code></pre>

<p>}
```</p>

<h3>附加返回类型与复式注解类型</h3>

<p>注解值可以是基本类型、枚举、Class引用、注解类型本身，或者任意这些类型的数组。我们以注解类型为例：</p>

<p>```java
public @interface Date {</p>

<pre><code>int month();
int day();
int year();
</code></pre>

<p>}</p>

<p>@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Ignore {</p>

<pre><code>Date date();
</code></pre>

<p>}</p>

<p>//使用示例
@Ignore(date=@Date(month=1, day=2, year=2014))
public void testC() {}
```</p>

<h3>包注解</h3>

<p>注解的目标除了方法、属性等外，还可以是包，那么包注解写在哪呢？方法在在包对应的目录中，创建一个名为package-info.java的源文件，这个文件应该包含所有的包注解，后面跟随适当的package语句。除此之外，这个文件不能够包含其它任何东西。示例如下：</p>

<p><code>java
@TestPackage(isPerformance=true) package sis.testing;
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Java-类和接口]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/08/effective-java-lei-he-jie-kou/"/>
    <updated>2014-07-08T18:58:31+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/08/effective-java-lei-he-jie-kou</id>
    <content type="html"><![CDATA[<p>本文总结《Effective Java》中“类和接口”的论述。</p>

<!--more-->


<h2>13.使类和成员的可访问性最小化</h2>

<p>最小化可访问性的目的是隐藏信息，隐藏信息的原因主要是为了模块解耦。正确地使用修饰符（private, protected和public）很重要。</p>

<p>第一条规则是：尽可能地使每个类或者成员不被外界访问。对于顶层（非嵌套）类和接口，应该只有两种可能的访问级别：包级私有（即没有修饰符时）和public。包级私有仍然是这个包的实现的一部分，以后可以对它进行修改，无需担心客户端。但如果是public，则有责任永远支持它。</p>

<p>如果一个包级私有的顶层类/接口只在某一个类的内部被使用，仍应该考虑将它变成那个类的私有嵌套类。</p>

<p>长度非零的数组总是可变的，所以，类具有公有的静态final数组域，或者返回这种域的访问方法，这几乎总是错误的！</p>

<p>```java</p>

<p>//潜在安全漏洞
public static final Thing[] VALUES = {&hellip;};</p>

<p>//可改为：
private static final Thing[] PRIVATE_VALUES = {&hellip;};
public static final List<Thing> VALUES =</p>

<pre><code>Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
</code></pre>

<p>//或者返回一个数组的备份：
private static final Thing[] PRIVATE_VALUES = {&hellip;};
public static final Thing[] values {</p>

<pre><code>return PRIVATE_VALUES.clones();
</code></pre>

<p>}</p>

<p>```</p>

<h2>14.在public类中使用访问方法而非公有域</h2>

<p>简单说，就是public类的属性不要public，而是提供访问方法（如getter, setter）。如果属性不是final的，直接公开属性将表示放弃对该值的控制。即使该属性是final，但如果它引用了可变对象，一样会存在问题。</p>

<h2>15.使可变性最小化</h2>

<p>不可变类是其实例无法修改的类。不可变类不容易出错，本质上是线程安全的，不要求同步。要使类成为不可变，要遵循以下五条规则：</p>

<ol>
<li>不提供任何会修改对象状态的方法。</li>
<li>保证类不会被扩展。</li>
<li>使所有域都是final的。</li>
<li>使所有域都成为私有的。</li>
<li>确保对任何可变组件的互斥访问。如果类中有指向可变对象的域，必须确保客户端无法获得指向这些对象的引用。<strong>永远不要用客户端提供的对象引用来初始化这样的域，也不要从任何访问方法返回该对象的引用。</strong>可使用保护性拷贝技术。</li>
</ol>


<p>不可变类唯一的缺点是，对每个不同的值都需要一个单独的对象。对大型对象代价会很高。</p>

<p>其中第2条，保证类不会被扩展，除了使类成为final外，也可以将类的构造器为私有或者包级私有，然后提供静态工厂。</p>

<p>如果你选择让自己的不可变类实现Serializable接口，并且它包含指向可变对象的域，就必须提供一个显式的readObject或者readResolve方法，或者使用ObjectOutputStream.writeUnshared和ObjectInputStream.readUnshared方法。否则攻击者可能从不可变类创建可变的实例。</p>

<p>如果类不能被做成不可变的，仍然应该尽可能地限制它的可变性。尽量使域/属性成为final。</p>

<p>构造器应该创建完全初始化的对象。尽量不要在构造器或者静态工厂之外再提供公有的初始化方法。同时也不应该提供“重新初始化”方法。</p>

<h2>16.复合优先于继承</h2>

<p>继承打破了封装性。子类依赖于父类中特定功能的实现细节。父类的实现有可能会随着发行版本的不同而有所变化。</p>

<p>通过复合（Composition），现有类变成了新类的一个组件，新类提供方法调用现有类实例中对应的方法，并返回它的结果。这被称为转发。</p>

<p>包装类几乎没有缺点。但包装类不适用于回调框架中。在回调框架中，对象把自己的引用传递给其他对象，用于后续调用。而被包装起来的对象并不知道它外面的包装对象，所以它传递一个指向自身的引用（this），回调时避开了外面的包装对象。这被称为<strong>SELF问题</strong>。</p>

<p>只有当子类真正是父类的子类型时，即它们是“is-a”的关系时，才适合用继承。</p>

<h2>17.要么为继承而设计，并提供文档说明，要么就禁止继承</h2>

<p>文档必须精确地描述覆盖每个方法所带来的影响。
对于为了继承而设计的类，唯一的测试方法就是编写子类。
<strong>为了允许继承，构造器决不能调用可被覆盖的方法，无论是直接调用还是间接调用！</strong>
对于为了继承而设计的类，实现Cloneable和Serializable这两个接口都不是好主意，因为将实际负担转嫁给了扩展这个类的程序员身上。还要注意clone和readObject这两个方法非常类似于构造器，也不能调用可覆盖的方法，不管是直接还是间接调用。如果实现了Serializable，并且该类还有readResolve或writeReplace方法，就必须将该方法成为protected方法，不能是private。</p>

<p>对于那些并非为了安全地进行子类化而设计和编写文档的类，要禁止子类化。有两种办法：声明为final或者将所有构造器都变成私有或包级私有，并增加一个公有静态工厂。</p>

<h2>18.接口优于抽象类</h2>

<h2>19.接口只用于定义类型</h2>

<p>书中建议不要用接口来定义常量，这是接口的不良使用。接口应该只用于定义类型，而常量可以通过以下方法实现：</p>

<ul>
<li>如果某些常量与某个现有类或接口紧密相关，就应该把这些常量加到这个类或接口中。例如Integer的MIN_VALUE常量。</li>
<li>如果这些常量最好被看作是枚举类型的成员，就应该使用枚举类型。</li>
<li>否则应该使用不可实例化的工具类来定义这些常量，例如：</li>
</ul>


<p>```java
public class PhysicalConstants {</p>

<pre><code>private PhysicalConstants() {} //避免实例化
public static final double AVOGADROS_NUMBER = 6.0221419e23;
...
</code></pre>

<p>}
```</p>

<h2>20.类层次优于标签类</h2>

<p>标签类（Tagged class）是指那些用一个类来表示多种对象的类。例如用一个类来表示矩形和圆。通过一个标签来区分当前实例是矩形还是圆。</p>

<p>标签类过于冗长，容易出错，而且效率低下。这种情况应该通过类层次来定义。</p>

<h2>21.用函数对象表示策略</h2>

<p>如果一个类，它的方法执行其他对象的操作，这个类仅导出一个这样的方法，它的实例就等同于一个指向该方法的指针。这样的实例就称为函数对象（function object）。例如：</p>

<p>```java
class StringLengthComparator {</p>

<pre><code>public int compare(String s1, String s2) {
    return s1.length() - s2.length();
}
</code></pre>

<p>}
```</p>

<p>上面这个类没有属性，因此适合于单例。为了把该类的实例传递给方法，应该定义一个接口，并让类实现这个接口。这就是一个策略接口：</p>

<p>```java
public interface Comparator<T> {</p>

<pre><code>public int compare(T t1, T t2);
</code></pre>

<p>}
```</p>

<p>函数指针的主要用途就是实现策略模式。为了在Java中实现这种模式，要声明一个接口来表示该策略，并且为每个具体策略声明一个实现了该接口的类。当一个具体策略只使用一次时，通常使用匿名类，如果可以重复使用，通常实现为私有的静态成员类，并通过公有的静态final属性导出，其类型为该策略接口。</p>

<h2>22.优先使用静态成员类</h2>

<p>嵌套类（nested class）有四种：静态成员类、非静态成员类、匿名类和局部类。后面三种都被称为内部类（inner class）。</p>

<p>非静态成员类的每个实例都隐含着与一个外围实例的关联，在其内部可以调用外围实例的方法。非静态成员类的一种常见用法是定义一个Adapter。</p>

<p>如果成员类不要求访问外围实例，就要始终把static放在它的声明中，使它成为静态成员类。</p>

<p>匿名类的适用性受到很多限制，它没有名字，不是外围类的成员。它在使用的同时被声明和实例化。不能实现多个接口或者扩展一个类，并同时扩展类和实现接口。它们必须保持简短，大约10行或更少。它主要用于：</p>

<ul>
<li>创建函数对象，例如匿名的Comparator实例。</li>
<li>创建过程对象，例如Runnable, Thread或者TimerTask实例。</li>
<li>在静态工厂方法的内部。参考第18条。</li>
</ul>

]]></content>
  </entry>
  
</feed>
