<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2015-04-12T12:27:12+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JAX-RS 2.0 REST 请求处理]]></title>
    <link href="http://blog.ubone.com/blog/2015/04/12/rest-qing-qiu-chu-li/"/>
    <updated>2015-04-12T09:57:39+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/04/12/rest-qing-qiu-chu-li</id>
    <content type="html"><![CDATA[<p>本章学习REST请求的完整处理过程，其中涉及JAX-RS 2.0定义的Provider及其两个特殊类型：过滤器和拦截器。</p>

<!--more-->


<p>REST风格的框架都从容器级别支持AOP式开发，Jersey内置AOP支持，可以不依赖于Spring等AOP框架。Jersey的AOP功能来自GlassFish的HK2项目（轻量级DI架构，jersey-common依赖HK2），它包括hk2-api和hk2-locator。hk2-locator致力于AOP方向。</p>

<p>Jersey提供的REST过滤器和拦截器为开发者提供了方便的扩展点，开发者无须像在Spring中为了某个类的方法进行AOP扩展而写配置文件。Jersey中只要实现相应扩展点的接口，即可实现REST请求流程中特定事件的拦截、扩展。</p>

<h2>1. Providers详解</h2>

<p>javax.ws.rs.ext.Providers是JAX-RS 2.0定义的一个辅助接口，其实现类用于完成过滤和读写拦截功能。@Provider标注的实现类，可以在运行时自动探测、加载。Provider实例可以通过@Context注解被依赖注入到其他实例中。Providers接口定义了4个方法，分别用来获取MessageBodyReader、MessageBodyWriter、ExceptionMapper和ContextResolver实例。</p>

<h3>1.1 实体Providers</h3>

<p>Jersey之所以可以支持多种响应实体的传输格式，是因为其底层实体Providers具备对不同格式的处理能力。它内部提供了丰富的MessageBodyReader和MessageBodyWriter接口实现类，用于处理不同的格式。</p>

<h4>1.1.1 MessageBodyReader</h4>

<p><code>MessageBodyReader&lt;T&gt;</code>用于将传输流转换成Java类型的对象。泛型类型即是该实现类所支持的转换类型。业务系统启用该实现类有两种方式：一是使用@Provider定义实现类，启动时自动加载；二是通过编码注册到Application类或子类中。</p>

<p><code>MessageBodyReader&lt;T&gt;</code>接口定义了两个方法：</p>

<ul>
<li>isReadable() 判断实现类是否支持将当前请求的数据类型反序列化。</li>
<li>readFrom() 反序列化处理，将流转换为Java类型对象。</li>
</ul>


<h4>1.1.2 MessageBodyWriter</h4>

<p><code>MessageBodyWriter&lt;T&gt;</code>接口用于将Java类型对象转换成流，完成序列化过程。与MessageBodyReader类似，它也有两个对应的方法：isWriteable()和writeTo()。</p>

<h4>1.1.3 MessageBodyWorkers</h4>

<p>MessageBodyReader和MessageBodyWriter的实现类非常多，选择哪个实现类处理当前请求的算法非常繁重，MessageBodyWorkers就是用于抽象这一遴选工作。它的实现类可以通过@Context依赖注入到使用MessageBodyWorkers的类中。MessageBodyFactory是MessageBodyWorkers接口的实现类。</p>

<h3>1.2 上下文Providers</h3>

<p><code>ContextResolver&lt;T&gt;</code>接口是用于提供资源类和其他Provider上下文信息的接口，它定义了getContext()方法，参数为表述对象的类型(响应实体的传输格式)，输出是上下文泛型。</p>

<h2>2. REST请求流程</h2>

<p>一个请求始于请求的发送，止于调用Response类的readEntity()方法，获取响应实体。整个流程如下图所示：</p>

<p><img src="/myresource/images/image_blog_-2015-04-12_jerseyrest.jpg" alt="image" /></p>

<ol>
<li>客户端接收请求，进入扩展点ClientRequestFilter实现类的filter()方法。</li>
<li>第二个扩展点：客户端写拦截器WriterInterceptor实现类的aroundWriteTo()方法，实现对客户端序列化操作的拦截。</li>
<li>客户端消息体写处理器MessageBodyWriter执行序列化，过渡到服务端。</li>
<li>进入第三个扩展点：服务器前置请求过滤器ContainerRequestFilter实现类的filter()方法。</li>
<li>过滤处理完毕后，找到匹配资源方法。</li>
<li>进入第四个扩展点：服务器后置请求过滤器ContainerRequestFilter实现类的filter()方法。</li>
<li>服务器消息体读处理器MessageBodyReader完成数据流的反序列化。</li>
<li>执行资源方法。</li>
<li>进入第六个扩展点：服务器响应过滤器ContainerResponseFilter实现类的filter()方法。</li>
<li>进入第七个扩展点：服务器写拦截器WriterInterceptor实现类的aroundWriteTo()方法，实现对服务端序列化到客户端这个操作的拦截。</li>
<li>服务器消息体写处理器MessageBodyWriter执行序列化。流程返回客户端。</li>
<li>客户端接收响应，进入第八个扩展点：客户端响应过滤器ClientResponseFilter实现类的filter方法。</li>
<li>客户端响应实例response返回到用户侧，用户执行response.readEntity()，进入第九个扩展点：客户端读拦截器ReaderInterceptor实现类的aroundReadFrom()方法，对客户端反序列化进行拦截。</li>
<li>客户端消息体读处理器MessageBodyReader执行反序列化，将Java类型的对象最终作为readEntity()方法的返回值。</li>
</ol>


<h2>3. REST过滤器</h2>

<p>在上面的流程中，JAX-RS 2.0定义了4种过滤器扩展点接口，供开发者实现业务逻辑，先后为：</p>

<ul>
<li>ClientRequestFilter</li>
<li>ContainerRequestFilter</li>
<li>ContainerResponseFilter</li>
<li>ClientResponseFilter</li>
</ul>


<h3>3.1 ClientRequestFilter</h3>

<p>通常可以通过filter()方法的参数ClientRequestContext获取请求方法(getMethod)、获取请求资源地址(getUri)和获取请求头信息（getHeaders）等。利用这些信息覆写该方法以实现过滤功能。示例如下：</p>

<p>```java
@Override
public filter(ClientRequestContext rc) throws IOException {</p>

<pre><code>if (!rc.getHeaders().containsKey(HttpHeaders.AUTHORIZATION)) {
  rc.getHeaders().add(HttpHeaders.AUTHORIZATION, authentication);
}
</code></pre>

<p>}
```</p>

<h3>3.2 ContainerRequestFilter</h3>

<p>该接口的实现类可以定义为前置处理和后置处理。分别对应服务器处理接收到的请求之前和之后执行过滤。如果希望实现前置处理，要在类名上定义注解@PreMatching。该接口的filter(ContainerRequestContext tx)与Client类似。</p>

<h3>3.3 ContainerResponseFilter</h3>

<p>该接口定义的过滤方法：void filter(ContainerRequestContext request, ContainerResponseContext response)。</p>

<h3>3.4 ClientResponseFilter</h3>

<p>该接口定义的过滤方法：void filter(ClientRequestContext requestContext, ClientResponseContext responseContext).</p>

<h3>3.5 过滤器示例</h3>

<p>下面的示例用于实现访问日志功能。</p>

<p>```java
//pugm4wh阶段的filter
@PreMatching
public class AirLogFilter implements ContainerRequestFilter,</p>

<pre><code>    ClientRequestFilter, ContainerResponseFilter, 
    ClientResponseFilter {
private static final Logger LOGGER = Logger.getLogger(AirLogFilter.class);
private static final String NOTIFICATION_PREFIX = "* ";
private static final String SERVER_REQUEST = "&gt; ";
private static final String SERVER_RESPONSE = "&lt; ";
private static final String CLIENT_REQUEST = "/ ";
private static final String CLIENT_RESPONSE = "\\ ";
private static final AtomicLong logSequence = new AtomicLong(0);

@Override
public void filter(ClientRequestContext context) throws IOException {
    long id = logSequence.incrementAndGet();
    StringBuilder b = new StringBuilder();
    //获取请求方法和地址
    printRequestLine(CLIENT_REQUEST, b, id, 
        context.getMethod(), context.getUri());
    //获取请求头信息
    printPrefixedHeaders(CLIENT_REQUEST, b, id, 
        /*HeadersFactory*/HeaderUtils.asStringHeaders(context.getHeaders()));
    LOGGER.info(b.toString());
}

@Override
public void filter(ClientRequestContext requestContext, 
    ClientResponseContext responseContext) throws IOException {
    long id = logSequence.incrementAndGet();
    StringBuilder b = new StringBuilder();
    printResponseLine(CLIENT_RESPONSE, b, id, responseContext.getStatus());
    printPrefixedHeaders(CLIENT_RESPONSE, b, id, responseContext.getHeaders());
    LOGGER.info(b.toString());
}

@Override
public void filter(ContainerRequestContext context) throws IOException {
    long id = logSequence.incrementAndGet();
    StringBuilder b = new StringBuilder();
    printRequestLine(SERVER_REQUEST, b, id,
         context.getMethod(), context.getUriInfo().getRequestUri());
    printPrefixedHeaders(SERVER_REQUEST, b, id, context.getHeaders());
    LOGGER.info(b.toString());
}

@Override
public void filter(ContainerRequestContext requestContext, 
    ContainerResponseContext responseContext) throws IOException {
    long id = logSequence.incrementAndGet();
    StringBuilder b = new StringBuilder();
    //获取容器响应状态
    printResponseLine(SERVER_RESPONSE, b, id, responseContext.getStatus());
    printPrefixedHeaders(SERVER_RESPONSE, b, id, 
        /*HeadersFactory*/HeaderUtils.asStringHeaders(responseContext.getHeaders()));
    LOGGER.info(b.toString());
}

private StringBuilder prefixId(StringBuilder b, long id) {
    b.append(Long.toString(id)).append(" ");
    return b;
}

private void printRequestLine(final String prefix, 
        StringBuilder b, long id, String method, URI uri) {
    prefixId(b, id).append(NOTIFICATION_PREFIX)
        .append("AirLog - Request received on thread ")
        .append(Thread.currentThread().getName()).append("\n");
    prefixId(b, id).append(prefix).append(method)
        .append(" ").append(uri.toASCIIString()).append("\n");
}

private void printResponseLine(final String prefix, 
    StringBuilder b, long id, int status) {
    prefixId(b, id).append(NOTIFICATION_PREFIX)
        .append("AirLog - Response received on thread ")
        .append(Thread.currentThread().getName()).append("\n");
    prefixId(b, id).append(prefix)
        .append(Integer.toString(status)).append("\n");
}

private void printPrefixedHeaders(final String prefix, 
    StringBuilder b, long id, MultivaluedMap&lt;String, String&gt; headers) {
    for (Map.Entry&lt;String, List&lt;String&gt;&gt; e : headers.entrySet()) {
        List&lt;?&gt; val = e.getValue();
        String header = e.getKey();

        if (val.size() == 1) {
            prefixId(b, id).append(prefix).append(header)
                .append(": ").append(val.get(0)).append("\n");
        } else {
            StringBuilder sb = new StringBuilder();
            boolean add = false;
            for (Object s : val) {
                if (add) {
                    sb.append(',');
                }
                add = true;
                sb.append(s);
            }
            prefixId(b, id).append(prefix).append(header)
                .append(": ").append(sb.toString()).append("\n");
        }
    }
}
</code></pre>

<p>}</p>

<p>//测试类
public class TIResourceJtfTest extends JerseyTest {</p>

<pre><code>private static final Logger LOGGER = Logger.getLogger(TIResourceJtfTest.class);
private static final String BASEURI = "books/";

@Override
protected Application configure() {
    ResourceConfig config = new ResourceConfig(BookResource.class);
    return config.register(com.example.filter.log.AirLogFilter.class);
}

@Override
protected void configureClient(ClientConfig config) {
    config.register(new AirLogFilter());
}

@Test
public void testPathGetJSON() {
    TIResourceJtfTest.LOGGER.debug("&gt;&gt;Test Path Get");
    final WebTarget pathTarget = target(TIResourceJtfTest.BASEURI + "1");
    final Invocation.Builder invocationBuilder = pathTarget.request(MediaType.APPLICATION_JSON_TYPE);
    final Book result = invocationBuilder.get(Book.class);
    TIResourceJtfTest.LOGGER.debug(result);
    Assert.assertNotNull(result.getBookId());
    TIResourceJtfTest.LOGGER.debug("&lt;&lt;Test Path Get");
}
</code></pre>

<p>}
```</p>

<p>注意在测试类中，需要在服务端和客户端分别注册服务日志类AirLogFilter。</p>

<h2>4. REST拦截器</h2>

<p>拦截器与过滤器都是一种在请求-响应模型中用做切面处理的Provider。但两种除了功能不一样外，形式也不同。拦截器通常读写成对，而且没有服务端和客户端的区分。例如GZiPEncoder同时实现了读/写拦截器。</p>

<p>读拦截器接口ReaderInterceptor定义的拦截方法是：</p>

<p>```java
Object aroundReadFrom(ReaderInterceptorContext context)</p>

<pre><code>throws IOException, javax.ws.rs.WebApplicationException;
</code></pre>

<p>```</p>

<p>写拦截器接口WriterInterceptor定义的拦截方法是：</p>

<p>```java
void aroundWriteTo(WriterInterceptorContext context)</p>

<pre><code>throws IOException, javax.ws.rs.WebApplicationException;
</code></pre>

<p>```</p>

<h2>5. Providers绑定机制</h2>

<p>通过下面的方式定义的过滤器或拦截器是全局有效的：</p>

<ul>
<li>通过手动注册到Application或者Configuration。</li>
<li>注解为@Provider，被自动探测。</li>
</ul>


<p>除了全局Provider，还可以进行名称绑定和动态绑定。</p>

<h3>5.1 名称绑定</h3>

<p>过滤器和拦截器可以通过名称绑定来指定其作用范围。@NameBinding注解可以定义一个运行时的自定义注解，该注解用于定义类级别的名称和类的方法名：</p>

<p><code>java
@NameBinding
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(value = RetentionPolicy.RUNTIME)
public @interface AirLog {
}
</code></p>

<p>然后将该注解绑定Provider，下例中的AirNameBindingFilter就实现了名称绑定：</p>

<p>```java
@AirLog
@Priority(Priorities.USER)
public class AirNameBindingFilter implements ContainerRequestFilter, ContainerResponseFilter {</p>

<pre><code>private static final Logger LOGGER = 
    Logger.getLogger(AirNameBindingFilter.class);

public AirNameBindingFilter() {
    LOGGER.info("Air-NameBinding-Filter initialized");
}

@Override
public void filter(final ContainerRequestContext containerRequest) 
throws IOException {
    LOGGER.debug("Air-ContainerRequestFilter invoked:" + 
        containerRequest.getMethod());          
    LOGGER.debug(containerRequest
        .getUriInfo().getRequestUri());
}
</code></pre>

<p>```</p>

<p>完成了Provider的名称绑定后，就可以在资源类的指定方法上使用自定义注解@AirLog，从而实现在该方法上启用Provider对应的过滤器。示例如下 ：</p>

<p>```java
@AirLog
@GET
@Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
public Books getBooks() {</p>

<pre><code>...
</code></pre>

<p>}
```</p>

<h3>5.2 动态绑定</h3>

<p>动态绑定无须新增注解，而是使用编码的方式实现接口javax.ws.rs.container.DynamicFeature，定义扩展点方法的名称、请求方法类型等匹配信息。在运行期，一旦Provider匹配当前处理类或方法，面向切面的Provider方法即被触发。</p>

<h4>5.2.1 定义绑定Provider</h4>

<p>```java
public class AirDynamicFeature implements DynamicFeature {</p>

<pre><code>@Override
public void configure(final ResourceInfo resourceInfo, 
        final FeatureContext context) {
    boolean classMatched = BookResource.class
        .isAssignableFrom(resourceInfo.getResourceClass());
    boolean methodNameMatched = resourceInfo
        .getResourceMethod().getName().contains("getBookBy");
    boolean methodTypeMatched = resourceInfo
        .getResourceMethod().isAnnotationPresent(POST.class);

    //匹配成功才注册
    if (classMatched &amp;&amp; (methodNameMatched || methodTypeMatched)) {
        context.register(AirDynamicBindingFilter.class);
    }
}
</code></pre>

<p>}
```</p>

<p>上面的示例代码启用了如下匹配规则：</p>

<ul>
<li>类匹配：对BookResource类及其子类匹配。</li>
<li>方法名称匹配：方法名包含getBookBy。</li>
<li>请求方法类型匹配：匹配POST方法。</li>
</ul>


<p>当匹配成功后，会触发下面的Provider:</p>

<p>```java
public class AirDynamicBindingFilter implements ContainerRequestFilter {</p>

<pre><code>private static final Logger LOGGER = Logger.getLogger(AirDynamicBindingFilter.class);

public AirDynamicBindingFilter() {
    LOGGER.info("Air-Dynamic-Binding-Filter initialized");
}

@Override
public void filter(final ContainerRequestContext requestContext) throws IOException {
    LOGGER.debug("Air-Dynamic-Binding-Filter invoked");
}
</code></pre>

<p>}
```</p>

<h2>6. 优先级</h2>

<p>对于同一个扩展点，如果有多个Provider，其执行先后顺序是靠优先级排序的。优先级使用@Priority，一个整型值，常量定义在javax.ws.rs.Priorities中。</p>

<p>```
@Priority(Priorities.USER)
public class AirNameBindingFilter &hellip;</p>

<p>@Priority(Priorities.USER + 1)
public class AirNameBindingFilter2 &hellip;
```</p>

<p>对于ContainerRequest、PreMatchContainerRequest、ClientRequest和读写拦截器，数值越小，优先级越高。对于ContainerResponse和ClientResponse，数值越大，优先级越高。</p>

<p>参考：《Java RESTful Web Service实战》</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAX-RS REST API设计]]></title>
    <link href="http://blog.ubone.com/blog/2015/04/09/rest-apishe-ji/"/>
    <updated>2015-04-09T19:54:14+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/04/09/rest-apishe-ji</id>
    <content type="html"><![CDATA[<p>REST式的Web服务和RPC式的Web服务在接口定义上的区别是，前者使用HTTP的方法作为统一接口的标准词汇，而后者所提供的方法信息在SOAP/HTTP信封里，每个RPC式的Web服务都会公布一套自己的方法词汇。</p>

<!--more-->


<h2>1. REST统一接口</h2>

<p>每一种HTTP请求方法都可以从安全性和幂等性两方面考虑，这对设计统一接口具有决定性意义。</p>

<ul>
<li>安全性：指对该接口的访问，不会使服务端资源的状态发生改变。</li>
<li>幂等性（Idempotence）：指对同一REST接口的多次访问，得到的资源状态是相同的。</li>
</ul>


<h3>1.1 GET方法</h3>

<p>HTTP GET方法用于读取资源。GET方法应该是安全的、幂等的。如果这样一种场景，虽然是读取资源，但服务端可能需要从其它系统同步资源，即意味着服务端资源状态可能发生改变，此时应该使用POST方法，而不是GET方法。</p>

<p>通常GET方法会以资源名称命名，根据不同情况使用单数或复数。</p>

<p>JAS-RS 2.0使用<code>@GET</code>注解来定义资源方法，注解可以定义在接口和POJO中，放在接口中更具抽象和通用性。示例如下：</p>

<p>```java
@Path(&ldquo;book&rdquo;)
public interface BookResource {</p>

<pre><code>@GET
public String getWeight();
</code></pre>

<p>}</p>

<p>public class EBookResourceImpl implements BookResource {</p>

<pre><code>//实现类无须加注解
@Override
public String getWeight() {
    return "150M";
}
</code></pre>

<p>}</p>

<p>public class GetTest extends JerseyTest {</p>

<pre><code>@Override
protected Application configure() {
    return new ResourceConfig(EBookResourceImpl.class);
}

@Test
public void testGet() {
    final Response response = target("book").request().get();
    Assert.assertEquals("150M", response.readEntity(String.class));
}
</code></pre>

<p>}
```</p>

<h3>1.2 HEAD和OPTIONS方法</h3>

<p>这两个方法与GET相似，但HEAD方法的返回值不包括HTTP实体，因此也应该是安全和幂等的。使用<code>@HEAD</code>注解来定义。而OPTIONS方法用于读取资源所支持（Allow）的所有HTTP请求方法，也是安全和幂等的。使用<code>@OPTIONS</code>注解进行定义。</p>

<h3>1.3 PUT方法</h3>

<p>PUT方法用于更新或添加资源，所以肯定不是安全的。PUT方法应该是幂等的。多次插入或者更新同一份数据，在服务端对资源状态所产生的改变应该是相同的。通常更新资源使用PUT方法没有问题，但添加资源时，需要考虑使用PUT方法还是POST方法。一般来说，如果同一份数据，总是可以提供唯一的主键，具有幂等性，使用PUT方法，否则使用POST方法。</p>

<p>JAX-RS 2.0定义了<code>@PUT</code>注解来定义PUT方法。示例如下：</p>

<p>```java
@Path(&ldquo;book&rdquo;)
public interface BookResource {</p>

<pre><code>@PUT
@Produces(MediaType.TEXT_PLAIN)
@Consumes(MediaType.APPLICATION_XML)
public String newBook(Book book);
</code></pre>

<p>}</p>

<p>public class EBookResourceImpl implements BookResource {</p>

<pre><code>@Override
public String newBook(Book book) {
    SimpleDateFormat f = new SimpleDateFormat("d MMM yyyy HH:mm:ss");
    Date lastUpdate = Calendar.getInstance().getTime();
    //...
    LOGGER.debug(book.getBookId());
    return f.format(lastUpdate);
}    
</code></pre>

<p>}</p>

<p>public class PutTest extends JerseyTest {</p>

<pre><code>private final static Logger LOGGER = Logger.getLogger(PutTest.class);
public static AtomicLong clientBookSequence = new AtomicLong();

@Override
protected Application configure() {
    enable(TestProperties.LOG_TRAFFIC);
    enable(TestProperties.DUMP_ENTITY);
    return new ResourceConfig(EBookResourceImpl.class);
}

@Test
public void testNew() {
    final Book newBook = new Book(clientBookSequence.incrementAndGet(), "book-" + System.nanoTime());
    MediaType contentTypeMediaType = MediaType.APPLICATION_XML_TYPE;
    MediaType acceptMediaType = MediaType.TEXT_PLAIN_TYPE;
    final Entity&lt;Book&gt; bookEntity = Entity.entity(newBook, contentTypeMediaType);
    final String lastUpdate = target("book").request(acceptMediaType).put(bookEntity, String.class);
    Assert.assertNotNull(lastUpdate);
    LOGGER.debug(lastUpdate);
}
</code></pre>

<p>}
```</p>

<p>PUT方法需要考虑请求实体的媒体类型（HTTP头的Content Type，上例中的@Consumes）和响应实体的媒体类型(HTTP头的Accept定义, 上例中的@Produces)。</p>

<h3>1.4 DELETE方法</h3>

<p>DELETE方法是幂等的、不安全的。使用<code>@DELETE</code>注解来定义资源方法。示例如下：</p>

<p>```java
@Path(&ldquo;book&rdquo;)
public interface BookResource {</p>

<pre><code>@DELETE
public void delete(@QueryParam("bookId") final long bookId);
</code></pre>

<p>}</p>

<p>public class EBookResourceImpl implements BookResource {</p>

<pre><code>@Override
public void delete(long bookId) {
    LOGGER.debug(bookId);
}
</code></pre>

<p>}</p>

<p>public class DeleteTest extends JerseyTest {</p>

<pre><code>private final static Logger LOGGER = Logger.getLogger(DeleteTest.class);
@Test
public void testGet() {
    final Response response = target("book").queryParam("bookId", "9527").request().delete();
    int status = response.getStatus();
    LOGGER.debug(status);
    Assert.assertEquals(Response.Status.NO_CONTENT.getStatusCode(), status);
}
</code></pre>

<p>}<br/>
```</p>

<p>上例中，delete方法没有返回值，将HTTP状态码设置为204. 在测试代码中，测试断言不是针对删除资源的实体，而是响应的HTTP状态码。</p>

<h3>1.5 POST方法</h3>

<p>POST方法用于写数据，既不幂等也不安全。REST只使用POST方法添加资源。使用<code>@POST</code>注解，示例如下：</p>

<p>```java
@Path(&ldquo;book&rdquo;)
public interface BookResource {</p>

<pre><code>@POST
@Produces(MediaType.APPLICATION_XML)
@Consumes(MediaType.APPLICATION_XML)
public Book createBook(Book book);
</code></pre>

<p>}</p>

<p>public class EBookResourceImpl implements BookResource {</p>

<pre><code>@Override
public Book createBook(Book book) {
    book.setBookId(serverBookSequence.incrementAndGet());
    return book;
}    
</code></pre>

<p>}</p>

<p>public class PostTest extends JerseyTest {</p>

<pre><code>private final static Logger LOGGER = Logger.getLogger(PostTest.class);
public static AtomicLong clientBookSequence = new AtomicLong();

@Override
protected Application configure() {
    enable(TestProperties.LOG_TRAFFIC);
    enable(TestProperties.DUMP_ENTITY);
    return new ResourceConfig(EBookResourceImpl.class);
}

@Test
public void testCreate() {
    final Book newBook = new Book("book-" + System.nanoTime());
    MediaType contentTypeMediaType = MediaType.APPLICATION_XML_TYPE;
    MediaType acceptMediaType = MediaType.APPLICATION_XML_TYPE;
    final Entity&lt;Book&gt; bookEntity = Entity.entity(newBook, contentTypeMediaType);
    final Book book = target("book").request(acceptMediaType).post(bookEntity, Book.class);
    Assert.assertNotNull(book.getBookId());
    LOGGER.debug("Server Id=" + book.getBookId());
}
</code></pre>

<p>}  <br/>
```</p>

<h2>2. REST资源定位</h2>

<p>在设计REST式的Web服务过程中，资源地址的设计是非常严谨的。地址应该是面向资源的，资源名称应是准确描述该资源的名词，资源地址应具有直观的描述性。</p>

<h3>2.1 资源地址设计</h3>

<p>一个典型的请求URL如下：<code>http://localhost:8080/myproject/webapi/books/book?id=1</code>，它包括以下部分：</p>

<ul>
<li>requestURI: <code>myproject/webapi/books/book?id=1</code></li>
<li>ContextPath: <code>myproject</code>，与部署服务器的配置或web.xml有关</li>
<li>ServletPath: <code>webapi</code>，与<code>@ApplicationPath</code>注解或web.xml配置有关</li>
<li>PathInfo: <code>books/book</code>，与<code>@Path</code>注解有关</li>
<li>QueryString: <code>id=1</code></li>
</ul>


<p>资源地址是否可以唯一定位一个资源？答案是否定的。因为资源地址相同，但HTTP方法不同时，对应的是不同的REST接口。</p>

<p>在路径变量中可以使用标点符号来辅助增强逻辑清晰性：</p>

<ul>
<li><code>?</code>号，用来分隔资源地址和查询字符串，<code>&amp;</code>号用于分隔参数。如: <code>GET /books?start=0&amp;size=10</code></li>
<li><code>,</code>逗号用来分隔有次序的作用域信息。也可以使用<code>-</code>,<code>_</code>来做逻辑上的辅助分隔。如：<code>GET /books/01,2002-12,2014</code></li>
<li><code>;</code>分号用来分隔无次序的作用域信息。这些信息在逻辑上通常是并列存在的，如并列查询条件。示例：<code>GET /books/restful;program=java;type=web</code></li>
</ul>


<h3>2.2 @QueryParam注解</h3>

<p>@QueryParam注解用来定义查询参数，例如：</p>

<p>```java
public Yijings getByPaging(</p>

<pre><code>@QueryParam("start")final int start, 
@DefaultValue("100") @QueryParam("limit")final int limit, 
@QueryParam("sort")final String sortName) {
//...
</code></pre>

<p>}
```</p>

<h3>2.3 @PathParam注解</h3>

<p>@PathParam注解用于定义路径参数，每个参数对应一个子资源。</p>

<h4>@Path注解</h4>

<p>格式为：{参数名称：正则表达式}，例如：</p>

<p>```java
@GET
@Path(&ldquo;{from:\d+}&ndash;{to:\d+}&rdquo;)
public String getByCondition(</p>

<pre><code>@PathParam("from")final Integer from, 
@PathParam("to")final Integer to){
...
</code></pre>

<p>}
//eg. /path-resource/199-1999
```</p>

<p>正则表达式的内容可以参考<a href="/blog/2015/04/06/xue-xi-zheng-ze-biao-da-shi/">这篇博客</a>。</p>

<h4>路径区间(PathSegment)</h4>

<p>路径区间可以支持更广泛的资源地址请求。示例如下：</p>

<p>```
/<em>
匹配以下资源(都有固定子资源shenyang)：
/path-res/Asia/China/northeast/liaoning/shenyang/huanggu
/path-res/China/northeast/liaoning/shenyang/tiexi
/path-res/China/shenyang/huanggu
</em>/</p>

<p>@GET
@Path(&ldquo;{region:.+}/shenyang/{district:\w+}&rdquo;)
public String getByAddress(</p>

<pre><code>@PathParam("region") final List&lt;PathSegment&gt; region, 
@PathParam("district") final String district) {
final StringBuilder result = new StringBuilder();
for(final PathSegment pathSegment : region) {
    result.append(pathSegment.getPath()).append("-");
}
...
</code></pre>

<p>}
```</p>

<p>对于查询参数动态给定的场景（经测，需要用分号分隔），可以定义PathSegment参数类型，示例如下：</p>

<p>```java
@GET
@Path(&ldquo;q/{condition}&rdquo;)
public String getByCondition(@PathParam(&ldquo;condition&rdquo;) final PathSegment condition) {</p>

<pre><code>final MultivaluedMap&lt;String, String&gt; matrixParameters = condition.getMatrixParameters();
final Iterator&lt;Map.Entry&lt;String, List&lt;String&gt;&gt;&gt; iterator = matrixParameters.entrySet().iterator();

StringBuilder result = new StringBuilder(condition.getPath()+":");
while (iterator.hasNext()) {
    final Map.Entry&lt;String, List&lt;String&gt;&gt; entry = iterator.next();
    result.append(entry.getKey()).append("=");
    result.append(entry.getValue()).append(" ");
}
return result.toString();
</code></pre>

<p>}</p>

<p>//<a href="http://localhost:8080/webapi/books/q/restful;program=java;type=web">http://localhost:8080/webapi/books/q/restful;program=java;type=web</a>
//输出：restful:program=[java] type=[web]  <br/>
```</p>

<p>上述示例也可以通过<code>@MatrixParam</code>注解来实现，示例如下：</p>

<p>```java
@GET
@Path(&ldquo;q/{condition}&rdquo;)
public String getByCondition(</p>

<pre><code>@PathParam("condition") final PathSegment condition, 
@MatrixParam("program") final String program, 
@MatrixParam("type") final String type) {
return condition.getPath() + ": program=[" + program + "] type=[" + type + "]";
</code></pre>

<p>}
```</p>

<p><code>@MatrixParam</code>注解可以清晰地表达可接收的参数名称和类型，但缺乏灵活性。</p>

<h3>2.4 @FormParam注解</h3>

<p>@FormParam注解用来定义表单参数，相应的REST方法用于处理请求实体媒体类型为Content-Type:application/x-www-form-urlencoded的请求。示例如下：</p>

<p>```java
@Path(&ldquo;form-resource&rdquo;)
@POST
public String newPassword(</p>

<pre><code>//注意可以使用@DefaultValue
@DefaultValue("meixuesong") @FormParam("user") final String user,
//注意@Encoded表示禁用自动解码，参数不会被解码，如果直接返回，客户端的值是处于编码状态的字符串。下面的测试代码可看到区别
@Encoded @FormParam("password") final String password,
@Encoded @FormParam("newPassword") final String newPassword,
@FormParam("verification") final String verification
</code></pre>

<p>) {</p>

<pre><code>return user + ":" + password + ":" + newPassword + ":" + verification;
</code></pre>

<p>}</p>

<p>/<em>* 测试代码</em>/
public class FormTest extends JerseyTest {</p>

<pre><code>private static final Logger LOGGER = Logger.getLogger(FormTest.class);

@Override
protected Application configure() {
    enable(TestProperties.LOG_TRAFFIC);
    enable(TestProperties.DUMP_ENTITY);
    return new ResourceConfig(BookResource.class);
}

@Test
public void testPost2() {
    final Form form = new Form();
    form.param("password", "北京");
    form.param("newPassword", "上海");
    form.param("verification", "上海");
    final String result = target("books/form-resource").request().post(Entity.entity(form, MediaType.APPLICATION_FORM_URLENCODED_TYPE), String.class);
    FormTest.LOGGER.debug(result);
    Assert.assertEquals("encoded should let it to disable decoding", "meixuesong:%E5%8C%97%E4%BA%AC:%E4%B8%8A%E6%B5%B7:上海", result);
}
</code></pre>

<p>}
```</p>

<h3>2.5 @BeanParam注解</h3>

<p>@BeanParam注解用于自定义参数组合，使REST方法的参数更加简洁。示例如下：</p>

<p>```java
@Path(&ldquo;bean-resource&rdquo;)
public class BeanParamResource {</p>

<pre><code>@GET
@Path("{region:.+}/shenyang/{district:\\w+}")
@Produces(MediaType.TEXT_PLAIN)
public String getByAddress(@BeanParam Jaxrs2GuideParam param) {
    System.out.println("acceptParam: " + param.getAcceptParam());
    //acceptParam: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2
    return param.getRegionParam() + ":" + param.getDistrictParam() + ":" + param.getStationParam() + ":" + param.getVehicleParam();
}
</code></pre>

<p>}</p>

<p>public class Jaxrs2GuideParam {</p>

<pre><code>@HeaderParam("accept")
private String acceptParam;
@PathParam("region")
private String regionParam;
@PathParam("district")
private String districtParam;
@QueryParam("station")
private String stationParam;
@QueryParam("vehicle")
private String vehicleParam;
//getter setter
</code></pre>

<p>}</p>

<p>//测试
public class BeanParamTest extends JerseyTest {</p>

<pre><code>private static final Logger LOGGER = Logger.getLogger(BeanParamTest.class);

@Override
protected Application configure() {
    enable(TestProperties.LOG_TRAFFIC);
    enable(TestProperties.DUMP_ENTITY);
    return new ResourceConfig(BeanParamResource.class);
}

@Test
public void testBeanParam() {
    final String path = "bean-resource";
    String result;

    /*http://localhost:9998/bean-resource/China/northeast/shenyang/tiexi?station=Workers+Village&amp;vehicle=bus*/
    final WebTarget queryTarget = target(path).path("China").path("northeast").path("shenyang").path("tiexi").queryParam("station", "Workers Village")
            .queryParam("vehicle", "bus");
    result = queryTarget.request().get().readEntity(String.class);
    LOGGER.debug(result);
    Assert.assertEquals("China/northeast:tiexi:Workers Village:bus", result);
}
</code></pre>

<p>}
```</p>

<h3>2.6 @CookieParam注解</h3>

<p>@CookieParam注解用于匹配Cookie中的键值对信息。示例如下：</p>

<p>```java
@Path(&ldquo;kuky-resource&rdquo;)
public class CookieResource {</p>

<pre><code>@GET
public String getHeaderParams(@CookieParam("longitude") final String longitude,
                              @CookieParam("latitude") final String latitude,
                              @CookieParam("population") final double population,
                              @CookieParam("area") final int area) {
    return longitude + "," + latitude + " population=" + population + ",area=" + area;
}
</code></pre>

<p>}</p>

<p>//测试
public class CookieTest extends JerseyTest {</p>

<pre><code>private static final Logger LOGGER = Logger.getLogger(CookieTest.class);

@Override
protected Application configure() {
    enable(TestProperties.LOG_TRAFFIC);
    enable(TestProperties.DUMP_ENTITY);
    return new ResourceConfig(CookieResource.class);
}

@Test
public void testContexts() {
    final String path = "kuky-resource";
    String result;

    /*http://localhost:9998/kuky-resource*/
    final Builder request = target(path).request();
    request.cookie("longitude", "123.38");
    request.cookie("latitude", "41.8");
    request.cookie("population", "822.8");
    request.cookie("area", "12948");
    result = request.get().readEntity(String.class);
    CookieTest.LOGGER.debug(result);
    Assert.assertEquals("123.38,41.8 population=822.8,area=12948", result);
}
</code></pre>

<p>}
```</p>

<h3>2.7 @Context注解</h3>

<p>@Context注解用于解析上下文参数。下面的示例代码定义了Application、Request、Providers、UriInfo和HttpHeaders等5种类型的上下文实例，从而可以获取请求过程中的重要参数信息。代码如下：</p>

<p>```java
@Path(&ldquo;ctx-resource&rdquo;)
public class ContextResource {</p>

<pre><code>@GET
@Path("{region:.+}/shenyang/{district:\\w+}")
@Produces(MediaType.TEXT_PLAIN)
public String getByAddress(
        @Context final Application application,
        @Context final Request request,
        @Context final javax.ws.rs.ext.Providers provider,
        @Context final UriInfo uriInfo,
        @Context final HttpHeaders headers) {
    final StringBuilder buf = new StringBuilder();
    final String path = uriInfo.getPath();
    buf.append("PATH=").append(path).append("\n");

    final MultivaluedMap&lt;String, String&gt; pathMap = uriInfo.getPathParameters();
    buf.append("PATH_PARAMETERS:\n");
    iterating(buf, pathMap);

    final MultivaluedMap&lt;String, String&gt; queryMap = uriInfo.getQueryParameters();
    buf.append("QUERY_PARAMETERS:\n");
    iterating(buf, queryMap);

    final List&lt;PathSegment&gt; segmentList = uriInfo.getPathSegments();
    buf.append("PATH_SEGMENTS:\n");
    for (final PathSegment pathSegment : segmentList) {
        final MultivaluedMap&lt;String, String&gt; matrix = pathSegment.getMatrixParameters();
        final String segmentPath = pathSegment.getPath();
        buf.append(matrix);
        buf.append(segmentPath);
    }
    buf.append("\nHEAD:\n");
    final MultivaluedMap&lt;String, String&gt; headerMap = headers.getRequestHeaders();
    iterating(buf, headerMap);
    buf.append("COOKIE:\n");
    final Map&lt;String, Cookie&gt; kukyMap = headers.getCookies();
    final Iterator&lt;Entry&lt;String, Cookie&gt;&gt; i = kukyMap.entrySet().iterator();
    while (i.hasNext()) {
        final Entry&lt;String, Cookie&gt; e = i.next();
        final String k = e.getKey();
        buf.append("key=").append(k).append(",value=");
        final Cookie cookie = e.getValue();
        buf.append(cookie.getValue()).append(" ");
        buf.append("\n");
    }
    return buf.toString();
}

private void iterating(final StringBuilder buf, final MultivaluedMap&lt;String, String&gt; pathMap) {
    final Iterator&lt;Entry&lt;String, List&lt;String&gt;&gt;&gt; i = pathMap.entrySet().iterator();
    while (i.hasNext()) {
        final Entry&lt;String, List&lt;String&gt;&gt; e = i.next();
        final String k = e.getKey();
        buf.append("key=").append(k).append(",value=");
        final List&lt;String&gt; vList = e.getValue();
        for (final String v : vList) {
            buf.append(v).append(" ");
        }
        buf.append("\n");
    }
}
</code></pre>

<p>}</p>

<p>//测试代码
public class ContextTest extends JerseyTest {</p>

<pre><code>private static final Logger LOGGER = Logger.getLogger(ContextTest.class);

@Override
protected Application configure() {
    enable(TestProperties.LOG_TRAFFIC);
    enable(TestProperties.DUMP_ENTITY);
    return new ResourceConfig(ContextResource.class);
}

@Test
public void testContexts() {
    final String path = "ctx-resource";
    String result;

    /*http://localhost:9998/ctx-resource/Asia/China/northeast/liaoning/shenyang/huangu*/
    final WebTarget pathTarget = target(path).path("Asia").path("China").path("northeast").path("liaoning").path("shenyang").path("huangu");
    result = pathTarget.request().get().readEntity(String.class);
    ContextTest.LOGGER.debug(result);

    /*http://localhost:9998/ctx-resource/China/shenyang/tiexi?station=Workers+Village&amp;vehicle=bus*/
    final WebTarget queryTarget = target(path).path("China").path("shenyang").path("tiexi").queryParam("station", "Workers Village")
            .queryParam("vehicle", "bus");
    result = queryTarget.request().get().readEntity(String.class);
    ContextTest.LOGGER.debug(result);
}
</code></pre>

<p>}
```</p>

<h2>3. REST传输格式</h2>

<p>采用什么样的数据格式进行传输也是API设计的一个重要内容。通常REST接口以XML和JSON作为主要的传输格式。</p>

<h3>3.1 基本类型、输入流及Reader</h3>

<p>Java的基本类型主要包括4种整型（byte，short, int, long）、两种浮点类型（float, double）、Unicode编码的字符(char)和布尔类型(boolean)。</p>

<p>Jersey开发REST接口时，除了支持基本类型外，还支持文件类型（File）、字节流（InputStream）、字符流类型以及Reader类型。示例代码及测试类如下：</p>

<p>```java
@Path(&ldquo;in-resource&rdquo;)
public class InResource {</p>

<pre><code>private static final Logger LOGGER = Logger.getLogger(InResource.class);

@POST
@Path("b")
public String postBytes(final byte[] bs) {
    for (final byte b : bs) {
        LOGGER.debug(b);
    }
    return "byte[]:" + new String(bs);
}

@POST
@Path("c")
public Response postString(final String s) {
    LOGGER.debug(s);
    //Response.noContent().build();
    return Response.ok().entity("char[]:" + s).build();
}

@DELETE
@Path("{s}")
public void delete(@PathParam("s") final String s) {
    LOGGER.debug(s);
}

@POST
@Path("f")
public File postFile(final File f) throws IOException {
    try (BufferedReader br = new BufferedReader(new FileReader(f))) {
        String s;
        do {
            s = br.readLine();
            LOGGER.debug(s);
        } while (s != null);
        return f;
    }
}

@POST
@Path("bio")
public String postStream(final InputStream is) throws IOException {
    try (BufferedReader br = new BufferedReader(new InputStreamReader(is))) {
        StringBuilder result = new StringBuilder();
        String s = br.readLine();
        while (s != null) {
            result.append(s).append("\n");
            LOGGER.debug(s);
            s = br.readLine();
        }
        return result.toString();
    }
}

@POST
@Path("cio")
public Response postChars(final Reader r) throws IOException {
    try (BufferedReader br = new BufferedReader(r)) {
        StringBuilder result = new StringBuilder();
        String s = br.readLine();
        if (s == null) {
            throw new RuntimeException("NOT FOUND FROM READER");
        }
        while (s != null) {
            result.append(s).append("\n");
            LOGGER.debug(s);
            s = br.readLine();
        }
        return Response.ok().entity(result.toString()).build();
    }
}
</code></pre>

<p>}</p>

<p>/<em>测试</em>/
public class InputTest extends JerseyTest {</p>

<pre><code>private static final Logger LOGGER = Logger.getLogger(InputTest.class);
final String path = "in-resource";
String result;

@Override
protected Application configure() {
    enable(TestProperties.LOG_TRAFFIC);
    enable(TestProperties.DUMP_ENTITY);
    return new ResourceConfig(InResource.class);
}

@Test
public void testBytes() {
    final String message = "TEST STRING";
    final Builder request = target(path).path("b").request();
    //final Response response = request.post(Entity.entity(message, MediaType.TEXT_PLAIN_TYPE), Response.class);
    final Response response = request.post(Entity.entity(message, MediaType.TEXT_HTML_TYPE), Response.class);
    result = response.readEntity(String.class);
    LOGGER.debug(result);
    Assert.assertEquals("byte[]:" + message, result);
}

@Test
public void testResponse() {
    final String message = "TEST STRING";
    final Builder request = target(path).path("c").request();
    final Response response = request.post(Entity.entity(message, MediaType.TEXT_HTML_TYPE), Response.class);
    result = response.readEntity(String.class);
    LOGGER.debug(result);
    Assert.assertEquals("char[]:" + message, result);
}

@Test
public void testVoid() {
    final String message = "TEST STRING";
    final Builder request = target(path).path(message).request();
    final Response response = request.delete();
    int status = response.getStatus();
    LOGGER.debug(status);
    Assert.assertEquals(Response.Status.NO_CONTENT.getStatusCode(), status);
}

@Test
public void testFile() throws IOException {
    final URL resource = getClass().getClassLoader().getResource("gua.txt");
    assert resource != null;
    final String file = resource.getFile();
    final File f = new File(file);
    final Builder request = target(path).path("f").request();
    Entity&lt;File&gt; e = Entity.entity(f, MediaType.TEXT_PLAIN_TYPE);
    final Response response = request.post(e, Response.class);
    File result = response.readEntity(File.class);
    try (BufferedReader br = new BufferedReader(new FileReader(result))) {
        String s;
        do {
            s = br.readLine();
            LOGGER.debug(s);
        } while (s != null);
    }
}

@Test
public void testStream() {
    final InputStream resource = getClass().getClassLoader().getResourceAsStream("gua.txt");
    final Builder request = target(path).path("bio").request();
    Entity&lt;InputStream&gt; e = Entity.entity(resource, MediaType.TEXT_PLAIN_TYPE);
    final Response response = request.post(e, Response.class);
    result = response.readEntity(String.class);
    LOGGER.debug(result);
}

@Test
public void testReader() {
    ClassLoader classLoader = getClass().getClassLoader();
    final Reader resource = new InputStreamReader(classLoader.getResourceAsStream("gua.txt"));
    final Builder request = target(path).path("cio").request();
    Entity&lt;Reader&gt; e = Entity.entity(resource, MediaType.TEXT_PLAIN_TYPE);
    final Response response = request.post(e, Response.class);
    result = response.readEntity(String.class);
    LOGGER.debug(result);
}
</code></pre>

<p>}
```</p>

<h3>3.2 XML类型</h3>

<p>Java处理XML有两大标准：JAXP(Java API for XML Processing)和JAXB(Java Architecture for XML Binding)。</p>

<h4>JAXP</h4>

<p>JAXP包含了DOM、SAX和StAX三种解析XML的技术标准。</p>

<ul>
<li>DOM 面向文档解析的技术，要求将XML全部加载到内存，映射为树和结点。</li>
<li>SAX 事件驱动的流解析技术，通过监听注册事件，触发回调方法以实现解析。</li>
<li>StAX 拉式流解析技术，读取过程可以主动推进当前XML位置指针，而不是被动获得解析中的XML数据。</li>
</ul>


<p>相应地，JAXP定义了三种标准类型的输入接口Source(DOMSource、SAXSource和StreamSource)和输出接口Result(DomResult、SAXResult和StreamResult)。示例代码：<a href="https://github.com/feuyeux/jax-rs2-guide/blob/master/sample/3/simple-service-3/src/main/java/com/example/media/xml/XMLResource.java">代码</a>、<a href="https://github.com/feuyeux/jax-rs2-guide/blob/master/sample/3/simple-service-3/src/test/java/com/example/media/xml/XMLTest.java">测试代码</a>。</p>

<h4>JAXB</h4>

<p>JAXP的缺点是需要编码解析XML，增加了开发工作量。JAXB只需要在POJO中定义相关的注解，无须对XML进行程序式解析，推荐使用JAXB作为XML解析技术。</p>

<p>Jersey支持使用JAXBElement作为REST方法参数，也支持直接使用POJO作为REST方法参数，示例如下：</p>

<p>```
@XmlRootElement
public class Book implements Serializable {</p>

<pre><code>private Long bookId;
private String bookName;
private String publisher;

@XmlAttribute(name = "bookId")
public Long getBookId() {
    return bookId;
}

@XmlAttribute(name = "bookName")
public String getBookName() {
    return bookName;
}
...
</code></pre>

<p>}</p>

<p>@POST
@Path(&ldquo;jaxb&rdquo;)
@Produces(MediaType.APPLICATION_XML)
@Consumes(MediaType.APPLICATION_XML)
public Book getEntity(JAXBElement<Book> bookElement) {</p>

<pre><code>Book book = bookElement.getValue();
...
</code></pre>

<p>}</p>

<p>/<em>以POJO作为参数</em>/
@POST
@Produces(MediaType.APPLICATION_XML)
@Consumes(MediaType.APPLICATION_XML)
public Book saveBook(final Book book) {</p>

<pre><code>return bookService.saveBook(book);
</code></pre>

<p>} <br/>
```</p>

<h3>3.3 JSON类型</h3>

<p>JSON类型已经成为Ajax数据传输的实际标准，Jersey提供了4种处理JSON数据的媒体包。它们支持的处理方式如下表：</p>

<table>
<thead>
<tr>
<th>解析方式 </th>
<th> MOXy </th>
<th> JSON-P </th>
<th> Jackson </th>
<th> Jettison</th>
</tr>
</thead>
<tbody>
<tr>
<td>POJO-based JSON Binding </td>
<td> yes </td>
<td> no </td>
<td> yes </td>
<td> no</td>
</tr>
<tr>
<td>JAXB-based JSON Binding </td>
<td> yes </td>
<td> no </td>
<td> yes </td>
<td> yes</td>
</tr>
<tr>
<td>Low-level JSON parsing &amp; processing  </td>
<td> no </td>
<td> yes </td>
<td> no </td>
<td> yes</td>
</tr>
</tbody>
</table>


<p>请注意，JSON-P是指Java API for JSON Processing，而不是JSON with Padding(JSONP)。前者是Java处理JSON格式数据的API，而后者是用于异步请求中传递脚本的回调函数来解决跨域问题。</p>

<h4>使用Jackson处理JSON</h4>

<p><strong>(1)定义依赖</strong>，在pom中增加依赖：</p>

<p>```xml
<dependency></p>

<pre><code>&lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
&lt;artifactId&gt;jersey-media-json-jackson&lt;/artifactId&gt;
&lt;version&gt;${jersey.version}&lt;/version&gt;
</code></pre>

<p></dependency>
```</p>

<p><strong>(2)定义Application</strong>，需要在application中注册JacksonFeature，如有必要根据不同的实体类做详细解析，则可以注册ContextResolver的实现类。示例：</p>

<p>```java
@ApplicationPath(&ldquo;/api/*&rdquo;)
public class JsonResourceConfig extends ResourceConfig {</p>

<pre><code>public JsonResourceConfig() {
    register(JacksonFeature.class);
    register(BookResource.class);

    //注册ContextResolver的实现类
    register(JsonContextProvider.class);
}
</code></pre>

<p>}
```</p>

<p><strong>(3)定义POJO</strong>，可以定义三种不同方式的POJO：</p>

<p>```java
//第一种：仅用JAXB注解的普通POJO
@XmlRootElement
@XmlType(propOrder = {&ldquo;bookId&rdquo;, &ldquo;bookName&rdquo;, &ldquo;chapters&rdquo;})
public class JsonBook {</p>

<pre><code>private String[] chapters;
private String bookId;
private String bookName;

public String getBookId() {
    return bookId;
}

...
</code></pre>

<p>}</p>

<p>//第二种：混和使用JAXB注解和Jackson注解的POJO
@XmlRootElement
public class JsonHybridBook {</p>

<pre><code>@SuppressWarnings("unused")
@JsonProperty("bookId")
private String bookId;

@SuppressWarnings("unused")
@JsonProperty("bookName")
private String bookName;

...
</code></pre>

<p>}</p>

<p>//第三种：不使用任何注解的POJO</p>

<p>public class JsonNoJaxbBook {</p>

<pre><code>private String bookId;
private String bookName;

public String getBookId() {
    return bookId;
}
...
</code></pre>

<p>}  <br/>
```</p>

<p><strong>(4) 定义资源类</strong></p>

<p>```java
@Path(&ldquo;books&rdquo;)
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public class BookResource {</p>

<pre><code>@Path("/emptybook")
@GET
public JsonBook getEmptyArrayBook() {
    return new JsonBook();
}

@Path("/hybirdbook")
@GET
public JsonHybridBook getHybirdBook() {
    return new JsonHybridBook();
}

@Path("/nojaxbbook")
@GET
public JsonNoJaxbBook getNoJaxbBook() {
    return new JsonNoJaxbBook();
}
</code></pre>

<p>}
```</p>

<p><strong>(5)上下文解析实现类</strong> 可以根据上下文提供的POJO类型，分别提供解析方式。<a href="https://github.com/feuyeux/jax-rs2-guide/blob/master/sample/3/2simple-service-jackson/src/main/java/com/example/resource/JsonContextProvider.java">示例代码</a></p>

<p><strong>(6)单元测试</strong> <a href="https://github.com/feuyeux/jax-rs2-guide/blob/master/sample/3/2simple-service-jackson/src/test/java/com/example/resource/BookResourceTest.java">代码</a></p>

<h2>4. REST连通性</h2>

<p>在Restful Web Service中，Representation应该是超媒体（HyperMedia），也就是说表示中不仅包含数据，还包含指向其它资源的连接。这种具有“连接”的特性，称为连通性。连通性使服务器通过超媒体告诉客户端当前状态有哪些后续状态可以进入。例如在Google搜索页的“下一页”连接起的就是这种推进作用——它指引你如何从当前状态进入下一个可能的状态。在Restful Web服务的文档中只要包含URI就可以指向本应用的其他状态，因为Restful WebService是可寻址且无状态的应用。</p>

<h3>4.1 过渡型链接</h3>

<p>Web Link通过使用HTTP头信息来传递操作链接。在Jersey中使用javax.ws.rs.core.Link类来支持Web Link的资源类。示例如下：</p>

<p>```java
@Path(&ldquo;weblink-resource&rdquo;)
public class WebLinkResource {</p>

<pre><code>@Context
UriInfo uriInfo;

@Path("{bookId:[0-9]*}")
@GET
@Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
public Book getOne(@PathParam("bookId") final Long bookId) {
    final Book result = LinkCache.map.get(bookId);
    if (result == null) {
        throw new RuntimeException("Not found for bookId=" + bookId);
    }
    return result;
}

@POST
@Produces(MediaType.APPLICATION_XML)
@Consumes({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_XML})
public Response saveBook(final Book book) {
    final long newId = System.nanoTime();
    book.setBookId(newId);
    LinkCache.map.put(newId, book);
    //方式1：通过uriInfo实例获取资源路径，然后添加资源ID信息
    final UriBuilder ub = uriInfo.getAbsolutePathBuilder();
    final URI location = ub.path("" + newId).build();
    //方式2：通过模板获取资源路径，
    final String uriTemplate = "http://{host}:{port}/{path}/{param}";
    final URI location2 = UriBuilder.fromUri(uriTemplate)
            .resolveTemplate("host", "localhost")
            .resolveTemplate("port", "9998")
            .resolveTemplate("path", "weblink-resource")
            .resolveTemplate("param", newId).build();
    //方式3：通过模板方法获取资源路径
    final UriBuilder ub3 = uriInfo.getAbsolutePathBuilder();
    final URI location3 = ub3.scheme("http")
            .host("localhost")
            .port(9998)
            .path("weblink-resource")
            .path("" + newId).build();

    //这三个与Link相关的URI实例由Response构建，作为返回值响应给客户端
    return Response.created(location)
            .link(location2, "view1")
            .link(location3, "view2")
            .entity(book).build();
}
</code></pre>

<p>}</p>

<p>//测试
public class WebLinkTest extends JerseyTest {</p>

<pre><code>private static final Logger LOGGER = Logger.getLogger(WebLinkTest.class);

@Override
protected Application configure() {
    enable(TestProperties.LOG_TRAFFIC);
    enable(TestProperties.DUMP_ENTITY);
    return new ResourceConfig(WebLinkResource.class);
}

@Test
public void testPostAndGet() {
    final Entity&lt;Book&gt; entity = Entity.entity(new Book("WEBLINK"), MediaType.APPLICATION_XML_TYPE);
    final Response response = target("weblink-resource").request().post(entity, Response.class);
    final URI location = response.getLocation();
    WebLinkTest.LOGGER.debug(location.toString());
    final Set&lt;Link&gt; links = response.getLinks();
    for (final Link link : links) {
        WebLinkTest.LOGGER.debug(link);
    }
    final Book book = response.readEntity(Book.class);
    WebLinkTest.LOGGER.debug("POSTED::" + book);
    Assert.assertEquals("WEBLINK", book.getBookName());

    final Client client = ClientBuilder.newClient();
    final WebTarget target = client.target(location);
    final Response response2 = target.request().get();
    final Book book2 = response2.readEntity(Book.class);
    WebLinkTest.LOGGER.debug("GET::" + book2);
    Assert.assertEquals("WEBLINK", book2.getBookName());
}
</code></pre>

<p>}
```</p>

<h3>4.2 结构型链接</h3>

<p>HATEOAS用以代替聚集数据并避免描述膨胀，通常使用Atom格式在实体字段中提供链接信息。<a href="https://github.com/feuyeux/jax-rs2-guide/blob/master/sample/3/simple-service-3/src/main/java/com/example/link/HATEOASResource.java">示例代码</a></p>

<h2>5. REST响应处理</h2>

<p>REST的响应处理结果应包括HTTP状态码、响应实体的媒体参数类型、返回值类型以及异常情况处理。</p>

<h3>5.1 返回类型</h3>

<p>JAX-RS 2.0支持4种返回值类型的响应。</p>

<p><strong>（1）void</strong> 在返回值类型为void的响应中，其响应实体为空，HTTP状态码为204.</p>

<p><strong>（2）Response</strong> 响应实体为Response类的entity()方法定义的实体类实例。如果该内容为空，则HTTP状态码为204，否则为200 OK. 参见3.1的代码。</p>

<p><strong>（3）GenericEntity</strong> 不常用。其形式是构造一个统一的实体实例并将其返回。实体实例作为第一个参数，实体类型作为第二个参数。</p>

<p><strong>（4）自定义类型</strong> 即返回自定义的POJO类型，前述代码中已经有很多例子。</p>

<h3>5.2 处理异常</h3>

<p>处理异常包括异常的定义和错误状态码的正确返回。</p>

<h4>5.2.1 处理状态码</h4>

<p>JAX-RS 2.0规定的REST式WEB服务的基本异常类型为运行时异常WebApplicationException类，该类包括3个主要子类：</p>

<ul>
<li>RedirectionException HTTP状态码3xx的重定向类</li>
<li>ClientErrorException HTTP状态码4xx的请求错误类</li>
<li>ServerErrorException HTTP状态码5xx的服务器错误类</li>
</ul>


<p>除了上面的标准异常，也可以定义业务相关的异常类。示例：</p>

<p>```java
public class Jaxrs2GuideNotFoundException extends WebApplicationException {</p>

<pre><code>private static final long serialVersionUID = 1L;

public Jaxrs2GuideNotFoundException() {
    super(javax.ws.rs.core.Response.Status.NOT_FOUND);
}

public Jaxrs2GuideNotFoundException(String message) {
    super(message);
}
</code></pre>

<p>}
```</p>

<h4>5.2.2 ExceptionMapper</h4>

<p>Jersey提供了更通用的异常处理方式。通过实现ExceptionMapper接口并使用@Provider注解将其定义为一个Provider，可以实现通用的异常的面向切面处理。示例：</p>

<p>```java
@Provider
public class EntityNotFoundMapper implements ExceptionMapper<Jaxrs2GuideNotFoundException> {</p>

<pre><code>@Override
public Response toResponse(final Jaxrs2GuideNotFoundException ex) {
    return Response.status(404).entity(ex.getMessage()).type("text/plain").build();
}
</code></pre>

<p>}
```</p>

<p>在上面的代码中，当响应中发生了Jaxrs2GuideNotFoundException异常时，响应流程就会被拦截并补充HTTP状态码和异常消息，以文本作为媒体格式返回给客户端。</p>

<h2>6. REST内容协商</h2>

<p>一个资源可以有不同格式的表述，即响应实体。内容协商是指在服务提供的多种表述中，为特定的请求选择最好的一种表述的处理过程。客户端/浏览器通过使用HTTP Accept、Accept-Charset、Accept-Language和Accept-Encoding头来定义接收头的信息，将其所期待的格式或MIME类型告知服务器，服务器根据协商算法返回客户端可接收的数据信息。</p>

<h3>6.1 @Produces注解</h3>

<p>JAX-RS 2.0对内容协商的支持，是通过@Produces实现的。该注解可以为每种类型定义质量因素（0～1的小数值）。如果不定义则默认为1. 例如：</p>

<p>```java
@GET
@Produces({&ldquo;application/json; qs=.9&rdquo;, &ldquo;application/xml; qs=.5&rdquo;})
@Path(&ldquo;book/{id}&rdquo;)
public Book getBook(@PathParam(&ldquo;id&rdquo;) final Long bookId) {</p>

<pre><code>return new Book(bookId);
</code></pre>

<p>}
```</p>

<p>客户端也可以指定每种类型的质量因素。内容协商过程通常如下：</p>

<ul>
<li>如果客户端指定了一种类型，且服务端支持，则返回该类型。</li>
<li>如果客户端指定了服务端支持的两种类型，则返回服务端质量因素高的那种类型。</li>
<li>如果客户端指定了服务端支持的两种类型，同时客户端指定了类型的质量因素，则返回客户端质量因素高的那种类型。</li>
</ul>


<h3>6.2 @Consumes注解</h3>

<p>@Consumes注解用于定义方法的请求实体的数据类型，它只用于匹配请求处理的方法，不做内容协商使用。如果匹配不到，则服务器返回HTTP状态码415（Unsupported Media Type）。</p>

<p>参考：《Java RESTful Web Service实战》</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TDD学习笔记]]></title>
    <link href="http://blog.ubone.com/blog/2015/03/17/tddxue-xi-bi-ji/"/>
    <updated>2015-03-17T11:42:46+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/03/17/tddxue-xi-bi-ji</id>
    <content type="html"><![CDATA[<p>本文是《测试驱动开发的艺术》的学习笔记。</p>

<!--more-->


<h2>1. TDD入门</h2>

<p>TDD周期包括三个步骤：写测试、添加恰巧能让测试通过的代码，最后进行彻底的重构以改善设计。</p>

<h3>1.1 什么是好的测试？</h3>

<p>编写（单元）测试时有许多准则可以遵循，例如“测试之间应该相互隔离，并且不依赖于执行顺序”，“测试应该能快速的执行”，“测试中不应该有手动的初始化工作”，等等。不过从把需求分解到测试的角度来看，有两点尤为重要：</p>

<ul>
<li>好测试是原子化的；</li>
<li>好测试是独立的。</li>
</ul>


<p>测试的“三角法”是指会从多个方向同时入手，共同确定出恰当的实现。我们可以称之为“找茬”（playing difficult），不过它真的可以帮助防止过早优化、功能蔓延以及总体上的过度设计。</p>

<p>若采用广度优先的方式，我们会集中实现高层的功能，实现过程中会暂时使用底层功能的伪实现。若采用深度优先的方式，我们会先实现底层功能，在所有底层功能都实现完后才会组合来实现出高层功能。通常我会把代码中任何可能的问题或者缺陷都写成新测试加到测试列表中。</p>

<h3>1.2 对异常的验证</h3>

<p>```java
try {</p>

<pre><code>...//应该触发异常的代码

fail("evaluate() should throw an exception if " + "a variable was left without a value!"); 
</code></pre>

<p>} catch (MissingValueException expected) {
}
```</p>

<p>JUnit 4带给我们一个方便的，基于注释语法的异常测试方法。若使用注释语法语法，测试可以改写成：</p>

<p>```java
@Test(expected=MissingValueException.class)
public void testMissingValueRaisesException() throws Exception {</p>

<pre><code>new Template("${foo}").evaluate(); 
</code></pre>

<p>}
```</p>

<p>虽然这个基于注释语法的测试看起来比try-catch结构的测试精炼，不过使用try-catch，我们能够验证异常的更多信息（例如其中包括的关键错误信息）。有些人喜欢使用注释语法，另一些人总是偏好使用try-catch模式。我在只测试异常类型时使用注释语法，希望发掘出更多的信息时使用try-catch模式。</p>

<h3>1.3 Spike</h3>

<p>Spike基本上是一种是以实验为目的的原型方法，目的是为了研究某个解决方法的可能性和可行性。</p>

<h3>1.4 一些概念</h3>

<p>学习完如何编写测试及通过测试的技巧后，我们将会讨论一些重要概念，包括“夹具”（fixture）、“测试替身”（test doubles），还会讨论到“基于状态的测试”（state-based testing）与“基于交互的测试”1（interaction-based testing）的区别。我们还会重点讨论如何用测试替身处理难缠的协作对象。我们也将会探究三种不同的测试替身，包括伪实现(fakes)、测试桩（stubs）及模拟对象（mock object）。</p>

<h2>2. 如何选择测试</h2>

<p>在衡量待选测试的各个特征时，我们需要依靠直觉，也需要注意收集各种带有启发性的线索。首先，下面四个技巧可以帮我们选择下一步的测试：</p>

<ul>
<li>深入细节与整体考虑</li>
<li>探索未知与轻车熟路</li>
<li>最大限度地获取价值与摘取现成的果实</li>
<li>走通基本功能路径与先处理出错情况</li>
</ul>


<h3>2.1 细节与整体</h3>

<p>我将这两种方法分别称为“细节优先”和“整体优先”。当然这两种方法各有优劣。细节优先有利于降低风险，例如“我们能够对用户提交上来的图片进行模式识别吗？”，不过从整体角度考虑，处理模式识别问题会耽搁总体进度。从另一方面考虑，整体优先能够很快的验证总体设计，同时不用过多操心细节。整体优先的劣势在于其推迟了细节方面的工作进度。 实际上，我们会对各种方法做出评估，通常会（但不总会，如下节所述）先解决我们最关心的问题。这样就引出第二个测试选择技巧——探索未知与轻车熟路。</p>

<h3>2.2 不确定与熟悉</h3>

<p>减少不确定性是我们选择测试时要考虑的因素之一。除此之外，我们还可以先挑选自己熟悉的测试，稍后再处理不确定因素较多的测试。处理不确定性的好处简单明了，因为把未知转化成已知能有效的降低风险。 一直在我们熟悉的设计领域工作有什么好呢？那又不会带来任何新的知识和信息。这种工作方式有什么好呢？可是，付出并不总会得到回报。虽然降低风险很有价值，但是比起爬到高高的枝头探索未知的空间，有时摘下唾手可得的果实更加实惠。</p>

<h3>2.3 高价值与现成果实</h3>

<p>理想情况下，我们应当挑选那些工作量最少，回报却最多的测试。不过通常待选测试之间的区别并不是很明显，我们需要在付出回报比差别不大的各个测试间做出选择。 测试对象的基本功能还是测试对象对null输入的处理，是高价值与现成果实的一个典型例子。开发基本功能需要更多的时间精力，价值也更大。防御出错的功能、处理null输入，这些都很容易实现，但价值也小得多。</p>

<h3>2.4 基本功能与出错情形</h3>

<p>通常，我会先设法完成基本功能，然后再处理出错情形，如第三方类库抛出的异常及非法的输入等。这样做的主要原因是出于价值的考虑。一个能够处理任何出错情况的异常健壮的系统，若不能提供基本功能，根本毫无用处。另一方面，若某个系统在网络出现问题时会崩溃，</p>

<p>话虽如此，有时候还是需要把基本功能放到一边，先处理所有的出错情况。若挨个处理出错情况相当自然并符合直觉，并且只有正确处理了所有错误情况后系统的价值方能得到体现，则应当使用这种策略。</p>

<p>现在我们已经学到了很多选择测试的技巧。不过，不必过多考虑哪个测试才是“正确”的选择，测试的选择并没有一个标准答案。你会逐渐消化那些测试选择技巧，使用起来也会更加得心应手。不过总体上，从简单的测试入手应该是个好主意。一旦完成了第一个测试，接下来的工作就会变得更有头绪了。</p>

<h2>3.　实现技巧</h2>

<p>在著名的Test-Driven Development by Example一书中，Kent Beck列举了3种实现方式：伪实现（faking it）、三角法（Triangulation）以及显而易见的实现（obvious implementation）。</p>

<h3>3.1 伪实现</h3>

<p>写完测试时，我们并不总是清楚如何正确的实现功能使测试通过。这时候，我们可能会先伪实现某个功能，尽快回到绿的状态。可能是因为我们步伐过大，或是触到了系统内的某个“边界”，不过无论是什么原因都需要尽快通过测试，回到稳固可靠的状态。而伪实现功能比停留在红的状态好得多。返回硬编码的值可能是最简单的伪实现方法。你可能还记得，我们在上一章开发模板引擎时曾用过这种方法。</p>

<p>在伪实现某个功能后，我们可以很容易地切换到“三角法”模式，因为产品代码中绝不能包含硬编码的值，所以要想方设法清除掉硬编码部分，使用真实的实现。当然，为了达到目的，我们需要写一个新的测试。</p>

<h3>3.2 三角法</h3>

<p>“三角法”，顾名思义，正如电视中的警察们利用手机信号追踪犯罪嫌疑人。警察们从多点监测疑犯的信号进行三角定位。已知观测点的位置，警察们就可以在地图上标出两条线，线的交点则为疑犯位置。</p>

<p>我们在使用三角法时，当然不会监测信号，也不会在地图上做标记。我们每写一个测试，都会在一个维度上约束了可能的解决方案。当测试足够多时，测试就能有效地缩减解空间，三角定位出我们期望的实现。</p>

<h3>3.3 显而易见地实现</h3>

<p>通过测试的方法通常都显而易见。当然我们并不是说像硬编码返回值那样显而易见，而是指正确的实现通常都很容易。在这种情况下，我们大可以快速前进，直接做实现，而不用像三角法或者做伪实现时那样谨小慎微。</p>

<h2>4 测试驱动的基本准则</h2>

<p>我们总结出以下几条指导准则：</p>

<ul>
<li>绝不跳过重构</li>
<li>尽快变绿</li>
<li>犯错后减慢速度</li>
</ul>


<p>测试驱动时，我们要用最简单的方法解决手中的问题。不过这不是编码阶段所追求的目的，编码阶段应当试图尽快回到绿的状态。重构时再考虑优化设计。</p>

<p>出错后放慢脚步 开发人员在实践TDD过程中会自然地逐渐增大步伐。不过有时候，我们前进步伐太大，以至于出现错误而前功尽弃。这时，我们应当意识到步伐已经太大了，修改已超出理解范围。我们需要小心行事，小步前行，并彻底地重构。</p>

<h2>5 重要的测试概念</h2>

<h3>5.1 夹具</h3>

<p>夹具是测试的上下文，我们把夹具定义为测试类中所有测试方法共有的初始条件。</p>

<p>首先讨论初始状态的各个组成部分及其成因。迄今为止，我们都是在某类初始化方法中创建相互关联的对象以及构建出各个测试方法所需的夹具的。不过夹具的范畴不仅如此。归结其本质，夹具是整个运行时的状态，而并非仅指测试类的成员变量值，或相关对象的内部状态。</p>

<p>夹具可消除重复。追求优良的设计，是重视夹具的部分原因。我们应当用产品代码的标准来衡量测试代码，没有重复可能是最关键的衡量标准之一。夹具把多个测试共享的状态移至一处，有效消除了重复。</p>

<p>光板夹具（clean slate fixture）是绝对要避免的反模式（anti-pattern）。光板夹具，指每个测试方法都从头构建出的夹具；各个测试方法的初始化过程毫无共性。这表明测试间要么存在大量重复，要么毫无内聚性。若是后者，则需要把测试类分成几个类。</p>

<p>夹具使测试更紧凑。熟练的TDD开发人员很容易写出紧凑的测试。其要诀是，利用夹具设置与测试相关的系统、对象，只用几行代码就可以完成验证逻辑。</p>

<p>测试方法只关注真正要测的东西，同时避免其他任何干扰，这样做的好处显而易见，因为我们不会被一叶障目而不见泰山。这样，我们不再反复阅读代码，企图弄清楚“那段逻辑”到底在哪儿。若夹具足够好，其本身就能直接给出上下文，这样测试代码就可以直指要害了。</p>

<h3>5.2　用测试替身替换依赖</h3>

<p>测试中遇到的困难不少是因为被测对象和其他对象之间存在协作，或存在其他类型的依赖关系。例如某个类的构造函数参数是一个java.sql.ResultSet对象。</p>

<p>我们可以用测试替身来替代真实对象。测试替身乔装打扮，使用者对此毫不察觉。无论从实际执行时间角度，还是从开发和维护测试所耗时间角度，测试替身通常都比真实对象更快。</p>

<p>我们通常这样使用测试替身：首先创建测试替身（数量多少根据需要而定），然后配置测试替身的状态、行为和期望，最后把测试替身传给待测类，验证执行结果。</p>

<h3>5.3　基于状态及基于交互的的测试</h3>

<p>在最高层面上，根据验证期望行为的方式不同，测试替身可分为两类：基于状态的测试以及基于交互的测试。</p>

<p><strong>基于状态的测试 </strong></p>

<p>基于状态的测试利用对象内部状态来验证执行结果的正确性。我们需要获取待测对象及其协作对象的状态，然后与期望的状态做对比，进行验证。</p>

<p><strong>测试交互 </strong></p>

<p>基于交互的测试的验证方法截然不同。基于交互的测试验证待测对象与其协作对象以我们期望的方式进行交互，而非验证这些对象的最终状态是否匹配。换句话说，我们并不关心对象的内部状态，而更在乎待测对象是否正确调用了协作对象的方法，是否使用了正确的参数。如果可能，还需要验证调用顺序是否正确。 要实现基于交互的测试，需要使用动态模拟对象库（dynamic mock objects library）。在Java中，这种库有EasyMock3、jMock4以及rMock5等。这些库都是开源的，用户也很多。</p>

<p><strong>各种方法的适用范围</strong></p>

<p>我们依赖基于交互的测试来验证待测对象如何与其协作类进行对话；用基于状态的测试验证对象如何做出回应”。</p>

<h2>6　近处观察测试替身</h2>

<p>下表总结了不同类型的模拟对象：</p>

<table>
<thead>
<tr>
<th> Mock类型 </th>
<th> 描　　述 </th>
</tr>
</thead>
<tbody>
<tr>
<td> 测试桩 </td>
<td> 测试桩实际上是给定接口最简单的实现。例如，测试桩内的方法通常返回硬编码的、无意义的值 </td>
</tr>
<tr>
<td> 伪实现</td>
<td> 伪实现比测试桩更复杂，通常可以认为是接口的另一种实现。换言之，虽然伪实现并不是鸭子，但是其外形和行走方式和鸭子并无二致。相比之下，测试桩只是看起来像鸭子而已 </td>
</tr>
<tr>
<td> 模拟对象 </td>
<td> 从实现角度而言，模拟对象更加复杂。模拟对象可以验证待测对象与其协作对象的交互。由于具体实现方式不同，有些模拟对象可以返回硬编码的值，而有些能够提供逻辑的伪实现。模拟对象通常由框架或类库（像EasyMock）动态产生，不过也可以手动实现</td>
</tr>
</tbody>
</table>


<p>在EasyMock中，所有的模拟对象，自创建时起就处于录制模式。在录制模式下，我们可以录制模拟对象与其协作对象的交互方式，以及模拟对象本身的行为。录制时，只需要调用模拟对象的方法，然后再告诉EasyMock模拟对象对该调用当做何反应，例如该返回什么值，或者该抛出何种异常。示例如下：</p>

<p><code>java
PricingService mock = createMock(PricingService.class);
expect(mock.getDiscountPercentage(customer, product)).andReturn(discount);
</code></p>

<p>当录制完期望的协作及行为后，我们应当让EasyMock从录制模式切换到播放模式（replay），模拟对象开始监听各种事件。接着，我们把模拟对象传给待测对象，作为其协作对象。这时，待测类会与其协作对象交互，当然包括我们创建的模拟对象。当实际交互行为与录制的期望行为不符时，测试会失败。 最后，我们用模拟对象作为协作对象执行测试代码，若模拟对象没有因遇到非预期的调用而抛出任何异常，那我们就可以让模拟对象验证是否所有期望的调用都发生了。</p>

<h2>7　提高设计的可测试性的准则</h2>

<p>为了帮您避免可测试性问题，这里列举了一些值得注意的设计准则：</p>

<ul>
<li>尽量使用组合（composition）而非继承（inheritance）</li>
<li>避免使用static关键字，以及Singleton模式</li>
<li>隔离依赖（Isolate dependencies）</li>
<li>注入依赖（Inject dependencies）</li>
</ul>


<h3>7.1　尽量使用组合而非继承</h3>

<p>在测试中试图实例化对象时，对象的继承体系有时会带来不必要的麻烦。例如在Java中，我们可能只关注子类的特征，但却必须要提供只有其父类构造函数才需要的各项参数。如果这些参数本身又是很复杂的对象，需要费很多功夫才能初始化，那这项缺点就更加明显了。</p>

<p>另外，哪怕是极小的修改所产生的影响，都可能在整个继承体系内产生较大的影响，显然这样并不好。继承带来的限制过多，使测试很麻烦。这时，我们不得不考虑另一种替代方法，即组合。</p>

<p>组合是指通过组装一些稍简单的类来获得一个功能复杂的大类的过程。顶层的组合对象会把工作委托给其各个组成部分，而不是通过调用父类的方法来完成工作。实际上组合是基于对象级别的责任划分，而不是静态的、类级别上的划分。组合比继承稍显麻烦，代码量更多，不过组合能够提高可测试性、适应性以及可维护性，这些优点远大于多出几行代码所带来的麻烦。</p>

<h3>7.2　避免使用static关键字以及Singleton模式</h3>

<p>静态方法调用及Singleton模式也会影响可测试性。取决于待测代码与静态方法或Singleton模式的纠葛程度，在测试中用测试替身替换静态方法可能极其困难。或许很多时候我们用不着替换掉 Singleton或静态方法，但如果想这么做（例如在测试过程中，静态方法或者Singleton实例会试着连接远程服务器），可没那么容易。</p>

<p>很难用伪实现替换静态方法，因为类的类型信息已经硬编码在代码中了。同样，用getInstance()方法获取的Singleton类也很难用伪实现替换。其实Singleton模式本身并没错，而是其默认实现方式存在问题。有时，我们需要在测试过程中替换掉静态方法或者Singleton的实现。要完成替换，我们需要有一个静态方法，用于替换当前实现，在测试完成后，还需要把替换过的实现恢复原样。</p>

<h3>7.3　隔离依赖</h3>

<p>为了能够方便地用测试替身替换依赖，隔离依赖使其更容易替换非常关键。有几种方法可以解决这个问题：</p>

<p>把静态方法的访问移至成员方法，</p>

<p>```java
//有味道的代码：通过调用静态方法获取依赖
//这种方法并不好。我们把获取依赖与使用依赖的逻辑混在了一起。简言之，我们需要隔离依赖。
public class OrderProcessor {</p>

<pre><code>public void process(Order order) { 
    PricingService service = PricingService.getInstance(); 
    // use the PricingService object for processing the order 
} 
</code></pre>

<p>}</p>

<p>//已消除了代码味道：静态方法的调用包装进了成员方法中
public class OrderProcessor {</p>

<pre><code>public void process(Order order) { 
    PricingService service = getPricingService(); 
    // 通过替换获取依赖 
    // use the PricingService object for processing the order 
} 

protected PricingService getPricingService() { 
    /*（以下3行）覆盖返回的测试替身*/ 
    return PricingService.getInstance(); 
} 
</code></pre>

<p>}
```</p>

<p>在Working Effectively with Legacy Code一书中，Michael Feather定义了接缝（seams）的概念：“不用修改直接影响行为的代码就能改变系统行为的那个点”。换言之，在测试期间可以在某个点用一段代码替换另一段代码，而无需修改待测试代码，这个点就是接缝。在上面的代码中，从测试用例调用process方法的角度来看，getPricingService方法的调用实际就是接缝。</p>

<p>接缝，根据其定义，由一个或几个入侵点（enabling points）构成，即入侵接缝的不同途径。getPricingService本身就是入侵点。我们可以使用代码清单4-6中的方法将其覆盖。</p>

<p>```java
//入侵接缝
public class OrderProcessor {</p>

<pre><code>public void process(Order order) { 
    PricingService service = getPricingService(); 
    // 这就是接缝 
    // use the PricingService object for processing the order 
} 

protected PricingService getPricingService() { 
    // 入侵点 return PricingService.getInstance(); 
} 
</code></pre>

<p>}</p>

<p>public class OrderProcessorTest {</p>

<pre><code>@Test 
public void testOrderProcessorByExploitingTheSeam() throws exception { 
    OrderProcessor p = new OrderProcessor() { 
        protected PricingService getPricingService() { 
            return new FakePricingService(); 
            // 通过入侵点使用接缝 
        } 
    }; 
    ... 
} 
</code></pre>

<p>}
```</p>

<p>我们刚才看到的接缝属于对象接缝，利用面向对象功能，在调用代码中透明的覆盖方法。还有其他多种类型的接缝（每种语言都不一样），如预处理接缝、链接接缝等。</p>

<p>隔离依赖对可测试性及可维护性至关重要。</p>

<h3>7.4　注入依赖</h3>

<p>依赖注入（Dependency Injection，DI）是近来软件圈子里的热门话题之一。这种代码组织方式可以减少直接依赖，将其变为间接依赖，或者说把getter变为setter。这个概念最初叫做依赖反转（Inversion of Control），表示依赖反转了。ThoughtWorks公司的Martin Fowler引入了依赖注入这个术语来更好的表达出概念的本意，即注入依赖而非查找依赖。</p>

<p>```java
//　有了依赖注入，测试代码可读性更强了
public class OrderProcessorTest {</p>

<pre><code>@Test 
public void testOrderProcessorWithDependencyInjection() throws Exception { 
    OrderProcessor p = new OrderProcessor(); 
    p.setPricingService(new FakePricingService()); 
    ... 
} 
</code></pre>

<p>}
```</p>

<p><strong>依赖注入的不同类型 </strong></p>

<p>setter-based 依赖注入，通过调用setter注入所需的依赖。不过这不是唯一的依赖注入方式。</p>

<p>field-based依赖注入，及基于构造函数的依赖注入也很常见。 field-based注入实际和setter-based注入一样，唯一的区别是在field-based注入过程中，会直接给实例变量赋值，不通过setter，所以不能对注入的依赖进行任何操作。部分由于这个原因，field-based注入通常用在框架代码中，使用反射API给任意对象注入依赖，而不强求开发人员为纯依赖注入而写setter这种的样板代码。</p>

<p>基于构造函数的依赖注入是指用构造函数参数注入依赖。这种方法比setter-based注入方法要好，因为要使用setter-based注入，程序员必须要清楚以哪种顺序注入依赖。换句话说，用setter-based注入方法，可能会使目标对象处于未完全配置的状态。 基于构造函数的依赖注入方式也有不足，因为构造函数并不能体现在接口上，所以不能通过接口向对象注入依赖5。另外，把所需的各种依赖作为构造函数参数，可能会使构造函数参数列表过长，含义模糊（这有可能是设计缺陷的象征）。</p>

<h2>8　单元测试模式</h2>

<p>单元测试是TDD中的重要一环，所以了解单元测试的常用模式很有必要。在这一节中，我们将会了解不少模式，包括：</p>

<ul>
<li>写断言的模式</li>
<li>组织及构建夹具的模式</li>
<li>测试类总体模式。</li>
</ul>


<h3>8.1 断言模式</h3>

<h4>8.1.1 结果状态验证（Resulting State Assertion）</h4>

<p>结果状态验证是单元测试中最常用的方法。这种方式是指先调用对象的功能，然后验证其内部状态与期望的是否一致.</p>

<h4>8.1.2 防卫断言（Guard Assertion）</h4>

<p>防卫断言用来明确的验证调用功能前对夹具所做的各项假设。下面这个简单的例子表明了防卫断言的用途：</p>

<p>```java
@Test
public void listIsNoLongerEmptyAfterAddingAnItemToIt() throws Exception {</p>

<pre><code>List&lt;String&gt; list = new ArrayList&lt;String&gt;(); 
assertTrue(list.isEmpty()); 
// guard assertion list.add("something"); 
assertFalse(list.isEmpty()); 
// state verification 
</code></pre>

<p>}
```</p>

<p>请注意，在调用add方法前，防卫断言保证了空列表的isEmpty方法正确的返回了true，确保所测试的确实是期望的行为。</p>

<p>防卫断言模式常常与结果状态验证模式一同使用。这两种方法常常结合在一起，首先验证调用前状态与期望的一致，然后调用功能，验证结果状态，与上面的例子完全一样。 不过有时候，使用防卫断言是为了保证夹具的初始状态的正确性。这时，可以把防卫断言移至初始化方法的末尾，因为这些断言实际上是为了验证初始化方法。</p>

<h4>8.1.3 差值断言（Delta Assertion）</h4>

<p>有时在进行测试时我们需要在控制权不完全在自己手中的代码基础上工作。尤其是我们的测试可能并不能完全控制夹具。由此，在不能硬编码夹具状态的情况下，如何写出可靠、健壮及自检查的测试呢？解决方法是不要验证绝对值，而是验证代码执行前后的差值。</p>

<h4>8.1.4 自定义断言</h4>

<p>有时候用于验证期望的代码比调用待测对象所需的代码要多得多。这时（特别是当出现了不止一次时），可以从测试代码中提取出一个自定义断言，把复杂的验证逻辑封装进一个小巧的方法之中，以备测试代码调用。</p>

<p>自定义断言的一个常见用途是做不同类型的模糊匹配。例如，我们可能希望用对象的一部分属性来比对两个对象。另外一个常见原因是对象并没有正确的实现equals方法，同时我们还不能对其进行修改。此外，创建自定义断言可以在验证失败后能够提供更有意义的错误信息（注释21：有意义的出错信息非常有用，特别是测试变得过大时）。</p>

<h4>8.1.5 交互断言（Interaction Assertion）</h4>

<p>我们的最后一个验证模式称为交互断言。交互断言很有趣，其并不验证代码结果的正确性，而是验证代码与其协作对象的交互行为的正确性。</p>

<p>EasyMock等模拟对象库的内部工作机理。这些库把实际的方法调用及期望的方法调用记录到一个类似于列表的数据结构中，然后把期望的列表与实际列表相比较。</p>

<h3>8.2　夹具模式</h3>

<p>夹具是测试的重要组成部分。夹具的结构通常并不简单，我看到了不少巨大的夹具，用巨大的初始化方法创建出巨多的对象，这方法大到一屏都显示不下。无论在产品代码中，还是测试代码中，这种庞杂的代码都是个问题。还好，这些年来我们发现了不少模式，用于解决这类问题。</p>

<p>我们将会谈到3个此类模式。前两个模式关于在夹具中创建对象，第三个关于在测试结束时处理创建出的对象方法。准备好了吗？</p>

<h4>8.2.1 参数化创建方法</h4>

<p>典型的夹具中的大部分对象是所谓的实体对象（entity objects），用来表示业务领域中存在的实体或者实际概念。这类对象通常有很多属性，我见到的大多数糟糕的夹具就是因为填充这些属性，尽管不少属性对当前测试根本不重要。</p>

<p>参数化创建方法（Parameterized Creation Method）可以解决此问题，把不重要的属性从初始化方法中移到单独的创建方法中。此创建方法接受变量的属性值作为其参数，而把常量或者随机值直接赋给不重要的属性。</p>

<h4>8.2.2 对象母亲</h4>

<p>重构测试类，在类中加入创建方法从而消除重复，这种修改一开始效果会很好。不过不久我们就会发现不同类的创建方法间存在重复。接下来自然要把创建方法移到单独的类中以消除重复。对象母亲模式就是创建方法的聚合体。</p>

<p>总的来说，对象母亲模式是一个复杂的对象工厂，用于创建领域对象（domain object）的整个对象网络（object graph），还可以创建出不同状态下的实例。此外，对象母亲也可以提供方法修改某个领域对象，例如在对象间建立关联关系、移除关联关系、或者把对象设置为特征状态。</p>

<h4>8.2.3 自动清理</h4>

<p>在测试框架（如JUnit）中之所以需要清理方法，是为了执行测试后做必要的清除工作，例如在集成测试后删掉数据库中保存的数据，或者移除测试过程中创建出的文件。假如清理逻辑很复杂，或者需要清除的对象过多，我们的测试代码会变得很混乱，也很容易漏掉某些需要清除的对象。这会使后续的测试出现问题，而且极难调试或跟踪出问题的源头。</p>

<p>可以看出，在自动清理模式中，夹具的初始化方法不仅仅创建出了夹具对象，而且把这些对象添加到测试对象注册表中。这注册表只不过是一个对象引用的集合，当夹具的清理方法触动注册表时，注册表会清除每一个注册了的夹具对象。</p>

<h3>8.3　测试模式</h3>

<p>我们已经接触到了防卫断言到对象母亲等一系列测试相关模式。接下来我们会先学习一些更为通用的测试模式，然后学习如何在遗留代码上工作。</p>

<p>下面要介绍的这些模式主要是关于如何可使代码的可测试性更佳，以及使测试代码更紧凑，结构更好的Java语言技巧。</p>

<h4>8.3.1 参数化测试</h4>

<p>有时，我们会发现我们编写的测试几乎一模一样，只有个别输入值不同，而测试逻辑完全相同。这时，我们或许可以把这类测试重写成参数化测试。 这类测试的基本要点是，只编写一个测试方法，包含应用于测试数据的测试逻辑。当然，显然还需要一个方法提供参数化数据，再用一些代码绑定给定的测试数据到测试方法上。 还好，JUnit4为此提供了很多便利，要创建参数化测试只需要给测试类加上相应的注释（annotation）即可。下面的代码是在JUnit4中编写参数化测试的例子：</p>

<p>```java
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameters;</p>

<p>@RunWith(Parameterized.class)
public class ParameterizedTest { 　</p>

<pre><code>@Parameters 
/*❶（以下2行）提供参数化数据*/ 
public static Collection&lt;Object[]&gt; parameters() { 
    Object[][] data = new Object[][] { 
        { 0, 0, 0 }, 
        { 1, 1, 0 }, 
        { 2, 1, 1 }, 
        { 3, 2, 1 }, 
        { 4, 3, 1 }, 
        { 5, 5, 0 }, 
        { 6, 8, -2 } 
    }; 
    return Arrays.asList(data); 
} 　 

public int expected, input1, input2; 
　 
public ParameterizedTest(int expected, int input1, int input2) { 
    // ❷数据通过构造函数绑定 
    this.expected = expected; 
    this.input1 = input1; 
    this.input2 = input2; 
} 　 

@Test 
/*❸（以下2行）每个对象数组调用一切测试方法*/ 
public void executeParameterizedTest() throws Exception { 
    assertEquals(expected, new Calculator().add(input1, input2)); 
} 
</code></pre>

<p>}
```</p>

<p>上面的参数化测试由三部分组成。首先，我们用一个标有@Parameters的静态方法提供参数化数据。此方法返回一个对象数组的集合，每一个数组都表示一个数据集或者一个测试实例❶。换句话讲，JUnit会为每一个对象数组都重新实例化一次测试类。JUnit❷会把对象数组作为构造函数参数传给测试类，通常测试类会把这个参数保存在内部变量中，在❸测试方法中使用。最后，JUnit会调用标有@Test的测试方法。这就是整个测试过程。</p>

<p>参数化测试模式（Parameterized Test Pattern）可以很好的用来实现数据驱动测试。一旦写好了一个类似于代码清单4-14中的架子，添加新测试就非常方便了，只要加新的对象数组就行。 不过，添加一个对象数组不是创建新测试用例的最佳方法。如果代码清单4-14中的测试，每一个测试用例都是一行代码的断言，那么可读性会好得多。确实，当测试数据量非常大，而且是从XML或ASCII文件类的外部数据源获得，那么使用参数化测试会很合适，解析外部数据源的工作可以交给标有@Paramters的方法做。这样，测试类难免会变得稍微有些复杂，不过好处是可以以更合适的语法和文件格式描述测试数据。 不过需要处理大量数据的测试毕竟是少数，我们接下来会讨论些更常见的东西。因为很多对象都和其他对象有依赖关系，或许接下来应该介绍自分流（Self-Shunt）模式。</p>

<h4>8.3.2 自分流</h4>

<p>前面我们讨论过几种不同的测试替身，不过没有提及自分流模式。自分流模式也是一种测试替身，同时也是我们的测试类。自分流模式首先由Micheal Feathers提出，这种模式是指在测试中，测试类本身充当测试替身。</p>

<p>```java
//自分流模式的例子
public class SelfShuntExample implements PricingService {</p>

<pre><code>/*❶（以下5行）实现PricingService接口*/ 　 
@Override 
public float getDiscountPercentage(Customer c, Product p) { 
    return 10.0f; 
} 　 

@Test 
public void testOrderProcessorWithMockObject() throws Exception { 
    // some setup omitted for brevity... 
    OrderProcessor processor = new OrderProcessor(); 
    processor.setPricingService(this); 
    // ❷ 将“this”传给待测对象 
    processor.process(new Order(customer, product));
    assertEquals(expectedBalance, customer.getBalance(), 0.001f); 
} 
</code></pre>

<p>}
```</p>

<p>从上面代码可以看出，测试类实现了PricingService接口❶，这样我们就可以直接给待测类传入this❷，作为其协作对象，而不用重新创建一个测试替身，或者写出匿名类这样的凌乱代码。对于这种简单的情况，匿名类也是个不错的选择，不过随着方法数量的增多，匿名类代码也会变得越加凌乱，这时最好能使用自分流模式，或者单独的测试替身类。</p>

<p>要想在需要的地方快速创建出简单的测试替身，Shelf-Shunt是个绝佳的工具。不过随着测试替身的逻辑变得更加复杂，把这些逻辑移到独立的测试替身中会更合适。即便如此，我们要知道，独立的测试替身也有缺点。如果我们想在测试方法间或者测试替身间共享对象及数据，无间内部类（Intimate Inner Class）也许是个更好的选择。</p>

<h4>8.3.3 无间内部类</h4>

<p>有时我们会想在测试类间或者测试替身间共享对象及数据。这问题有几种解决办法（例如添加个getter），无间内部类作为解决方法之一，可能并不很一目了然。不过这并不意味着这种方法不好。实际上，非静态内部类那能够读取和修改测试类成员变量的能力，可以使测试代码更紧凑，比起用getter暴露测试替身内部状态要好得多。 我们可以用一段代码展示无间内部类的作用。下面的示例代码测试的行为是，Server对象在初始化时会从ThreadFactory中获取一个Thread对象，停止时会挂起这个线程。解决办法是使用无间内部类，它将一个新创建的Thread实例赋给包含测试类的thread成员变量。</p>

<p>```java
//无间内部类的例子
public class IntimateAnonymousInnerClassExample { 　</p>

<pre><code>private StartStopSynchronizedThread thread; 
// ❶在测试类和测试替身间共享 　 
@Test 
public void testStartingAndStoppingThreadsThroughAnExecutorService() throws Exception { 
    Server server = new Server(); 
    server.setThreadFactory(new ThreadFactory() { 
        /*❷无间内部类*/ 
        public Thread newThread(Runnable task) { 
            thread = new StartStopSynchronizedThread(task); 
            // ❶在测试类和测试替身间共享 
            return thread; 
        } 
    }); 

    server.start(); 
    thread.shouldBeStartedWithin(1, TimeUnit.SECONDS); 
    // ❸测试即可访问共享域 
    server.stop(); 
    thread.shouldBeStoppedWithin(1, TimeUnit.SECONDS); 
    // ❸测试即可访问共享域 
} 
</code></pre>

<p>}
```</p>

<p>可以看到，无间内部类❶使用了测试类中的thread成员变量❷，这样测试中就可以访问thread的成员变量做验证了❸。从技术层面上，无间内部类可以实现为匿名类或者内嵌类。像上面代码中的内部匿名类，可能会变得不好控制，但是它可以访问创建它的方法中的final变量。相比之下，内嵌类更清楚一些，不过数据访问上存在限制。两种方式都可以访问测试类的成员变量。 说到访问成员变量，下一个模式专门介绍如何访问那些本不该被访问到的成员变量。</p>

<h4>8.3.4 特许访问（Privileged Access）</h4>

<p>有时候你可能想改变一点系统现有代码，以测试新添加的代码，但由于某种原因，不能够修改那些代码。这时，“侵犯”现有代码的隐私，通过反射（reflection）API直接读取内部数据，就可以绕过问题，写出测试了。 JUnit邮件列表的文件区有PrivilegedAccessor类的源代码，可以用来做这类工作。另外JUnit-Addons的开源库6里包含PrivateAccessor类、Langhing Panda社区开发的BeanInject工具，也有类似的功能。</p>

<h4>8.3.5 额外构造函数（Extra Constructor）</h4>

<p>计算机世界里面充斥着大段大段怪物般的代码。与这种代码一起工作，很容易头昏脑胀，因为要实例化一个类，可能需要准备一大堆其他对象。这问题很可能是因为没有正确地隔离依赖。当然相应的解决方法是恰当地隔离依赖，把整个架构往依赖注入方向引导，不过这需要花费很多时间。这时，可以使用额外构造函数模式作为临时解决方法。 因为我们没法从外部替换掉依赖，所以要从内部替换。因此，需要给待测类添加额外的构造函数，把依赖作为参数传入，保存到相应的成员变量中，替换真实的依赖。 若原先的构造函数会创建或配置依赖（若不是，我们也可以把依赖配置代码移至这里），我们则可以修改原先构造函数，使其调用新构造函数。</p>

<h3>8.4 小结</h3>

<p>一开始，我们探讨了如何编写测试，介绍了一些测试选择技巧。有了这些技巧，选择测试时有了更多的依据。然后我们转而讨论最为基础的技术，如何使测试通过。这些技术有：伪实现、用三角定位法逐渐逼近正确的功能实现、及时常遇见的显而易见的实现。接着，我们简要陈述了测试驱动的三项准则：毫无保留的重构，尽快变绿，出了问题后放慢速度。</p>

<p>我们也讨论了几个重要的测试概念。我们把夹具定义为测试执行的上下文环境。我们研究了测试替身的多彩世界，学习了它的分类，包括：伪实现、测试桩及模拟对象。接着，我们比较了基于状态的测试及更为复杂的基于交互的测试。 通过深入地探讨伪实现、测试桩，特别是模拟对象，我们对测试替身的理解也更加细致。然后我们转而讨论提高可测试性等更高层次的准则。我们讨论了继承及组合，讨论了静态方法和Singleton模式的潜在问题。</p>

<p>在讨论完用接缝解决依赖问题后，我们进一步讨论了依赖注入带来的好处。 在理解了测试的重要概念，及具有良好的可测试性的设计的准则后，我们回到了模式方面的讨论。这些模式不少源自Gerard Meszaros的xunitpaterns.com。我们探讨了单元测试的相关模式，从不同断言间的微小差别，到初始化及清除夹具的大家伙模式。 我们的模式乐园之旅正式结束啦。</p>

<h2>9. 其它测试</h2>

<h3>9.1 测试驱动Web组件</h3>

<h4>9.1.1　测试驱动Java Servlets</h4>

<p>HttpServlet类的service方法负责处理所有HTTP请求。我们的Servlet类会继承自这个HttpServlet类。HttpServlet的Service方法根据HTTP请求的类型把请求转发到相应的doXXX()方法上。</p>

<p>```java
//为LoginServlet配置AuthenticationService
public class TestLoginServlet { 　</p>

<pre><code>private static final String CORRECT_PASSWORD = "correctpassword"; 
private static final String VALID_USERNAME = "validuser";
private LoginServlet servlet; 

/* 将普通对象移到域中*/ 
private FakeAuthenticationService authenticator; 
private MockHttpServletRequest request; 
private MockHttpServletResponse response; 　 
@Before 
public void setUp() { 
    authenticator = new FakeAuthenticationService(); 
    authenticator.addUser(VALID_USERNAME, CORRECT_PASSWORD); 　 
    servlet = new LoginServlet() { 
        @Override 
        protected AuthenticationService getAuthenticationService() { 
            return authenticator; 
        } 
    }; 

    request = new MockHttpServletRequest(); 
    response = new MockHttpServletResponse(); 
} 　 

@Test 
public void wrongPasswordShouldRedirectToErrorPage() throws Exception { 
    request.addParameter("j_username", VALID_USERNAME); 
    request.addParameter("j_password", "wrongpassword"); 
    servlet.service(request, response); 
    assertEquals("/invalidlogin", response.getRedirectedUrl()); 
} 　 

@Test public void validLoginForwardsToFrontPageAndStoresUsername() throws Exception { 
    request.addParameter("j_username", VALID_USERNAME); 
    request.addParameter("j_password", CORRECT_PASSWORD); 
    servlet.service(request, response); assertEquals("/frontpage", response.getRedirectedUrl()); 
    assertEquals(VALID_USERNAME, request.getSession() .getAttribute("username")); 
} 
</code></pre>

<p>}
```</p>

<p>提取出公用初始化方法后，测试都通过了。不过j_username和j_password这两个字符串还存在重复，也可以重构成常量。虽然有时候可读性比“不能有重复”更重要，不过就这具体情况，我强烈建议做重构。这重复不但存在于测试方法之间，还存在于测试代码与产品代码之间，为此我们需要定义公共的常量，让产品代码和测试代码都使用此常量，这样就可以消除重复了。</p>

<p>现在来看看我们对AuthenticationService接口做了哪些工作。我们引入了AuthenticationService接口，这样LoginServlet就不用知道过多验证细节了。至于如何给Servlet注入AuthenticationService暂时不做考虑，先使用getter方法，做测试时可以覆盖这个方法。目前我们还没实现真正的AuthenticationService，只有一个伪实现。 采用分治法，我们可以保持Java Servlet的代码既干净，可测试性又好。使用意图编程，小步地通过测试，我们正在一步步地实现完整的功能。在LoginServlet例子中我们也看到了，用测试驱动的方法编写Servlet代码并不比写普通代码难多少。</p>

<p>```java
//包含依赖注入的LoginController的完整实现
public class LoginController implements Controller { 　</p>

<pre><code>private AuthenticationService authenticator; 　 
public void setAuthenticationService(AuthenticationService authService) { 
    this.authenticator = authService; 
} 　 

public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { 
    String user = request.getParameter("j_username"); 
    String pass = request.getParameter("j_password"); 
    if (authenticator.isValidLogin(user, pass)) { 
        return new ModelAndView("frontpage"); 
    } 
    return new ModelAndView("wrongpassword"); 
} 
</code></pre>

<p>}
```</p>

<p>上面的代码没什么新东西。运行所有测试，当前有效登录的测试通过了，第一个测试却失败了。这是因为我们没有给第一个测试中的控制器注入AuthenticationService。我们可以把公共的初始化代码提取成一个成员方法，再给这个方法标记上@Before。这一步重构的结果就不在这里演示了，你可以自己试试，重构后代码会很简洁。 看完这些例子后，我想不会再有人认为现代MVC框架下测试驱动控制器类有任何麻烦或者困难了。这些实际上都只是普通的Java代码，只不过接口稍微大了一点而已。</p>

<h4>9.1.2　用JspTest测试驱动JSP</h4>

<p>JspTest里有一个叫做HtmlTestCase的抽象类，所有测试都需要继承这个类。HtmlTestCase提供了一些方法来模拟HTTP请求和渲染JSP文件以及做HTTP相关的验证等。</p>

<h3>9.2 测试驱动数据访问</h3>

<p>开发应用逻辑层（application logic layer）时，可以使用持久化逻辑伪实现。我们可以验证业务逻辑代码正确地调用了持久层方法，传入了正确的参数。那么我们在开发持久层时应该模拟JDBC API（或其他任何正在使用的持久化框架接口），还是该访问数据库？应该使用真实的数据库，还是使用轻量级，速度飞快的，但和真实数据库系统有一定差别的内存数据库？</p>

<h4>9.2.1　用DAO模式分层</h4>

<p>此模式是指每个持久化的领域对象（domain object）都应该有一个DAO接口负责其持久化工作。具体持久化方式有很多种，可以是关系数据库、对象数据库、或是文件系统上的一堆XML文件。对象本身及DAO的调用者并不知道对象从哪里来，到哪里去，以及是否具有持久性。因此，我们可以随意替换持久化的具体实现技术，而上层应用程序对此不会有一丝察觉。</p>

<p>```java
//PersonDao接口对应用代码隐藏了实现细节
public interface PersonDao {</p>

<pre><code>Person find(Integer id); 
void save(Person person); 
void update(Person person); 
void delete(Person person); 
List&lt;Person&gt; findAll(); 
List&lt;Person&gt; findByLastname(String lastname); 
</code></pre>

<p>}
```</p>

<p>比起把数据访问代码与应用逻辑代码混在一起，使用DAO模式的好处显而易见。另外使用DAO模式还可以缩减代码量。如果使用了Hibernate或Spring框架的JdbcTemplate等现成的开源持久层框架，能够显著加快开发速度。好的框架能帮你做不少工作，开发人员就可以专心开发持久化逻辑，而不用在持久化技术细节上花太多功夫了。</p>

<h3>9.3 小结</h3>

<p>我们了解了如何测试驱动数据访问代码。这工作比想象的要容易得多。我们从两个角度阐述了这个问题——分别使用了单元测试和集成测试驱动产品代码的开发。 首先，我们讨论了为何数据访问代码与普通的应用程序代码或业务逻辑代码间存在一定差别，为何其会跨越许多层。然后我们了解了DAO模式，以及如何用这种模式解决代码臃肿的现实问题。 然后，我们尝试用3种不同的持久化技术实现一个简单的DAO类。这3种技术分别为：纯JDBC API、Spring框架提供的JdbcTemplate以及Hibernate API。因为使用3种技术实现同一种功能，我们很容易看出框架的可测试性风格对TDD过程的影响。 在学会用单元测试驱动数据访问代码后，我们转向了另一种方式：直接连接到HSQLDB内存数据库进行集成测试。我们讨论了在集成测试中使用轻量级数据库可能带来的问题，也讨论了在版本控制系统中维护各项配置的必要性。 我们学习了如何搭建集成测试的基础架构，好让集成测试编写工作变得飞快，讨论了用SQL脚本及Hibernate API来创建数据库模式，亦讨论了如何用事务夹具清理测试数据。我们也介绍了用DbUnit填充数据库，以及用外部XML数据文件中的内容进行结果验证。 在尝试测试驱动数据访问代码的两种不同方法后，我们发现两种方法各自的优势，并决定针对具体情况而使用不同的方法。</p>

<h2>10　JUnit 4简明教程</h2>

<p>```java
import static org.junit.Assert.<em>;
// ❶
import org.junit.</em>;
import java.io.*;</p>

<p>public class TestConsoleLogger {</p>

<pre><code>// ❷ private static final String EOL = System.getProperty("line.separator"); 
private ConsoleLogger logger; 
/*❸ */ 
private PrintStream originalSysOut, originalSysErr; 
private ByteArrayOutputStream sysOut, sysErr; 

@Before 
public void createFixture() { 
    // ❹ 
    logger = new ConsoleLogger(); 
    /*❸*/ 
    originalSysOut = System.out; 
    originalSysErr = System.err; 
    sysOut = new ByteArrayOutputStream(); 
    sysErr = new ByteArrayOutputStream(); 
    System.setOut(new PrintStream(sysOut)); 
    System.setErr(new PrintStream(sysErr)); 
} 

@After 
public void resetStandardStreams() { 
    // ❺ System.setOut(originalSysOut); 
    System.setErr(originalSysErr); 
} 

@Test /*❻❼ */
public void infoLevelGoesToSysOut() throws Exception { 
    logger.info("msg"); 
    streamShouldContain("[INFO] msg" + EOL, sysOut.toString()); 
} 

@Test(timeout = 100) // ❽ 
public void errorLevelGoesToSysErr() throws Exception { 
    // ❻❼ 
    logger.error("Houston..."); 
    streamShouldContain("[ERROR] Houston..." + EOL, sysErr.toString()); 
} 

/*❾ */
private void streamShouldContain(String expected, String actual) { 
    /*❿ */ 
    assertEquals("Wrong stream content.", expected, actual); 
} 
</code></pre>

<p>}
```</p>

<p>❶ 通过静态导入的JUnit的Assert类获取断言方法。 ❷ 类名应该表明它是一个测试（例如名称中包含Test）。 ❸ 在@Before方法中设置的实例变量表示测试方法中常用的类具。 ❹ 通过为一个公有方法加上@Before注解来为测试准备一个已知状态。 ❺ 通过为一个公有方法加上@After注解来在测试之后执行清理操作。 ❻ 所有带@Test注解的public void方法均被视为JUnit 4 TestRunner的测试用例。 ❼ 测试方法可以声明任何异常——JUnit负责捕获它们。 ❽ @Test注解也可以用于计时测试、测试异常等。 ❾ 除测试方法外，还可以声明任意数量的辅助方法。</p>

<h2>11　EasyMock简明教程</h2>

<p>```java
import static org.easymock.EasyMock.<em>;
/</em>❶ */
import org.easymock.EasyMock;
import org.junit.Test;</p>

<p>public class TestInternetRelayChat {</p>

<pre><code>@Test public void messagesAreOnlyDeliveredToOtherClients() throws Exception { 
    String msg = "Maisk Maisk!"; 
    Client koskela = EasyMock.createMock(Client.class); 
    /*❷*/ 
    Client freeman = EasyMock.createMock(Client.class); 
    Client himberg = EasyMock.createMock(Client.class); 
    /*❸ */
    expect(himberg.onMessage("lasse", msg)).andReturn(true); 
    freeman.onMessage("lasse", msg); /*❹*/ 
    expectLastCall().andReturn(true); 
    replay(freeman, koskela, himberg); // ❺ 
    InternetRelayChat irc = new InternetRelayChat(); /*❻ */ 
    irc.join("inhuman", freeman); 
    irc.join("vilbert", himberg); 
    Prompt prompt = irc.join("lasse", koskela); 
    prompt.say(msg); 
    verify(freeman, koskela, himberg); // ❼ 
} 
</code></pre>

<p>}
```</p>

<p>❶ 从EasyMock和类自身中导入静态辅助方法。 ❷ 让EasyMock为指定接口创建模拟对象。 ❸ 记录期望的交互操作。 ❹ 功能上与上一条语句等价，但语法不同。 ❺ 记录完期望的信息后，转换为应答模式。 ❻ 一切都准备好以后，做个练习。 ❼ 让模拟对象验证是否发生了期望的交互行为。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Collections]]></title>
    <link href="http://blog.ubone.com/blog/2015/03/14/java-collections/"/>
    <updated>2015-03-14T20:51:05+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/03/14/java-collections</id>
    <content type="html"><![CDATA[<p>Java提供了一套完整的Collection框架，能够帮助我们减少开发工作量、提高程序运行速度和代码质量。本文学习Java Collection框架。</p>

<!--more-->


<h2>1. 接口层级结构</h2>

<p>核心Collection接口封装了各种类型的集合，它是Java Collections框架的基石。接口继承层次如下图所示：</p>

<p><img src="/myresource/images/image_blog_2015-03-14-colls-coreInterfaces.png" alt="image" /></p>

<p>注意，从上图可以看出，Map并不是真正的Collection。所有核心Collection接口都支持泛型。在声明Collection实例时，你可以也应该指明集合的元素类型，让编译器帮你校验放入集合的元素类型是否匹配，从而降低运行时错误。</p>

<p>类结构图</p>

<p><img src="/myresource/images/image_blog_2015-03-14-colls-classdiagram.jpg" alt="image" /></p>

<h2>2. Collection接口</h2>

<p>Collection类都有很方便的构造器。例如你有一个<code>Collection&lt;String&gt; c</code>，它可能是一个List、Set或其它Collection类型。通过构造方法可以转换成另一种Collection：</p>

<p><code>java
List&lt;String&gt; list = new ArrayList&lt;String&gt;(c);
</code></p>

<p>基本的Collection操作包括：</p>

<ul>
<li><code>int size()</code></li>
<li><code>boolean isEmpty()</code></li>
<li><code>boolean contains(Object element)</code></li>
<li><code>boolean add(E element)</code></li>
<li><code>boolean remove(Object element)</code></li>
<li><code>Iterator&lt;E&gt; iterator()</code></li>
</ul>


<p>操作整个Collection的相关方法：</p>

<ul>
<li><code>boolean containsAll(Collection&lt;?&gt; c)</code></li>
<li><code>boolean addAll(Collection&lt;? extends E&gt; c)</code></li>
<li><code>boolean removeAll(Collection&lt;?&gt; c)</code></li>
<li><code>boolean retainAll(Collection&lt;?&gt; c</code>)（交集，只保留c中存在的元素）</li>
<li><code>void clear()</code></li>
</ul>


<p>此外还有数组的操作：<code>Object[] toArray()</code>,  <code>&lt;T&gt; T[] toArray(T[] a)</code></p>

<h3>2.1 遍历Collection</h3>

<p>有三种方法遍历Collection：聚合操作、for-each和Iterator。</p>

<h4>2.1.1 聚合操作</h4>

<p>JDK8之后，推荐使用聚合操作来遍历Collection。聚合操作常常与lambda表达式一起让代码更具表达力。下面的代码完成遍历并打印红色的对象的name:</p>

<p>```java
myShapesCollection.stream()</p>

<pre><code>.filter(e -&gt; e.getColor() == Color.RED)
.forEach(e -&gt; System.out.println(e.getName()));
</code></pre>

<p>```</p>

<p>对多核系统，还可以请求并行流，这对超大Collection有帮助：</p>

<p>```java
myShapesCollection.parallelStream()</p>

<pre><code>.filter(e -&gt; e.getColor() == Color.RED)
.forEach(e -&gt; System.out.println(e.getName()));
</code></pre>

<p>```</p>

<p>更多例子：</p>

<p>```java
//将Collection中的元素转换成一个String，用逗号分隔：
String joined = elements.stream()</p>

<pre><code>.map(Object::toString)
.collect(Collectors.joining(", "));
</code></pre>

<p>//计算合计
int total = employees.stream()</p>

<pre><code>.collect(Collectors.summingInt(Employee::getSalary)));
</code></pre>

<p>```</p>

<h4>2.1.2 for-each</h4>

<p>```java
for (Object o : collection)</p>

<pre><code>System.out.println(o);
</code></pre>

<p>```</p>

<h4>2.1.3 Iterator</h4>

<p>```java
public interface Iterator<E> {</p>

<pre><code>boolean hasNext();
E next();
void remove(); //optional
</code></pre>

<p>}
```</p>

<p>注意remove方法删除最后一次next()方法返回的对象。因此，每调用一次remove方法之前都必须调用next方法，否则会抛出异常。remove方法也是迭代过程中唯一安全的修改Collection的方法。以下场景需要使用Iterator而不是for-each:</p>

<ul>
<li>删除当前元素</li>
<li>并行遍历多个Collection</li>
</ul>


<p>下面的代码演示了如何使用Iterator过滤Collection:</p>

<p>```java
static void filter(Collection&lt;?> c) {</p>

<pre><code>for (Iterator&lt;?&gt; it = c.iterator(); it.hasNext(); )
    if (!cond(it.next()))
        it.remove();
</code></pre>

<p>}
```</p>

<h3>2.2 Collection批量操作</h3>

<p>Collection批量操作的方法大部分返回值都是boolean，如果Collection有变化则返回true:</p>

<ul>
<li><code>boolean containsAll(Collection&lt;?&gt; c)</code></li>
<li><code>boolean addAll(Collection&lt;? extends E&gt; c)</code></li>
<li><code>boolean removeAll(Collection&lt;?&gt; c)</code></li>
<li><code>boolean retainAll(Collection&lt;?&gt; c)</code>（取交集）</li>
<li><code>void clear()</code>.</li>
</ul>


<p>Collections.singleton(T o)用于创建包含一个元素“o”的Set，类似的方法还包括：<code>List&lt;T&gt; singletonList(T o)</code>， <code>&lt;K,V&gt; Map&lt;K,V&gt; singletonMap(K key, V value)</code>。示例：</p>

<p><code>
//移除某个元素的所有实例
c.removeAll(Collections.singleton(e));
//移除所有null
c.removeAll(Collections.singleton(null));
</code></p>

<h3>2.3 Collections工具类</h3>

<p>除了singleton方法，Collections工具类还有一些常用的方法，如：</p>

<ul>
<li><code>unmodifiableXXX()</code>返回一个只读视图。(xxx可能是Collection, List, Map, Set, SortedMap, SortedSet)</li>
<li><code>synchronizedXXX()</code>返回一个同步（线程安全）的Collection。</li>
<li><code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>方法</li>
<li><code>shuffle</code>方法（打乱顺序）</li>
<li><code>min/max</code> 可传Comparator</li>
<li><code>copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</code> 复制所有元素到另一个List。dest的数量必须大于等于src，操作完成后，src中的所有元素会覆盖dest中相应位置（index）的元素。</li>
<li><code>int frequency(Collection&lt;?&gt; c,Object o)</code> 返回c中o出现的次数。</li>
<li><code>fill(List&lt;? super T&gt; list, T obj)</code> 将所有元素替换成obj。</li>
</ul>


<h3>2.4 Array操作</h3>

<p>Collection提供了toArray()方法，用于转换成数组。示例：</p>

<p><code>
Object[] a = c.toArray();
</code></p>

<p>如果已知Collection中的元素是字符串类型，如Collection<String> c，则可以直接转换成字符串数组：</p>

<p><code>
String[] a = c.toArray(new String[0]);  //0没有意义，只是和new String一起表示是字符串数组。
</code></p>

<h2>3. Set</h2>

<p>Set是一种不能包含重复元素的Collection。Set接口只继承了Collection接口的方法，并增加了禁止重复元素的限制，它依赖于equals和hashCode方法的行为。Set包括三种类型：</p>

<ul>
<li>HashSet 元素保存在hash表中，高性能，但无法保证迭代顺序。</li>
<li>TreeSet 元素保存在红黑树中，有序，但比HashSet慢不少。</li>
<li>LinkedHashSet hash表加linked list实现，顺序为插入顺序。避免HashSet顺序的不确定性，同时性能接近HashSet。</li>
</ul>


<p>对于HashSet，需要注意的是遍历性能与entry数量和bucket数量(容量)之和成线性关系。如果初始容量太大，则浪费空间和时间；反过来，如果初始容量太小则浪费增容时的复制时间。如果不指定初始容量，默认值为16. 过去通过指定一个初始容量能提高性能，但现在已经没必要了。LinkedHashSet的迭代时间与容量没有关系。</p>

<p>除了上面三种标准Set实现，还有两个特殊的Set实现：EnumSet和CopyOnWriteArraySet.</p>

<p>EnumSet是用于枚举类型的高性能Set实现。所有元素必须是同一种枚举类型。内部采用bit-vector实现，通常是一个long。它支持在指定范围内遍历，也可以替代传统的标志位。示例如下：</p>

<p>```
for (Day d : EnumSet.range(Day.MONDAY, Day.FRIDAY))</p>

<pre><code>System.out.println(d);
</code></pre>

<p>EnumSet.of(Style.BOLD, Style.ITALIC)
```</p>

<p>CopyOnWriteArraySet是由copy-on-write数组实现的Set. 所有修改操作，如add, set, remove都会复制一个新的数组拷贝，因此不需要锁。只适合于很少修改、但频繁遍历的Set。</p>

<p>HashSet、TreeSet和LinkedHashSet的实现并不是同步的。因此如果多个线程同时访问一个Set，且有线程会修改Set，就必须进行同步处理，或者使用Collections.synchronizedSet方法对其封装。最好在创建时就完成此操作，以HashSet为例：</p>

<p><code>
Set s = Collections.synchronizedSet(new HashSet(...));
</code></p>

<h3>3.1 基本操作</h3>

<p>假设你有一个Collection c，下面的代码可以让你方便地去除重复：</p>

<p>```java
Collection<Type> noDups = new HashSet<Type>&copy;;
//如果要保持原来的顺序，可以：
Collection<Type> noDups = new LinkedHashSet<Type>&copy;;</p>

<p>//如果是JDK8，你还可以这么玩：
c.stream().collect(Collectors.toSet()); // no duplicates
//另一个例子，将姓名放到一个TreeSet中
Set<String> set = people.stream()
.map(Person::getName)
.collect(Collectors.toCollection(TreeSet::new));
```</p>

<table>
<thead>
<tr>
<th>方法 </th>
<th> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>int size() </td>
<td> 返回元素数量</td>
</tr>
<tr>
<td>boolean isEmpty() </td>
<td> 是否为空</td>
</tr>
<tr>
<td>boolean add() </td>
<td> 增加元素，如果之前不存在，返回true</td>
</tr>
<tr>
<td>boolean remove() </td>
<td> 删除元素，如果之前存在此元素，返回true</td>
</tr>
<tr>
<td><code>Iterator&lt;E&gt; iterator()</code> </td>
<td> 迭代器</td>
</tr>
</tbody>
</table>


<p>JDK8聚合操作与for-each操作示例：</p>

<p>```java
//JDK8
public class FindDups {</p>

<pre><code>public static void main(String[] args) {
    Set&lt;String&gt; distinctWords = Arrays.asList(args).stream()
        .collect(Collectors.toSet()); 
    System.out.println(distinctWords.size()+ 
          " distinct words: " + distinctWords);
}
</code></pre>

<p>}
//for-each
public class FindDups {</p>

<pre><code>public static void main(String[] args) {
    Set&lt;String&gt; s = new HashSet&lt;String&gt;();
    for (String a : args)
       s.add(a);
    System.out.println(s.size() + " distinct words: " + s);
}
</code></pre>

<p>}
//运行
java FindDups i came i saw i left
//结果：
4 distinct words: [left, came, saw, i]
```</p>

<p>上面的代码使用的是HashSet，所以顺序是乱的。如果你改成TreeSet/LinkedHashSet，则结果变为：</p>

<p><code>
//TreeSet
4 distinct words: [came, i, left, saw]
//LinkedHashSet
4 distinct words: [i, came, saw, left]
</code></p>

<h3>3.2 批量操作</h3>

<p>Set的批量操作并没有什么特殊的方法，但是利用Set元素不会重复这个特性，可以做一些有意思的事情。例如修改FindDups，找到不重复的单词和重复的单词：</p>

<p>```
public class FindDups2 {</p>

<pre><code>public static void main(String[] args) {
    Set&lt;String&gt; uniques = new HashSet&lt;String&gt;();
    Set&lt;String&gt; dups    = new HashSet&lt;String&gt;();

    for (String a : args)
        if (!uniques.add(a))
            dups.add(a);

    // Destructive set-difference
    uniques.removeAll(dups);

    System.out.println("Unique words:    " + uniques);
    System.out.println("Duplicate words: " + dups);
}
</code></pre>

<p>}</p>

<p>//output:
Unique words:    [left, saw, came]
Duplicate words: [i]
```</p>

<h3>3.3 HashSet</h3>

<p>HashSet通过hash table（实际上就是一个HashMap实例）实现。允许null元素。基本方法（如add, remove, contains, size）为常量时间，而遍历性能则与元素数量加桶数量之和成正比。因此，如果迭代性能要求高的话，不要将初始容量设置得太大。</p>

<h3>3.4 TreeSet</h3>

<p>TreeSet是基于TreeMap的NavigableSet实现。元素按natural ordering或Comparator排序。注意要正确地实现Set接口，就应该让Comparable与equals接口实现保持一致。因为Set不重复由equals决定，而顺序由Comparable决定。TreeSet提供降序或升序视图，但升序一般比降序性能更优。</p>

<p>TreeSet允许null元素，但一些方法的返回值也可能是null（不存在时），这样就会造成混乱。因此建议不要加入null元素。基本操作（add, remove, contains）的时间成本为log(n). TreeSet增加了NavigableSet接口的方法，常用方法如下表：</p>

<table>
<thead>
<tr>
<th>方法 </th>
<th> 说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>E ceiling(E e) </td>
<td> 返回大于等于e的最小元素，如果没有返回null</td>
</tr>
<tr>
<td>E higher(E e) </td>
<td> 返回大于e的最小元素，如果没有返回null</td>
</tr>
<tr>
<td>E floor(E e) </td>
<td> 返回小于等于e的最大元素，如果没有返回null</td>
</tr>
<tr>
<td>E lower(E e) </td>
<td> 返回小于e的最大元素，如果没有返回null</td>
</tr>
<tr>
<td><code>Iterator&lt;E&gt;</code> descendingIterator() </td>
<td> 返回降序迭代器。</td>
</tr>
<tr>
<td><code>NavigableSet&lt;E&gt;</code> descendingSet() </td>
<td> 返回降序视图</td>
</tr>
<tr>
<td>E first() </td>
<td> 返回第一个（最小的）元素</td>
</tr>
<tr>
<td>E last() </td>
<td> 返回最后一个（最大的）元素</td>
</tr>
<tr>
<td><code>NavigableSet&lt;E&gt;</code> headSet(E toElement, boolean inclusive) </td>
<td> 返回小于toElement的元素，如果inclusive=true表示返回结果包含toElement。</td>
</tr>
<tr>
<td><code>NavigableSet&lt;E&gt;</code> tailSet(E fromElement, boolean inclusive) </td>
<td> 返回大于（等于，如果inclusive=true）的元素。</td>
</tr>
<tr>
<td>E pollFirst() </td>
<td> Retrieves and removes the first (lowest) element, or returns null if this set is empty.</td>
</tr>
<tr>
<td>E pollLast() </td>
<td> Retrieves and removes the last (highest) element, or returns null if this set is empty.</td>
</tr>
<tr>
<td><code>NavigableSet&lt;E&gt;</code> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) </td>
<td> 取子集。</td>
</tr>
<tr>
<td>Object clone() </td>
<td> 返回TreeSet实例的浅拷贝</td>
</tr>
</tbody>
</table>


<h3>3.5 LinkedHashSet</h3>

<p>LinkedHashSet会保持插入的顺序，但是如果多次添加一个元素，并不会改变元素原来的的位置。允许null元素。</p>

<p>与HashSet一样，有两个参数影响其性能：初始容量和load factor。</p>

<h3>3.6 EnumSet</h3>

<p>EnumSet的所有元素必须是同一个枚举类型的值，不允许null元素。它的效率很高，是替代传统标志位的推荐方案，用long实现。Iterator按自然顺序（枚举中声明的顺序）返回元素。常用方法如下表：</p>

<table>
<thead>
<tr>
<th>方法</th>
<th> 说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt;  allOf(Class&lt;E&gt; elementType)</code> </td>
<td> 创建一个包括枚举类型所有值的EnumSet</td>
</tr>
<tr>
<td><code>EnumSet&lt;E&gt; clone()</code> </td>
<td> 复制一份。</td>
</tr>
<tr>
<td><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; complementOf(EnumSet&lt;E&gt; s)</code> </td>
<td> 创建一个同类型的EnumSet，其中的元素为枚举类型所有值减去s中的值。</td>
</tr>
<tr>
<td><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; copyOf(Collection&lt;E&gt; c)</code> </td>
<td> 创建EnumSet，元素来自c。</td>
</tr>
<tr>
<td><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType)</code> </td>
<td> 创建一个空的EnumSet</td>
</tr>
<tr>
<td><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; of(E e, E... rest)</code> </td>
<td> 创建包括指定元素的EnumSet</td>
</tr>
<tr>
<td><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; range(E from, E to)</code> </td>
<td> 创建指定元素范围的EnumSet</td>
</tr>
</tbody>
</table>


<h3>3.7 CopyOnWriteArraySet</h3>

<p>CopyOnWriteArraySet内部使用CopyOnWriteArrayList来实现所有操作。因此：</p>

<ul>
<li>最适合那些size小，读操作远多于修改操作，在遍历中需要防止其它线程干扰的场景。</li>
<li>它是线程安全的。</li>
<li>修改操作成本较高，因为通常要复制整个数组。</li>
<li>Iterator不支持remove操作。</li>
<li>通过iterator遍历很快，不会受其它线程影响，因为它依赖一个在iterator创建时的数组只读镜像。</li>
</ul>


<p>示例代码：</p>

<p>```
class Handler { void handle(); &hellip; }</p>

<p>class X {
   private final CopyOnWriteArraySet<Handler> handlers</p>

<pre><code> = new CopyOnWriteArraySet&lt;Handler&gt;();
</code></pre>

<p>   public void addHandler(Handler h) { handlers.add(h); }</p>

<p>   private long internalState;
   private synchronized void changeState() { internalState = &hellip;; }</p>

<p>   public void update() {</p>

<pre><code> changeState();
 for (Handler handler : handlers)
   handler.handle();
</code></pre>

<p>   }
}
```</p>

<h2>4. List接口</h2>

<p>List接口继承自Collection，它比后者增加了以下类型的方法：</p>

<ul>
<li>Positional access 基于位置的访问方法，如get, set, addAll</li>
<li>Search 搜索指定对象并返回数字索引，如indexOf, lastIndexOf</li>
<li>Iteration 继承Iterator，增加增了List的特性。ListIterator。</li>
<li>Rang-View sublist方法提供range相关操作。</li>
</ul>


<p>Java提供两种普通List实现：ArrayList和LinkedList，前者通常有更好的性能，后者在特定场景有更好性能。如果你需要频繁地在List的起始位置插入元素，或者频繁遍历元素并删除，则使用LinkedList更合适。</p>

<p>另一个特殊的实现是CopyOnWriteArrayList，与CopyOnWriteArraySet类似。无需同步操作，不会有ConcurrentModificationException.</p>

<p>Arrays工具类提供了<code>asList()</code>方法，这样可以用List的方式查看数组。但是该操作并不是复制整个数组，对List的修改操作将会影响array，反过来也是如此。因此这个List并不是真正的List，它没有add, remove方法，因为数组不是变长的。如果List是定长的，也没有containsAll之类的bulk操作，可以考虑使用Arrays.asList。</p>

<p>ListIterator提供两个方向迭代的能力，因此多了hasPrevious和previous方法。ListIterator的构造方法有两种格式，默认格式不带参数，表示从头遍历。带int参数的格式表示从指定位置遍历。ListIterator提供了安全的修改方法add, remove和set。它们能够在迭代的过程中安全地修改List的内容。</p>

<ul>
<li>add()方法，在List当前位置插入一个对象。所谓当前位置就是：add方法增加对象后，调用previous()方法将返回这个对象。</li>
<li>remove()方法，将当前元素删除。所谓当前元素就是：如果刚调用了next()或previous()方法，当前元素就是它们返回的元素。注：每调用一次remove()，都需要先调用一次next()或者previous()，如果刚调用了add()，也必须先调用一次next()或者previous()。</li>
<li>set()方法，更新当前元素。当前元素的定义与remove()方法相同。每次set()之前，也必须调用next()或previous()。</li>
</ul>


<p><code>subList(int fromIndex, int toIndex)</code>方法提供了range-view操作。由于subList返回的只是List的一个view，因此对返回结果的修改会影响原List。例如下面的代码删除指定范围内的数据：</p>

<p><code>
list.subList(fromIndex, toIndex).clear();
</code></p>

<h3>4.1 LinkedList</h3>

<p>Doubly-linked列表，实现了List和Deque接口。由于是链表结构，因此基于索引的操作将导致从头遍历。常用的方法：</p>

<table>
<thead>
<tr>
<th>方法 </th>
<th> 说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void addFirst(E e)</code> </td>
<td> 在最前面插入</td>
</tr>
<tr>
<td><code>void addLast(E e)</code> </td>
<td> 加到最后面</td>
</tr>
<tr>
<td><code>boolean offer(E e)</code>, <code>boolean offerFirst(E e)</code>, <code>boolean offerLast(E e)</code> </td>
<td> 增加操作。默认是加到最后。如果操作成功返回true</td>
</tr>
<tr>
<td><code>E element()</code> </td>
<td> 获取但不删除第1个元素</td>
</tr>
<tr>
<td><code>E getFirst()/getLast()</code> </td>
<td> 返回第1个/最后一个元素</td>
</tr>
<tr>
<td><code>E peek()</code> </td>
<td> 获取但不移除第一个元素</td>
</tr>
<tr>
<td><code>E peekFirst()/peakLast()</code> </td>
<td> 获取但不移除第一个/最后一个元素，如果list为空则返回null</td>
</tr>
<tr>
<td><code>E poll()</code> </td>
<td> 获取并删除第1个元素, 如果list为空则抛出NoSuchElementException</td>
</tr>
<tr>
<td><code>E pollFirst()/pollLast()</code> </td>
<td> 获取并删除第一个/最后一个元素，如果list为空则返回null, 如果list为空则抛出NoSuchElementException</td>
</tr>
<tr>
<td><code>E pop()</code> </td>
<td> stack pop</td>
</tr>
<tr>
<td><code>void push(E e)</code> </td>
<td> stack push</td>
</tr>
<tr>
<td><code>boolean remove(Object o)</code>, <code>E removeFirst()</code>, <code>boolean removeFirstOccurrence(Object o)</code>, <code>E removeLast()</code>, <code>boolean removeLastOccurrence(Object o)</code> </td>
<td> 与删除相关的操作，如果list为空则抛出NoSuchElementException</td>
</tr>
</tbody>
</table>


<h3>4.2 Stack</h3>

<table>
<thead>
<tr>
<th>方法 </th>
<th> 说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>boolean empty()</code> </td>
<td> Tests if this stack is empty.</td>
</tr>
<tr>
<td><code>E peek()</code> </td>
<td> Looks at the object at the top of this stack without removing it from the stack.</td>
</tr>
<tr>
<td><code>E pop()</code> </td>
<td> Removes the object at the top of this stack and returns that object as the value of this function.</td>
</tr>
<tr>
<td><code>E push(E item)</code> </td>
<td> Pushes an item onto the top of this stack.</td>
</tr>
<tr>
<td>int search(Object o) </td>
<td> Returns the 1-based position where an object is on this stack</td>
</tr>
</tbody>
</table>


<h2>5. Queue接口</h2>

<p>Queue接口增加了以下方法，它们的返回值有两种类型：抛出异常、返回特殊值：</p>

<p>```
public interface Queue<E> extends Collection<E> {</p>

<pre><code>E element();
boolean offer(E e);
E peek();
E poll();
E remove();
</code></pre>

<p>}
```</p>

<table>
<thead>
<tr>
<th>操作类型 </th>
<th> 抛出异常 </th>
<th> 返回特殊值</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入操作 </td>
<td> add(e) </td>
<td> offer(e) 成功返回true</td>
</tr>
<tr>
<td>删除操作 </td>
<td> remove() 队列为空时异常 </td>
<td> poll() 队列为空返回null</td>
</tr>
<tr>
<td>检查操作 </td>
<td> element() 队列为空时异常 </td>
<td> peek() 队列为空返回null</td>
</tr>
</tbody>
</table>


<p>队列通常是FIFO的行为，但优先队列的顺序取决于它的值。java.util.concurrent下的一些队列有数量限制（bounded），但java.util下的队列没有数量限制。java.util.concurrent.BlockingQueue 继承自Queue，提供了阻塞的机制。</p>

<h3>5.1 普通队列</h3>

<p>LinkedList实现了Queue接口，提供FIFO队列操作add, poll等等。优先队列PriorityQueue的顺序取决于元素的natural ordering或构造方法的Comparator参数。</p>

<h3>5.2 多线程队列</h3>

<p>java.util.concurrent.BlockingQueue继承自Queue，其实现是线程安全的。所有队列方法使用内部锁或其它多线程控制实现原子操作。但是bulk操作，如addAll, containsAll, retainAll, removeAll并没有实现原子操作。例如<code>addAll(c)</code>执行时，如果另一线程在c中添加了元素则会导致addAll失败。</p>

<p>BlockingQueue不支持null元素。它可能有数量限制，否则最大为Integer.MAX_VALUE。它的方法有四种模式：</p>

<table>
<thead>
<tr>
<th>操作类型 </th>
<th>Throws exception </th>
<th> Special value </th>
<th> Blocks </th>
<th> Times out</th>
</tr>
</thead>
<tbody>
<tr>
<td>Insert</td>
<td>add(e) </td>
<td> offer(e)</td>
<td> put(e) </td>
<td> offer(e, time, unit)</td>
</tr>
<tr>
<td>Remove</td>
<td>remove() </td>
<td> poll() </td>
<td> take() </td>
<td> poll(time, unit)</td>
</tr>
<tr>
<td>Examine</td>
<td>element() </td>
<td> peek() </td>
<td> not applicable </td>
<td> not applicable</td>
</tr>
</tbody>
</table>


<p>JDK提供了以下实现：</p>

<ul>
<li>LinkedBlockingQueue — an optionally bounded FIFO blocking queue backed by linked nodes</li>
<li>ArrayBlockingQueue — a bounded FIFO blocking queue backed by an array</li>
<li>PriorityBlockingQueue — an unbounded blocking priority queue backed by a heap</li>
<li>DelayQueue — a time-based scheduling queue backed by a heap</li>
<li>SynchronousQueue — a simple rendezvous mechanism that uses the BlockingQueue interface</li>
<li>LinkedTransferQueue — an unbounded TransferQueue based on linked nodes</li>
</ul>


<h2>6. Deque接口</h2>

<p>音（deck），支持从两端插入和删除的队列。它同时包含了Queue和Stack接口方法。ArrayDeque和LinkedList实现了Deque接口。Deque支持FIFO和LIFO。</p>

<p>相关的方法参考LinkedList。LinkedBlockingDeque实现了多线程Deque。</p>

<h2>7. Map接口</h2>

<p>Java提供了三种通用的Map实现：HashMap, TreeMap和LinkedHashMap。它们的行为与HashSet, TreeSet和LinkedHashSet相似。如果你想要有序的Map，能够提供有序的keySet，使用TreeMap；如果想要最优性能，使用HashMap。如果既想要高性能，又想保持插入的顺序，使用LinkedHashSet。</p>

<p>JDK8中引入了相关的聚合操作，示例如下：</p>

<p>```
// Group employees by department
Map&lt;Department, List<Employee>> byDept = employees.stream()</p>

<pre><code>.collect(Collectors.groupingBy(Employee::getDepartment));
</code></pre>

<p>// Compute sum of salaries by department
Map&lt;Department, Integer> totalByDept = employees.stream()</p>

<pre><code>.collect(Collectors.groupingBy(Employee::getDepartment, Collectors.summingInt(Employee::getSalary)));
</code></pre>

<p>// Partition students into passing and failing
Map&lt;Boolean, List<Student>> passingFailing = students.stream()</p>

<pre><code>.collect(Collectors.partitioningBy(s -&gt; s.getGrade()&gt;= PASS_THRESHOLD)); 
</code></pre>

<p>// Classify Person objects by city
Map&lt;String, List<Person>> peopleByCity</p>

<pre><code>= personStream.collect(Collectors.groupingBy(Person::getCity));
</code></pre>

<p>//cascade two collectors to classify people by state
Map&lt;String, Map&lt;String, List<Person>>> peopleByStateAndCity</p>

<pre><code>= personStream.collect(Collectors.groupingBy(Person::getState,
</code></pre>

<p>  Collectors.groupingBy(Person::getCity)))
```</p>

<p>Map提供了Collecton view，有三种方法：</p>

<ul>
<li>keySet 所有key的集合</li>
<li>values 所有值。这不是一个Set，因为value会有重复。</li>
<li>entrySet 所有key-value的集合</li>
</ul>


<p>Map的遍历方法有多种：</p>

<p>```
for (KeyType key : m.keySet())</p>

<pre><code>System.out.println(key);
</code></pre>

<p>// Filter a map based on some
// property of its keys.
for (Iterator<Type> it = m.keySet().iterator(); it.hasNext(); )</p>

<pre><code>if (it.next().isBogus())
    it.remove();
</code></pre>

<p>for (Map.Entry&lt;KeyType, ValType> e : m.entrySet())</p>

<pre><code>System.out.println(e.getKey() + ": " + e.getValue());            
</code></pre>

<p>```</p>

<p>不用担心Map创建Collection view的性能。通过Collecton view iterator遍历时，可以调用Iterator的remove方法来删除map中的键值对。利用Map.Entry遍历时也可以调用entry.setValue方法来修改值。Collection view支持remove, removeAll, retainAll, clear, Iterator.remove操作。例如，以下命令会清空所有数据：</p>

<p><code>
Set&lt;Integer&gt; set = map.keySet();
set.clear();
</code></p>

<p>Map的Collection view在很多场合能起到便利作用。以下是一些示例：</p>

<p>```
//判断一个Map的key是否包含另一个Map的key
if (m1.entrySet().containsAll(m2.entrySet())) {</p>

<pre><code>...
</code></pre>

<p>}</p>

<p>//判断两个Map的key是否相同
if (m1.keySet().equals(m2.keySet())) {</p>

<pre><code>...
</code></pre>

<p>}</p>

<p>//判断两个Map的key交集（注意新建了一个set，避免对Map产生影响）
Set<KeyType>commonKeys = new HashSet<KeyType>(m1.keySet());
commonKeys.retainAll(m2.keySet());
```</p>

<h3>7.1 LinkedHashMap</h3>

<p>LinkedHashMap的顺序通常是插入顺序，同一元素多次重复插入并不会修改它的位置。</p>

<p>LinkedHashMap还提供了一个特殊的构造方法，它创建的LinkedHashMap顺序是entry被访问的顺序。元素的访问时间越近，则它越靠前。因此这种LinkedHashMap非常适合做LRU(least recently used)缓存。构造方法如下：</p>

<p>```
public LinkedHashMap(int initialCapacity,</p>

<pre><code>                 float loadFactor,
                 boolean accessOrder)
</code></pre>

<p>```</p>

<p>影响这种LinkedHashMap元素顺序的访问方法包括：put, putInfoAbsent, get, getOrDefault, compute, computeIfAbsent, computeIfPresent, merge, replace(如果之前存在，替换动作成功)和putAll方法。其中putAll方法会对指定map中的所有元素都产生一次访问，访问的顺序取决于指定map的entryset iterator。除了以上方法外，其他方法都不会影响元素顺序，特别是作用于Collection view的方法也不会对元素顺序产生影响。</p>

<p>覆盖removeEldestEntry(Map.Entry)方法可以在Map移除旧Entry时自定义一些策略。</p>

<p>LinkedHashMap性能接近于HashMap，在遍历时性能比HashMap更优。因为LinkedHashMap的迭代性能只与size相关，而HashMap还与容量相关。</p>

<h3>7.2 其它Map实现类</h3>

<p>除了HashMap, TreeMap和LinkedHashMap, 还有一些其它的Map实现：</p>

<ul>
<li>EnumMap与EnumSet类似。</li>
<li>WeakHashMap 弱引用，便于垃圾收集</li>
<li>IdentityHashMap 在此Map中，当且仅当k1==k2时，认为两个key是相等的。（HashMap判断相等使用的是equals）很少用。</li>
<li>ConcurrentHashMap 高并发、高性能的Map。线程安全。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Web中文编码]]></title>
    <link href="http://blog.ubone.com/blog/2015/02/23/java-webzhong-wen-bian-ma/"/>
    <updated>2015-02-23T15:57:18+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/02/23/java-webzhong-wen-bian-ma</id>
    <content type="html"><![CDATA[<p>介绍常见的编码格式，以及Java Web和JavaScript相关的字符集编码。</p>

<!--more-->


<h2>1. 常见的编码格式</h2>

<table>
<thead>
<tr>
<th>编码 </th>
<th> 说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ASCII </td>
<td> 共128个，用1个字节表示。0～31为控制字符，如换行、回车等。32～126为打印字符。</td>
</tr>
<tr>
<td>ISO-8859-1 </td>
<td> 扩展ASCII编码，仍然是单字节，共256个字符。</td>
</tr>
<tr>
<td>GB2312 </td>
<td> 双字节编码，A1~A9是符号区，共682个符号；B0~F7是汉字区，共6763个汉字</td>
</tr>
<tr>
<td>GBK </td>
<td> 为Win95所制定的汉字内码规范，扩展GB2312，与GB2312兼容，能表示21003个汉字。</td>
</tr>
<tr>
<td>GB18030 </td>
<td> 可能是单字节、双字节或者四字节编码，与GB2312兼容。虽然是国家标准，但未广泛使用。</td>
</tr>
<tr>
<td>UTF-16 </td>
<td> 定义了Unicode字符在计算机中的存取方法。Unicode是ISO试图创建一个全新的超语言字典，世界上所有语言都可以通过这个字典相互翻译。Unicode是Java和XML的基础。UTF-16用两个字节来表示Unicode的转化格式，采用定长的表示方法。</td>
</tr>
<tr>
<td>UTF-8 </td>
<td> 避免UTF-16的空间浪费，采用变长技术，每个编码区域有不同的字码长度。不同类型的字符可以由1～6个字节组成。</td>
</tr>
</tbody>
</table>


<p>UTF-8的编码规则：</p>

<ul>
<li>如果是1个字节，最高位（第8位）为0，表示1个ASCII字符。</li>
<li>如果是1个字节，以11开着，则连续的1的个数表示这个字符的字节数。例如110xxxxx表示它是双字节UTF-8字符的首字节。</li>
<li>如果1个字节，以10开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节。</li>
</ul>


<h2>2. Java中的编码场景</h2>

<h3>2.1 在I/O中编码</h3>

<p>在磁盘和网络I/O中，都涉及字节与字符的转换。Reader类是Java的I/O中读字符的父类，而InputStream类是读字节的父类。两者之间的转换由StreamDecoder和StreamEncoder完成。在编、解码过程中必须指定Charset，否则使用本地环境默认字符集，如中文环境使用GBK。</p>

<p>在实际开发过程中，只要保持编码的一致就不会造成乱码：</p>

<p>```java
String charset = &ldquo;UTF-8&rdquo;;
String file = &ldquo;c:/stream.txt&rdquo;;</p>

<p>FileOutputStream fos = new FieOutputStream(file);
OutputStreamWriter writer = new OutputStreamWriter(fos, charset);</p>

<p>&hellip;
InputStreamReader reader = new InputStreamReader(inputStream, charset);
```</p>

<h3>2.2 在内存中编码</h3>

<p>String类提供了字符和字节的转换方法：</p>

<p><code>java
String s= "这是一段中文";
byte[] b = s.getBytes("UTF-8");
String n = new String(b, "UTF-8");
</code></p>

<p>另一种方法是使用Charset类：</p>

<p><code>java
Charset charset = Charset.forName("UTF-8");
ByteBuffer byteBuffer = charset.encode("abcd");
CharBuffer charBuffer = charset.decode(byteBuffer);
</code></p>

<h2>3. Java Web中的编解码</h2>

<p>用户从浏览器发起一个HTTP请求，需要编码的地方包括URL、Cookie和Parameter。</p>

<h3>3.1 URL的编解码</h3>

<p>URL <code>http://localhost:8080/examples/servlets/servlet/books?author=jason</code> 可分解为：</p>

<ul>
<li>URI: <code>/examples/servlets/servlet/books</code></li>
<li>schema: http</li>
<li>domain: localhost</li>
<li>port: 8080</li>
<li>contextPath: examples</li>
<li>servletPath: servlets/servlet</li>
<li>PathInfo: books</li>
<li>QueryString: author=jason</li>
</ul>


<p>对于Tomcat，对URL的URI部分进行解码的字符集是在Connector中定义的。如果没有定义，那么默认为ISO-8859-1。QueryString的解码字符集要么是Header中ContentType定义的Charset，要么是默认的ISO-8859-1。要使用ContentType定义的编码，需要设置Connector。因此Tomcat一般会设置：</p>

<p><code>&lt;Connector URIEncoding="UTF-8" useBodyEncodingForURI="true" /&gt;</code></p>

<h3>3.2 HTTP Header的编解码</h3>

<p>除了URL外，还可能在Header中传递其它参数，如Cookie、redirectPath等。不要在Header中传递非ASCII字符，如果一定要传递，可以先用URLEncoder编码，再添加到Header中。</p>

<h3>3.3 其它编解码</h3>

<p>POST表单也是通过ContentType的Charset编码。用JDBC来存取数据时要和数据的内置编码保持一致，可以通过设置JDBC URL来指定，如MySQL: url=&ldquo;jdbc:mysql://localhost:3306/DB?useUnicode=true&amp;characterEncoding=GBK"。</p>

<h2>4. Javascript中的编码问题</h2>

<p>如果Javascript文件的编码格式与当前页面不一致，需要指定字符集，否则可能出现乱码：<code>&lt;script src="abc.js" charset="gbk"/&gt;</code>。在Javascript中处理URL可以使用<code>encodeURI()</code>和<code>encodeURIComponent()</code>。后者编码得更彻底，除了<code>!</code>、<code>'</code>、<code>(</code>、<code>)</code>、<code>*</code>、<code>-</code>、<code>.</code>、<code>_</code>、<code>~</code>、<code>0-9</code>、<code>a-z</code>和<code>A-Z</code>之外，对其他所有字符都编码，因此通常用于将一个URL当作一个参数放在另一个URL中。</p>
]]></content>
  </entry>
  
</feed>
