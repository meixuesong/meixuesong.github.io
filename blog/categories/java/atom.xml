<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2014-08-28T23:23:53+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Effective Java - 异常]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/28/effective-java-yi-chang/"/>
    <updated>2014-08-28T23:15:18+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/28/effective-java-yi-chang</id>
    <content type="html"><![CDATA[<p>Effective Java 通用程序设计，读书笔记：</p>

<ol>
<li>只对异常情况才使用异常</li>
<li>对可恢复的情况使用受检异常，对编程错误使用运行时异常</li>
<li>避免不必要地使用受检的异常</li>
<li>优先使用标准的异常</li>
<li>抛出与抽象相对应的异常</li>
<li>每个方法抛出的异常都要有文档</li>
<li>在细节消息中包含能捕获失败的消息</li>
<li>努力使失败保持原子性</li>
<li>不要忽略异常</li>
</ol>


<!--more-->


<h2>57 只对异常情况才使用异常</h2>

<p>永远不要将异常用于正常的控制流。下面的代码试图使用异常退出循环，这是有问题的：</p>

<p>```java
//有问题的代码
try {</p>

<pre><code> int i = 0;
 while(true)
      range[i++].climb();
</code></pre>

<p>} catch (ArrayIndexOutOfBoundsException e) {
}
```</p>

<p>设计良好的API不应该强迫客户端为了正常的控制流而使用异常。可以考虑提供“状态测试”方法，例如Iterator的next()方法有一个对应的“状态测试方法” hasNext()。</p>

<h2>58 对可恢复的情况使用受检异常，对编程错误使用运行时异常</h2>

<p>如果期望调用者能够适当地恢复，应该使用受检的异常。对于程序错误，则使用运行时异常。对于受检异常，可以提供一些辅助方法，通过这些方法调用者可以获得一些有助于恢复的信息。例如用户取款时余额不足，可以提供一个方法获取余额。</p>

<h2>59 避免不必要地使用受检的异常</h2>

<p>当以下两个条件都成立时，才使用受检异常：</p>

<ol>
<li>正确地使用API并不能阻止这种异常条件的产生（例如网络、文件）。</li>
<li>一旦产生异常，使用API的程序员可以立即采取有用的动作，这种负担被认为是正当的。</li>
</ol>


<p>把受检异常变成运行时异常的一种方法是，把这个抛出异常的方法分成两个方法，其中一个返回boolean，表明是否应该抛出异常。例如前述的hasNext()。</p>

<h2>60 优先使用标准的异常</h2>

<p>使用标准的异常至少有以下好处：</p>

<ol>
<li>API更加易于学习和使用</li>
<li>可读性更好</li>
<li>异常类越少，内存印迹（footprint）就越少，装载这些类的时间开销也越少。</li>
</ol>


<p>常见的可重用异常包括：</p>

<ol>
<li>IllegalArgumentException 非Null的参数值不正确</li>
<li>IllegalStateException 对于方法调用而言，对象状态不合适。</li>
<li>NullPointException</li>
<li>IndexOutOfBoundsException</li>
<li>ConcurrentModificationException 禁止并修改时，检测到对象的并发修改</li>
<li>UnsupportedOperationException</li>
</ol>


<h2>61 抛出与抽象相对应的异常</h2>

<p>更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常。这种做法也就是<strong>异常转译</strong>。</p>

<p>如果低层的异常对于调试导致高层异常的问题非常有帮助，使用异常链就很合适。大多数标准异常都支持链的构造器，如果不支持，可以利用Throwable的initCause方法设置原因。下面代码展示了异常转译和异常链：</p>

<p>```java
try{
&hellip;
} catch(LowerLevelException cause) {</p>

<pre><code> throw new HigherLevelException(cause);
</code></pre>

<p>}</p>

<p>class HigherLevelException extends Exception {</p>

<pre><code> HigherLevelException(Throwable cause) {
      super(cause);
 }
</code></pre>

<p>}
```</p>

<h2>62 每个方法抛出的异常都要有文档</h2>

<p>始终要单独地声明受检的异常，并利用Javadoc的<code>@throws</code>标记，准确地记录下抛出每个异常的条件 。如果一个方法可能抛出多个异常，不要使用“快捷方式”，声明它们的某个父类。永远不要声明一个方法“throws Exception”，因为它不仅没有提供任何有用的信息，而且掩盖了其它可能抛出的异常。</p>

<p>对于接口中的方法，在文档中记录下它可能抛出的未受检异常也很重要。也就是用Javadoc的<code>@throws</code>标记进行说明，但在方法的声明中不使用throws关键字。</p>

<h2>63 在细节消息中包含能捕获失败的消息</h2>

<p>为了捕获失败，异常的细节信息应该包含所有“对该异常有贡献”的参数和域的值。例如IndexOutOfBoundsException就包括了三个信息：上界、下界以及不在界内的下标值。但是包含大量的描述信息也没有什么意义，因为堆栈轨迹的用途是与源文件结合起来使用的。</p>

<p>异常的细节消息不应该与“用户层次的错误信息”混为一谈。</p>

<p>为了确保异常的细节消息中包含足够的能捕获失败的消息，通常在异常的构造器中引入这些信息。如：</p>

<p>```java
public IndexOutOfBoundsException(int lowerBound, int upperBound, int index) {</p>

<pre><code> ...
</code></pre>

<p>}
```</p>

<h2>64 努力使失败保持原子性</h2>

<p>一般而言，失败的方法调用应该使对象保持在被调用之前的状态。具有这种属性的方法称为具有失败原子性。</p>

<p>要实现失败原子性，最简单的办法是设计不可变对象。对于可变对象，可采取的办法包括：</p>

<ol>
<li>执行操作前，检查参数的有效性。</li>
<li>调整计算处理的顺序，使任何可能会失败的计算部分在对象状态被修改之前发生。</li>
<li>编写一段恢复代码。（这种办法主要用于永久性的数据结构，如磁盘）</li>
<li>在对象的一份临时拷贝上执行操作，操作完成后再用临时拷贝中的结果替换对象的内容。</li>
</ol>


<h2>65 不要忽略异常</h2>

<p>空的catch块会使异常达不到应有的目的。如果确实需要空catch块，至少也要包含一条说明，为什么可以忽略此异常。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Java-通用程序设计]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/22/effective-java-tong-yong-cheng-xu-she-ji/"/>
    <updated>2014-08-22T20:06:07+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/22/effective-java-tong-yong-cheng-xu-she-ji</id>
    <content type="html"><![CDATA[<p>Effective Java 通用程序设计，读书笔记：</p>

<ol>
<li>将局部变量的作用域最小化</li>
<li>for-each循环优先于传统的for循环</li>
<li>使用类库</li>
<li>如果需要精确值，就避免使用float和double</li>
<li>基本类型优先于装箱基本类型</li>
<li>如果其它类型更合适，则尽量避免使用字符串</li>
<li>小心字符串拼接的性能问题</li>
<li>通过接口引用对象</li>
<li>接口优先于反射机制</li>
<li>谨慎使用本地方法</li>
<li>谨慎进行优化</li>
<li>遵守普遍接受的命名惯例</li>
</ol>


<!--more-->


<h2>45 将局部变量的作用域最小化</h2>

<p>局部变量只在第一次使用它的地方声明。每个局部变量的声明都应该包含一个初始化表达式。</p>

<h2>46 for-each循环优先于传统的for循环</h2>

<p><code>for(String str : list)</code>这样的for-each语句在简洁性和预防Bug方面有着传统for循环无法比拟的优势，并且没有性能损失。但如果在遍历时删除、替换、前移等操作时，无法使用for-each语句。</p>

<h2>47 使用类库</h2>

<p>不要重新发明轮子，尽量使用标准类库。例如随机数应该使用Random.nextInt(int)，而不是自己去写一个生成随机数的类。Java程序员应该精通java.lang, java.util包中的内容，还应该熟悉java.io, Collection, concurrent类库。</p>

<h2>48 如果需要精确值，就避免使用float和double</h2>

<p>要计算精确的结果，可以使用BigDecimal，它还包括8种舍入模式。但是它的缺点是不太方便并且有性能上的损失。也可以自己处理小数点和舍入，使用int, long。数据数值没有超过9位十进制数字，可以使用int，如果不超过18位数字，可以使用long。如果可能超过18位，就必须使用BigDecimal</p>

<h2>49 基本类型优先于装箱基本类型</h2>

<p>也就是int，boolean等优先于Integer和Boolean等。下面方法的返回值是多少？</p>

<p>```java
public int compare(Integer first, Integer second) {</p>

<pre><code> return first &lt; second ? -1 : (first == second ? 0 : 1);
</code></pre>

<p>}</p>

<p>compare(new Integer(42), new Integer(42));  //结果为1
```</p>

<p>原因是装箱类型是对象引用，<code>first == second</code> 为false。除此之外，需要注意的是装箱类型可能是null，可能因此引起一些潜在隐患。而装箱类型的性能也可能是个问题（如创建和销毁对象中第5条“避免创建不必要的对象”中提到的循环累计时的Long性能不如long）/blog/2014/06/27/effective-java-chuang-jian-he-xiao-hui-dui-xiang/</p>

<h2>50 如果其它类型更合适，则尽量避免使用字符串</h2>

<ol>
<li>字符串不适合代替其它的值类型，例如从文件中的int值以字符串存在，读出后就应该还原成int类型。</li>
<li>字符串不适合代替枚举类型</li>
<li>字符串不适合代替聚集类型。如用001_003代表两个东西，更好的办法是用一个私有静态成员类。</li>
</ol>


<h2>51 小心字符串拼接的性能问题</h2>

<h2>52 通过接口引用对象</h2>

<p>养成用接口作为类型的习惯。如果没有合适的接口存在，完全可以用（基）类来引用对象。</p>

<h2>53 接口优先于反射机制</h2>

<p>反射机制是一种功能强大的机制，对于特定的复杂系统编程任务，它是非常必要的，但它也有一些缺点：</p>

<ol>
<li>丧失了编译时类型检查的好处</li>
<li>执行反射访问所需的代码笨拙而冗长</li>
<li>性能损失</li>
</ol>


<p>因此，如果你编写的程序必须要与编译时未知的类一起工作，如有可能，就应该仅仅使用反射机制来实例化对象，而访问对象时则使用编译时已知的某个接口或者父类。例如未知的类实现了Set，则可以用反射机制实例化它，但访问它的方法时，使用Set的方法。</p>

<h2>54 谨慎使用本地方法</h2>

<p>Java Native Interface(JNI)允许Java调用本地方法（指本地程序设计语言如C, C++编写的特殊方法）。Java早期时，本地方法的用途是访问特定平台的能力（如注册表）、访问遗留代码库和提高性能。但现在已经没有太大必要了。</p>

<h2>55 谨慎进行优化</h2>

<p>不要费力去编写快速的程序，应该努力编写好的程序。在设计API、数据格式时，一定要考虑性能的因素。例如API，如果后期将公有的类型变成可变的（mutable），可能会导致大量不必要的保护性拷贝，影响性能。同样地，在适合使用复合模式的公有类使用了继承，会把这个类永远与父类绑在一起，人为地限制了子类的性能。如果在API中使用实现类型而不是接口，就会被束缚在一个具体的实现上，即使将来出现了更快的实现你也无法使用。</p>

<h2>56 遵守普遍接受的命名惯例</h2>

<p>对于类型参数：</p>

<ul>
<li>T表示任意类型</li>
<li>E表示集合的元素类型</li>
<li>K和V表示Map的键和值</li>
<li>X表示异常</li>
<li>任何类型的序列可以是T, U, V或者T1, T2, T3</li>
</ul>


<p>对于转换对象的方法，返回不同类型的独立对象的方法，通常被称为toType，如toString, toArray。返回视图的方法通常称为asType，如asList。静态工厂的常用名称为valueOf, of, getInstance, newInstance, getType和newType。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Java-方法]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/20/effective-java-fang-fa/"/>
    <updated>2014-08-20T19:32:51+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/20/effective-java-fang-fa</id>
    <content type="html"><![CDATA[<p>读书笔记：</p>

<ol>
<li>检查参数的有效性</li>
<li>必要时进行保护性拷贝</li>
<li>谨慎设计方法签名</li>
<li>慎用重载</li>
<li>慎用可变参数</li>
<li>返回零长度的数组或者集合，而不是null
44. 为所有导出的API元素编写文档注释</li>
</ol>


<!--more-->


<h2>38 检查参数的有效性</h2>

<p>检查方法参数的有效性，以便更早地发现问题。对于公有方法，要用Javadoc的@throw标签在文档中说明违反参数限制时会抛出的异常。例如：IllegalArgumentException, IndexOutOfBundsException或NullPointerException。对于非公有方法，一般采用断言来检查参数。</p>

<p>通常在计算过程之前，应该进行有效性检查。但如果有效性检查工作成本较高，或者有效性检查已经隐含在计算过程中，那么就不用先进行检查。但计算过程中由于参数的问题造成的异常可能不是方法文档中标明的那个异常，此时可以使用异常转译（第61条）技术，将其转换为正确的异常。</p>

<h2>39 必要时进行保护性拷贝</h2>

<p>如果类的内部状态使用了客户端传入的对象，而该对象是可变的，那么尽量不要直接引用这个外部对象，而是将其复制一份。对于构造器的每个可变参数进行保护性拷贝是必要的。而且保护性拷贝应该在有效性检查之前进行。如果参数类型可以被不可信任方子类化，那么不要使用clone方法进行保护性拷贝。</p>

<p>对于访问方法(如get)，为了防御类似的攻击，可以返回内部属性的保护性拷贝。例如对于Date类属性，在返回时，可以新建一个Date对象返回。另一种方式是返回Date.getTime()，即返回long基本类型的时间。访问方法在进行保护性拷贝时，允许使用clone方法，原因是我们知道返回类型时什么，只要它不会是其他某个潜在不可信子类，就可以使用clone方法。</p>

<p>对于内部长度非零的数组，在返回给客户端之前，应该总是进行保护性拷贝。另一种解决方案是，返回数组的不可变视图。（见第13条）</p>

<p>如果类信任它的调用者不会修改内部组件，例如在同一个包中，那么不进行保护性拷贝也是可以的，但类文档中应该清楚说明，调用者绝不能修改受到影响的参数或返回值。</p>

<h2>40 谨慎设计方法签名</h2>

<ol>
<li>谨慎选择方法的名称。</li>
<li>不要过于追求提供便利的方法。每个方法都应该尽其所能，方法太多会使类难以学习。只有某一项操作经常使用时，才考虑为其提供快捷方式。</li>
<li>避免过长的参数列表。解决方法：一是将方法分解成多个方法；二是创建辅助类（一般为静态成员类），保存这些参数。三是使用Builder模式。</li>
</ol>


<p>对于参数类型，优先使用接口。</p>

<p>对于boolean参数，优先使用两个元素的枚举类型。它使代码更易于阅读和编写。而且未来扩展时，可以轻易增加更多状态。</p>

<h2>41 慎用重载</h2>

<p>下面的代码执行结果可能与预期不同：
```java
public static String classify(List&lt;?> list) {</p>

<pre><code> return "List";
</code></pre>

<p>}</p>

<p>public static String classify(Collection&lt;?> c) {</p>

<pre><code> return "Collection";
</code></pre>

<p>}</p>

<p>public static void main(String[] args) {</p>

<pre><code> Collection&lt;?&gt; c = new ArrayList&lt;BigInteger&gt;();
 System.out.println(classify(c));
 //结果是Collection
</code></pre>

<p>}
```</p>

<p>原因是重载(overload)方法的选择是静态的，即在编译期决定。而被覆盖(override)的方法的选择是动态的，即在运行时决定。在上面的例子中，程序编译时，参数的类型是Collection，所以打印的结果是Collection。正如<a href="/blog/2014/08/19/she-ji-mo-shi-fang-wen-zhe-mo-shi">访问者模式</a>提到的：</p>

<blockquote><p>Java语言支持静态的多分派和动态的单分派。对于Java方法重载（Overload），在编译期会根据方法的接收者类型和方法的所有参量类型进行分派，因此是静态多分派。而方法覆盖（Override），是在运行时仅仅根据方法的接收者类型进行分派。</p></blockquote>

<p>因此，安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法。如果方法使用了可变参数，最好是不要重载它。例如ObjectOutputStream类中，没有使用重载方法，而是对于每种类型都提供了read和write方法: writeBoolean(boolean), writeInt(int)。对于构造器，没有办法使用不同的方法名称，但可以使用静态工厂方法或者Builder模式。</p>

<p>Java 1.5的自动装箱出现之后，重载也导致了一些麻烦。例如下面的代码：</p>

<p>```java
List<Integer> list = new ArrayList<Integer>();
for(int i = -3; i &lt; 3; i++) {</p>

<pre><code> list.add(i);
</code></pre>

<p>}</p>

<p>for(int i= 0; i &lt; 3; i++) {</p>

<pre><code> list.remove(i);
</code></pre>

<p>}</p>

<p>System.out.println(&ldquo;list: &rdquo; + list);
//打印结果：list: [-2, 0, 2]
```</p>

<p>原因是List.remove是重载方法：<code>remove(int i); remove(Object o);</code> 所以为了达到预期效果，要改为：<code>list.remove((Integer)i);</code></p>

<p>因此，能够重载方法并不意味着就应该重载方法。请慎用重载方法。</p>

<h2>42 慎用可变参数</h2>

<p>可变参数接受0或多个指定类型的参数。如果希望参数最少要1个，则可以这样定义方法：</p>

<p><code>java
public void someOperation(int a, int... otherArgs) {
}
</code></p>

<h2>43 返回零长度的数组或者集合，而不是null</h2>

<p>如果返回null，那么客户端始终要进行null判断。返回零长度的数组或集合时，不用在这个级别担心性能问题。</p>

<h2>44 为所有导出的API元素编写文档注释</h2>

<p>其中要注意的是，文档注释也应该描述类或者方法的线程安全性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式系统的基础知识]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/22/fen-bu-shi-xi-tong-de-ji-chu-zhi-shi/"/>
    <updated>2014-07-22T20:04:40+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/22/fen-bu-shi-xi-tong-de-ji-chu-zhi-shi</id>
    <content type="html"><![CDATA[<p>这是一篇学习笔记，内容为《大型网站系统与Java中间件实践》的第一章。</p>

<p>组成计算机的5要素为：输入、输出、运算器、控制器、存储器（内存、外存）。分布式系统也一样，可以分为这5个要素。因此这本书会对分布式系统中，这5个要素的变化进行说明。</p>

<!--more-->


<p>阿姆达尔定律（Amdahl&rsquo;s law）说明程序中可以并行的代码的比例，决定了你增加处理器能带来的速度提升的上限。</p>

<p>```
S(N) = 1 / ((1 &ndash; P) + P / N)</p>

<p>P: 可并行的程序在单核上执行时间的占比
N: 处理器的个数
S(N): 程序在N个处理器（总核心数）相对于单个处理器中的速度提升比。</p>

<p>当P=0.2, S(N)的上限为1.25
当P=0.5, S(N)的上限为2
```</p>

<p>根据阿姆达尔定律，提升P非常的重要！</p>

<h2>1.多线程模式</h2>

<p>这里所说的多线程，是指单进程内的多线程。</p>

<h3>1.1互不通信的多线程模式</h3>

<p>线程之间没有交集，各自执行各自的任务和逻辑。这种模式的编程最简单，与单线程差不多。</p>

<h3>1.2基于共享容器的多线程模式</h3>

<p>例如多个线程共用一个队列。对于存储数据的容器或者对象，分为线程安全和线程不安全。</p>

<ul>
<li>如果是线程不安全的，一般可以通过加锁或者Copy On Write（COW）的方式控制并发。对于加锁的情况，如果是读多写少，可以用读写锁而不是互斥锁。</li>
<li>如果是线程安全的，就可以直接使用。</li>
</ul>


<h3>1.3通过事件协同的多线程模式</h3>

<p>某个线程需要等到某个状态或者事件发生后才能继续自己的工作，而这个状态或者事件与另一个线程有关，这时候就需要完成线程间的协调。<strong>为了防止死锁，一般要原子性地获取所需的多个锁，或者注意以相同的顺序获取多个锁。</strong></p>

<p>```java
//原子性地获取多个锁
Thread 1
GetLocks(A, B); //伪代码，一次性获取两个锁，不同平台支持不同。</p>

<p>Thread 2
GetLocks(A, B);</p>

<p>//或者同样的顺序获取多个锁
Thread 1
A.lock();</p>

<pre><code>B.lock();
</code></pre>

<p>Thread 2
A.lock();</p>

<pre><code>B.lock();
</code></pre>

<p>//两个线程的加锁顺序一致，如果Thread 2中的顺序反过来，则很可能造成锁死。</p>

<p>```</p>

<h2>2.多进程模式</h2>

<p>进程之间的内存空间是独立的，因此多进程相对会容易一些。但也正因为内存空间独立，因此数据共享就涉及序列化和反序列化。</p>

<p>对于多进程，单个进程的问题不会造成整体的不可用。</p>

<h2>3.网络基础</h2>

<h3>3.1 OSI七层模型</h3>

<p>OSI七层模型还记得？从上到下依次是：</p>

<ul>
<li>应用层：为应用程序（如Email）提供网络服务。</li>
<li>表示层：确保一个应用层发送的信息可被另一个系统的应用层读取。</li>
<li>会话层：通过传输层建立数据传输的通路。</li>
<li>传输层：定义传输数据的协议和端口。</li>
<li>网络层：在位于不同位置的网络中的两个主机系统之间提供连接和路径选择。</li>
<li>数据链路层：定义如何让格式化数据以进行传输。</li>
<li>物理层：定义物理设备标准，传输比特流。</li>
</ul>


<h3>3.2 网络IO实现方式</h3>

<ul>
<li>BIO（Blocking IO），阻塞方式，一个Socket需要一个线程来处理。</li>
<li>NIO（Nonblocking IO），基于事件驱动思想，采用Reactor模式。</li>
<li>AIO (Asynchronous IO)，异步IO，采用Proactor模式。</li>
</ul>


<p>Reactor模式和Proactor模式，后续要再研究一下。</p>

<h2>4.从单机到分布式</h2>

<h3>4.1 输入、输出设备的变化</h3>

<p>除了传统意义的人机交互输入、输出设备，分布式环境中的其它节点也可以看作是输入或输出设备。</p>

<h3>4.2 控制器的变化</h3>

<p>在单机中，控制器是CPU中的控制器。在分布式系统中，控制器是控制方式。</p>

<ol>
<li>使用硬件负载均衡</li>
<li>使用软件负载均衡，如LVS</li>
<li>通过名称服务器</li>
<li>通过规则服务器</li>
<li>Master + Worker的方式</li>
</ol>


<p>前面两种一般称为透明代理。有两种缺点，一是增加了流量，即代理服务器与请求处理服务器之间多了一次发送和返回。当然，LVS通过配置，可以将请求的处理结果直接返回给客户端，不通过中间代理。二是如果代理出现问题，会影响到所有请求。</p>

<p>第三、四种控制方式，都是客户端先访问名称服务器或者规则服务器，得到真正的请求处理服务器地址，然后直接与该地址进行连接。</p>

<p>第五种一般用来管理任务，由Master把任务分给不同的Worker处理。</p>

<h3>4.3 运算器的变化</h3>

<p>分布式系统中的运算器包括多个节点的计算能力。</p>

<ol>
<li>通过DNS解析，实现调度和控制</li>
<li>使用负载均衡设备或软件</li>
<li>使用Master+Worker方式</li>
<li>使用规则服务器等。</li>
</ol>


<h3>4.4 存储器的变化</h3>

<p>与前面的类似，也可以通过：</p>

<ol>
<li>直接访问存储服务器</li>
<li>通过代理服务器访问存储服务器</li>
<li>使用名称服务</li>
<li>使用规则服务</li>
<li>使用Master控制。但没有Worker了。与规则服务不同，这里的Master根据请求返回存储服务器的地址，而不是返回所有地址。</li>
</ol>


<h2>5. 分布式系统的难点</h2>

<ol>
<li>缺乏全局时钟</li>
<li>面对故障独立性。故障独立性指整个系统的一部分有问题，而其他部分正常。</li>
<li>处理单点故障。如果某个功能或角色只有一台单机在支撑，这个节点就称为单点。它发生的故障就是单点故障（SPoF, Single Point of Failure）</li>
<li>事务的挑战。即ACID和CAP。</li>
</ol>


<p>后续将研究文中提到的COW、读写锁、互斥锁，以及Reactor模式和Proactor模式。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java注解]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/09/javazhu-jie/"/>
    <updated>2014-07-09T22:22:10+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/09/javazhu-jie</id>
    <content type="html"><![CDATA[<p>本文记录Java注解的基本用法。</p>

<!--more-->


<p>注解类型声明与接口声明的唯一区别是，在interface之前增加了一个@符：</p>

<p><code>java
public @interface TestMethod {
}
</code></p>

<p>判断方法是否有某个注解：</p>

<p>```java</p>

<pre><code>for(Method method: testClass.getDeclaredMethods())
    if (method.isAnnotationPresent(TestMethod.class)) {
        ...
    }           
</code></pre>

<p>```</p>

<h3>保留(Retention)</h3>

<p>注解信息的保留策略：</p>

<ul>
<li>RetentionPolicy.SOURCE 在编译时丢弃。</li>
<li>RetentionPolicy.CLASS（缺省） 保存在类文件中，运行时可被VM丢弃。</li>
<li>RetentionPolicy.RUNTIME 保存在类文件中，运行时由VM保留。</li>
</ul>


<p><code>java
@Retention(RetentionPolicy.RUNTIME)
public @interface TestMethod {
}
</code></p>

<h3>注解的目标（Annotation Target）</h3>

<p><code>java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface TestMethod {
}
</code></p>

<p>目标的类别包括：TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, ANNOTATION_TYPET和PACKAGE。如果没有指定目标，则注解可以修饰任何Java元素。</p>

<h3>单值注解</h3>

<p>为了在注解类型中支持单个参数，需要提供一个名为value的方法，返回适当的类型并且没有任何参数。</p>

<p>```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Ignore {</p>

<pre><code>String value();
</code></pre>

<p>}</p>

<p>//使用示例
@Ignore(&ldquo;忽略&rdquo;)
public void testC() {}
```</p>

<p>不能将null作为注解的值（value）。</p>

<h3>数组参数</h3>

<p>可指定value方法的返回值为数组：</p>

<p>```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Ignore {</p>

<pre><code>String[] value();
</code></pre>

<p>}</p>

<p>//使用示例
@Ignore({&ldquo;忽略&rdquo;, &ldquo;房价涨了&rdquo;})
public void testC() {}</p>

<p>//如果数组只有一个成员，也可以这样写：
@Ignore(&ldquo;房价涨了&rdquo;)
public void testC() {}
```</p>

<h3>多个参数的注解</h3>

<p>注解有多个参数时，注解类型的成员名与注解声明的名称一致，如下例中的reasons和initials：</p>

<p>```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Ignore {</p>

<pre><code>String[] reasons();
String initials();
</code></pre>

<p>}</p>

<p>//使用示例
@Ignore(reasons={&ldquo;just because&rdquo;, &ldquo;and why not&rdquo;}, initials=&ldquo;jjl&rdquo;)
```</p>

<h3>缺省值</h3>

<p>```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Ignore {</p>

<pre><code>String[] reasons() default "房价涨了";
String initials();
</code></pre>

<p>}
```</p>

<h3>附加返回类型与复式注解类型</h3>

<p>注解值可以是基本类型、枚举、Class引用、注解类型本身，或者任意这些类型的数组。我们以注解类型为例：</p>

<p>```java
public @interface Date {</p>

<pre><code>int month();
int day();
int year();
</code></pre>

<p>}</p>

<p>@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Ignore {</p>

<pre><code>Date date();
</code></pre>

<p>}</p>

<p>//使用示例
@Ignore(date=@Date(month=1, day=2, year=2014))
public void testC() {}
```</p>

<h3>包注解</h3>

<p>注解的目标除了方法、属性等外，还可以是包，那么包注解写在哪呢？方法在在包对应的目录中，创建一个名为package-info.java的源文件，这个文件应该包含所有的包注解，后面跟随适当的package语句。除此之外，这个文件不能够包含其它任何东西。示例如下：</p>

<p><code>java
@TestPackage(isPerformance=true) package sis.testing;
</code></p>
]]></content>
  </entry>
  
</feed>
