<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2015-01-18T23:45:08+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JVM监控与故障处理工具]]></title>
    <link href="http://blog.ubone.com/blog/2015/01/04/jvmjian-kong-yu-gu-zhang-chu-li-gong-ju/"/>
    <updated>2015-01-04T21:42:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/01/04/jvmjian-kong-yu-gu-zhang-chu-li-gong-ju</id>
    <content type="html"><![CDATA[<p>本文介绍常用的Java虚拟机性能监控与故障处理工具。</p>

<!--more-->


<h2>1. JDK命令行工具</h2>

<h3>1.1 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jps.html">jps</a></h3>

<p>与Unix下的ps命令相似，可以列出正在运行的虚拟机进程并显示主类（main()函数所在类）类名以及LVMID(Local Virtual Machine Identifier)。LVMID与PID是一致的。命令格式：</p>

<p><code>jps [options] [hostid]</code></p>

<table>
<thead>
<tr>
<th>选项 </th>
<th> 用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>-q </td>
<td> 只输出LVMID</td>
</tr>
<tr>
<td>-m </td>
<td> 输出JVM启动时传递给主类main()函数的参数</td>
</tr>
<tr>
<td>-l </td>
<td> 输出主类全名</td>
</tr>
<tr>
<td>-v </td>
<td> 输出JVM启动时的JVM参数</td>
</tr>
</tbody>
</table>


<h3>1.2 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html">jstat</a>，虚拟机统计信息监视工具</h3>

<p>在<a href="/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>中已经有描述。</p>

<h3>1.3 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jinfo.html">jinfo</a>, Java配置信息工具</h3>

<p>用于实时查看和调整虚拟机各项参数。</p>

<h3>1.4 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jmap.html">jmap</a>, Java内存映像工具</h3>

<p>在<a href="/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>中已经有描述。</p>

<h3>1.5 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jhat.html">jhat</a>， 堆转储快照分析工具</h3>

<p>用于分析堆转储快照，内置一个微型HTTP服务器，分析结果后可在浏览器中查看。但这个工具并不常用。</p>

<h3>1.6 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstack.html">jstack</a>, Java堆栈跟踪工具</h3>

<p>用于生成虚拟机当前时刻的线程快照（threaddump），即当前每一条线程正在执行的方法堆栈集合。主要目的是定位线程出现长时间停顿的原因，如死锁、死循环、请求外部资源等。</p>

<p>当线程出现停顿时，通过jstack查看各线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么。</p>

<table>
<thead>
<tr>
<th>选项 </th>
<th> 用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>-F </td>
<td> 当正常输出的请求不被响应时，强制输出线程堆栈</td>
</tr>
<tr>
<td>-l </td>
<td> 除堆栈外，显示关于锁的附加信息</td>
</tr>
<tr>
<td>-m </td>
<td> 如果调用本地方法的话，显示C/C++堆栈</td>
</tr>
</tbody>
</table>


<h2>2. JDK的可视化工具</h2>

<h3>2.1 JConsole</h3>

<p>基于JMX的可视化监视、管理工具。直接通过集令后运行jconsol。</p>

<h3>2.2 <a href="http://visualvm.java.net/">VisualVM</a>，多合一故障处理工具</h3>

<p>VisualVM Is Designed For You:</p>

<ul>
<li><strong>Application Developer</strong>: Monitor, profile, take thread dumps, browse heap dumps</li>
<li><strong>System Administrator</strong>: Monitor and control Java applications across the entire network</li>
<li><strong>Java Application User</strong>: Create bug reports containing all the necessary information</li>
</ul>


<p>在命令行执行<code>jvisualvm</code>即可</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java垃圾收集与内存分配]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/26/la-ji-shou-ji-qi-yu-nei-cun-fen-pei-ce-lue/"/>
    <updated>2014-12-26T20:20:12+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/26/la-ji-shou-ji-qi-yu-nei-cun-fen-pei-ce-lue</id>
    <content type="html"><![CDATA[<p>在<a href="/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>中，了解了Java的内存管理和垃圾收集。本文再深入学习垃圾收集算法和HotSpot中垃圾收集的实现。</p>

<!--more-->


<h2>1. 什么是垃圾</h2>

<p>Java并没有使用引用计数法来识别对象是否为垃圾，而是采用可达性分析（Reachability Analysis）判断对象是否存活。其基本思路就是通过GC Roots对象为起点，搜索其引用链，只要是通过它们可达的对象就是活对象。GC Roots对象包括以下几种：</p>

<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI(即Native方法)引用的对象</li>
</ul>


<p>而Java的引用又分为多种类型，对象是否存活也与引用类型有关：</p>

<ul>
<li>强引用：普通引用都是强引用，只要强引用还存在，对象就不会被回收。</li>
<li>软引用：SoftReference关联的对象是还有用，但不是必须的对象。在系统将要发生内存溢出异常之前，会把这些对象列入回收范围进行第二次回收。</li>
<li>弱引用：WeakReference与SoftReference更弱，它关联的对象只能生成到下一次垃圾收集发生之前（无论内存是否足够，都会被回收）。</li>
<li>虚引用：PhantomReference是最弱的一种引用，对生存时间完全没有影响，也无法通过虚引用来取得一个对象实例。其唯一目的就是在回收时收到一个系统通知。</li>
</ul>


<p>真正宣告一个对象的死亡，要经历至少两次标记过程。当扫描发现对象与GC Roots没有引用链，将进行第一次标记，并判断对象是否有必要执行finalize()方法（如果对象没有覆盖该方法，或者方法已经被调用过，视为没有必要执行）。如果有必要执行finalize()方法，虚拟机将该对象放入F-Queue队列，稍后自动由低优先级的Finalizer线程执行该方法。之后GC还会对F-Queue中的对象进行第二次标记，如果对象在finalize()方法中重新建立了一个有效引用，就会被移除出“即将回收”的集合，逃脱回收。</p>

<p>但注意finalize()方法是没有保障的，JVM只会触发它执行，并不保证它会运行结束。试想如果finalize()方法中有死循环，会造成整个内存回收系统崩溃。所以正如<a href="/blog/2014/06/27/effective-java-chuang-jian-he-xiao-hui-dui-xiang/">Effective Java-创建和销毁对象</a>中提到的，你就当Java没有finalize()方法吧!</p>

<p>方法区（通常所指的永久代）也是<strong>可以（非必须）</strong>垃圾收集的。主要回收废弃常量和无用的类。对于常量，例如“abc”已经进入常量池，但当前没有任何一个String对象是“abc”，那么这个常量可能会被清理出去。如何判断无用的类则要苛刻许多，需要同时满足以下条件：</p>

<ul>
<li>该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例。</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>


<p>方法区的对象仅仅是可以回收，并不是必然会回收。在大量使用反射、动态代理、CGLib等字节码框架、动态JSP和OSGi这类频繁自定义ClassLoader场景下，虚拟机需要具备类卸载的功能。</p>

<p>HotSpot提供了参数<code>-Xnoclassgc</code>参数控制方法区回收。在Product版JVM中还可以使用<code>-verbose:class</code>和<code>-XX:+TraceClassLoading</code>查看类加载信息。FastDebug版的JVM还支持<code>-XX:+TraceClassUnLoading</code>查看卸载信息。</p>

<h2>2. 垃圾收集算法</h2>

<p>各平台的虚拟机操作内存的方法各不相同，常见的垃圾收集算法说明如下：</p>

<h3>2.1 常见的垃圾收集算法</h3>

<h4>标记-清除算法(Mark-Sweep)</h4>

<p>这是最基础的收集算法，分为标记和清除两个阶段。首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。它有两个主要问题：一是效率不高，另一个是空间问题，会产生大量不连续的内存碎片。</p>

<h4>复制算法(Copying)</h4>

<p>复制算法的思路是将内存分为大小相等的两块，每次只使用其中一块，永远有一块是空的。当一块用完了，就将存活对象复制到另一块上，把前者内存空间一次清理掉。</p>

<p>复制算法特别适合那些短命的对象，现代虚拟机都采用这个算法来回收新生代。将内存分为较大的Eden区和两个较小的Survivor，每次使用Eden和其中一个Survivor。回收时，将Eden和Survivor存活的对象复制到另一个Survivor，最后清理掉Eden和前一个Survivor空间。HotSpot默认的Eden和Survivor比例是8：1. 如果另一个Survivor空间不足以放下存活对象，那些经历多少GC仍存活的对象会被放入老年代。</p>

<h4>标记-整理算法（Mark-Compact）</h4>

<p>对于长命的对象，复制算法的效率就变得太低。标记-整理算法就适合老年代。其思路是标记后，将活对象向一端移动，然后清理掉边界以外的内存。</p>

<h4>分代收集算法(Generational Collection)</h4>

<p>这个算法没有特殊之处，就是将堆分为新生代和老年代，然后根据各年代的特点选择最适当的算法。在新生代使用复制算法，在老年代使用“标记-清理”或者“标记-整理”算法。</p>

<h3>2.2 HotSpot的算法实现</h3>

<p>结合前面的垃圾收集算法，看看HotSpot是如何实现的。</p>

<h4>2.2.1 枚举GC Roots</h4>

<p>前面说到GC Roots主要是在全局性的引用和执行上下文（如栈帧中的本地变量表）中，但HotSpot并不需要逐个检查这里面的引用，因为这样的效率太低了。</p>

<p>HotSpot使用一组称为OopMap的数据结构，在类加载完成时，就把对象内各偏移量上是什么类型的数据计算出来了，因此GC扫描时，可以直接得到这些信息，并准确判断堆上的数据是否还可能被使用。</p>

<h4>2.2.2 安全点</h4>

<p>当GC时，线程会停在安全点，常见的安全点包括方法调用、循环跳转、异常跳转等。如何让线程停在安全点，有两种方案：抢先式中断和主动式中断。抢先式指中断所有线程，如果发现某个线程不在安全点，则恢复线程让它跑到安全点。但几乎所有虚拟机都没有采用这个方法。</p>

<p>主动式中断的思路是GC需要中断线程时，设置一个标志，各线程执行时会在安全点和创建对象需要分配内存的地方轮询这个标志，如果为真就把自己挂起。</p>

<p>对于那些处于Sleep或Blocked状态的线程，无法跑到安全点，则需要安全区域来解决。安全区域中任何地方GC都是安全的。当线程执行到安全区域中的代码时，先标识自己已经进入安全区，这时GC就不管这些线程了。当线程要离开安全区时，它要检查系统是否已经完成了根节点枚举或GC过程，如果完成则继续执行，否则继续等待直到收到可安全离开的信号。</p>

<h4>2.2.3 垃圾收集器</h4>

<p><a href="https://blogs.oracle.com/jonthecollector/entry/our_collectors">下图</a>展示了HotSpot用于不同年代的7种收集器，如果两个收集器间有连线，说明它们可以搭配使用。</p>

<p><img src="/myresource/images/image_blog_2014-12-26-Collectors.jpg" alt="image" /></p>

<h5>Serial收集器</h5>

<p>这是一个单线程的收集器，工作于年轻代，使用复制算法。当它工作时，会把所有用户线程全部停下来。它现在仍然是Client模式下的默认收集器。它比其他收集器简单但高效，没有了线程交互的开销。桌面应用由于分配的内存相对较少，收集时停顿时间可控制在几十到一百多毫秒，对桌面应用是可以接受的。</p>

<h5>ParNew收集器</h5>

<p>它其实就是Serial收集器的多线程版本，对于单核CPU的环境下，绝对不会比Serial更好。但它适合于在服务端模式时与CMS配合(CMS用于老年代，ParNew用于年轻代)。</p>

<h5>Parallel Scavenge收集器</h5>

<p>这是一个年轻代的收集器，使用复制算法，是并行的多线程收集器。</p>

<ul>
<li>并行(Parallel):指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li>并发(Concurrent): 指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行）。</li>
</ul>


<p>Parallel Scavenge收集器与其它收集器不同，它的目标是达到一个可控制的吞吐量，即CPU用于运行用户代码的时间与CPU总消耗时间的比值。因此适合于不需要太多交互，主要是后台运算的场景。</p>

<h5>Serial Old收集器</h5>

<p>这是Serial收集器的老年代版本，同样是单线程收集器，使用“标记-整理”算法。其主要意义也是Client模式的虚拟机中使用。如果在Server模式下，主要是在JDK1.5及之前的版本中与Parallel Scavenge搭配使用，以及作为CMS的后备预案。</p>

<h5>Parallel Old收集器</h5>

<p>这是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。从JDK1.6开始提供，主要用于与Parallel Scavenge搭配使用，作为“吞吐量优先”的组合。</p>

<h5>CMS收集器(Concurrent Mark Sweep)</h5>

<p>这是一种以获取最短回收停顿时间为目标的收集器。也是基于“标记-清除”算法实现，整个过程分为4步：</p>

<ol>
<li>初始标记：标记GC Roots能直接关联到的对象，时间很快。</li>
<li>并发标记：进行GC Roots Tracing，时间很长。</li>
<li>重新标记：修正并发标记期间因用户程序继续运行而导致标记发生变化的那一部分对象的标记记录，比第一步稍长。</li>
<li>并发清除</li>
</ol>


<p>第1、3步需要Stop the World，而耗时最长的第2、4步可以与用户线程一起工作。</p>

<p>CMS是非常优秀的垃圾收集器，是Java 5推荐的高性能收集器，在Java 6仍保持了旺盛的生命力。但它的主要缺点是：</p>

<ol>
<li>对CPU资源非常敏感。在并发标记阶段，虽然用户程序不用停顿，但CMS占用了一部分CPU资源而导致应用变慢，总吞吐量降低。</li>
<li>无法处理浮动垃圾，可能出现“Concurrent Mode Failure”，导致另一次Full GC。浮动垃圾就是在并发清除阶段，用户线程还在运行并产生新的垃圾。CMS需要预留一部分内存空间给用户线程使用。如果预留的空间无法满足程序需要，就会出现“Concurrent Mode Failure”，导致JVM临时启用Serial Old收集器来重新进行老年代收集，停顿时间就很长了。</li>
<li>由于使用“标记-清除”算法，因此会有碎片产生，有时不得不提前触发一次Full GC。</li>
</ol>


<h5>G1收集器</h5>

<p>这是面向服务端应用的垃圾收集器，可用于替换CMS。具备如下特点：</p>

<ol>
<li>并行与并发：充分利用多CPU、多核优势，缩短Stop the world时间。</li>
<li>分代收集：仍保留分代概念，可以独立管理整个GC堆。</li>
<li>空间整合：G1整体上是基于“标记-清除”，但从局部看是基于“复制”算法，不会产生内存碎片。</li>
<li>可预测的停顿：G1能建立可预测的停顿时间模型，可指定一个长度为M毫秒的时间片段，G1分将停顿时间尽量控制在该时间范围内。</li>
</ol>


<p>G1将整个堆划分为多个大小相等的独立区域（Region），虽然保留分代概念，但新生代和老年代不是物理隔离的，它们是一部分Region的集合（不需要连续）。</p>

<p>它的实现方式是跟踪每个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及所需时间的经验值），维护一个优先列表，每次根据停顿目标值，回收价值最大的Region。保证在有限的时间内获得尽可能高的收集效率。</p>

<p>每个Region都有一个对应的Remembered Set，用于记录跨Region的引用。因此进行内存回收时，只需要在GC Roots枚举范围内加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SecureRandom导致Tomcat启动过慢]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/20/%5B%3F%5D-ci-jie-jue-tomcatqi-dong-guo-man-de-jing-li/"/>
    <updated>2014-12-20T12:08:33+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/20/[?]-ci-jie-jue-tomcatqi-dong-guo-man-de-jing-li</id>
    <content type="html"><![CDATA[<p>昨天晚上在Tomcat上部署一个小应用时，Tomcat启动非常慢，有时甚至需要10分钟。查看日志，发现一直停在Deploying阶段：</p>

<!--more-->


<p><code>
INFO: Starting service Catalina
Dec 19, 2014 9:56:33 AM org.apache.catalina.core.StandardEngine startInternal
INFO: Starting Servlet Engine: Apache Tomcat/7.0.52 (Ubuntu)
Dec 19, 2014 9:56:33 AM org.apache.catalina.startup.HostConfig deployWAR
INFO: Deploying web application archive /usr/mxs/kindleinstance/webapps/kindlegen.war
</code></p>

<p>难道是war文件有问题？检查了md5校验码，尝试了解压缩，完全没问题啊！到底是什么原因呢？等了十分钟后，发现Tomcat已经启动完成，可以使用了。再次查看日志：</p>

<p><code>
INFO: Deploying web application archive /usr/mxs/kindleinstance/webapps/kindlegen.war
Dec 19, 2014 10:11:25 AM org.apache.catalina.util.SessionIdGenerator createSecureRandom
INFO: Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [888,934] milliseconds.
Dec 19, 2014 10:11:25 AM org.apache.coyote.AbstractProtocol start
INFO: Starting ProtocolHandler ["http-bio-9090"]
Dec 19, 2014 10:11:25 AM org.apache.catalina.startup.Catalina start
INFO: Server startup in 892334 ms
</code></p>

<p>原来是“Creation of SecureRandom instance for session ID”消耗了888秒，这个SecureRandom实例是什么呢？在<a href="http://wiki.apache.org/tomcat/HowTo/FasterStartUp">How do I make Tomcat startup faster?</a>中，有这样的描述：</p>

<blockquote><p>Tomcat 7+ heavily relies on SecureRandom class to provide random values for its session ids and in other places. Depending on your JRE it can cause delays during startup if entropy source that is used to initialize SecureRandom is short of entropy.</p></blockquote>

<p>也就是说，Tomcat 7之后严重依赖SecureRandom类来提供随机数用于Session ID。当Tomcat启动时，取决于你使用的JRE，如果用来初始化SecureRandom的熵值（Entropy）资源是一个短熵时，将可能导致延时。</p>

<p>再看看JDK中关于<a href="http://docs.oracle.com/javase/7/docs/api/java/security/SecureRandom.html">SecureRandom类</a>:</p>

<blockquote><p>This class provides a cryptographically strong random number generator (RNG). A cryptographically strong random number minimally complies with the statistical random number generator tests specified in FIPS 140-2, Security Requirements for Cryptographic Modules, section 4.9.1. Additionally, SecureRandom must produce non-deterministic output. Therefore any seed material passed to a SecureRandom object must be unpredictable, and all SecureRandom output sequences must be cryptographically strong, as described in RFC 1750: Randomness Recommendations for Security.</p></blockquote>

<p>该类提供保密性强的随机数生成器（RNG）。一个保密性强的随机数应最低限度遵循FIPS 140-2指定的统计随机数发生器测试和4.9.1节的加密模块安全要求。并且SecureRandom必须产出非确定性的输出。因此，正如RFC 1750中描述的，传递给SecureRandom对象的任何材料必须是不可预测的，并且所有SecureRandom输出序列必须是保密性强的的。</p>

<p>在<a href="http://www.cigital.com/justice-league-blog/2014/01/06/issues-when-using-java-securerandom/">ISSUES TO BE AWARE OF WHEN USING JAVA’S SECURERANDOM</a>中，提到了使用SecureRandom可能存在的问题，主要包括三个方面：调用顺序、阻塞和内部Seeding机制。其中说明了阻塞是如何产生的：</p>

<blockquote><p>Some SecureRandom implementations in the Oracle JRE for *nix use /dev/random to get entropy at certain times. Since /dev/random can block if sufficient entropy is not available, your code will stop executing if you call certain SecureRandom methods at times when /dev/random does not have sufficient entropy available.</p></blockquote>

<p>这样看来，我的Ubuntu 14中的OpenJDK(OpenJDK Runtime Environment (IcedTea 2.5.3) (7u71-2.5.3-0ubuntu0.14.04.1))正是使用了操作系统的<code>/dev/random</code>作为信息源，而它又没有提供足够的熵，所以导致阻塞。</p>

<p>按照前文<a href="http://wiki.apache.org/tomcat/HowTo/FasterStartUp">How do I make Tomcat startup faster?</a>中给出的次安全的解决办法，改为使用<code>-Djava.security.egd=file:/dev/./urandom</code>，即在setenv.sh中加入一行：</p>

<p>```</p>

<h1>!/bin/sh</h1>

<p>export CATALINA_OPTS=&ldquo;-Djava.security.egd=file:/dev/./urandom&rdquo;
```</p>

<p>然后再重启Tomcat，这次非常快了，整个启动只用了3秒多：</p>

<p><code>
INFO: Starting service Catalina
Dec 19, 2014 10:51:55 PM org.apache.catalina.core.StandardEngine startInternal
INFO: Starting Servlet Engine: Apache Tomcat/7.0.52 (Ubuntu)
Dec 19, 2014 10:51:55 PM org.apache.catalina.startup.HostConfig deployWAR
INFO: Deploying web application archive /usr/mxs/kindleinstance/webapps/kindlegen.war
Dec 19, 2014 10:51:58 PM org.apache.coyote.AbstractProtocol start
INFO: Starting ProtocolHandler ["http-bio-9090"]
Dec 19, 2014 10:51:58 PM org.apache.catalina.startup.Catalina start
INFO: Server startup in 3418 ms
</code></p>

<p>修改后的<code>/dev/urandom</code>没有默认的<code>dev/random</code>安全吗？似乎也不一定，博文<a href="http://www.2uo.de/myths-about-urandom/">Myths about /dev/urandom</a>对两者进行了全面的分析，值得一看。最后作者认为用<code>/dev/urandom</code>就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java运行时数据区与内存溢出异常]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/15/javayun-xing-shi-shu-ju-qu-yu-nei-cun-yi-chu-yi-chang/"/>
    <updated>2014-12-15T21:55:31+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/15/javayun-xing-shi-shu-ju-qu-yu-nei-cun-yi-chu-yi-chang</id>
    <content type="html"><![CDATA[<p>JVM定义了各种运行时数据区用于程序执行。有些数据区随着JVM启动而创建，当JVM退出时销毁。另一些数据区则是随着线程而存亡。每个数据区都是内存，因此就存在内存溢出的异常。本文学习JVM有哪些数据区以及常见的内存溢出异常。</p>

<!--more-->


<h2>1. 运行时数据区（Run-Time Data Areas）</h2>

<p>根据<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5">JVM规范</a>，运行时数据区主要分为以下部分。</p>

<h3>1.1 程序计数器（Program Counter Register）</h3>

<p>每个JVM线程拥有自己的程序计数器，各线程之间计数器互不影响，这部分区域可以称为线程私有的内存。在任何时间点，一个CPU核心都只会执行一个线程中某个方法的指令，这就是当前方法：</p>

<ul>
<li>如果当前方法不是Native方法，程序计数器包含正在执行的虚拟机字节码指令的地址。</li>
<li>如果是Native方法计数器值为Undefined。</li>
</ul>


<p>程序计数器所占内存非常小，也是唯一没有规定任何内存溢出异常的区域。</p>

<h3>1.2 虚拟机栈（JVM Stacks）</h3>

<p>每个线程同时也有一个私有的虚拟机栈，因此虚拟机栈的生命周期与线程相同。每个栈包括帧（frames），帧与方法调用相关，每当方法被调用，就会创建一个新的帧。当方法结束，帧也就被销毁。帧包括局域变量、自己的操作栈和当前方法的运行时常量池引用。</p>

<p>虚拟机栈与C语言中的栈相似，它包括局域变量和部分结果，并在方法调用和返回中扮演角色。除了push和pop帧，虚拟机栈并不提供其它直接操作。帧可能是在堆中分配内存。虚拟机栈的内存并不需要是连续的。</p>

<p>通常人们把Java内存分为堆和栈，其中栈就是虚拟机栈。虚拟机栈的内存可以是固定大小或者根据计算动态扩展。虚拟机栈涉及两个异常：</p>

<ul>
<li>StackOverflowError: 如果线程请求的栈深度大于允许的深度。</li>
<li>OutOfMemoryError：如果栈是动态扩展的，扩展时无法申请足够的内存。</li>
</ul>


<p>本地方法栈（Native Method Stack）与虚拟机栈发挥着相似的作用，但它是为Native方法服务。JVM规范并没有对其强制规定。HotSpot直接把本地方法栈和虚拟栈合二为一，相同对待。</p>

<p>栈虽然有两个异常，但实验时，如果是单线程操作，无论是栈帧太大还是虚拟机栈容量太小，基本只会出现StackOverflowError，示例如下：</p>

<p>```java
/<em>*
* -Xss128k
</em>/
public class JavaVMStackSOF {</p>

<pre><code>private int stackLength = 1;
public void stackLeak() {
    stackLength++;
    stackLeak();
}

public static void main(String[] args) {
    JavaVMStackSOF oom = new JavaVMStackSOF();
    try {
        oom.stackLeak();
    } catch(Throwable e) {
        ...
    }
}
</code></pre>

<p>}
```</p>

<p>实验中，只有多线程时，才会出现OutOfMemoryError。通过不停地创建线程，并且每个线程不停止，当线程足够多时就可以重现此异常。</p>

<h3>1.3 堆（Heap）</h3>

<p>堆是在JVM所管理的内存中最大的一块，它是所有线程共享的区域。当JVM启动时会创建此区域。所有对象实例和数组都在堆上分配（现在也有例外，参见<a href="/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">逸出分析</a>）。</p>

<p>堆中存储的对象由垃圾收集器负责回收。堆的大小可以是固定或者动态扩展。堆不需要连续内存空间，只要逻辑上连续即可。根据垃圾收集器的不同，堆内存有不同的管理方式。例如CMS采用分代收集算法，将堆分为年轻代和老年代；而G1则将堆分成大小相同的区域。详见<a href="/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>。</p>

<p>堆涉及的内存异常为OutOfMemoryError，如果堆中没有内存用于实例分配并且无法再扩展时，就会抛出此异常。堆内存溢出很容易模拟，示例如下：</p>

<p>```java
/<em>*
* -Xms20m -Xmx20m
</em>/
public static void main(String[] args) {</p>

<pre><code>List&lt;SomeObject&gt; list = new ArrayList&lt;&gt;();
while(true) {
    list.add(new SomeObject());
}
</code></pre>

<p>}
```</p>

<h3>1.4 方法区（Method Area）</h3>

<p>方法区也是所有线程共享的内存区域。它存储了每个类的信息，例如运行时常量池、属性和方法数据、方法和构造方法代码，包括类和实例初始化和接口初始化的特殊方法。</p>

<p>方法区随着虚拟机启动而创建。逻辑上它是堆的一部分，但JVM实现可以选择不对它进行垃圾收集或者压缩。JVM规范并没有强制规定它的位置和管理已编译代码的策略。它可以是固定大小或者动态扩展，也不需要是连续的。</p>

<p>对于HotSpot虚拟机来说，开发者更愿意把方法区称为永久代（Permanent Generation），但本质上两者并不等价。这仅仅是因为HotSpot设计团队使用永久代来实现方法区而已。但其它虚拟机（如Bea JRocket, IBM J9）并没有永久代的概念。</p>

<p>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。如果一些框架使用CGLib这类字节码技术，增强的类过多，或者JVM上的动态语言（如Groovy）持续创建类来实现语言动态特性，可能出现此异常。</p>

<h3>1.5 运行时常量池</h3>

<p>在<a href="/blog/2014/12/04/lei-wen-jian-yu-zi-jie-ma/">类文件与字节码</a>中介绍了类文件的常量池，运行时常量池就是这个常量池的运行时表示。运行时常量池相对于类文件常量池主要有两个区别：</p>

<ul>
<li>除了类文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</li>
<li>运行时常量池可以在运行期间将新的常量加入池中。</li>
</ul>


<p>运行时常量池的内存是从方法区分配出来的。当JVM创建类或接口时，会为它创建运行时常量池。因此它的内存受方法区内存限制，也可能抛出OutOfMemoryError异常。</p>

<h3>1.6 直接内存</h3>

<p>直接内存（Direct Memory）并不是JVM运行时数据区的一部分，也不是JVM规范定义的内存区域。但它也被频繁使用，可能导致OutOfMemoryError异常。</p>

<p>JDK 1.4中加入NIO类，引入了基于Channel与Buffer的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过DirectByteBuffer对象作为这块内存的引用进行操作。由于避免了Java堆与Native堆之间复制数据，在一些场景能显著提高性能。</p>

<p>这部分内存虽然不受Java堆大小限制，但肯定会受本机总内存和寻址空间限制。因此动态扩展时可能出现OutOfMemoryError异常。</p>

<h2>2. 内存Dump分析</h2>

<p>在<a href="/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>中介绍了jmap, jstat等工具可以查看内存映射和垃圾收集活动。这里介绍另一个工具Eclipse Memory Analyzer可以对堆内存溢出问题进行分析。首先需要生成堆转储文件。通过启用参数：</p>

<p><code>-XX:+HeapDumpOnOutOfMemoryError</code></p>

<p>JVM 就会在发生内存泄露时抓拍下当时的内存状态，也就是我们想要的堆转储文件。也可以在未溢出时用jmap创建转储文件。</p>

<p>有了转储文件，利用Eclipse Memory Analyzer tool打开该文件，就可以进行分析了。分析通常分为三步：</p>

<ul>
<li>对内存状态获取一个整体印象。</li>
<li>找到最有可能导致内存泄露的元凶，通常也就是消耗内存最多的对象。</li>
<li>进一步查看这个内存消耗大户的具体情况，看看是否有什么异常行为。</li>
</ul>


<p><img src="/myresource/images/image_blog_2014-12-17-20.30.59.jpg" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解Java性能调优]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you/"/>
    <updated>2014-12-06T21:00:37+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you</id>
    <content type="html"><![CDATA[<p>人们总是猜不对系统变慢的原因在哪里，你必须量体裁衣。没有评测就没有合适的调优。本文重点学习性能相关的内存管理、垃圾收集、相关工具并简单了解HotSpot。</p>

<!--more-->


<h2>1. 性能指标</h2>

<h3>评价性能的常用指标</h3>

<ul>
<li>等待时间(Latency)：在给定工作量的情况下，处理一个任务单元所消耗的时长。通常用响应时间随负载增长的变化曲线来反映。</li>
<li>吞吐量(Throughput)：在某一参考平台（硬件配置、OS和软件环境）上的每秒事务处理数。</li>
<li>利用率(Utilization)：在可用资源中处理工作单元的资源百分比。例如CPU的利用率。</li>
<li>效率(Efficiency)：吞吐量除以所用资源。</li>
<li>容量(Capacity)：任一时刻能通过系统的工作单元数量。</li>
<li>扩展性(Scalability)：当系统得到更多资源时，吞吐量或等待时间的变化。如果方案A可用的服务器数量翻倍，它的吞吐量也能翻倍，那么它就实现了完美的线性扩展。</li>
<li>退化(Degradation)：分为正面退化和负面退化。当工作单元增加时，性能通常会降低，即负面退化。但也存在正面退化，例如负载超过阈值，使系统切换到高性能模式，处理时间可能缩短。JVM是动态非常强的运行时系统，有几部分可以达成这种效果。</li>
</ul>


<p>性能分析时要了解一些概念：</p>

<blockquote><p>中位数（又称中值，Median），统计学中的专有名词，代表一个样本、种群或概率分布中的一个数值，其可将数值集合划分为相等的上下两部分。对于有限的数集，可以通过把所有观察值高低排序后找出正中间的一个作为中位数。如果观察值有偶数个，通常取最中间的两个数值的平均数作为中位数。</p>

<p>方差是各个数据分别与其和的平均数之差的平方的和的平均数，用字母D表示。在概率论和数理统计中，方差（Variance）用来度量随机变量和其数学期望（即均值）之间的偏离程度。在许多实际问题中，研究随机变量和均值之间的偏离程度有着重要意义。</p>

<p>百分位数是统计学术语，如果将一组数据从小到大排序，并计算相应的累计百分位，则某一百分位所对应数据的值就称为这一百分位的百分位数。可表示为：一组n个观测值按数值大小排列。如，处于p%位置的值称第p百分位数。</p>

<p>标准差（Standard Deviation） ，中文环境中又常称均方差，但不同于均方误差（mean squared error，均方误差是各数据偏离真实值的距离平方的平均数，也即误差平方和的平均数，计算公式形式上接近方差，它的开方叫均方根误差，均方根误差才和标准差形式上接近），标准差是离均差平方和平均后的方根，用σ表示。标准差是方差的算术平方根。标准差能反映一个数据集的离散程度。平均数相同的，标准差未必相同。</p></blockquote>

<h2>2. 务实的性能分析法</h2>

<p>做性能分析最重要的是知道哪个可测环节最重要。应该把测量结果、目标和结论跟一个或多个可测环节结合起来。以下是常见的可测项，都是性能调优的好对象：</p>

<ul>
<li>方法handelRequest()运行所需的平均时间。</li>
<li>并发10客户端时，系统等待时间的第90个百分位数。</li>
<li>并发用户从1增长到1000时，响应时间的退化。</li>
</ul>


<p>要精确确定一个方法或代码片段运行需要多长时间，只有两种方法：</p>

<ul>
<li>直接测量，在源码中插入测量代码。最容易理解，但是侵入式的。如果测量结果不断增多，代码很容易就被数据淹没。</li>
<li>在类加载时把类转换成受测类。使用特殊的类加载器，在方法开始和结束的地方加上记录时间的字节码。典型的有OpTier CoreFirst等性能监测工具，但似乎还没有开源工具。</li>
</ul>


<h2>3. 时间问题</h2>

<p>为了进行性能调优，需要对时间有深刻认识。</p>

<h4>硬件时钟</h4>

<p>基于x64的机器有四种不同的硬件时间源：</p>

<ul>
<li>RTC: 实时时钟（RTC）基本和电子表里的元件一样，在系统断电时由主板上的电池供电。系统启动时从它那得到时间。很多系统会在OS启动后通过网络时间协议（Network Time Protocol, NTP）与时间服务器同步。</li>
<li>8254：是可编程计时芯片，现在基本不需要了。</li>
<li>TSC：时间戳计时器，这是应用最广泛的现代计时器。可认为是一个跟踪CPU运行了多少周期的CPU计数器。由于与CPU相关，因此运行时可能受节能或其它因素影响。不同的CPU会互相偏离，不能跟钟表时间保持一致。</li>
<li>HPET，高精度事件计时器，最近几年才出现。精度非常高，但不是所有硬件都可用，也不是所有操作系统都支持。</li>
</ul>


<h4>Java获取时间的方法</h4>

<p>Java提供了两个获取时间的方法：</p>

<ul>
<li>System.currentTimeMillis()，解析度为毫秒级，几乎所有情况下都跟钟表时间相符。</li>
<li>System.nanoTime()，用于测量比毫秒更精确的时间，时间源来自TSC，可能偏离钟表时间。</li>
</ul>


<p>对于较长的间隔时间，nanoTime()基本是不可信的，应该使用currentTimeMillis()，nanoTime()它只能测量较短的时间间隔。</p>

<h2>4. 垃圾收集</h2>

<h3>4.1 内存管理</h3>

<p>内存自动管理是Java平台最重要的组成部分之一。Java内存分为栈和堆。</p>

<p>栈内存，即虚拟机栈。每个方法被执行的时候都会同时创建一个栈帧，用来存储局部变量，操作栈，动态链接，方法出口等信息。<strong>局部变量包括各种基本类型的变量和对象的引用变量都是在方法的栈内存中分配。</strong>其中，64位长度的long和double类型的数据占用2个局部变量的空间，其他数据类型只占用1个。局部变量所需要的内存空间是在编译期间完成的，当进入一个方法时候，这个方法所需的局部变量空间已经确定，在方法运行期间不会改变。当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。当线程请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常。当虚拟机栈无法扩展时候则抛出OutOfMemoryError异常。</p>

<p>堆内存，在虚拟机启动时创建。堆内存的唯一目的就是创建对象实例，所有的对象实例和数组都要在堆上分配。对象的域即使是原始类型，也仍然分配在堆内存中。堆内存的回收由垃圾回收负责。</p>

<h4>标记和清除</h4>

<p>标记和清除是最简单、也是出现最早的垃圾收集算法。Perl和PHP等语言则采用引用计数法。</p>

<p>最简单的标记和清除算法会暂停所有正在运行的线程，并从一组“活”对象（任何用户线程的任何堆栈帧中存在引用的对象）开始遍历其引用树，标记出路径上的所有活对象。遍历完成后，所有没被标记的被当作垃圾，可以回收。被清除的内存不是还给OS，而是JVM。</p>

<p>Java平台对基本的标记清除算法进行了改进，采用“分代式垃圾收集”。内存分成了几个不同的区域：</p>

<p><img src="/myresource/images/image_blog_2014-12-07-Java-Memory-Model-450x186.png" alt="image" /></p>

<ul>
<li>Eden(伊甸园)：对象最初降生的堆区域。</li>
<li>Survivor(幸存者乐园)：分为两个空间（S0, S1）,除非正在执行垃圾收集，否则总有一个空间是空的。</li>
<li>Old Generation：老年代。是那些“足够老”的幸存对象的归宿。</li>
<li>PermGen：为内部结构分配的内存，例如类定义。它不是严格的堆内存，并且普通的对象最后不会在这里结束。</li>
</ul>


<p>上面这些内存区域的垃圾收集方式不尽相同。</p>

<h4>年轻代收集（Minor GC）</h4>

<p>年轻代收集只会清理“年轻的”空间（伊甸园和幸存者乐园），其过程如下：</p>

<ul>
<li>在标记阶段发现的所有仍然存活的年轻对象都会被挪走：那些足够老的对象（从次数足够多的GC中幸存下来的）进入老年代；所有Eden中存活的对象被移到幸存者乐园的其中一个空间，幸存者乐园中的存活对象也会被移到该空间。（S0, S1总有一个是空的）</li>
<li>伊甸园和最近腾空的幸存者乐园可以重用了，因为它们里面已经全是垃圾了。</li>
</ul>


<h4>完全收集（Major GC）</h4>

<p>当年轻代收集不能把对象放进老年代时（空间不够了），就会触发一次完全收集，这通常要更长的时间。根据老年代所用的收集器，可能会牵涉到老年代对象的内部迁移。以确保必要时能从老年代对象所占的内存中给大的对象腾出足够的空间。这被称为压缩。</p>

<p>由于Major GC会消耗更长时间，消耗的时间取决于垃圾收集策略，这期间应用将无响应。因此在高响应应用中，有必要监视和优化垃圾回收以避免超时。</p>

<h4>安全点</h4>

<p>因为垃圾收集时，要暂停所有应用线程，因此线程给执行GC留出了特定的位置——安全点。常见的安全点是方法被调用的地方（调用点），不过也有其它安全点。当执行垃圾收集时，所有应用线程都必须停在安全点。</p>

<h3>4.2 工具</h3>

<p>借助一些工具可以帮你了解运行中的进程和垃圾收集。</p>

<h4>jmap</h4>

<p>jmap是Oracle JVM自带的一个工具，用来显示Java进程的内存映射，也能分析Java核心文件（Java core file，主要保存各应用线程在某一时刻的执行栈以及stack trace的显示）。</p>

<p><strong>默认视图</strong></p>

<p>jmap最简单的用法是查看连接到进程里的本地类库。用处不大，用得最多的是后面两种视图。</p>

<p><code>
$ jmap 25154
Attaching to process ID 25154, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 24.65-b04
</code></p>

<p><strong>堆视图</strong></p>

<p>使用-heap选项，jmap会抓取进程当前的堆快照。以下是输出结果示例：</p>

<p>```
$ jmap -heap 25164
Attaching to process ID 25164, please wait&hellip;
Debugger attached successfully.
Server compiler detected.
JVM version is 24.65-b04</p>

<p>using thread-local object allocation.
Parallel GC with 4 thread(s)</p>

<p>Heap Configuration:
   MinHeapFreeRatio = 0
   MaxHeapFreeRatio = 100
   MaxHeapSize      = 2147483648 (2048.0MB)
   NewSize          = 1310720 (1.25MB)
   MaxNewSize       = 17592186044415 MB
   OldSize          = 5439488 (5.1875MB)
   NewRatio         = 2
   SurvivorRatio    = 8      //Eden = (From+To)*幸存比例
   PermSize         = 21757952 (20.75MB)
   MaxPermSize      = 85983232 (82.0MB)
   G1HeapRegionSize = 0 (0.0MB)</p>

<p>Heap Usage:
PS Young Generation
Eden Space:
   capacity = 69206016 (66.0MB)
   used     = 22857000 (21.798133850097656MB)
   free     = 46349016 (44.201866149902344MB)
   33.02747553045099% used
From Space:
   capacity = 5242880 (5.0MB)
   used     = 5223552 (4.9815673828125MB)
   free     = 19328 (0.0184326171875MB)
   99.63134765625% used
To Space:
   capacity = 5242880 (5.0MB)
   used     = 0 (0.0MB)
   free     = 5242880 (5.0MB)
   0.0% used
PS Old Generation
   capacity = 89128960 (85.0MB)
   used     = 14067336 (13.415657043457031MB)
   free     = 75061624 (71.58434295654297MB)
   15.78312593347886% used
PS Perm Generation
   capacity = 22020096 (21.0MB)
   used     = 15539944 (14.820045471191406MB)
   free     = 6480152 (6.179954528808594MB)
   70.57164510091145% used</p>

<p>10750 interned Strings occupying 1540688 bytes.
```</p>

<p>可以看到，堆的大小是年轻代、老年代加上PermGen的总和。年轻代分为Eden和幸存者乐园（From + To）。要知道堆里面有什么，需要柱状视图。</p>

<p><strong>柱状视图</strong></p>

<p>柱状视图显示了系统中每个类型的实例占用的内存量，并按占用内存倒序排序，非常直观：</p>

<p>```
$ jmap -histo 25164 | head -30</p>

<h2> num     #instances         #bytes  class name</h2>

<p>   1:         46155       20826544  [B
   2:         78977       13845352  [C
   3:          1777       10259592  [I
   4:         28606        3977416  <constMethodKlass>
   5:         28606        3670320  <methodKlass>
   6:          2464        2990888  <constantPoolKlass>
   7:          2193        1756960  <constantPoolCacheKlass>
   8:          2464        1728800  <instanceKlassKlass>
   9:         53032        1272768  java.lang.String
  10:         12669         405408  java.util.HashMap$Entry
  11:          2740         333816  java.lang.Class
  12:          4131         330480  java.lang.reflect.Method
  13:          4488         297968  [S
  14:          4204         287432  [Ljava.lang.Object;
  15:           524         271024  <methodDataKlass>
  16:          4277         228680  [[I
  17:          2107         185416  org.apache.naming.resources.FileDirContext$FileResourceAttributes
  18:          3047         170632  java.util.zip.ZipFile$ZipFileInputStream
  19:           987         167256  [Ljava.util.HashMap$Entry;
  20:          2929         164024  java.util.zip.ZipFile$ZipFileInflaterInputStream
  21:           259         140896  <objArrayKlassKlass>
  22:          4282         137024  java.io.File
  23:          2194         131888  [Ljava.lang.String;
  24:          5483         131592  java.lang.StringBuilder
  25:          2656         127488  java.util.HashMap
  26:          2520         100800  java.lang.ref.Finalizer
  27:          2341          93640  java.util.LinkedHashMap$Entry
```</p>

<p>结果使用的是类型内部名称，例如byte数组会写成[B，char数组会写成[C（字符数组数据经常出现在String对象里）。参考<a href="/blog/2014/12/04/lei-wen-jian-yu-zi-jie-ma/">类文件与字节码</a>。以char数组为例，共有78977个实例，占用约13.8MB。</p>

<p>使用-histo:live选项，jmap将只处理活对象，而不是整个堆：</p>

<p>```
$ jmap -histo:live 25164 | head -7</p>

<h2> num     #instances         #bytes  class name</h2>

<p>   1:         28573        5905704  [C
   2:         28606        3977416  <constMethodKlass>
   3:         28606        3670320  <methodKlass>
   4:          2464        2990888  <constantPoolKlass>
```</p>

<p>活的字符串只有28573个实例，占用约5.9MB，证明有（13.8-5.9）MB在等待回收。需要注意的是，如果jmap正在执行时，JVM做了垃圾回收，有可能看到奇怪或太好的结果，所以应该多运行几次。</p>

<p><strong>产生离线导出文件</strong></p>

<p>jmap能创建导出文件：</p>

<p><code>
$ jmap -dump:live,format=b,file=heap.hprof 25164
Dumping heap to /Users/mxs/Documents/blog/heap.hprof ...
Heap dump file created
</code></p>

<p>导出结果可以用来做离线分析，留给jmap以后使用，或者留给Oracle的jhat（Java堆分析工具）做高级分析。</p>

<h4>jstat</h4>

<p>Oracle JVM自带的jstat可以查看内存和垃圾收集的活动，并能循环显示。下例以每秒一次的频率显示内存状况：</p>

<p><code>
meixuesongdeMacBook-Pro:blog mxs$ jstat -gc 25164 1000
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC     PU    YGC     YGCT    FGC    FGCT     GCT   
14336.0 13312.0  0.0    0.0   133632.0 85887.5   52224.0    10313.5   33280.0 15221.9      7    0.064   3      0.171    0.236
14336.0 13312.0  0.0    0.0   133632.0 85887.5   52224.0    10313.5   33280.0 15221.9      7    0.064   3      0.171    0.236
</code></p>

<ul>
<li>S0C和S1C: Survivor0和Survivor1的大小（KB）</li>
<li>S0U和S1U: Survivor0和Survivor1的已使用大小（KB）</li>
<li>EC and EU：Eden空间的大小和已经使用大小（KB）</li>
<li>OC and OU: 老年代空间的大小和已经使用大小（KB）</li>
<li>PC and PU: Perm空间的大小和已经使用大小（KB）</li>
<li>YGC and YGCT：YGC为年轻代GC的次数。YGCT显示年轻代GC的累计时间。</li>
<li>FGC and FGCT：Full GC的次数和累计时间</li>
<li>GCT：GC总时间，包括年轻代和Full GC。</li>
</ul>


<h4>Java VisualVM</h4>

<p>另一个可视化的工具是Java VisualVM，在命令行执行<code>jvisualvm</code>即可。</p>

<h3>4.3 与GC相关的JVM参数</h3>

<p>JVM的参数非常多。以<code>-X</code>开头的选项不是标准选项，在其它JVM上可能不可用。而<code>-XX</code>开头的是扩展选项，不要随便使用。很多与性能相关的选项都是扩展选项。</p>

<p>基本的垃圾收集选项可以见本文前面的内存分布图片。主要包括：</p>

<ul>
<li><code>-Xms</code>: 堆的初始大小</li>
<li><code>-Xmx</code>: 堆的最大大小</li>
<li><code>-Xmn</code>: 堆中年轻大的大小</li>
<li><code>-XX:-DisableExplicitGC</code>: 让System.gc()调用不产生任何作用。</li>
</ul>


<h3>4.4 逸出分析</h3>

<p>这是JVM最近的一项修改，开发者不能直接控制或影响这项修改。从Java 6u23之后，逸出分析是默认打开的。</p>

<p>它的基本思路是分析方法并确认其中哪个局部变量只用在方法内部，以及哪些变量不会传入其他方法或从当前方法中返回。JVM可以在当前方法的栈内部创建这个对象，不再使用堆内存。在当前方法返回时，被局部变量占用的内存就自动释放了，因此将减少程序年轻代收集的次数，提高性能。</p>

<h3>4.5 并发标记清除（CMS）</h3>

<p>CMS是Java 5推荐的高性能收集器，在Java 6仍保持了旺盛的生命力。通过以下选项激活：</p>

<table>
<thead>
<tr>
<th>选项 </th>
<th> 效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-XX:+UseConcMarkSweepGC</code> </td>
<td> 打开CMS收集</td>
</tr>
<tr>
<td><code>-XX:+CMSIncrementalMode</code> </td>
<td> 增量模式（一般都需要）</td>
</tr>
<tr>
<td><code>-XX:+CMSIncrementalPacing</code> </td>
<td> 配合增量模式，根据应用的行为自动调整每次执行垃圾回收任务的幅度（一般都需要）</td>
</tr>
<tr>
<td><code>-XX:+UseParNewGC</code> </td>
<td> 并发收集年轻代</td>
</tr>
<tr>
<td><code>-XX:ParallelGCThreads=&lt;N&gt;</code> </td>
<td> GC使用的线程数</td>
</tr>
</tbody>
</table>


<p>并发方式是如何工作的，以下是重要事实：</p>

<ul>
<li>某种世界停转（SWT）的暂停是不可避免的；</li>
<li>GC子系统绝对不能漏掉存活对象，这样做会导致JVM垮掉（或更糟）</li>
<li>只有所有应用线程都为整体收集暂停下来，才能保证收集所有的垃圾。</li>
</ul>


<p>CMS利用最后一点，制造两个非常短暂的STW暂停，并且在GC周期的剩余时间和应用程序的线程一起运行。CMS要在运行时做复杂的记账工作，记录哪些是垃圾，哪些不是。CMS在更多CPU核心的机器上表现会更好，并且会制造更频繁的短暂暂停。</p>

<h3>4.6 新的收集器：G1</h3>

<p>G1是Java平台最新的收集器，预发布于Java 6，到Java 7时已是成品。G1有望成为高性能应用的默认选择。</p>

<p>G1与原来的收集器完全不同，开发人员有更多控制权。其核心思想是暂停目标（Pause gaol），也就是程序能为GC暂停多长时间（如每5分钟20ms）。G1会努力达成该目标。</p>

<p>尽管G1仍然使用标记清除法，但它不是真正的分代式垃圾收集器。它把堆分成大小相同的区域（如每个1MB），不区分年轻、老年代。暂停时，对象被撤到其他区域（就像Eden挪到Survivor），清空的区域被放回到空白区自由列表上。</p>

<p>这个新的收集策略让Java平台统计收集单个区域所需平均时长。然后你就可以指定一个合理的暂停目标。G1只会在有限的时间内收集尽可能多的区域。与G1相关的选项如下表：</p>

<table>
<thead>
<tr>
<th>选项 </th>
<th> 效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-XX:+UseG1GC</code> </td>
<td> 打开G1收集</td>
</tr>
<tr>
<td><code>-XX:MaxGCPauseMillis=50</code> </td>
<td> 收集一次暂停的时间应尽量保持在50ms以内</td>
</tr>
<tr>
<td><code>-XX:GCPauseIntervalMillis=200</code> </td>
<td> 两次收集的时间间隔尽量保持在200ms以上。</td>
</tr>
</tbody>
</table>


<h2>5. HotSpot的JIT编译</h2>

<p>Java是一种“动态编译”语言。方法一开始都是以字节码形态存在，JVM对其解释并执行，同时会记录被调用的次数。当调用次数超过某个阈值（默认1万次）时，后台就会把字节码编译成机器码。如果编译成功，以后就会调用该方法的编译结果。编译后的机器码运行速度可能会快1000倍。</p>

<p>那为什么要动态编译，先编译好岂不是性能更好？原因之一是与平台无关的东西作为基本部署单位要更轻松。原因之二是动态编译能提供给编译器更多信息，例如某个指令是否可用，代码运行情况的统计数据等。因此Java这样的动态编译语言实际上可能会比提前编译的语言运行得更快。</p>

<p>HotSpot有两种运行模式：客户端模式和服务器模式，分别对应JVM启动选项：<code>-client</code>和<code>-server</code>。前者编译时会确保操作的一致性，较为保守。后者编译时会大胆假设，做一次运行时检查，以确保假设有效。编译结果性能好很多。</p>

<p><strong>实时Java</strong>是近年出现的，它并不一定是最快的。它关注的是让执行操作的时间尽量保持一致。为了达成这个目的，它可能会牺牲一些平均等待时间，整体性能可以受到轻微影响。</p>

<p><strong>内联</strong>是HotSpot的最大卖点之一。内联的方法不再是被调用，而是直接放到调用者内部。HotSpot会根据运行时的统计数据（方法调用频率）和其他因素来决定如何处理内联。这比提前编译更智能。它完全是自动的，通常不需要修改选项（用处不大）。</p>

<p><strong>独占调用</strong></p>

<p>独占调用是大胆优化的例子之一，只有服务端编译器才会做这种大胆优化，实时和客户端编译器都不会这样做。它是基于大量观察做出的优化，以下面的代码为例：</p>

<p><code>
MyActualClassNotInterface obj = getInstance();
obj.callMyMethod();
</code></p>

<p>如果上面的代码只会在一种类型的对象上调用（基于统计），也就是obj.callMyMethod()几乎不会同时碰到一个类和它的子类。这时就可以把Java方法查找替换为callMyMethod()编译结果的直接调用。为了防止getInstance()可能返回的是其他类，运行时会检查，确保对象的类型是由编译器按预期插入的。如果这个预期被违背，运行时会取消优化。程序不会注意到这些动作也不会犯任何错误。</p>

<p>通过启动选项<code>-XX:+PrintCompilation</code>可以告诉JIT编译线程输出标准日志。</p>
]]></content>
  </entry>
  
</feed>
