<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2014-12-21T13:58:53+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SecureRandom导致Tomcat启动过慢]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/20/%5B%3F%5D-ci-jie-jue-tomcatqi-dong-guo-man-de-jing-li/"/>
    <updated>2014-12-20T12:08:33+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/20/[?]-ci-jie-jue-tomcatqi-dong-guo-man-de-jing-li</id>
    <content type="html"><![CDATA[<p>昨天晚上在Tomcat上部署一个小应用时，Tomcat启动非常慢，有时甚至需要10分钟。查看日志，发现一直停在Deploying阶段：</p>

<!--more-->


<p><code>
INFO: Starting service Catalina
Dec 19, 2014 9:56:33 AM org.apache.catalina.core.StandardEngine startInternal
INFO: Starting Servlet Engine: Apache Tomcat/7.0.52 (Ubuntu)
Dec 19, 2014 9:56:33 AM org.apache.catalina.startup.HostConfig deployWAR
INFO: Deploying web application archive /usr/mxs/kindleinstance/webapps/kindlegen.war
</code></p>

<p>难道是war文件有问题？检查了md5校验码，尝试了解压缩，完全没问题啊！到底是什么原因呢？等了十分钟后，发现Tomcat已经启动完成，可以使用了。再次查看日志：</p>

<p><code>
INFO: Deploying web application archive /usr/mxs/kindleinstance/webapps/kindlegen.war
Dec 19, 2014 10:11:25 AM org.apache.catalina.util.SessionIdGenerator createSecureRandom
INFO: Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [888,934] milliseconds.
Dec 19, 2014 10:11:25 AM org.apache.coyote.AbstractProtocol start
INFO: Starting ProtocolHandler ["http-bio-9090"]
Dec 19, 2014 10:11:25 AM org.apache.catalina.startup.Catalina start
INFO: Server startup in 892334 ms
</code></p>

<p>原来是“Creation of SecureRandom instance for session ID”消耗了888秒，这个SecureRandom实例是什么呢？在<a href="http://wiki.apache.org/tomcat/HowTo/FasterStartUp">How do I make Tomcat startup faster?</a>中，有这样的描述：</p>

<blockquote><p>Tomcat 7+ heavily relies on SecureRandom class to provide random values for its session ids and in other places. Depending on your JRE it can cause delays during startup if entropy source that is used to initialize SecureRandom is short of entropy.</p></blockquote>

<p>也就是说，Tomcat 7之后严重依赖SecureRandom类来提供随机数用于Session ID。当Tomcat启动时，取决于你使用的JRE，如果用来初始化SecureRandom的熵值（Entropy）资源是一个短熵时，将可能导致延时。</p>

<p>再看看JDK中关于<a href="http://docs.oracle.com/javase/7/docs/api/java/security/SecureRandom.html">SecureRandom类</a>:</p>

<blockquote><p>This class provides a cryptographically strong random number generator (RNG). A cryptographically strong random number minimally complies with the statistical random number generator tests specified in FIPS 140-2, Security Requirements for Cryptographic Modules, section 4.9.1. Additionally, SecureRandom must produce non-deterministic output. Therefore any seed material passed to a SecureRandom object must be unpredictable, and all SecureRandom output sequences must be cryptographically strong, as described in RFC 1750: Randomness Recommendations for Security.</p></blockquote>

<p>该类提供保密性强的随机数生成器（RNG）。一个保密性强的随机数应最低限度遵循FIPS 140-2指定的统计随机数发生器测试和4.9.1节的加密模块安全要求。并且SecureRandom必须产出非确定性的输出。因此，正如RFC 1750中描述的，传递给SecureRandom对象的任何材料必须是不可预测的，并且所有SecureRandom输出序列必须是保密性强的的。</p>

<p>在<a href="http://www.cigital.com/justice-league-blog/2014/01/06/issues-when-using-java-securerandom/">ISSUES TO BE AWARE OF WHEN USING JAVA’S SECURERANDOM</a>中，提到了使用SecureRandom可能存在的问题，主要包括三个方面：调用顺序、阻塞和内部Seeding机制。其中说明了阻塞是如何产生的：</p>

<blockquote><p>Some SecureRandom implementations in the Oracle JRE for *nix use /dev/random to get entropy at certain times. Since /dev/random can block if sufficient entropy is not available, your code will stop executing if you call certain SecureRandom methods at times when /dev/random does not have sufficient entropy available.</p></blockquote>

<p>这样看来，我的Ubuntu 14中的OpenJDK(OpenJDK Runtime Environment (IcedTea 2.5.3) (7u71-2.5.3-0ubuntu0.14.04.1))正是使用了操作系统的<code>/dev/random</code>作为信息源，而它又没有提供足够的熵，所以导致阻塞。</p>

<p>按照前文<a href="http://wiki.apache.org/tomcat/HowTo/FasterStartUp">How do I make Tomcat startup faster?</a>中给出的次安全的解决办法，改为使用<code>-Djava.security.egd=file:/dev/./urandom</code>，即在setenv.sh中加入一行：</p>

<p>```</p>

<h1>!/bin/sh</h1>

<p>export CATALINA_OPTS=&ldquo;-Djava.security.egd=file:/dev/./urandom&rdquo;
```</p>

<p>然后再重启Tomcat，这次非常快了，整个启动只用了3秒多：</p>

<p><code>
INFO: Starting service Catalina
Dec 19, 2014 10:51:55 PM org.apache.catalina.core.StandardEngine startInternal
INFO: Starting Servlet Engine: Apache Tomcat/7.0.52 (Ubuntu)
Dec 19, 2014 10:51:55 PM org.apache.catalina.startup.HostConfig deployWAR
INFO: Deploying web application archive /usr/mxs/kindleinstance/webapps/kindlegen.war
Dec 19, 2014 10:51:58 PM org.apache.coyote.AbstractProtocol start
INFO: Starting ProtocolHandler ["http-bio-9090"]
Dec 19, 2014 10:51:58 PM org.apache.catalina.startup.Catalina start
INFO: Server startup in 3418 ms
</code></p>

<p>修改后的<code>/dev/urandom</code>没有默认的<code>dev/random</code>安全吗？似乎也不一定，博文<a href="http://www.2uo.de/myths-about-urandom/">Myths about /dev/urandom</a>对两者进行了全面的分析，值得一看。最后作者认为用<code>/dev/urandom</code>就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java运行时数据区与内存溢出异常]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/15/javayun-xing-shi-shu-ju-qu-yu-nei-cun-yi-chu-yi-chang/"/>
    <updated>2014-12-15T21:55:31+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/15/javayun-xing-shi-shu-ju-qu-yu-nei-cun-yi-chu-yi-chang</id>
    <content type="html"><![CDATA[<p>JVM定义了各种运行时数据区用于程序执行。有些数据区随着JVM启动而创建，当JVM退出时销毁。另一些数据区则是随着线程而存亡。每个数据区都是内存，因此就存在内存溢出的异常。本文学习JVM有哪些数据区以及常见的内存溢出异常。</p>

<!--more-->


<h2>1. 运行时数据区（Run-Time Data Areas）</h2>

<p>根据<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5">JVM规范</a>，运行时数据区主要分为以下部分。</p>

<h3>1.1 程序计数器（Program Counter Register）</h3>

<p>每个JVM线程拥有自己的程序计数器，各线程之间计数器互不影响，这部分区域可以称为线程私有的内存。在任何时间点，一个CPU核心都只会执行一个线程中某个方法的指令，这就是当前方法：</p>

<ul>
<li>如果当前方法不是Native方法，程序计数器包含正在执行的虚拟机字节码指令的地址。</li>
<li>如果是Native方法计数器值为Undefined。</li>
</ul>


<p>程序计数器所占内存非常小，也是唯一没有规定任何内存溢出异常的区域。</p>

<h3>1.2 虚拟机栈（JVM Stacks）</h3>

<p>每个线程同时也有一个私有的虚拟机栈，因此虚拟机栈的生命周期与线程相同。每个栈包括帧（frames），帧与方法调用相关，每当方法被调用，就会创建一个新的帧。当方法结束，帧也就被销毁。帧包括局域变量、自己的操作栈和当前方法的运行时常量池引用。</p>

<p>虚拟机栈与C语言中的栈相似，它包括局域变量和部分结果，并在方法调用和返回中扮演角色。除了push和pop帧，虚拟机栈并不提供其它直接操作。帧可能是在堆中分配内存。虚拟机栈的内存并不需要是连续的。</p>

<p>通常人们把Java内存分为堆和栈，其中栈就是虚拟机栈。虚拟机栈的内存可以是固定大小或者根据计算动态扩展。虚拟机栈涉及两个异常：</p>

<ul>
<li>StackOverflowError: 如果线程请求的栈深度大于允许的深度。</li>
<li>OutOfMemoryError：如果栈是动态扩展的，扩展时无法申请足够的内存。</li>
</ul>


<p>本地方法栈（Native Method Stack）与虚拟机栈发挥着相似的作用，但它是为Native方法服务。JVM规范并没有对其强制规定。HotSpot直接把本地方法栈和虚拟栈合二为一，相同对待。</p>

<p>栈虽然有两个异常，但实验时，如果是单线程操作，无论是栈帧太大还是虚拟机栈容量太小，基本只会出现StackOverflowError，示例如下：</p>

<p>```java
/<em>*
* -Xss128k
</em>/
public class JavaVMStackSOF {</p>

<pre><code>private int stackLength = 1;
public void stackLeak() {
    stackLength++;
    stackLeak();
}

public static void main(String[] args) {
    JavaVMStackSOF oom = new JavaVMStackSOF();
    try {
        oom.stackLeak();
    } catch(Throwable e) {
        ...
    }
}
</code></pre>

<p>}
```</p>

<p>实验中，只有多线程时，才会出现OutOfMemoryError。通过不停地创建线程，并且每个线程不停止，当线程足够多时就可以重现此异常。</p>

<h3>1.3 堆（Heap）</h3>

<p>堆是在JVM所管理的内存中最大的一块，它是所有线程共享的区域。当JVM启动时会创建此区域。所有对象实例和数组都在堆上分配（现在也有例外，参见<a href="/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">逸出分析</a>）。</p>

<p>堆中存储的对象由垃圾收集器负责回收。堆的大小可以是固定或者动态扩展。堆不需要连续内存空间，只要逻辑上连续即可。根据垃圾收集器的不同，堆内存有不同的管理方式。例如CMS采用分代收集算法，将堆分为年轻代和老年代；而G1则将堆分成大小相同的区域。详见<a href="/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>。</p>

<p>堆涉及的内存异常为OutOfMemoryError，如果堆中没有内存用于实例分配并且无法再扩展时，就会抛出此异常。堆内存溢出很容易模拟，示例如下：</p>

<p>```java
/<em>*
* -Xms20m -Xmx20m
</em>/
public static void main(String[] args) {</p>

<pre><code>List&lt;SomeObject&gt; list = new ArrayList&lt;&gt;();
while(true) {
    list.add(new SomeObject());
}
</code></pre>

<p>}
```</p>

<h3>1.4 方法区（Method Area）</h3>

<p>方法区也是所有线程共享的内存区域。它存储了每个类的信息，例如运行时常量池、属性和方法数据、方法和构造方法代码，包括类和实例初始化和接口初始化的特殊方法。</p>

<p>方法区随着虚拟机启动而创建。逻辑上它是堆的一部分，但JVM实现可以选择不对它进行垃圾收集或者压缩。JVM规范并没有强制规定它的位置和管理已编译代码的策略。它可以是固定大小或者动态扩展，也不需要是连续的。</p>

<p>对于HotSpot虚拟机来说，开发者更愿意把方法区称为永久代（Permanent Generation），但本质上两者并不等价。这仅仅是因为HotSpot设计团队使用永久代来实现方法区而已。但其它虚拟机（如Bea JRocket, IBM J9）并没有永久代的概念。</p>

<p>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。如果一些框架使用CGLib这类字节码技术，增强的类过多，或者JVM上的动态语言（如Groovy）持续创建类来实现语言动态特性，可能出现此异常。</p>

<h3>1.5 运行时常量池</h3>

<p>在<a href="/blog/2014/12/04/lei-wen-jian-yu-zi-jie-ma/">类文件与字节码</a>中介绍了类文件的常量池，运行时常量池就是这个常量池的运行时表示。运行时常量池相对于类文件常量池主要有两个区别：</p>

<ul>
<li>除了类文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</li>
<li>运行时常量池可以在运行期间将新的常量加入池中。</li>
</ul>


<p>运行时常量池的内存是从方法区分配出来的。当JVM创建类或接口时，会为它创建运行时常量池。因此它的内存受方法区内存限制，也可能抛出OutOfMemoryError异常。</p>

<h3>1.6 直接内存</h3>

<p>直接内存（Direct Memory）并不是JVM运行时数据区的一部分，也不是JVM规范定义的内存区域。但它也被频繁使用，可能导致OutOfMemoryError异常。</p>

<p>JDK 1.4中加入NIO类，引入了基于Channel与Buffer的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过DirectByteBuffer对象作为这块内存的引用进行操作。由于避免了Java堆与Native堆之间复制数据，在一些场景能显著提高性能。</p>

<p>这部分内存虽然不受Java堆大小限制，但肯定会受本机总内存和寻址空间限制。因此动态扩展时可能出现OutOfMemoryError异常。</p>

<h2>2. 内存Dump分析</h2>

<p>在<a href="/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>中介绍了jmap, jstat等工具可以查看内存映射和垃圾收集活动。这里介绍另一个工具Eclipse Memory Analyzer可以对堆内存溢出问题进行分析。首先需要生成堆转储文件。通过启用参数：</p>

<p><code>-XX:+HeapDumpOnOutOfMemoryError</code></p>

<p>JVM 就会在发生内存泄露时抓拍下当时的内存状态，也就是我们想要的堆转储文件。也可以在未溢出时用jmap创建转储文件。</p>

<p>有了转储文件，利用Eclipse Memory Analyzer tool打开该文件，就可以进行分析了。分析通常分为三步：</p>

<ul>
<li>对内存状态获取一个整体印象。</li>
<li>找到最有可能导致内存泄露的元凶，通常也就是消耗内存最多的对象。</li>
<li>进一步查看这个内存消耗大户的具体情况，看看是否有什么异常行为。</li>
</ul>


<p><img src="/myresource/images/image_blog_2014-12-17-20.30.59.jpg" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解Java性能调优]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you/"/>
    <updated>2014-12-06T21:00:37+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you</id>
    <content type="html"><![CDATA[<p>人们总是猜不对系统变慢的原因在哪里，你必须量体裁衣。没有评测就没有合适的调优。本文重点学习性能相关的内存管理、垃圾收集、相关工具并简单了解HotSpot。</p>

<!--more-->


<h2>1. 性能指标</h2>

<h3>评价性能的常用指标</h3>

<ul>
<li>等待时间(Latency)：在给定工作量的情况下，处理一个任务单元所消耗的时长。通常用响应时间随负载增长的变化曲线来反映。</li>
<li>吞吐量(Throughput)：在某一参考平台（硬件配置、OS和软件环境）上的每秒事务处理数。</li>
<li>利用率(Utilization)：在可用资源中处理工作单元的资源百分比。例如CPU的利用率。</li>
<li>效率(Efficiency)：吞吐量除以所用资源。</li>
<li>容量(Capacity)：任一时刻能通过系统的工作单元数量。</li>
<li>扩展性(Scalability)：当系统得到更多资源时，吞吐量或等待时间的变化。如果方案A可用的服务器数量翻倍，它的吞吐量也能翻倍，那么它就实现了完美的线性扩展。</li>
<li>退化(Degradation)：分为正面退化和负面退化。当工作单元增加时，性能通常会降低，即负面退化。但也存在正面退化，例如负载超过阈值，使系统切换到高性能模式，处理时间可能缩短。JVM是动态非常强的运行时系统，有几部分可以达成这种效果。</li>
</ul>


<p>性能分析时要了解一些概念：</p>

<blockquote><p>中位数（又称中值，Median），统计学中的专有名词，代表一个样本、种群或概率分布中的一个数值，其可将数值集合划分为相等的上下两部分。对于有限的数集，可以通过把所有观察值高低排序后找出正中间的一个作为中位数。如果观察值有偶数个，通常取最中间的两个数值的平均数作为中位数。</p>

<p>方差是各个数据分别与其和的平均数之差的平方的和的平均数，用字母D表示。在概率论和数理统计中，方差（Variance）用来度量随机变量和其数学期望（即均值）之间的偏离程度。在许多实际问题中，研究随机变量和均值之间的偏离程度有着重要意义。</p>

<p>百分位数是统计学术语，如果将一组数据从小到大排序，并计算相应的累计百分位，则某一百分位所对应数据的值就称为这一百分位的百分位数。可表示为：一组n个观测值按数值大小排列。如，处于p%位置的值称第p百分位数。</p>

<p>标准差（Standard Deviation） ，中文环境中又常称均方差，但不同于均方误差（mean squared error，均方误差是各数据偏离真实值的距离平方的平均数，也即误差平方和的平均数，计算公式形式上接近方差，它的开方叫均方根误差，均方根误差才和标准差形式上接近），标准差是离均差平方和平均后的方根，用σ表示。标准差是方差的算术平方根。标准差能反映一个数据集的离散程度。平均数相同的，标准差未必相同。</p></blockquote>

<h2>2. 务实的性能分析法</h2>

<p>做性能分析最重要的是知道哪个可测环节最重要。应该把测量结果、目标和结论跟一个或多个可测环节结合起来。以下是常见的可测项，都是性能调优的好对象：</p>

<ul>
<li>方法handelRequest()运行所需的平均时间。</li>
<li>并发10客户端时，系统等待时间的第90个百分位数。</li>
<li>并发用户从1增长到1000时，响应时间的退化。</li>
</ul>


<p>要精确确定一个方法或代码片段运行需要多长时间，只有两种方法：</p>

<ul>
<li>直接测量，在源码中插入测量代码。最容易理解，但是侵入式的。如果测量结果不断增多，代码很容易就被数据淹没。</li>
<li>在类加载时把类转换成受测类。使用特殊的类加载器，在方法开始和结束的地方加上记录时间的字节码。典型的有OpTier CoreFirst等性能监测工具，但似乎还没有开源工具。</li>
</ul>


<h2>3. 时间问题</h2>

<p>为了进行性能调优，需要对时间有深刻认识。</p>

<h4>硬件时钟</h4>

<p>基于x64的机器有四种不同的硬件时间源：</p>

<ul>
<li>RTC: 实时时钟（RTC）基本和电子表里的元件一样，在系统断电时由主板上的电池供电。系统启动时从它那得到时间。很多系统会在OS启动后通过网络时间协议（Network Time Protocol, NTP）与时间服务器同步。</li>
<li>8254：是可编程计时芯片，现在基本不需要了。</li>
<li>TSC：时间戳计时器，这是应用最广泛的现代计时器。可认为是一个跟踪CPU运行了多少周期的CPU计数器。由于与CPU相关，因此运行时可能受节能或其它因素影响。不同的CPU会互相偏离，不能跟钟表时间保持一致。</li>
<li>HPET，高精度事件计时器，最近几年才出现。精度非常高，但不是所有硬件都可用，也不是所有操作系统都支持。</li>
</ul>


<h4>Java获取时间的方法</h4>

<p>Java提供了两个获取时间的方法：</p>

<ul>
<li>System.currentTimeMillis()，解析度为毫秒级，几乎所有情况下都跟钟表时间相符。</li>
<li>System.nanoTime()，用于测量比毫秒更精确的时间，时间源来自TSC，可能偏离钟表时间。</li>
</ul>


<p>对于较长的间隔时间，nanoTime()基本是不可信的，应该使用currentTimeMillis()，nanoTime()它只能测量较短的时间间隔。</p>

<h2>4. 垃圾收集</h2>

<h3>4.1 内存管理</h3>

<p>内存自动管理是Java平台最重要的组成部分之一。Java内存分为栈和堆。</p>

<p>栈内存，即虚拟机栈。每个方法被执行的时候都会同时创建一个栈帧，用来存储局部变量，操作栈，动态链接，方法出口等信息。<strong>局部变量包括各种基本类型的变量和对象的引用变量都是在方法的栈内存中分配。</strong>其中，64位长度的long和double类型的数据占用2个局部变量的空间，其他数据类型只占用1个。局部变量所需要的内存空间是在编译期间完成的，当进入一个方法时候，这个方法所需的局部变量空间已经确定，在方法运行期间不会改变。当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。当线程请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常。当虚拟机栈无法扩展时候则抛出OutOfMemoryError异常。</p>

<p>堆内存，在虚拟机启动时创建。堆内存的唯一目的就是创建对象实例，所有的对象实例和数组都要在堆上分配。对象的域即使是原始类型，也仍然分配在堆内存中。堆内存的回收由垃圾回收负责。</p>

<h4>标记和清除</h4>

<p>标记和清除是最简单、也是出现最早的垃圾收集算法。Perl和PHP等语言则采用引用计数法。</p>

<p>最简单的标记和清除算法会暂停所有正在运行的线程，并从一组“活”对象（任何用户线程的任何堆栈帧中存在引用的对象）开始遍历其引用树，标记出路径上的所有活对象。遍历完成后，所有没被标记的被当作垃圾，可以回收。被清除的内存不是还给OS，而是JVM。</p>

<p>Java平台对基本的标记清除算法进行了改进，采用“分代式垃圾收集”。内存分成了几个不同的区域：</p>

<p><img src="/myresource/images/image_blog_2014-12-07-Java-Memory-Model-450x186.png" alt="image" /></p>

<ul>
<li>Eden(伊甸园)：对象最初降生的堆区域。</li>
<li>Survivor(幸存者乐园)：分为两个空间（S0, S1）,除非正在执行垃圾收集，否则总有一个空间是空的。</li>
<li>Old Generation：老年代。是那些“足够老”的幸存对象的归宿。</li>
<li>PermGen：为内部结构分配的内存，例如类定义。它不是严格的堆内存，并且普通的对象最后不会在这里结束。</li>
</ul>


<p>上面这些内存区域的垃圾收集方式不尽相同。</p>

<h4>年轻代收集（Minor GC）</h4>

<p>年轻代收集只会清理“年轻的”空间（伊甸园和幸存者乐园），其过程如下：</p>

<ul>
<li>在标记阶段发现的所有仍然存活的年轻对象都会被挪走：那些足够老的对象（从次数足够多的GC中幸存下来的）进入老年代；所有Eden中存活的对象被移到幸存者乐园的其中一个空间，幸存者乐园中的存活对象也会被移到该空间。（S0, S1总有一个是空的）</li>
<li>伊甸园和最近腾空的幸存者乐园可以重用了，因为它们里面已经全是垃圾了。</li>
</ul>


<h4>完全收集（Major GC）</h4>

<p>当年轻代收集不能把对象放进老年代时（空间不够了），就会触发一次完全收集，这通常要更长的时间。根据老年代所用的收集器，可能会牵涉到老年代对象的内部迁移。以确保必要时能从老年代对象所占的内存中给大的对象腾出足够的空间。这被称为压缩。</p>

<p>由于Major GC会消耗更长时间，消耗的时间取决于垃圾收集策略，这期间应用将无响应。因此在高响应应用中，有必要监视和优化垃圾回收以避免超时。</p>

<h4>安全点</h4>

<p>因为垃圾收集时，要暂停所有应用线程，因此线程给执行GC留出了特定的位置——安全点。常见的安全点是方法被调用的地方（调用点），不过也有其它安全点。当执行垃圾收集时，所有应用线程都必须停在安全点。</p>

<h3>4.2 工具</h3>

<p>借助一些工具可以帮你了解运行中的进程和垃圾收集。</p>

<h4>jmap</h4>

<p>jmap是Oracle JVM自带的一个工具，用来显示Java进程的内存映射，也能分析Java核心文件（Java core file，主要保存各应用线程在某一时刻的执行栈以及stack trace的显示）。</p>

<p><strong>默认视图</strong></p>

<p>jmap最简单的用法是查看连接到进程里的本地类库。用处不大，用得最多的是后面两种视图。</p>

<p><code>
$ jmap 25154
Attaching to process ID 25154, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 24.65-b04
</code></p>

<p><strong>堆视图</strong></p>

<p>使用-heap选项，jmap会抓取进程当前的堆快照。以下是输出结果示例：</p>

<p>```
$ jmap -heap 25164
Attaching to process ID 25164, please wait&hellip;
Debugger attached successfully.
Server compiler detected.
JVM version is 24.65-b04</p>

<p>using thread-local object allocation.
Parallel GC with 4 thread(s)</p>

<p>Heap Configuration:
   MinHeapFreeRatio = 0
   MaxHeapFreeRatio = 100
   MaxHeapSize      = 2147483648 (2048.0MB)
   NewSize          = 1310720 (1.25MB)
   MaxNewSize       = 17592186044415 MB
   OldSize          = 5439488 (5.1875MB)
   NewRatio         = 2
   SurvivorRatio    = 8      //Eden = (From+To)*幸存比例
   PermSize         = 21757952 (20.75MB)
   MaxPermSize      = 85983232 (82.0MB)
   G1HeapRegionSize = 0 (0.0MB)</p>

<p>Heap Usage:
PS Young Generation
Eden Space:
   capacity = 69206016 (66.0MB)
   used     = 22857000 (21.798133850097656MB)
   free     = 46349016 (44.201866149902344MB)
   33.02747553045099% used
From Space:
   capacity = 5242880 (5.0MB)
   used     = 5223552 (4.9815673828125MB)
   free     = 19328 (0.0184326171875MB)
   99.63134765625% used
To Space:
   capacity = 5242880 (5.0MB)
   used     = 0 (0.0MB)
   free     = 5242880 (5.0MB)
   0.0% used
PS Old Generation
   capacity = 89128960 (85.0MB)
   used     = 14067336 (13.415657043457031MB)
   free     = 75061624 (71.58434295654297MB)
   15.78312593347886% used
PS Perm Generation
   capacity = 22020096 (21.0MB)
   used     = 15539944 (14.820045471191406MB)
   free     = 6480152 (6.179954528808594MB)
   70.57164510091145% used</p>

<p>10750 interned Strings occupying 1540688 bytes.
```</p>

<p>可以看到，堆的大小是年轻代、老年代加上PermGen的总和。年轻代分为Eden和幸存者乐园（From + To）。要知道堆里面有什么，需要柱状视图。</p>

<p><strong>柱状视图</strong></p>

<p>柱状视图显示了系统中每个类型的实例占用的内存量，并按占用内存倒序排序，非常直观：</p>

<p>```
$ jmap -histo 25164 | head -30</p>

<h2> num     #instances         #bytes  class name</h2>

<p>   1:         46155       20826544  [B
   2:         78977       13845352  [C
   3:          1777       10259592  [I
   4:         28606        3977416  <constMethodKlass>
   5:         28606        3670320  <methodKlass>
   6:          2464        2990888  <constantPoolKlass>
   7:          2193        1756960  <constantPoolCacheKlass>
   8:          2464        1728800  <instanceKlassKlass>
   9:         53032        1272768  java.lang.String
  10:         12669         405408  java.util.HashMap$Entry
  11:          2740         333816  java.lang.Class
  12:          4131         330480  java.lang.reflect.Method
  13:          4488         297968  [S
  14:          4204         287432  [Ljava.lang.Object;
  15:           524         271024  <methodDataKlass>
  16:          4277         228680  [[I
  17:          2107         185416  org.apache.naming.resources.FileDirContext$FileResourceAttributes
  18:          3047         170632  java.util.zip.ZipFile$ZipFileInputStream
  19:           987         167256  [Ljava.util.HashMap$Entry;
  20:          2929         164024  java.util.zip.ZipFile$ZipFileInflaterInputStream
  21:           259         140896  <objArrayKlassKlass>
  22:          4282         137024  java.io.File
  23:          2194         131888  [Ljava.lang.String;
  24:          5483         131592  java.lang.StringBuilder
  25:          2656         127488  java.util.HashMap
  26:          2520         100800  java.lang.ref.Finalizer
  27:          2341          93640  java.util.LinkedHashMap$Entry
```</p>

<p>结果使用的是类型内部名称，例如byte数组会写成[B，char数组会写成[C（字符数组数据经常出现在String对象里）。参考<a href="/blog/2014/12/04/lei-wen-jian-yu-zi-jie-ma/">类文件与字节码</a>。以char数组为例，共有78977个实例，占用约13.8MB。</p>

<p>使用-histo:live选项，jmap将只处理活对象，而不是整个堆：</p>

<p>```
$ jmap -histo:live 25164 | head -7</p>

<h2> num     #instances         #bytes  class name</h2>

<p>   1:         28573        5905704  [C
   2:         28606        3977416  <constMethodKlass>
   3:         28606        3670320  <methodKlass>
   4:          2464        2990888  <constantPoolKlass>
```</p>

<p>活的字符串只有28573个实例，占用约5.9MB，证明有（13.8-5.9）MB在等待回收。需要注意的是，如果jmap正在执行时，JVM做了垃圾回收，有可能看到奇怪或太好的结果，所以应该多运行几次。</p>

<p><strong>产生离线导出文件</strong></p>

<p>jmap能创建导出文件：</p>

<p><code>
$ jmap -dump:live,format=b,file=heap.hprof 25164
Dumping heap to /Users/mxs/Documents/blog/heap.hprof ...
Heap dump file created
</code></p>

<p>导出结果可以用来做离线分析，留给jmap以后使用，或者留给Oracle的jhat（Java堆分析工具）做高级分析。</p>

<h4>jstat</h4>

<p>Oracle JVM自带的jstat可以查看内存和垃圾收集的活动，并能循环显示。下例以每秒一次的频率显示内存状况：</p>

<p><code>
meixuesongdeMacBook-Pro:blog mxs$ jstat -gc 25164 1000
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC     PU    YGC     YGCT    FGC    FGCT     GCT   
14336.0 13312.0  0.0    0.0   133632.0 85887.5   52224.0    10313.5   33280.0 15221.9      7    0.064   3      0.171    0.236
14336.0 13312.0  0.0    0.0   133632.0 85887.5   52224.0    10313.5   33280.0 15221.9      7    0.064   3      0.171    0.236
</code></p>

<ul>
<li>S0C和S1C: Survivor0和Survivor1的大小（KB）</li>
<li>S0U和S1U: Survivor0和Survivor1的已使用大小（KB）</li>
<li>EC and EU：Eden空间的大小和已经使用大小（KB）</li>
<li>OC and OU: 老年代空间的大小和已经使用大小（KB）</li>
<li>PC and PU: Perm空间的大小和已经使用大小（KB）</li>
<li>YGC and YGCT：YGC为年轻代GC的次数。YGCT显示年轻代GC的累计时间。</li>
<li>FGC and FGCT：Full GC的次数和累计时间</li>
<li>GCT：GC总时间，包括年轻代和Full GC。</li>
</ul>


<h4>Java VisualVM</h4>

<p>另一个可视化的工具是Java VisualVM，在命令行执行<code>jvisualvm</code>即可。</p>

<h3>4.3 与GC相关的JVM参数</h3>

<p>JVM的参数非常多。以<code>-X</code>开头的选项不是标准选项，在其它JVM上可能不可用。而<code>-XX</code>开头的是扩展选项，不要随便使用。很多与性能相关的选项都是扩展选项。</p>

<p>基本的垃圾收集选项可以见本文前面的内存分布图片。主要包括：</p>

<ul>
<li><code>-Xms</code>: 堆的初始大小</li>
<li><code>-Xmx</code>: 堆的最大大小</li>
<li><code>-Xmn</code>: 堆中年轻大的大小</li>
<li><code>-XX:-DisableExplicitGC</code>: 让System.gc()调用不产生任何作用。</li>
</ul>


<h3>4.4 逸出分析</h3>

<p>这是JVM最近的一项修改，开发者不能直接控制或影响这项修改。从Java 6u23之后，逸出分析是默认打开的。</p>

<p>它的基本思路是分析方法并确认其中哪个局部变量只用在方法内部，以及哪些变量不会传入其他方法或从当前方法中返回。JVM可以在当前方法的栈内部创建这个对象，不再使用堆内存。在当前方法返回时，被局部变量占用的内存就自动释放了，因此将减少程序年轻代收集的次数，提高性能。</p>

<h3>4.5 并发标记清除（CMS）</h3>

<p>CMS是Java 5推荐的高性能收集器，在Java 6仍保持了旺盛的生命力。通过以下选项激活：</p>

<table>
<thead>
<tr>
<th>选项 </th>
<th> 效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-XX:+UseConcMarkSweepGC</code> </td>
<td> 打开CMS收集</td>
</tr>
<tr>
<td><code>-XX:+CMSIncrementalMode</code> </td>
<td> 增量模式（一般都需要）</td>
</tr>
<tr>
<td><code>-XX:+CMSIncrementalPacing</code> </td>
<td> 配合增量模式，根据应用的行为自动调整每次执行垃圾回收任务的幅度（一般都需要）</td>
</tr>
<tr>
<td><code>-XX:+UseParNewGC</code> </td>
<td> 并发收集年轻代</td>
</tr>
<tr>
<td><code>-XX:ParallelGCThreads=&lt;N&gt;</code> </td>
<td> GC使用的线程数</td>
</tr>
</tbody>
</table>


<p>并发方式是如何工作的，以下是重要事实：</p>

<ul>
<li>某种世界停转（SWT）的暂停是不可避免的；</li>
<li>GC子系统绝对不能漏掉存活对象，这样做会导致JVM垮掉（或更糟）</li>
<li>只有所有应用线程都为整体收集暂停下来，才能保证收集所有的垃圾。</li>
</ul>


<p>CMS利用最后一点，制造两个非常短暂的STW暂停，并且在GC周期的剩余时间和应用程序的线程一起运行。CMS要在运行时做复杂的记账工作，记录哪些是垃圾，哪些不是。CMS在更多CPU核心的机器上表现会更好，并且会制造更频繁的短暂暂停。</p>

<h3>4.6 新的收集器：G1</h3>

<p>G1是Java平台最新的收集器，预发布于Java 6，到Java 7时已是成品。G1有望成为高性能应用的默认选择。</p>

<p>G1与原来的收集器完全不同，开发人员有更多控制权。其核心思想是暂停目标（Pause gaol），也就是程序能为GC暂停多长时间（如每5分钟20ms）。G1会努力达成该目标。</p>

<p>尽管G1仍然使用标记清除法，但它不是真正的分代式垃圾收集器。它把堆分成大小相同的区域（如每个1MB），不区分年轻、老年代。暂停时，对象被撤到其他区域（就像Eden挪到Survivor），清空的区域被放回到空白区自由列表上。</p>

<p>这个新的收集策略让Java平台统计收集单个区域所需平均时长。然后你就可以指定一个合理的暂停目标。G1只会在有限的时间内收集尽可能多的区域。与G1相关的选项如下表：</p>

<table>
<thead>
<tr>
<th>选项 </th>
<th> 效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-XX:+UseG1GC</code> </td>
<td> 打开G1收集</td>
</tr>
<tr>
<td><code>-XX:MaxGCPauseMillis=50</code> </td>
<td> 收集一次暂停的时间应尽量保持在50ms以内</td>
</tr>
<tr>
<td><code>-XX:GCPauseIntervalMillis=200</code> </td>
<td> 两次收集的时间间隔尽量保持在200ms以上。</td>
</tr>
</tbody>
</table>


<h2>5. HotSpot的JIT编译</h2>

<p>Java是一种“动态编译”语言。方法一开始都是以字节码形态存在，JVM对其解释并执行，同时会记录被调用的次数。当调用次数超过某个阈值（默认1万次）时，后台就会把字节码编译成机器码。如果编译成功，以后就会调用该方法的编译结果。编译后的机器码运行速度可能会快1000倍。</p>

<p>那为什么要动态编译，先编译好岂不是性能更好？原因之一是与平台无关的东西作为基本部署单位要更轻松。原因之二是动态编译能提供给编译器更多信息，例如某个指令是否可用，代码运行情况的统计数据等。因此Java这样的动态编译语言实际上可能会比提前编译的语言运行得更快。</p>

<p>HotSpot有两种运行模式：客户端模式和服务器模式，分别对应JVM启动选项：<code>-client</code>和<code>-server</code>。前者编译时会确保操作的一致性，较为保守。后者编译时会大胆假设，做一次运行时检查，以确保假设有效。编译结果性能好很多。</p>

<p><strong>实时Java</strong>是近年出现的，它并不一定是最快的。它关注的是让执行操作的时间尽量保持一致。为了达成这个目的，它可能会牺牲一些平均等待时间，整体性能可以受到轻微影响。</p>

<p><strong>内联</strong>是HotSpot的最大卖点之一。内联的方法不再是被调用，而是直接放到调用者内部。HotSpot会根据运行时的统计数据（方法调用频率）和其他因素来决定如何处理内联。这比提前编译更智能。它完全是自动的，通常不需要修改选项（用处不大）。</p>

<p><strong>独占调用</strong></p>

<p>独占调用是大胆优化的例子之一，只有服务端编译器才会做这种大胆优化，实时和客户端编译器都不会这样做。它是基于大量观察做出的优化，以下面的代码为例：</p>

<p><code>
MyActualClassNotInterface obj = getInstance();
obj.callMyMethod();
</code></p>

<p>如果上面的代码只会在一种类型的对象上调用（基于统计），也就是obj.callMyMethod()几乎不会同时碰到一个类和它的子类。这时就可以把Java方法查找替换为callMyMethod()编译结果的直接调用。为了防止getInstance()可能返回的是其他类，运行时会检查，确保对象的类型是由编译器按预期插入的。如果这个预期被违背，运行时会取消优化。程序不会注意到这些动作也不会犯任何错误。</p>

<p>通过启动选项<code>-XX:+PrintCompilation</code>可以告诉JIT编译线程输出标准日志。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类文件与字节码]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/04/lei-wen-jian-yu-zi-jie-ma/"/>
    <updated>2014-12-04T20:40:02+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/04/lei-wen-jian-yu-zi-jie-ma</id>
    <content type="html"><![CDATA[<p>本篇学习类加载过程、类文件的分析工具和字节码。</p>

<!--more-->


<h2>1. 类加载和类对象</h2>

<p>一个.class文件定义了JVM的一种类型。类加入到JVM当前运行态中，首先要加载并连接，进行大量验证，然后提供一个代表该类型的Class对象给正在运行的系统，用于创建新的实例。</p>

<h4>加载</h4>

<p>加载的过程首先要读取类文件的字节数据流，创建一个字节数组，然后产生对应的Class对象。这个过程会进行一些基本检查。加载结束时，Class对象还不成熟，类也不可用。</p>

<h4>连接</h4>

<p>加载完成后，类必须连接起来。这分为三个步骤：验证、准备和解析。验证类文件符合预期，不会引起系统运行时错误。准备阶段会分配内存，准备好初始化类中的静态变量（但不会现在初始化变量）。解析阶段会检查类中引用的类型是否有未知类型，如果有会加载进来。一旦需要加载的其他类型全部定位并完成解析，VM就可以初始化这个类。这时所有静态变量都可以被初始化，所有静态初始化代码块都会运行。类的加载全部完成，已经可以使用了。</p>

<h4>Class对象</h4>

<p>加载和连接过程的最终结果是一个Class对象，可以使用这个新类型创建实例了。Class对象可以和反射API一起实现对方法、域和构造方法等类成员的间接访问，通过getSuperClass()返回其父类。</p>

<h4>类加载器</h4>

<p>Java平台有几个经典的类加载器：</p>

<ul>
<li>根（或引导）类加载器：通常在VM启动后不久实例化，一般用本地代码实现。可视为VM的一部分。负责加载系统的基础JAR(主要是rt.jar),而且不做验证工作。</li>
<li>扩展类加载器：用来加载安装时自带的标准扩展。一般包括安全性扩展。</li>
<li>应用（或系统）类加载器：应用最广泛的类加载器，负责加载应用类。</li>
<li>定制类加载器：在更复杂的环境，如EE或比较复杂的SE框架，通常会有些附加（即定制）的类加载器。</li>
</ul>


<h2>2. 方法句柄</h2>

<p>反射代码有很多套路，要捕获各种讨厌的异常，代码看起来也不直观。Java 7为间接调用方法引入了java.lang.invoke包，即方法句柄，可以提高安全性和代码的可读性。</p>

<h4>MethodHandle</h4>

<p>它是对可直接执行的方法（或域、构造方法等）的类型化引用，是一个有能力安全调用方法的对象。</p>

<p>```java
MethodHandle mh = getTwoArgMH();
MyType ret;
try {</p>

<pre><code>//调用obj对象的句柄，传入参数arg0, arg1
ret = mh.invokeExact(obj, arg0, arg1);
</code></pre>

<p>} catch(Throwable e) {</p>

<pre><code>//...
</code></pre>

<p>}
```</p>

<h4>MethodType</h4>

<p>它表示方法签名类型的不可变对象。每个方法句柄都有一个MethodType实例，用来指明方法的返回类型和参数类型。但它没有方法的名称和接收者类型。通过工厂方法可以得到MethodType实例：</p>

<p><code>java
//第一个参数为返回类型，随后是方法参数的类型。
//toString()
MethodType mtToString = MethodType.methodType(String.class);
//setter方法
MethodType mtSetter = MethodType.methodType(void.class, Object.class);
//Comparator&lt;String&gt;定义的compareTo()方法
MethodType mtStringComparator = MethodType.methodType(int.class, String.Class, String.class);
</code></p>

<h4>查找方法句柄</h4>

<p>通过lookup对象，你给出持有所需方法的类、方法名称以及你所需方法签名相匹配的MethodType，就可以得到方法句柄：</p>

<p>```java
public MethodHandle getToStringMH() {</p>

<pre><code>MethodHandle mh;
MethodType mt = MethodType.methodType(String.class);
MethodHandles.Lookup lk = MethodHandles.lookup();

try {
    mh = lk.findVirtual(getClass(), "toString", mt);
} catch(NoSuchMethodException | IllegalAccessException mhx) {
    //...
}

return mh;
</code></pre>

<p>}
```</p>

<blockquote><p>如果不是从当前类中查找，则只能看到或取得public方法的句柄。方法句柄总是在安全管理之下安全使用。没有反射中setAccessible()那种破解方法。</p></blockquote>

<p>有了方法句柄，就可以执行它了。执行方法有两个：invokeExact()和invoke()。前者要求参数类型完全匹配，后者可以在不太匹配时做些修改后执行（如装箱或拆箱）。</p>

<h4>示例：反射、代理和方法句柄的使用对比</h4>

<p>现在通过一个实例来对比这三种方法。下面的代码演示了如何通过这三种方法来访问私有方法cancel()：</p>

<p>```java
public class ThreadPoolManager {</p>

<pre><code>//...
private void cancel(final ScheduledFuture&lt;?&gt; hndl) {
    //...
}

/* 反射方法
* 使用方法简单示例：
* Method meth = manager.makeReflective();
* meth.invoke(hndl);
*/
public Method makeReflective() {
    Method method = null;
    try {
        Class&lt;?&gt; argTypes = new Class[] {ScheduledFuture.class};
        method = ThreadPoolManager.class.getDeclaredMethod("cancel", argTypes);
        method.setAccessible(true);
    } catch(IllegalArgumentException | NoSuchMethodException | SecurityException e) {
        //...
    }

    return method;
}

/* 代理方法
*  使用方法简单示例：
*  CancelProxy proxy = manager.makeProxy();
*  proxy.invoke(manager, hndl);
*/
public static class CancelProxy {
    private CancelProxy() {}
    public void invoke(ThreadPoolManager mae, ScheduledFuture&lt;?&gt; hndl) {
        mae.cancel(hndl);
    }
}

public CancelProxy makeProxy() {
    return new CancelProxy();
}

/* 方法句柄
* 使用方法简单示例：
* MethodHandle mh = manager.makeMh();
* mh.invokeExact(manager, hndl);
*/
public MethodHandle makeMh() {
    MethodHandle mh;
    MethodType desc = MethodType.methodType(void.class, ScheduledFuture.class);
    try {
        mh = MethodHandles.lookup().findVirtual(ThreadPoolManager.class, "cancel", desc);
    } catch(NoSuchMethodException | IllegalAccessException e) {
        //...
    }

    return mh;
}
</code></pre>

<p>}
```</p>

<p>三种方法的比较：</p>

<table>
<thead>
<tr>
<th>方法 </th>
<th> 访问控制 </th>
<th> 类型纪律 </th>
<th> 性能  </th>
</tr>
</thead>
<tbody>
<tr>
<td>反射 </td>
<td> 必须使用setAccesible。会被安全管理器禁止 </td>
<td> 不匹配就抛异常 </td>
<td> 较慢</td>
</tr>
<tr>
<td>代理 </td>
<td> 内部类可以访问受限方法 </td>
<td> 静态，为了代理全部代理类，可能需要更多PermGen </td>
<td> 跟其他方法一样快</td>
</tr>
<tr>
<td>方法句柄 </td>
<td> 取决于上下文，与安全管理器没有冲突 </td>
<td> 运行时是类型安全的，不占用PermGen </td>
<td> 力求跟其他方法调用一样快</td>
</tr>
</tbody>
</table>


<p>方法句柄还有一个特性，可以在静态上下文中确定当前类。例如下面的代码改写了logger的创建方式，可以不用将类名写死：</p>

<p><code>java
Logger logger = LoggerFactory.getLogger(MyClass.class);
//可改为：
Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
</code></p>

<h2>3. 了解类文件</h2>

<p>有时候有必要查看类文件，但它是二进制文件，和它打交道并不容易。Oracle JVM的javap这个工具可以用来探视类文件内部和反编译。</p>

<p>我们以一个简单的Java类作为示例：</p>

<p>```java
public class Sample {</p>

<pre><code>private byte b;
private char c;
private double d;
private float f;
private int i;
private Integer Int;
private long l;
private String s;
private boolean bl;
private int[] array;

//getter, setter
</code></pre>

<p>```</p>

<h3>查看类文件的方法和属性</h3>

<p><code>java
$ javap  Sample.class
Compiled from "Sample.java"
public class com.ubone.tdd.chapter1.javaio.Sample {
  public com.ubone.tdd.chapter1.javaio.Sample();
  public byte getB();
  public void setB(byte);
  public char getC();
  //其它getter, setter方法...
}
</code></p>

<p>javap默认显示public, protected和包级protected级别的方法和属性。加上-p选项后可以显示private方法和属性。</p>

<h3>方法签名的内部形式</h3>

<p>JVM内部用的方法签名使用紧凑形式，例如int用I表示。这称为类型描述符：</p>

<ul>
<li>B: byte</li>
<li>C: char(16位Unicode字符)</li>
<li>D: double</li>
<li>F: float</li>
<li>I: int</li>
<li>J: long</li>
<li>L&lt;类型名称>: 引用类型，如：Ljava/lang/String</li>
<li>S: short</li>
<li>Z: boolean</li>
<li>[: array-of</li>
</ul>


<p>使用javap -s可以输出签名的类型描述符：</p>

<p>```java
$ javap -s Sample.class
Compiled from &ldquo;Sample.java&rdquo;
public class com.ubone.tdd.chapter1.javaio.Sample {
  public com.ubone.tdd.chapter1.javaio.Sample();</p>

<pre><code>Signature: ()V
</code></pre>

<p>  public byte getB();</p>

<pre><code>Signature: ()B
</code></pre>

<p>  public void setB(byte);</p>

<pre><code>Signature: (B)V
</code></pre>

<p>  public char getC();</p>

<pre><code>Signature: ()C
</code></pre>

<p>  public void setC(char);</p>

<pre><code>Signature: (C)V
</code></pre>

<p>  public double getD();</p>

<pre><code>Signature: ()D
</code></pre>

<p>  public void setD(double);</p>

<pre><code>Signature: (D)V
</code></pre>

<p>  public float getF();</p>

<pre><code>Signature: ()F
</code></pre>

<p>  public void setF(float);</p>

<pre><code>Signature: (F)V
</code></pre>

<p>  public int getI();</p>

<pre><code>Signature: ()I
</code></pre>

<p>  public void setI(int);</p>

<pre><code>Signature: (I)V
</code></pre>

<p>  public java.lang.Integer getInt();</p>

<pre><code>Signature: ()Ljava/lang/Integer;
</code></pre>

<p>  public void setInt(java.lang.Integer);</p>

<pre><code>Signature: (Ljava/lang/Integer;)V
</code></pre>

<p>  public long getL();</p>

<pre><code>Signature: ()J
</code></pre>

<p>  public void setL(long);</p>

<pre><code>Signature: (J)V
</code></pre>

<p>  public java.lang.String getS();</p>

<pre><code>Signature: ()Ljava/lang/String;
</code></pre>

<p>  public void setS(java.lang.String);</p>

<pre><code>Signature: (Ljava/lang/String;)V
</code></pre>

<p>  public boolean isBl();</p>

<pre><code>Signature: ()Z
</code></pre>

<p>  public void setBl(boolean);</p>

<pre><code>Signature: (Z)V
</code></pre>

<p>  public int[] getArray();</p>

<pre><code>Signature: ()[I
</code></pre>

<p>  public void setArray(int[]);</p>

<pre><code>Signature: ([I)V
</code></pre>

<p>}
```</p>

<h3>常量池</h3>

<p>常量池是为类文件中的其他（常量）元素提供快捷访问方式的区域。通过javap -v可以查看常量池的信息：</p>

<p><code>
Constant pool:
   #1 = Class              #2             //  com/ubone/tdd/chapter1/javaio/Sample
   #2 = Utf8               com/ubone/tdd/chapter1/javaio/Sample
   #3 = Class              #4             //  java/lang/Object
   #4 = Utf8               java/lang/Object
   #5 = Utf8               b
   #6 = Utf8               B
   #7 = Utf8               c
   #8 = Utf8               C
   #9 = Utf8               d
  #10 = Utf8               D
  #11 = Utf8               f
  #12 = Utf8               F
  #13 = Utf8               i
  #14 = Utf8               I
  #15 = Utf8               Int
  #16 = Utf8               Ljava/lang/Integer;
  #17 = Utf8               l
  #18 = Utf8               J  
  ...
  #70 = Utf8               getL
  #71 = Utf8               ()J
  #72 = Fieldref           #1.#73         //  com/ubone/tdd/chapter1/javaio/Sample.l:J
  #73 = NameAndType        #17:#18        //  l:J
  #74 = Utf8               setL
  #75 = Utf8               (J)V
  ...
</code></p>

<p>如上所示，常量池的条目是带有类型的，它们还会相互引用。例如类型为Class的条目会引用类型为Utf8的条目。后者是个字符串，因此第1行为类的名称。</p>

<p>72行的Fieldref定义了一个域，解析这个域需要名称、类型和它所在的类。<code>#1.#73</code>表示来自类<code>#1</code>,域为<code>#73</code>。<code>#73</code>的NameAndType描述名称和类型，分别来自17和18，即类型J(Long)，名称为<code>l</code>。</p>

<h2>4. 字节码</h2>

<p>字节码的基本特性：</p>

<ul>
<li>字节码是程序的中间表示形式，介于人类可读的源码和机器码之间。</li>
<li>字节码由javac产生。</li>
<li>某些高级语言特性在编译时已经从字节码去掉。例如for语句在字节码中被转换成分支指令。</li>
<li>每个操作码都由一个字节表示（因此叫做字节码）。</li>
<li>字节码可以进一步编译成机器码，也就是“即时编译”。</li>
</ul>


<h3>反编译类</h3>

<p>javap可以用于反编译类：</p>

<p>```
$ javap -c -p Sample.class
Compiled from &ldquo;Sample.java&rdquo;
public class com.ubone.tdd.chapter1.javaio.Sample {
  private byte b;</p>

<p>  private char c;
  &hellip;</p>

<pre><code>public com.ubone.tdd.chapter1.javaio.Sample();
Code:
   0: aload_0       
   1: invokespecial #28                 // Method java/lang/Object."&lt;init&gt;":()V
   4: return        
</code></pre>

<p>  &hellip;</p>

<p>  public long getL();</p>

<pre><code>Code:
   0: aload_0       
   1: getfield      #72                 // Field l:J
   4: lreturn       
</code></pre>

<p>  public void setL(long);</p>

<pre><code>Code:
   0: aload_0       
   1: lload_1       
   2: putfield      #72                 // Field l:J
   5: return        
</code></pre>

<p>```</p>

<p>代码前的数字表示从方法开始算起的字节码偏移量。先看构造方法，由于void构造方法总会隐式调用父类的构造方法。因此有invokespecial指令。对于方法getL()和setL()也可以看到相应的操作码和参数。</p>

<p>javac产生的字节码没有经过特别优化，是非常简单的表示形式。大部分优化工作由JIT编译器来完成。</p>

<h3>运行时环境</h3>

<p>JVM没有处理器寄存器，而是使用堆栈机完成所有的计算和操作，所以理解堆栈机的操作对理解字节码至关重要。方法在运行时需要一块内存区域作为计算堆栈来计算新值。另外，每个运行的线程都需要一个调用堆栈来记录当前正在执行的方法。来看下面的代码是如何完成计算的：</p>

<p><code>return 3 + petRecords.getNumberOfPets("Ben");</code></p>

<p>系统首先会把3压入操作数栈，然后把接收对象（petRecords）压入计算堆栈，传入的参数尾随其后。然后invoke操作符会调用方法getNumberOfPets，把控制权移交给被调用的方法。进入新方法后，需要启用不同的操作数栈，所以已经在调用者操作数栈中的值不可能影响被调用方法的计算结果。</p>

<p>当getNumberOfPets完成时，返回结果会被放到调用者的操作数栈中，进程中与getNumberOfPets相关的部分也会从调用堆栈中移走。然后相加运算得到结果。</p>

<h3>操作码</h3>

<p>JVM字节码由操作码（opcode）序列构成，每个指令后可能会跟一些参数。每个操作码由一个单字节值表示，所以最多有255个操作码。目前用了200个左右。大致可以分为以下几类，摘要说明如下：</p>

<blockquote><ul>
<li>参数：操作码参数。如果参数出现在括号中，表示可选。以i打头的参数用来作为常量池或局部变量中的查询索引的几个字节。如果有多个此类参数，会合并在一直。例如i1,i2表示从这两个字节生成一个16位的索引。</li>
<li>堆栈布局：展示栈在操作码执行前后的状态。</li>
<li>表中操作码并不全，只用于示例。</li>
</ul>
</blockquote>

<p>加载和储存操作码，这个族系负责将值加载到栈或者检索值。有很多不同形式的变体。如dload操作码把双精度数从局部变量加载到栈上。</p>

<p><img src="/myresource/images/image_blog_2014-12-05-5-4.jpg" alt="image" /></p>

<p>数学运算操作码用来执行数学运算。</p>

<p><img src="/myresource/images/image_blog_2014-12-05-5-5.jpg" alt="image" /></p>

<p><img src="/myresource/images/image_blog_2014-12-05-5-6.jpg" alt="image" /></p>

<p><img src="/myresource/images/image_blog_2014-12-05-5-7.jpg" alt="image" /></p>

<p><strong>平台操作操作码</strong></p>

<p>在字节码这一级，构造方法被转换成带有特殊名称<init>的方法。不能由用户代码调用，但可以由字节码调用。这便形成了一个与对象创建直接相关的不同的字节码模式：new之后跟着一个dup，然后是一个调用<init>方法的invokespecial.</p>

<p><img src="/myresource/images/image_blog_2014-12-05-5-8.jpg" alt="image" /></p>

<blockquote><p>为了节省字节，很多字节码都有快捷方式。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java并发编程(四)]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/01/javabing-fa-bian-cheng-si/"/>
    <updated>2014-12-01T22:43:50+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/01/javabing-fa-bian-cheng-si</id>
    <content type="html"><![CDATA[<p>在学习了《Java编程思想》中关于<a href="/blog/2014/09/02/javabing-fa-bian-cheng-san/">并发编程</a>的内容后，继续学习Java并发编程。</p>

<!--more-->


<h2>1. 常用的并发构件</h2>

<h3>为什么是synchronized?</h3>

<p>这个单词的意思是同步，那么Java中synchronized表示什么意思呢？其实就是同步被锁定对象的主内存块。</p>

<ul>
<li>当进入一个synchronized代码块时，持有锁的线程和被锁定对象主内存中的视图会进行同步。</li>
<li>当synchronized代码块执行完之后，被锁定对象所做的任何修改会在线程锁释放之前刷回到主内存中。</li>
</ul>


<p>而volatile变量，在使用之前总是会从主内存中再读出来。线程所写的值总会在指令完成之前被刷回到主内存中。volatile变量不会引入线程锁，是真正线程安全的。<strong>但只有写入时不依赖当前状态（读取的状态）的变量才应该声明为volatile变量。对于要关注当前状态的变量，只能借助线程锁保证绝对安全性。</strong></p>

<h3>Lock有什么好处？</h3>

<ul>
<li>添加不同类型的锁，比如读取锁和写入锁。</li>
<li>对锁的阻塞没有限制，即允许在一个方法中上锁，在另一个方法中解锁。</li>
<li>如果线程得不到锁，比如锁由另外一个线程持有，就允许该线程后退或继续执行，或者做点别的事情——运用tryLock()方法。</li>
<li>允许线程尝试取锁，并可以在超过等待时间后放弃。</li>
</ul>


<p>Lock接口的两个实现类：</p>

<ul>
<li>ReentranLock: 本质上与同步块一样，但更灵活些。</li>
<li>ReentranReadWriteLock: 在读多写入的时候，性能更好。</li>
</ul>


<h3>ConcurrentHashMap</h3>

<p>ConcurrentHashMap是HashMap的并发版本，改进了Collections.synchronizedMap()功能。它是concurrent包中最有用的类之一，不仅提供了多线程的安全性，而且性能更优。它提供了原子操作的新方法：</p>

<ul>
<li>putIfAbsent(): 如果没有对应键，则将键值对添加到HashMap中。</li>
<li>remove(): 如果键存在，且值与当前状态相等，则用原子方式移除键值对。</li>
<li>replace(): 当键存在时，进行原子替换。</li>
</ul>


<h3>CopyOnWriteArrayList</h3>

<p>它是标准ArrayList的替代品，通过copy-on-write来实现线程安全性，对修改列表的任何操作都会创建一个新复本。当快速、一致的数据快照（不同的读取器读到的数据偶尔可能会不一样）比完美的同步以及性能上的突破更重要时，这种共享数据的方法非常理想，经常出现在非关键任务中。</p>

<h3>Queue</h3>

<p>Java有些多线程编程模型在很大程度上依赖于Queue实现线程安全性。BlockingQueue是最简单的实现。向队列put()时，如果队列满则放入线程会等待。从队列take()时，如果队列空，则取出线程阻塞。</p>

<p>Queue接口全是泛型<code>Queue&lt;E&gt;</code>，利用这一点把工作项封装到一个人工容器中会更方便。例如工作单元MyAwesomeClass，与其用<code>BlockingQueue&lt;MyAwesomeClass&gt;</code>不如使用<code>BlockingQueue&lt;WorkUnit&lt;MyAwesomeClass&gt;&gt;</code>：</p>

<p>```java
public class WorkUnit<T> {</p>

<pre><code>private final T workUnit;
public T getWork() {return workUnit;}
public WorkUnit(T workUnit) {
    this.workUnit = workUnit;
}
</code></pre>

<p>}
```</p>

<p>有了这层间接引用，可以添加额外的元数据而不用牺牲MyAwesomeClass的完整性。例如在WorkUnit中添加用于测试、性能指标和运行时系统信息等。</p>

<p>除了基本的put()和take()方法，BlockingQueue还提供了还超时的放入和取出方法：offer(E e, long timeout, TimeUnit unit)和poll(long timeout, TimeUnit unit)。</p>

<p>Java 7还引入了TransferQueue，本质上是多了transfer()操作的BlockingQueue。在BlockingQueue中，当上游线程池比下游快时，可能会引发一些问题，导致LinkedBlockingQueue溢出。反之，如果下游比上游快，则可能队列经常空着。TransferQueue可以优化这种情况，调控上/下游的速度。当消费线程在等待时，transfer()操作会马上把工作项传给它，否则就会阻塞直到取走工作项的线程出现。可以把这看做“挂号信”选项，即正在处理工作项的线程在交付当前工作项之前不会开始其他工作项的工作。</p>

<p>用TransferQueue取代BlockingQueue的代码性能可能会更好，因为前者的实现考虑了现代编译器和处理器的特性，执行效率更高。</p>

<h2>2. 控制执行</h2>

<p>如果每个工作单元都启动一个新线程执行，效率会太低。因此可以利用线程池来执行工作单元/任务。</p>

<h3>任务建模</h3>

<p>任务建模可以采用三种办法：Callable, Future接口和FutureTask类。</p>

<h4>Callable接口</h4>

<p>Callable接口代表一段可以调用并返回结果的代码，典型用法是匿名实现类：</p>

<p>```java
final MyObject obj = new MyObject();</p>

<p>Callable<String> cb = new Callable<String>() {</p>

<pre><code>public String call() throws Exception {
    return obj.someMethod();
}
</code></pre>

<p>};</p>

<p>String s = cb.call();
```</p>

<h4>Future接口</h4>

<p>Future接口用来表示异步任务。主要有三个方法：</p>

<ul>
<li>get()，获取结果，如果没执行完会阻塞，直到能取得结果。</li>
<li>cancel()，在结束前取消。</li>
<li>isDonw()，判断是否结束。</li>
</ul>


<p>```java
interface ArchiveSearcher { String search(String target); }
 class App {
   ExecutorService executor = &hellip;
   ArchiveSearcher searcher = &hellip;
   void showSearch(final String target)</p>

<pre><code>   throws InterruptedException {
 Future&lt;String&gt; future
   = executor.submit(new Callable&lt;String&gt;() {
     public String call() {
         return searcher.search(target);
     }});
 displayOtherThings(); // do other things while searching
 try {
   displayText(future.get()); // use future
 } catch (ExecutionException ex) { cleanup(); return; }
</code></pre>

<p>   }
 }
```</p>

<h4>FutureTask类</h4>

<p>FutureTask类是Future接口的常用实现类，实现了Runnable接口，因此可以由执行者调度。它提供的方法基本是Future和Runnable接口的组合：get(), cancel(), isDone(), isCancelled()和run()。它还提供了两个很方便的构造器：一个以Callable为参数，另一个以Runnable为参数。</p>

<p>```java
FutureTask<String> future =</p>

<pre><code>   new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() {
     public String call() {
       return searcher.search(target);
   }});
</code></pre>

<p>executor.execute(future);
```</p>

<h3>ScheduledThreadPoolExecutor(STPE)</h3>

<p>STPE是Executors类工厂方法的众多执行者之一。它有以下特点：</p>

<ul>
<li>可以预定线程池大小，也可自适应</li>
<li>所安排的任务可以定期执行，也可只运行一次。</li>
</ul>


<p>```java
ScheduledExecutorService stpe = Executors.newScheduledThreadPool(2);</p>

<p>final Runnable msgReader = new Runnable() {</p>

<pre><code>public void run() {
    //...
}
</code></pre>

<p>};</p>

<p>//每10毫秒唤醒一个线程。该线程可以尝试poll一个队列&hellip;
ScheduledFuture&lt;?> hndl = stpe.scheduleAtFixedRate(msgReader, 10, 10, TimeUnit.MILLISECONDS);
```</p>

<h2>3.分支/合并框架</h2>

<p>这是Java 7重点突出的框架之一，用于轻量级并发，实现线程池中任务的自动调度。</p>

<p>先来看看之前的并发算法可能存在的问题。如果某个线程的运行队列都是小任务，而另一个全是大任务。那么小任务的线程可能会空闲很多。而基于Work-Stealing（工作窃取）算法的ForkJoin则可以很好地解决此问题。</p>

<p><img src="/myresource/images/image_blog_2014-12-02-fork-join.GIF" alt="image" /></p>

<ul>
<li>分支/合并框架引入一种新的执行者服务，称为ForkJoinPool</li>
<li>ForkJoinPool处理比线程更小的并发单元ForkJoinTask</li>
<li>ForkJoinTask是一种由ForkJoinPool以更轻量化的方式所调度的抽象</li>
<li>通常使用两种任务（尽管都表示为ForkJoinTask实例）：“小型”任务是无需耗费太多时间就可以直接执行的任务；“大型”任务是需要分解（可能多次分解）后再执行的任务。</li>
</ul>


<p>这个框架的关键特性之一就是这些轻量的任务都能生成新的ForkJoinTask实例，而这些实例将仍由执行它们父任务的线程池来安排调度。这就是分而治之。例如在归并算法中，就可以将左侧、右侧的排序任务视为一个ForkJoinTask，在递归过程中，不断产生小型任务执行。下面的示例是一个对微博按时间归并排序的例子：</p>

<p>```java
//RecursiveAction继承自ForkJoinTask<Void>
public class MicroBlogUpdateSorter extends RecursiveAction {
  private static final int SMALL_ENOUGH = 32;
  private final Update[] updates;
  private final int start, end;
  private final Update[] result;</p>

<p>  public MicroBlogUpdateSorter(Update[] updates_) {</p>

<pre><code>this(updates_, 0, updates_.length);
</code></pre>

<p>  }</p>

<p>  public MicroBlogUpdateSorter(Update[] upds<em>, int startPos</em>, int endPos_) {</p>

<pre><code>start = startPos_;
end = endPos_;
updates = upds_;
result = new Update[updates.length];
</code></pre>

<p>  }</p>

<p>  private void merge(MicroBlogUpdateSorter left<em>, MicroBlogUpdateSorter right</em>) {</p>

<pre><code>int i = 0;
int lCt = 0;
int rCt = 0;
while (lCt &lt; left_.size() &amp;&amp; rCt &lt; right_.size()) {
  result[i++] = (left_.result[lCt].compareTo(right_.result[rCt]) &lt; 0) ? left_.result[lCt++]
      : right_.result[rCt++];
}
while (lCt &lt; left_.size())
  result[i++] = left_.result[lCt++];
while (rCt &lt; right_.size())
  result[i++] = right_.result[rCt++];
</code></pre>

<p>  }</p>

<p>  public int size() {</p>

<pre><code>return end - start;
</code></pre>

<p>  }</p>

<p>  public Update[] getResult() {</p>

<pre><code>return result;
</code></pre>

<p>  }</p>

<p>  @Override
  protected void compute() {</p>

<pre><code>  //如果数组太小，就用系统排序
if (size() &lt; SMALL_ENOUGH) {
  System.arraycopy(updates, start, result, 0, size());
  Arrays.sort(result, 0, size());
} else {
  int mid = size() / 2;
  MicroBlogUpdateSorter left = new MicroBlogUpdateSorter(updates, start,
      start + mid);
  MicroBlogUpdateSorter right = new MicroBlogUpdateSorter(updates, start
      + mid, end);
  invokeAll(left, right);
  merge(left, right);
}
</code></pre>

<p>  }</p>

<pre><code>public static void main() {
List&lt;Update&gt; lu = new ArrayList&lt;Update&gt;();
String text = "";
final Update.Builder ub = new Update.Builder();
final Author a = new Author("Tallulah");

for (int i = 0; i &lt; 256; i++) {
  text = text + "X";
  long now = System.currentTimeMillis();
  lu.add(ub.author(a).updateText(text).createTime(now).build());
  try {
    Thread.sleep(1);
  } catch (InterruptedException e) {
  }
}
Collections.shuffle(lu);
Update[] updates = lu.toArray(new Update[0]); // Avoid allocation by passing
                                              // zero-sized array
MicroBlogUpdateSorter sorter = new MicroBlogUpdateSorter(updates);
ForkJoinPool pool = new ForkJoinPool(4);
pool.invoke(sorter);

for (Update u : sorter.getResult()) {
  System.out.println(u);
}
</code></pre>

<p>  }
}
```</p>

<p>如果下面这些问题答案是肯定的，那么就适合于使用分支/合并框架：</p>

<ul>
<li>问题的子任务是否无需与其他子任务有显式的协作或同步也可以工作？</li>
<li>子任务是不是不会对数据进行修改，只是经过计算得出结果？</li>
<li>对于子任务来说，分而治之是不是很自然的事？子任务是不是会创建更多的子任务，而且它们要比派生出它们的任务粒度更细？</li>
</ul>

]]></content>
  </entry>
  
</feed>
