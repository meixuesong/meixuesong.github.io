<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2015-03-08T21:59:44+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java Web中文编码]]></title>
    <link href="http://blog.ubone.com/blog/2015/02/23/java-webzhong-wen-bian-ma/"/>
    <updated>2015-02-23T15:57:18+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/02/23/java-webzhong-wen-bian-ma</id>
    <content type="html"><![CDATA[<p>介绍常见的编码格式，以及Java Web和JavaScript相关的字符集编码。</p>

<!--more-->


<h2>1. 常见的编码格式</h2>

<table>
<thead>
<tr>
<th>编码 </th>
<th> 说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ASCII </td>
<td> 共128个，用1个字节表示。0～31为控制字符，如换行、回车等。32～126为打印字符。</td>
</tr>
<tr>
<td>ISO-8859-1 </td>
<td> 扩展ASCII编码，仍然是单字节，共256个字符。</td>
</tr>
<tr>
<td>GB2312 </td>
<td> 双字节编码，A1~A9是符号区，共682个符号；B0~F7是汉字区，共6763个汉字</td>
</tr>
<tr>
<td>GBK </td>
<td> 为Win95所制定的汉字内码规范，扩展GB2312，与GB2312兼容，能表示21003个汉字。</td>
</tr>
<tr>
<td>GB18030 </td>
<td> 可能是单字节、双字节或者四字节编码，与GB2312兼容。虽然是国家标准，但未广泛使用。</td>
</tr>
<tr>
<td>UTF-16 </td>
<td> 定义了Unicode字符在计算机中的存取方法。Unicode是ISO试图创建一个全新的超语言字典，世界上所有语言都可以通过这个字典相互翻译。Unicode是Java和XML的基础。UTF-16用两个字节来表示Unicode的转化格式，采用定长的表示方法。</td>
</tr>
<tr>
<td>UTF-8 </td>
<td> 避免UTF-16的空间浪费，采用变长技术，每个编码区域有不同的字码长度。不同类型的字符可以由1～6个字节组成。</td>
</tr>
</tbody>
</table>


<p>UTF-8的编码规则：</p>

<ul>
<li>如果是1个字节，最高位（第8位）为0，表示1个ASCII字符。</li>
<li>如果是1个字节，以11开着，则连续的1的个数表示这个字符的字节数。例如110xxxxx表示它是双字节UTF-8字符的首字节。</li>
<li>如果1个字节，以10开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节。</li>
</ul>


<h2>2. Java中的编码场景</h2>

<h3>2.1 在I/O中编码</h3>

<p>在磁盘和网络I/O中，都涉及字节与字符的转换。Reader类是Java的I/O中读字符的父类，而InputStream类是读字节的父类。两者之间的转换由StreamDecoder和StreamEncoder完成。在编、解码过程中必须指定Charset，否则使用本地环境默认字符集，如中文环境使用GBK。</p>

<p>在实际开发过程中，只要保持编码的一致就不会造成乱码：</p>

<p>```java
String charset = &ldquo;UTF-8&rdquo;;
String file = &ldquo;c:/stream.txt&rdquo;;</p>

<p>FileOutputStream fos = new FieOutputStream(file);
OutputStreamWriter writer = new OutputStreamWriter(fos, charset);</p>

<p>&hellip;
InputStreamReader reader = new InputStreamReader(inputStream, charset);
```</p>

<h3>2.2 在内存中编码</h3>

<p>String类提供了字符和字节的转换方法：</p>

<p><code>java
String s= "这是一段中文";
byte[] b = s.getBytes("UTF-8");
String n = new String(b, "UTF-8");
</code></p>

<p>另一种方法是使用Charset类：</p>

<p><code>java
Charset charset = Charset.forName("UTF-8");
ByteBuffer byteBuffer = charset.encode("abcd");
CharBuffer charBuffer = charset.decode(byteBuffer);
</code></p>

<h2>3. Java Web中的编解码</h2>

<p>用户从浏览器发起一个HTTP请求，需要编码的地方包括URL、Cookie和Parameter。</p>

<h3>3.1 URL的编解码</h3>

<p>URL <code>http://localhost:8080/examples/servlets/servlet/books?author=jason</code> 可分解为：</p>

<ul>
<li>URI: <code>/examples/servlets/servlet/books</code></li>
<li>schema: http</li>
<li>domain: localhost</li>
<li>port: 8080</li>
<li>contextPath: examples</li>
<li>servletPath: servlets/servlet</li>
<li>PathInfo: books</li>
<li>QueryString: author=jason</li>
</ul>


<p>对于Tomcat，对URL的URI部分进行解码的字符集是在Connector中定义的。如果没有定义，那么默认为ISO-8859-1。QueryString的解码字符集要么是Header中ContentType定义的Charset，要么是默认的ISO-8859-1。要使用ContentType定义的编码，需要设置Connector。因此Tomcat一般会设置：</p>

<p><code>&lt;Connector URIEncoding="UTF-8" useBodyEncodingForURI="true" /&gt;</code></p>

<h3>3.2 HTTP Header的编解码</h3>

<p>除了URL外，还可能在Header中传递其它参数，如Cookie、redirectPath等。不要在Header中传递非ASCII字符，如果一定要传递，可以先用URLEncoder编码，再添加到Header中。</p>

<h3>3.3 其它编解码</h3>

<p>POST表单也是通过ContentType的Charset编码。用JDBC来存取数据时要和数据的内置编码保持一致，可以通过设置JDBC URL来指定，如MySQL: url=&ldquo;jdbc:mysql://localhost:3306/DB?useUnicode=true&amp;characterEncoding=GBK"。</p>

<h2>4. Javascript中的编码问题</h2>

<p>如果Javascript文件的编码格式与当前页面不一致，需要指定字符集，否则可能出现乱码：<code>&lt;script src="abc.js" charset="gbk"/&gt;</code>。在Javascript中处理URL可以使用<code>encodeURI()</code>和<code>encodeURIComponent()</code>。后者编码得更彻底，除了<code>!</code>、<code>'</code>、<code>(</code>、<code>)</code>、<code>*</code>、<code>-</code>、<code>.</code>、<code>_</code>、<code>~</code>、<code>0-9</code>、<code>a-z</code>和<code>A-Z</code>之外，对其他所有字符都编码，因此通常用于将一个URL当作一个参数放在另一个URL中。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java内存模型与线程]]></title>
    <link href="http://blog.ubone.com/blog/2015/01/31/javanei-cun-mo-xing-yu-xian-cheng/"/>
    <updated>2015-01-31T19:45:39+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/01/31/javanei-cun-mo-xing-yu-xian-cheng</id>
    <content type="html"><![CDATA[<p>学习并发编程，需要了解Java内存模型与线程。</p>

<!--more-->


<h2>1. 硬件的基础</h2>

<p>为了提高效率，现在的CPU都有一层读写速度接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存中。</p>

<p>对于多处理器系统，每个处理器都有自己的高速缓存，而它们又共享同一个主内存。因此就存在缓存一致性的问题。当多个处理器的运算任务都涉及同一块主内存区域时，就可能导致各自的缓存数据不一致。为了解决一致性问题，需要遵循一些协议（如MSI, MESI, MOSI等）。</p>

<p><img src="/myresource/images/image_blog_-2015-01-31-19.55.58.png" alt="image" /></p>

<p>乱序执行（Out-Of-Order Execution）优化。为了使处理器内部的运算单元能尽量充分利用，处理器可能会对代码进行乱序执行优化，在计算之后将结果重组，保证该结果与顺序执行的结果一致。也就是处理器并不保证各条语句执行的先后顺序与输入顺序一致。JIT也有类似的指令重排序（Instruction Recorder）优化。</p>

<h2>2. Java内存模型</h2>

<h3>2.1 主内存与工作内存</h3>

<p>JVM规范定义了Java内存模型来屏蔽各种硬件和OS的内存访问差异。该模型规定所有变量都存储在主内存（仅是虚拟机内存的一部分）中，每条线程还有自己的工作内存，线程的工作内存保存了该线程使用到的变量（不是对象，而是对象的引用）的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p>

<p><img src="/myresource/images/image_blog_-2015-01-31-20.27.06.png" alt="image" /></p>

<h3>2.2 内存间交互操作</h3>

<p>关于主内存与工作内存之间的交互，Java内存模型定义了8种操作来完成，每种操作都是原子操作。</p>

<ul>
<li>lock: 作用于主内存变量，把一个变量标识为一条线程独占状态</li>
<li>unlock: 作用于主内存变量，释放一个锁定的变量，可以被其他线程锁定</li>
<li>read: 作用于主内存变量，把一个变量的值从主内存传输到线程的工作内存中，以便load动作使用。</li>
<li>load: 作用于工作内存变量，把read操作从主内存中得到的变量值放入工作内存变量副本中。</li>
<li>use: 作用于工作内存变量，把工作内存中的变量的值传递给执行引擎。每当虚拟机遇到一个需要使用变量的值的字节码指令时会执行这个操作。</li>
<li>assign: 作用于工作内存变量，把从执行引擎接收到的值赋给工作内存变量。每当虚拟机遇到一个给变量赋值的字节码指令时执行此操作。</li>
<li>store: 作用于工作内存变量，把工作内存中一个变量的值传送到主内存中，以便write操作使用。</li>
<li>write: 作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>


<h3>2.3 volatile变量</h3>

<h4>2.3.1 可见性</h4>

<p>对于volatile变量，具备两个特性：一是保证此变量对所有线程的可见性，即当一个线程修改了这个变量的值，新值对于其他线程来说可以立即得知。实际上volatile变量在各线程的工作内存中也可以存在不一致的情况，但是由于使用之前都要先刷新，因此可以认为不存在一致性问题。但由于Java中的运算不是原子操作，因此volatile在并发下也不一定是安全的。例如下面的代码：</p>

<p>```java
public static volatile int race = 0;</p>

<p>public static void increase() {</p>

<pre><code>race++;
</code></pre>

<p>}</p>

<p>//测试代码：
for(int i = 0; i &lt; 20; i++) {</p>

<pre><code>...//用20个线程调用increase()方法
public void run() {
    for(int j = 0; j &lt; 10000; j++) {
        increase();
    }
}
</code></pre>

<p>}</p>

<p>//当20个线程结束后，race的值通常会少于20万。
```</p>

<p>volatile变量与普通变量的区别在于，前者保证新值能立即同步到主内存，并且每次使用前都立即从主内存刷新。对于volatile变量，如果不符合以下两条规则，则仍然要通过加锁来实现同步：</p>

<ol>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ol>


<h4>2.3.2 禁止指令重排序优化</h4>

<p>volatile变量也用于禁止指令重排序。直接看伪代码：</p>

<p>```java
volatile boolean initialized = false;</p>

<p>//线程A
initConfig() //做一些初始化的工作
initialized = true;</p>

<p>//线程B
while(! initialized) { sleep();}
//使用线程A中初始化好的配置信息
doSomethingWithConfig();
```</p>

<p>如果变量initialized不声明为volatile，则指令重排序后，有可能线程A中的<code>initialized = true</code>比<code>initConfig()</code>提前执行。导致线程B无法正确获取配置信息。</p>

<h2>3. Java与线程</h2>

<p>主流操作系统都提供了线程实现，Java语言则提供了在不同硬件和操作系统平台下对线程操作的统一处理。线程实现主要有3种方式：</p>

<h3>3.1 使用内核线程实现</h3>

<p>内核线程是由操作系统内核（Kernel）支持的线程。程序并不直接使用内核线程，而是使用轻量级进程（Light Weight Process, LWP）。LWP就是我们通常意义上所讲的线程。每个LWP与内核线程是1：1关系。</p>

<p>内核线程的缺点是调用代价高，需要在用户态和内核态来回切换。同时LWP要消耗一定的内核资源。因此一个系统支持LWP的数量是有限的。</p>

<h3>3.2 使用用户线程实现</h3>

<p>用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核帮助。因此可以支持更大的线程数量，不需要切换到内核，快速且消耗低。进程与用户线程的关系为1：N关系。</p>

<p>由于没有系统内核支援，所有线程操作都需要用户程序自己处理，因此程序比较复杂。Java曾经使用过用户线程，但最终放弃使用它。</p>

<h3>3.3 使用用户线程加LWP混合实现</h3>

<p>这种混合实现方式即存在用户线程，也存在LWP。用户线程还是完全建立在用户空间中，因此创建、切换等操作依然廉价，并且可以支持大规模用户线程并发。而操作系统提供支持的LWP则作为用户线程与内核线程之间的桥梁，可以使用内核提供的线程调度功能及处理器映射，用户线程的系统调用通过LWP完成，大大降低了整个进程被完全阻塞的风险。用户线程与LWP的数量比不定，即N:M的关系。</p>

<h3>3.4 Java线程的实现</h3>

<p>JDK1.2之前使用用户线程实现。从1.2开始，线程模型基于操作系统原生线程模型来实现。对于SunJDK，Windows和Linux版都是使用1：1的线程模型，即一条Java线程映射到一条LWP。而Solaris，HP-UX等则由于操作系统的线程特性，可以同时支持1：1及N:M模型。</p>

<h2>4. 线程安全</h2>

<p>Brian Goetz对线程安全的定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。</p>

<h3>4.1 Java语言中的线程安全</h3>

<h4>4.1.1 不可变</h4>

<p>Java中不可变的对象一定是线程安全的。如果共享的数据是一个基本数据类型，只要在定义时使用了final关键字就可以保证它是不可变的。如果共享数据是一个对象，则需要保证对象的行为不会对其状态产生任何影响。</p>

<h4>4.1.2 绝对线程安全</h4>

<p>Java API中标注为线程安全的类，大多数都不是绝对的线程安全。例如java.util.Vector是线程安全的容器，其get(), remove()和size()方法都是同步的。但如果不在方法调用端做额外的同步措施，代码仍然是不安全的：</p>

<p>```java
//如果一个线程在操作Vector时，另一个线程删除了了个元素，导致i元素不可再用，就会抛出异常。
private static Vector<Integer> vector = new Vector<Integer>();</p>

<p>public static void main(String[] args) {</p>

<pre><code>while(true) {
    for(int i = 0; i &lt; 10; i++) {vector.add(i);}

    Thread removeThread = new Thread(new Runnable(){
        public void run() {
            for(int i = 0; i &lt; vector.size(); i++) {
                vector.remove(i);
            }
        }
    });

    Thread printThread = new Thread(new Runnable(){
        public void run() {
            for(int i = 0; i &lt; vector.size(); i++) {
                System.out.println((vector.get(i)));
            }
        }
    });

    removeThread.start();
    printThread.start();

    while(Thread.activeCount() &gt; 20);
}
</code></pre>

<p>}
```</p>

<h4>4.1.3 相对线程安全</h4>

<p>这就是我们平时说的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用时不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p>

<h4>4.1.4 线程兼容</h4>

<p>对象本身并不是线程安全的，但是可以在调用端正确使用同步手段来保证对象在并发环境下可以安全使用。</p>

<h4>4.1.5 线程对立</h4>

<p>无论调用端是否采取了同步措施，都无法在多线程环境中并发使用。Java中这种代码很少，但Thread的suspend()和resume()方法就是个例子。如果并发情况下，一个尝试中断，另一个尝试恢复线程，无论调用时是否进行了同步，目标线程都存在死锁风险。这两个方法已经声明为Deprecated.</p>

<h3>4.2 线程安全的实现方法</h3>

<h4>4.2.1 互斥同步</h4>

<p>Java中最基本的互斥同步手段是synchronized关键字。这是一个相对重量级的操作，因为需要进行用户态和核心态的转换。</p>

<p>ReentranLock是另一个同步实现方法。它与synchronized相比，有以下高级功能：</p>

<ul>
<li>等待可中断：如果持有锁的线程长期不释放锁，正在等待锁的线程可以选择放弃。</li>
<li>公平锁：多个线程在等待同一个锁时，必须按照申请的顺序依次获得锁。（synchronized是非公平的。 ReentranLock默认也是非公平的，但通过参数可以要求用公平锁）</li>
<li>锁绑定多个条件：一个ReentranLock对象可以同时绑定多个Condition对象。</li>
</ul>


<p>JDK6之后，虚拟机对synchronized性能进行了优化，已经与ReentranLock持平了，未来优化还会偏向于synchronized。因此如果性能满足需要时，可以优先考虑使用synchronized来同步。</p>

<h4>4.2.2 非阻塞同步</h4>

<p>互斥同步是一种悲观的并发策略，因为不论是否真的存在竞争，它都会加锁。随着硬件指令集的发展，有了另一种选择。基于冲突检测的乐观并发策略，就是先进行操作，如果没有其他线程急用共享数据，那操作就成功。如果产生了冲突，再采取其他的补偿措施。这种乐观的并发策略不需要把线程挂起，因此称为非阻塞同步。</p>

<p>非阻塞同步需要了解CAS指令。它有3个操作数，分别是内存位置（V）、旧的预期值(A)和新值（B）。CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则它就不执行更新。但是无论是否更新了V的值，都会返回V的旧值，这是一个原子操作。</p>

<p>CAS指令看起来很美，但可能产生“ABA”问题。如果V初次读取时是A，并且在准备赋值时检查到它仍然是A，并不能说明它没有被其他线程修改过。因此在此过程中，它可能被改为B，然后再改为A。这时候CAS操作就误以为它从来没有被改变过。当然大部分情况下ABA问题不会影响程序的正确性。</p>

<h3>4.3 JDK的锁优化</h3>

<h4>4.3.1 自旋锁与自适应自旋</h4>

<p>互斥同步对性能最大的影响是阻塞的实现，因为线程挂起和恢复操作都要转入内核态中完成。很多应用中共享数据的锁定状态只会持续很短的时间，为了这个时间去挂起和恢复线程并不值得。因此不妨让后面的请求线程“稍等一下”，执行一个忙循环（自旋），这就是自旋锁。</p>

<p>自旋锁如果占用时间长了，就失去了自旋的意义，因此JDK6之前的自旋锁超过10次仍然没有成功获得锁，就会改用传统的方式去挂起线程。</p>

<p>JDK6引入了自适应的自旋锁，也就是自旋的时间不固定了，会根据前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。例如前几次成功了，就认为后面也会成功。如果自旋很少成功，以后就可能直接省略自旋，避免浪费资源。</p>

<h4>4.3.2 锁消除</h4>

<p>通常基于逃逸分析，如果堆上的数据不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁就无须进行。</p>

<h4>4.3.3 锁粗化</h4>

<p>大部分情况下，我们都要将同步代码块限制得尽量小。但是如果一系列的连续操作导致对同一个对象反复加锁、解锁，虚拟机会把加锁同步的范围扩大，只需要加一次锁就行了。</p>

<h4>4.3.4 轻量级锁</h4>

<p>轻量级锁的依据是：对于绝大部分锁，在整个同步周期内都是不存在竞争的。因此可以在没有多线程竞争的前提下，减少传统重量级锁使用操作系统互斥量产生的性能消耗。实现原理是在对象头（Object Header）的内存中加入锁标志位，利用CAS操作来实现。</p>

<h4>4.3.5 偏向锁</h4>

<p>如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM字节码执行引擎]]></title>
    <link href="http://blog.ubone.com/blog/2015/01/20/jvmzi-jie-ma-zhi-xing-yin-qing/"/>
    <updated>2015-01-20T06:40:46+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/01/20/jvmzi-jie-ma-zhi-xing-yin-qing</id>
    <content type="html"><![CDATA[<p>JVM执行引擎输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。本文从概念模型的角度学习栈帧结构、方法调用和字节码执行。</p>

<!--more-->


<h2>1. 运行时栈帧结构</h2>

<p>栈帧（Stack Frame）是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素，是支持虚拟机进行方法调用和方法执行的数据结构。每个方法从调用开始到执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p>

<p>每个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和额外的附加信息。在编译生成字节码时，栈帧中需要多大的局部变量表、多深的操作数栈就已经完全确定并保存在方法表的Code属性中。</p>

<p>一个线程中的方法调用链可能很长，很多方法同时处于执行状态。但对执行引擎来说，活动线程中，只有栈顶的栈帧才是有效的，称为当前栈帧。与当前栈帧相关联的方法称为当前方法。执行引擎运行的所有字节码指令都只针对当前栈帧操作。</p>

<p><img src="/myresource/images/image_blog_-2015-01-20_06.59.02.jpg" alt="image" /></p>

<h3>1.1 局部变量表</h3>

<p>局部变量表用于存放方法参数和方法内局部变量，其容量以Variable Slot为最小单位。每个Slot可以存放32位以内的数据类型，包括boolean、byte、char、short、int、float、reference和returnAddress，对于64位的数据类型long和double，会分配2个连续的Slot。由于虚拟机栈是线程的私有数据，因此操作2个Slot不会引起数据安全问题。</p>

<p>虚拟机通过索引定位的方式使用局部变量表，索引值从0到最大Slot数量。在方法执行时，局部变量表完成参数值到数量变量列表的传递过程。如果执行的是实例方法（非static），关键字"this"是隐含参数，位于第0个索引，其余参数按照参数表顺序排列。</p>

<p>为了节省栈帧空间，Slot是可以重用的，因为方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用。但这也会有一些副作用，示例如下：</p>

<p>```java
public static void main(String[] args) {</p>

<pre><code>{
    byte[] placeholder = new byte[64*1024*1024];//64MB
}

int a = 0; //!
System.gc();
</code></pre>

<p>}
```</p>

<p>上面的代码，如果没有<code>int a</code>那一行，从逻辑上讲应该能够回收placeholder的内存，但实际上并非如此。原因就是代码虽然已经离开了placeholder的作用域，但在此之后，没有任何对局部变量表的读写操作，placeholder占用的Slot还没有被其他变量复用，所以GC Roots一部分的局部变量表仍然保持对它的关联。因此加上<code>int a</code>那一行就能够正常回收了。</p>

<p>因此，如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用大量内存，实际上已经不再会使用的变量，手动将其设置为null以帮助内存回收也是有意义的。需要注意的是，在日常编程时，没必要过度依赖将变量设置为null，因为编译器优化和JIT编译都可能使赋null语句被优化掉。</p>

<p>此外，局部变量并没有类变量和实例变量那样存在“准备阶段”，因此不会自动赋予系统初始值。</p>

<h3>1.2 操作数栈</h3>

<p>操作数栈（Operand Stack）也常称为操作栈，它是后入先出（LIFO）栈。当一个方法开始执行时，它的操作数栈是空的。在方法执行过程中，会有各种字节码指令往操作数栈写入和提取内容。</p>

<p>在概念模型中，两个栈帧是完全独立的。但大多虚拟机实现都会做优化，让两个栈帧出现一部分重叠。让下面的栈帧的部分操作数栈与上面的栈帧的部分局部变量表重叠在一起，无须进行额外的参数复制。</p>

<h3>1.3 动态连接</h3>

<p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。</p>

<h3>1.4 方法返回地址</h3>

<p>当方法开始执行后，有两种方式退出。一是遇到方法返回的字节码指令；二是遇到异常并且这个异常没有在方法体内得到处理。无论哪种退出方式，方法退出之后都要返回到方法被调用的位置。一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是通过异常处理器表来确定的，栈帧中一般不会保存此信息。</p>

<p>方法退出的过程就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，修改PC计数器的值以指向后一条指令等。</p>

<h3>1.5 附加信息</h3>

<p>各虚拟实现时会增加一些规范中没有描述的信息放到栈帧中，例如与调试相关的信息。</p>

<h2>2. 方法调用</h2>

<p>方法调用并不是方法执行，此阶段的唯一任务是确定被调用方法的版本，即调用哪一个方法。</p>

<h3>2.1 解析（Resolution）</h3>

<p>所有方法调用中的目标方法在Class文件里都是一个常量池中的符号引用。在解析阶段，会将其中一部分符号引用转化为直接引用：如果方法在真正运行之前就有一个可确定的调用版本，并且这个调用版本在运行期是不可改变的，那么就会被转化为直接引用。</p>

<p>符合这个条件的有静态方法、私有方法、实例构造器和父类方法4类。这4类方法和final方法都称为非虚方法。非虚方法在编译期间就完成了解析调用，将符号引用转变为可确定的直接引用。</p>

<h3>2.2 分派（Dispatch）</h3>

<p>分派与解析相反，要在运行时确定调用哪个版本的方法。这是多态特性的体现。分派可能是静态或动态的，根据分派的依据又分为单分派和多分派。</p>

<h4>2.2.1 静态分派</h4>

<p>首先明确什么是静态类型和实际类型，看下面的代码：</p>

<p>```java
public class Human{&hellip;}
public class Man extends Human{&hellip;}
public class Woman extends Human{&hellip;}</p>

<p>public void sayHello(Human h) {print(&ldquo;human&rdquo;);}
public void sayHello(Man h) {print(&ldquo;man&rdquo;);}
public void sayHello(Woman h) {print(&ldquo;woman&rdquo;);}</p>

<p>public static void main(String[] args) {</p>

<pre><code>Human man = new Man();
syaHello(man); //会打印什么呢？
</code></pre>

<p>}
```</p>

<p>在main方法中，Human称为变量的Static类型或Apparent类型，而Man则为变量的实际类型。</p>

<p>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是方法重载(Overload)。虚拟机在重载时通过参数的静态类型而不是实际类型作为判定依据。并且静态类型是编译期可知的，因此在编译阶段，编译器会根据参数的静态类型决定使用哪个方法的重载版本。所以main方法中会打印human.</p>

<h4>2.2.2 动态分派</h4>

<p>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。典型应用是方法重写(Override)。</p>

<h4>2.2.3 单分派与多分派</h4>

<p>方法的接收者和方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以分为单分派和多分派。单分派根据一个宗量对目标方法进行选择，而多分派则根据多于一个宗量对目标方法进行选择。</p>

<p>根据上面的知识，可以得知：Java是一门静态多分派，动态单分派的语言。</p>

<h4>2.2.4 虚拟机动态分派的实现</h4>

<p>由于动态分派是非常频繁的动作，需要在运行时中确定，因此虚拟机的实现基于性能考虑，并不会进行频繁的搜索，而是采用虚方法表来提高性能。</p>

<p>虚方法表中存放了各个方法的实际入口。如果某个方法在子类中没有被重写，那么子类的虚方法表里面的地址入口与父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类重写了这个方法，则子类方法表中的地址将会替换为指向子类实现版本的入口地址。</p>

<p>方法表一般在类加载的连接阶段进行初始化，类的变量初始值后，会把该类的方法表也初始化。</p>

<h2>3. 基于栈的字节码解释执行引擎</h2>

<p>虚拟机执行Java代码时有解释执行和编译执行。先学习一下解释执行。</p>

<p>Java编译器输出的指令流，基本是一种基于栈的指令集架构（Instruction Set Architecture, ISA），指令流中的指令大部分是零地址指令，它们依赖操作数栈工作。相对应的，x86使用的是基于寄存器的指令集。</p>

<p>基于栈的指令集主要优点是可移植，但缺点是执行速度会稍慢一些，因为出栈入栈操作本身就产生了相当多的指令数量，而且栈实现是在内存中，比寄存器的速度慢了很多。</p>

<p>通过一段代码来学习基于栈的解释器执行过程。</p>

<p>```java
public int calc() {</p>

<pre><code>int a = 100;
int b = 200;
int c = 300;
return (a+b) *c;
</code></pre>

<p>}
```</p>

<p>对应的字节码：</p>

<p><code>
public int calc();
Code:
stack=2, Locals=4, Args_size=1
0: bipush 100       //将单字节的整数常量值(-128~`17)推入操作数栈
2: istore_1     //将操作数栈顶的整形值出栈并存放到第1个局部变量Slot中
3: sipush 200       //与0类似
6: istore_2
7: sipush 300       
10:istore_3
11:iload_1      //将局部变量表第1个Slot的整型值复制到操作数栈顶
12:iload_2      //将局部变量表第2个Slot的整型值复制到操作数栈顶
13:iadd     //将操作数栈中的头两个栈顶出栈，相加，再将结果入栈
14:iload_3      //把第3个Slot的300压入操作数栈
15:imul     //将操作数栈中头两个栈顶出栈，相乘，将结果入栈
16:ireturn      //结束方法执行，将操作数栈顶的整数返回
</code></p>

<p>上面的示例可以看出中间变量都以操作数栈的入栈和出栈为信息交换途径。以上执行过程只是概念模型，实际执行时虚拟机会做优化。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM监控与故障处理工具]]></title>
    <link href="http://blog.ubone.com/blog/2015/01/04/jvmjian-kong-yu-gu-zhang-chu-li-gong-ju/"/>
    <updated>2015-01-04T21:42:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/01/04/jvmjian-kong-yu-gu-zhang-chu-li-gong-ju</id>
    <content type="html"><![CDATA[<p>本文介绍常用的Java虚拟机性能监控与故障处理工具。</p>

<!--more-->


<h2>1. JDK命令行工具</h2>

<h3>1.1 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jps.html">jps</a></h3>

<p>与Unix下的ps命令相似，可以列出正在运行的虚拟机进程并显示主类（main()函数所在类）类名以及LVMID(Local Virtual Machine Identifier)。LVMID与PID是一致的。命令格式：</p>

<p><code>jps [options] [hostid]</code></p>

<table>
<thead>
<tr>
<th>选项 </th>
<th> 用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>-q </td>
<td> 只输出LVMID</td>
</tr>
<tr>
<td>-m </td>
<td> 输出JVM启动时传递给主类main()函数的参数</td>
</tr>
<tr>
<td>-l </td>
<td> 输出主类全名</td>
</tr>
<tr>
<td>-v </td>
<td> 输出JVM启动时的JVM参数</td>
</tr>
</tbody>
</table>


<h3>1.2 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html">jstat</a>，虚拟机统计信息监视工具</h3>

<p>在<a href="/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>中已经有描述。</p>

<h3>1.3 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jinfo.html">jinfo</a>, Java配置信息工具</h3>

<p>用于实时查看和调整虚拟机各项参数。</p>

<h3>1.4 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jmap.html">jmap</a>, Java内存映像工具</h3>

<p>在<a href="/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>中已经有描述。</p>

<h3>1.5 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jhat.html">jhat</a>， 堆转储快照分析工具</h3>

<p>用于分析堆转储快照，内置一个微型HTTP服务器，分析结果后可在浏览器中查看。但这个工具并不常用。</p>

<h3>1.6 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstack.html">jstack</a>, Java堆栈跟踪工具</h3>

<p>用于生成虚拟机当前时刻的线程快照（threaddump），即当前每一条线程正在执行的方法堆栈集合。主要目的是定位线程出现长时间停顿的原因，如死锁、死循环、请求外部资源等。</p>

<p>当线程出现停顿时，通过jstack查看各线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么。</p>

<table>
<thead>
<tr>
<th>选项 </th>
<th> 用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>-F </td>
<td> 当正常输出的请求不被响应时，强制输出线程堆栈</td>
</tr>
<tr>
<td>-l </td>
<td> 除堆栈外，显示关于锁的附加信息</td>
</tr>
<tr>
<td>-m </td>
<td> 如果调用本地方法的话，显示C/C++堆栈</td>
</tr>
</tbody>
</table>


<h2>2. JDK的可视化工具</h2>

<h3>2.1 JConsole</h3>

<p>基于JMX的可视化监视、管理工具。直接通过集令后运行jconsol。</p>

<h3>2.2 <a href="http://visualvm.java.net/">VisualVM</a>，多合一故障处理工具</h3>

<p>VisualVM Is Designed For You:</p>

<ul>
<li><strong>Application Developer</strong>: Monitor, profile, take thread dumps, browse heap dumps</li>
<li><strong>System Administrator</strong>: Monitor and control Java applications across the entire network</li>
<li><strong>Java Application User</strong>: Create bug reports containing all the necessary information</li>
</ul>


<p>在命令行执行<code>jvisualvm</code>即可</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java垃圾收集与内存分配]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/26/la-ji-shou-ji-qi-yu-nei-cun-fen-pei-ce-lue/"/>
    <updated>2014-12-26T20:20:12+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/26/la-ji-shou-ji-qi-yu-nei-cun-fen-pei-ce-lue</id>
    <content type="html"><![CDATA[<p>在<a href="/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>中，了解了Java的内存管理和垃圾收集。本文再深入学习垃圾收集算法和HotSpot中垃圾收集的实现。</p>

<!--more-->


<h2>1. 什么是垃圾</h2>

<p>Java并没有使用引用计数法来识别对象是否为垃圾，而是采用可达性分析（Reachability Analysis）判断对象是否存活。其基本思路就是通过GC Roots对象为起点，搜索其引用链，只要是通过它们可达的对象就是活对象。GC Roots对象包括以下几种：</p>

<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI(即Native方法)引用的对象</li>
</ul>


<p>而Java的引用又分为多种类型，对象是否存活也与引用类型有关：</p>

<ul>
<li>强引用：普通引用都是强引用，只要强引用还存在，对象就不会被回收。</li>
<li>软引用：SoftReference关联的对象是还有用，但不是必须的对象。在系统将要发生内存溢出异常之前，会把这些对象列入回收范围进行第二次回收。</li>
<li>弱引用：WeakReference与SoftReference更弱，它关联的对象只能生成到下一次垃圾收集发生之前（无论内存是否足够，都会被回收）。</li>
<li>虚引用：PhantomReference是最弱的一种引用，对生存时间完全没有影响，也无法通过虚引用来取得一个对象实例。其唯一目的就是在回收时收到一个系统通知。</li>
</ul>


<p>真正宣告一个对象的死亡，要经历至少两次标记过程。当扫描发现对象与GC Roots没有引用链，将进行第一次标记，并判断对象是否有必要执行finalize()方法（如果对象没有覆盖该方法，或者方法已经被调用过，视为没有必要执行）。如果有必要执行finalize()方法，虚拟机将该对象放入F-Queue队列，稍后自动由低优先级的Finalizer线程执行该方法。之后GC还会对F-Queue中的对象进行第二次标记，如果对象在finalize()方法中重新建立了一个有效引用，就会被移除出“即将回收”的集合，逃脱回收。</p>

<p>但注意finalize()方法是没有保障的，JVM只会触发它执行，并不保证它会运行结束。试想如果finalize()方法中有死循环，会造成整个内存回收系统崩溃。所以正如<a href="/blog/2014/06/27/effective-java-chuang-jian-he-xiao-hui-dui-xiang/">Effective Java-创建和销毁对象</a>中提到的，你就当Java没有finalize()方法吧!</p>

<p>方法区（通常所指的永久代）也是<strong>可以（非必须）</strong>垃圾收集的。主要回收废弃常量和无用的类。对于常量，例如“abc”已经进入常量池，但当前没有任何一个String对象是“abc”，那么这个常量可能会被清理出去。如何判断无用的类则要苛刻许多，需要同时满足以下条件：</p>

<ul>
<li>该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例。</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>


<p>方法区的对象仅仅是可以回收，并不是必然会回收。在大量使用反射、动态代理、CGLib等字节码框架、动态JSP和OSGi这类频繁自定义ClassLoader场景下，虚拟机需要具备类卸载的功能。</p>

<p>HotSpot提供了参数<code>-Xnoclassgc</code>参数控制方法区回收。在Product版JVM中还可以使用<code>-verbose:class</code>和<code>-XX:+TraceClassLoading</code>查看类加载信息。FastDebug版的JVM还支持<code>-XX:+TraceClassUnLoading</code>查看卸载信息。</p>

<h2>2. 垃圾收集算法</h2>

<p>各平台的虚拟机操作内存的方法各不相同，常见的垃圾收集算法说明如下：</p>

<h3>2.1 常见的垃圾收集算法</h3>

<h4>标记-清除算法(Mark-Sweep)</h4>

<p>这是最基础的收集算法，分为标记和清除两个阶段。首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。它有两个主要问题：一是效率不高，另一个是空间问题，会产生大量不连续的内存碎片。</p>

<h4>复制算法(Copying)</h4>

<p>复制算法的思路是将内存分为大小相等的两块，每次只使用其中一块，永远有一块是空的。当一块用完了，就将存活对象复制到另一块上，把前者内存空间一次清理掉。</p>

<p>复制算法特别适合那些短命的对象，现代虚拟机都采用这个算法来回收新生代。将内存分为较大的Eden区和两个较小的Survivor，每次使用Eden和其中一个Survivor。回收时，将Eden和Survivor存活的对象复制到另一个Survivor，最后清理掉Eden和前一个Survivor空间。HotSpot默认的Eden和Survivor比例是8：1. 如果另一个Survivor空间不足以放下存活对象，那些经历多少GC仍存活的对象会被放入老年代。</p>

<h4>标记-整理算法（Mark-Compact）</h4>

<p>对于长命的对象，复制算法的效率就变得太低。标记-整理算法就适合老年代。其思路是标记后，将活对象向一端移动，然后清理掉边界以外的内存。</p>

<h4>分代收集算法(Generational Collection)</h4>

<p>这个算法没有特殊之处，就是将堆分为新生代和老年代，然后根据各年代的特点选择最适当的算法。在新生代使用复制算法，在老年代使用“标记-清理”或者“标记-整理”算法。</p>

<h3>2.2 HotSpot的算法实现</h3>

<p>结合前面的垃圾收集算法，看看HotSpot是如何实现的。</p>

<h4>2.2.1 枚举GC Roots</h4>

<p>前面说到GC Roots主要是在全局性的引用和执行上下文（如栈帧中的本地变量表）中，但HotSpot并不需要逐个检查这里面的引用，因为这样的效率太低了。</p>

<p>HotSpot使用一组称为OopMap的数据结构，在类加载完成时，就把对象内各偏移量上是什么类型的数据计算出来了，因此GC扫描时，可以直接得到这些信息，并准确判断堆上的数据是否还可能被使用。</p>

<h4>2.2.2 安全点</h4>

<p>当GC时，线程会停在安全点，常见的安全点包括方法调用、循环跳转、异常跳转等。如何让线程停在安全点，有两种方案：抢先式中断和主动式中断。抢先式指中断所有线程，如果发现某个线程不在安全点，则恢复线程让它跑到安全点。但几乎所有虚拟机都没有采用这个方法。</p>

<p>主动式中断的思路是GC需要中断线程时，设置一个标志，各线程执行时会在安全点和创建对象需要分配内存的地方轮询这个标志，如果为真就把自己挂起。</p>

<p>对于那些处于Sleep或Blocked状态的线程，无法跑到安全点，则需要安全区域来解决。安全区域中任何地方GC都是安全的。当线程执行到安全区域中的代码时，先标识自己已经进入安全区，这时GC就不管这些线程了。当线程要离开安全区时，它要检查系统是否已经完成了根节点枚举或GC过程，如果完成则继续执行，否则继续等待直到收到可安全离开的信号。</p>

<h4>2.2.3 垃圾收集器</h4>

<p><a href="https://blogs.oracle.com/jonthecollector/entry/our_collectors">下图</a>展示了HotSpot用于不同年代的7种收集器，如果两个收集器间有连线，说明它们可以搭配使用。</p>

<p><img src="/myresource/images/image_blog_2014-12-26-Collectors.jpg" alt="image" /></p>

<h5>Serial收集器</h5>

<p>这是一个单线程的收集器，工作于年轻代，使用复制算法。当它工作时，会把所有用户线程全部停下来。它现在仍然是Client模式下的默认收集器。它比其他收集器简单但高效，没有了线程交互的开销。桌面应用由于分配的内存相对较少，收集时停顿时间可控制在几十到一百多毫秒，对桌面应用是可以接受的。</p>

<h5>ParNew收集器</h5>

<p>它其实就是Serial收集器的多线程版本，对于单核CPU的环境下，绝对不会比Serial更好。但它适合于在服务端模式时与CMS配合(CMS用于老年代，ParNew用于年轻代)。</p>

<h5>Parallel Scavenge收集器</h5>

<p>这是一个年轻代的收集器，使用复制算法，是并行的多线程收集器。</p>

<ul>
<li>并行(Parallel):指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li>并发(Concurrent): 指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行）。</li>
</ul>


<p>Parallel Scavenge收集器与其它收集器不同，它的目标是达到一个可控制的吞吐量，即CPU用于运行用户代码的时间与CPU总消耗时间的比值。因此适合于不需要太多交互，主要是后台运算的场景。</p>

<h5>Serial Old收集器</h5>

<p>这是Serial收集器的老年代版本，同样是单线程收集器，使用“标记-整理”算法。其主要意义也是Client模式的虚拟机中使用。如果在Server模式下，主要是在JDK1.5及之前的版本中与Parallel Scavenge搭配使用，以及作为CMS的后备预案。</p>

<h5>Parallel Old收集器</h5>

<p>这是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。从JDK1.6开始提供，主要用于与Parallel Scavenge搭配使用，作为“吞吐量优先”的组合。</p>

<h5>CMS收集器(Concurrent Mark Sweep)</h5>

<p>这是一种以获取最短回收停顿时间为目标的收集器。也是基于“标记-清除”算法实现，整个过程分为4步：</p>

<ol>
<li>初始标记：标记GC Roots能直接关联到的对象，时间很快。</li>
<li>并发标记：进行GC Roots Tracing，时间很长。</li>
<li>重新标记：修正并发标记期间因用户程序继续运行而导致标记发生变化的那一部分对象的标记记录，比第一步稍长。</li>
<li>并发清除</li>
</ol>


<p>第1、3步需要Stop the World，而耗时最长的第2、4步可以与用户线程一起工作。</p>

<p>CMS是非常优秀的垃圾收集器，是Java 5推荐的高性能收集器，在Java 6仍保持了旺盛的生命力。但它的主要缺点是：</p>

<ol>
<li>对CPU资源非常敏感。在并发标记阶段，虽然用户程序不用停顿，但CMS占用了一部分CPU资源而导致应用变慢，总吞吐量降低。</li>
<li>无法处理浮动垃圾，可能出现“Concurrent Mode Failure”，导致另一次Full GC。浮动垃圾就是在并发清除阶段，用户线程还在运行并产生新的垃圾。CMS需要预留一部分内存空间给用户线程使用。如果预留的空间无法满足程序需要，就会出现“Concurrent Mode Failure”，导致JVM临时启用Serial Old收集器来重新进行老年代收集，停顿时间就很长了。</li>
<li>由于使用“标记-清除”算法，因此会有碎片产生，有时不得不提前触发一次Full GC。</li>
</ol>


<h5>G1收集器</h5>

<p>这是面向服务端应用的垃圾收集器，可用于替换CMS。具备如下特点：</p>

<ol>
<li>并行与并发：充分利用多CPU、多核优势，缩短Stop the world时间。</li>
<li>分代收集：仍保留分代概念，可以独立管理整个GC堆。</li>
<li>空间整合：G1整体上是基于“标记-清除”，但从局部看是基于“复制”算法，不会产生内存碎片。</li>
<li>可预测的停顿：G1能建立可预测的停顿时间模型，可指定一个长度为M毫秒的时间片段，G1分将停顿时间尽量控制在该时间范围内。</li>
</ol>


<p>G1将整个堆划分为多个大小相等的独立区域（Region），虽然保留分代概念，但新生代和老年代不是物理隔离的，它们是一部分Region的集合（不需要连续）。</p>

<p>它的实现方式是跟踪每个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及所需时间的经验值），维护一个优先列表，每次根据停顿目标值，回收价值最大的Region。保证在有限的时间内获得尽可能高的收集效率。</p>

<p>每个Region都有一个对应的Remembered Set，用于记录跨Region的引用。因此进行内存回收时，只需要在GC Roots枚举范围内加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p>
]]></content>
  </entry>
  
</feed>
