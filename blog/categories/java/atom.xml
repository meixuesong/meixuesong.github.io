<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2014-09-02T23:17:42+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java并发编程（二）]]></title>
    <link href="http://blog.ubone.com/blog/2014/09/02/javabing-fa-er/"/>
    <updated>2014-09-02T21:03:49+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/09/02/javabing-fa-er</id>
    <content type="html"><![CDATA[<p>本文是《Java编程思想》第21章并发的读书笔记。<a href="/blog/2014/08/30/javabing-fa-bian-cheng/">Java并发编程（一）</a></p>

<!--more-->


<h2>3. 终结任务</h2>

<h3>3.1 阻塞</h3>

<p>一个任务进入阻塞状态，可能有如下原因：</p>

<ol>
<li>调用sleep(milliseconds)</li>
<li>调用wait()挂起线程，直到线程得到了notify()或notifyAll()（Java5中的signal或signalAll）</li>
<li>等待某个输入/输出完成</li>
<li>试图在某个对象上调用同步控制方法，但对象锁不可用。</li>
</ol>


<p>早期代码中还有suspend()和resume()来阻塞和唤醒线程，但现在已经被废止了（可能导致死锁），还有stop()也已经废止了（因为不释放线程获得的锁）。</p>

<h3>3.2 中断</h3>

<p>有几种方法中断线程。</p>

<p>一是声明一个变量canceled，然后正常的run方法中循环检查它的值，从而决定是否跳出循环，退出run方法。</p>

<p>二是调用Thread类的interrupt()方法，该方法提供了离开run()循环而不抛出异常的第二种方式。这种方式必须持有Thread对象。</p>

<p>如果调用Executor的shutdownNow()，那么它将发送一个interrupt()调用给它启动的所有线程。如果想只中断某一个线程，可以使用Future的cancel方法。下面是各种中断的示例：</p>

<h4>中断Sleep Runnable</h4>

<p>```java
public class ThreadInterrupt {</p>

<pre><code>public static void main(String[] args) {
    ExecutorService exec = Executors.newCachedThreadPool();
    Future f = exec.submit(new SleepInterruptThread());
    try {
        TimeUnit.SECONDS.sleep(1);
        f.cancel(true);

    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println("退出主程序");
}
</code></pre>

<p>}</p>

<p>public class SleepInterrupt implements Runnable {</p>

<pre><code>@Override
public void run() {
    try {
        TimeUnit.SECONDS.sleep(10);
        System.out.println("end sleep 10s");
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    System.out.println("exit SleepInterrupt run");
}
</code></pre>

<p>}
```</p>

<p>上面的代码可以正常中断Sleep线程，捕获了InterruptedException异常。</p>

<h4>中断Sleep Thread</h4>

<p>```java
public class ThreadInterrupt {</p>

<pre><code>public static void main(String[] args) {
    Thread f = new SleepInterruptThread();
    f.start();
    try {
        TimeUnit.SECONDS.sleep(1);
        f.interrupt();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println("退出主程序");
}
</code></pre>

<p>}</p>

<p>public class SleepInterruptThread extends Thread {</p>

<pre><code>@Override
public void run() {
    try {
        TimeUnit.SECONDS.sleep(5);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    System.out.println("exit SleepInterrupt run");
}
</code></pre>

<p>}</p>

<p>```</p>

<p>上面的代码可以正常中断Sleep线程，捕获了InterruptedException异常。</p>

<h4>中断IO线程</h4>

<p>```java
public class ThreadInterrupt {</p>

<pre><code>public static void main(String[] args) {
    ExecutorService exec = Executors.newCachedThreadPool();
    Future f = exec.submit(new IOInterrupt(System.in));
    try {
        TimeUnit.SECONDS.sleep(1);
        f.cancel(true);

    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println("退出主程序");
}
</code></pre>

<p>}</p>

<p>public class IOInterrupt implements Runnable {</p>

<pre><code>private InputStream in;

public IOInterrupt(InputStream is) {
    in = is;
}

@Override
public void run() {
    try {
        in.read();
    } catch (IOException e) {
        e.printStackTrace();
    }

    System.out.println("exit run");
}
</code></pre>

<p>}</p>

<p>```
<strong>对于IO阻塞线程，则无法进行中断！从catch语句中没有InterruptedException也可以看出。</strong>同样无法中断的还有SynchronizedBlocked，也就是如果线程进入synchronized方法或临界区中后，将无法中断。</p>

<p>对于网络访问这样的IO阻塞，如果不能中断有时挺烦人的。一个较笨的办法是关闭底层资源（例如关闭连接。）示例如下：</p>

<p><code>java
InputStream socketInput = new Socket("localhost", 8080).getInputStream();
exec.execute(new IOBlocked(socketInput));
//...
exec.shutdownNow(); //无法中断线程
//...
socketInput.close(); //关闭后，解除阻塞。
</code></p>

<p><strong>Java提供的各种nio类具有更人性化的I/O中断，被阻塞的nio通道会自动地响应中断。</strong></p>

<p><strong>synchronized方法或临界区上的阻塞，存在锁住程序的可能。而ReentrantLock上的阻塞则具备被中断的能力。</strong>例如当线程1 lock后，线程2也请求lock，在等待的过程中将产生阻塞，调用Thread.interrupt或Future.cancel可以将其中断。</p>

<h3>3.3 检查中断</h3>

<p>当你在线程上调用interrupt()时，如何保证安全地退出run方法，释放该释放的资源？</p>

<p>如果类必须响应interrupt()，那么就必须建立一种策略。当创建了需要清理的对象后，就必须紧跟try-finally子句，使得无论run()循环如何退出，都能正常清理。</p>

<h2>4. 线程之间的协作</h2>

<h3>4.1 wait()与notifyAll()</h3>

<p>调用sleep()和yield()时，锁并没有被释放。而调用wait()时，线程的执行被挂起，对象上的锁被释放。wait()表示无限期等待下去，直到notify或notifyAll，它也可以传入参数表示时间到期后恢复。当wait恢复时，会首先重新获取进入wait时释放的锁，在这个锁变为可用之前，是不会被唤醒的。</p>

<p><strong>只能在同步控制方法或者同步控制块里调用wait(), notify()和notifyAll()！</strong>否则虽然能够编译通过，但运行时将报异常：IllegalMonitorStateException。为什么要这样设计？<a href="http://javarevisited.blogspot.sg/2011/05/wait-notify-and-notifyall-in-java.html">这篇博客</a>作了解释。如果不这样做，就没有锁，就可能导致下一节中的“错失的信号”。</p>

<p>当从wait唤醒时，往往需要判断特定条件是否满足，如果不满足就返回到wait中，惯用的方法就是使用while来编写这种代码。下例是一个汽车打蜡抛光的示例，其它两个线程未列出。</p>

<p>```java
class Car {
private boolean waxOn = false;
public synchronized void waxed() {
waxOn = true;
notifyAll();
}
public synchronized void buffed() {
waxOn = false;
notifyAll();
}
public synchronized void waitForWaxing() throws InterruptedException {
while (waxOn == false) {
wait();
}
}
public synchronized void waitForBuffing() throws InterruptedException {
while (waxOn == true) {
wait();
}
}
}</p>

<p>```</p>

<h4>错失的信号</h4>

<p>当两个线程协作时，要特别注意可能会错过某个信号，例如下例T1通知T2，但是有可能T2收不到这个信号：</p>

<p>```java
T1:
synchronized(shareMonitor) {</p>

<pre><code> //&lt;setup condition for T2&gt;
 shareMonitor.notify();
</code></pre>

<p>}</p>

<p>T2:
while(someCondition) {</p>

<pre><code> //Point 1
 synchronized(shareMonitor) {
      shareMonitor.wait();
 }
</code></pre>

<p>}
```</p>

<p>以上代码运行到Point1时，如果调度到了T1，则T2收不到通知，就会永远在那里等待。T2正确的做法是：</p>

<p>```java
synchronized(shareMonitor) {</p>

<pre><code> while(someCondition) {
      shareMonitor.wait();
 }
</code></pre>

<p>}
```</p>

<h3>4.2 notify()与notifyAll()</h3>

<p>两者的不同之处在于，前者只唤醒一个线程，而后者唤醒同一锁定的所有线程。当有多个等待线程时，notify唤醒哪一个线程由调度决定。notifyAll唤醒多个线程后，它们将先为锁而战，先取得锁的线程先执行。</p>

<p>什么情况下使用notify或者notifyAll？在多个等待的线程中，如果它们都在等同一个条件，并且当条件变为真时，只有一个线程从中受益，那么用notify比notifyAll更好，因为它避免浪费CPU循环。 notify()只唤醒其中一个。因此当你使用notify时要确保只唤醒正确的那个。</p>

<p>notifyAll并不是唤醒所有等待线程，而是等待某个特定锁的所有线程。</p>

<h3>4.3 生产者和消费者</h3>

<p>除了wait()、notify()和notifyAll()方法用于同步方法或者同步代码块外，也可以使用Lock、Condition、await()、signal()和signalAll()方法。示例如下：</p>

<p>```java
class Car {</p>

<pre><code>private Lock lock = new ReentrantLock();
private Condition condition = lock.newCondition();
private boolean waxOn = false;
public void waxed() {
    lock.lock();
    try {
        waxOn = true;
        condition.signalAll();
    } finally {
        lock.unlock();
    }
}

public void waitForWaxing() throws InterruptedException {
    lock.lock();
    try {
        while (waxOn == false) 
            condition.await();
    } finally {
        lock.unlock();
    }
}

//...
</code></pre>

<p>}
```</p>

<p>注意，每个lock()的调用都必须紧跟一个try-finally子句，以保证所有情况都可以释放锁。在await()、signal()或signalAll()之前，必须拥有这个锁。</p>

<p>使用wait()和notifyAll()这样的方法来解决任务互操作的问题比较复杂。在典型的生产者-消费者实现中，常使用先进先出队列来存储被生产和消费的对象。BlockingQueue接口提供了这样的同步队列，该接口有多种实现，常见的是LinkedBlockingQueue和ArrayBlockingQueue(固定尺寸)。</p>

<p>如果消费者试图从队列中获取对象，而此时该队列为空，那么消费者将挂起，直到队列中有可消费的内容。阻塞队列可以解决很多问题，比wait()和notifyAll()相比，要简单得多，也更加可靠。示例如下：</p>

<p>```java
class LiftOffRunner implements Runnable {</p>

<pre><code>private BlockingQueue&lt;LiftOff&gt; rockets;
public LiftOffRunner(BlockingQueue&lt;LiftOff&gt; queue) {
    rockets = queue;
}

public void add(LiftOff lo) {
    try {
        rockets.put(lo);
    } catch(InterruptedException e) {
        print("Interrupted during put");
    }
}

public void run() {
    try {
        while(! Thread.interrupted)) {
            LiftOff rocket = rockets.take(); //阻塞直至rockets中有东西
            rocket.run();
        }
    } catch(InterruptedException e) {
        print("Exiting LiftOffRunner");
    }
}
</code></pre>

<p>}</p>

<p>//其它线程可以往rockets中添加内容，无需同步方法或者锁。
```</p>

<h3>4.4 任务间使用管道进行输入/输出</h3>

<p>通过输入/输出在线程间进行通信也很有用。这种管道在Java IO库中的对应物就是PipedWriter类和PipedReader类。这也是“生产者-消费者”的变体。示例如下：</p>

<p>```java
class Sender implements Runnable {</p>

<pre><code>private PipedWriter out = new PipedWriter();
public PipedWriter getWriter() { return out;}
public void run() {
    try {
        while (true) {
            for(char c = 'A'; c &lt;= 'z'; c++) {
                out.write(c);
                TimeUnit.MILLISECONDS.sleep(rand.nextInt(500));
            }
        }
    } catch(IOException e) {
        //...
    } catch(InterruptedException e ) {
        //...
    }
}
</code></pre>

<p>}</p>

<p>class Receiver implements Runnable {</p>

<pre><code>private PipedReader in;
public Receiver(Sender sender) {
    in = new PipedReader(sender.getWriter());
}

public void run() {
    try {
        while (true) {
            print("read: " + (char) in.read());
        }
    } catch (IOException e) {
        //...
    }
}
</code></pre>

<p>}</p>

<p>//与普通I/O不能interrupt不同，PipedReader是可以中断的。</p>

<p>```</p>

<p>相比之下，BlockingQueue使用起来更加健壮而容易。</p>

<h2>5. 死锁</h2>

<p>当以下四个条件同时满足时，就会发生死锁：</p>

<ol>
<li>互斥条件。任务使用的资源中至少有一个是不能共享的。</li>
<li>至少有一个任务必须持有一个资源且正在等待获取一个当前被别的任务持有的资源。</li>
<li>资源不能被任务抢占，任务必须把资源释放当作普通事件。</li>
<li>必须有循环等待。A等待B持有的资源，B又等待C持有的资源，这样一直下去之后，直到X在等待A所持有的资源。</li>
</ol>


<p>要防止死锁，只需破坏上述四条中的任意一条。破坏第4条是最容易的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java并发编程（一）]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/30/javabing-fa-bian-cheng/"/>
    <updated>2014-08-30T21:58:15+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/30/javabing-fa-bian-cheng</id>
    <content type="html"><![CDATA[<p>本文是《Java编程思想》第21章并发的读书笔记。</p>

<!--more-->


<p>操作系统：抢占式（调度机制会周期性地中断线程，将上下文切换到另一个线程）、协作式（每个任务自己放弃控制）。</p>

<h2>1. 基本线程机制</h2>

<h3>1.1 定义任务</h3>

<p>```java
public class LiftOff implements Runnable {</p>

<pre><code> public void run() {
      //...
      Thread.yield(); //声明，我已经干完重要的事，可以把CPU让给其他任务了。
 }
</code></pre>

<p>}
```</p>

<h3>1.2 Thread类</h3>

<p><code>java
Thread t = new Thread(new LiftOff());
t.start();
</code></p>

<h3>1.3 使用Executor</h3>

<p>```java
ExecutorService exec = Executors.newCachedThreadPool(); //or newFixedThreadPool, newSingleThreadExecutor
exec.execute(new LiftOff());</p>

<p>exec.shutdown(); //防止加入新任务。
```</p>

<h3>1.4 从任务中产生返回值</h3>

<p>Runnable不返回任何值，Callable接口可以返回值。两者的区别只是后者的方法是call()而不是run()。</p>

<p>```java
class TaskWithResult implements Callable<String> {</p>

<pre><code> public String call() {
      return "result";
 }
</code></pre>

<p>}</p>

<p>ExecutorService exec = Executors.newSingleThreadExecutor();
Future<String> future = exec.submit(new TaskWithResult());
String result = future.get(); //get方法会一直等线程结束后返回结果。isDone()查询Future是否已经完成。
```</p>

<h3>1.5 休眠</h3>

<p>```java
public class SleepingTask extends LiftOff {</p>

<pre><code> public void run() {
      try {
           while(countDown-- &gt; 0) {
                //...
                TimeUnit.MILLISECONDS.sleep(100);
           }
      } catch(InterruptedException e) {
           //...
      }
 }
</code></pre>

<p>}
```</p>

<h3>1.6 优先级</h3>

<p>```java</p>

<pre><code> public void run() {
      Thread.currentThread().setPriority(Thread.MAX_PRIORITY);
 }
</code></pre>

<p>```</p>

<p>Windows有7个优先级， Solaris有2<sup>31</sup>个优先级。各操作系统不一致，因此建议只使用三个优先级：Thread.MAX_PRIORITY, NORM_PRIORITY, MIN_PRIORITY。</p>

<h3>1.7 后台线程</h3>

<p>后台线程指程序运行时在后台提供通用服务的线程，并且不属性程序中不可或缺的部分。<strong>当所有非后台线程结束时，程序就终止了，同时会杀死所有后台线程。</strong>如果有非后台线程还在运行，则程序不会终止。</p>

<p>要设置为后台线程，必须在线程启动之前调用setDaemon()方法。</p>

<p>```java</p>

<pre><code> Thread daemon = new Thread(new LiftOff() );
 daemon.setDaemon(true); //必须在start()方法前调用
 daemon.start(); 
</code></pre>

<p>```</p>

<p>可以通过定制的ThreadFactory创建后台线程，例如：</p>

<p>```java
public class DaemonThreadFactory implements ThreadFactory {</p>

<pre><code> public Thread newThread(Runnable r) {
      Thread t = new Thread(r);
      t.setDaemon(true);
      //还可以设置优先级、名称等，这些将成为新线程的默认值。

      return t;
 }
</code></pre>

<p>}</p>

<p>ExecutorService exec = Executors.newCachedThreadPool(new DaemonThreadFactory()); //这个Factory将用于创建新的线程。
exec.execute(new LiftOff());
```</p>

<p><code>isDaemon()</code>方法用于判断是否后台线程。后台线程创建的任何线程都将自动设置为后台线程。</p>

<p>注意！对于后台线程，在不会执行<code>finally</code>子句的情况下就会终止其<code>run()</code>方法：</p>

<p>```java
class ADaemon implements Runnable {</p>

<pre><code>public void run() {
    try {
        //...
        TimeUnit.SECONDS.sleep(1);
    } catch(InterruptedException e) {
        //...
        //注意，此时已经是false, 因为异常被捕获时将清理这个标志
        print("isInterrupted(): " + isInterrupted()); 
    } finally {
        print("会运行到这吗？")
    }
}
</code></pre>

<p>}</p>

<p>public class DaemonsDontRunFinally {</p>

<pre><code>public static void main(String[] args) {
    Thread t = new Thread(new ADaemon());
    t.setDaemon(true);
    t.start();
}
</code></pre>

<p>}
```</p>

<p>一旦<code>setDaemon(true)</code>，finally并没有被执行。因为一旦main结束，所有后台线程就立即终止了。</p>

<h3>1.8 编码的变体</h3>

<p>除了实现Runnable，也可以直接继承Thread类。但是由于Java不支持多重继承，所以继承自Thread适应的场景要少一些。</p>

<p>```java
private class SampleThread extends Thread{</p>

<pre><code>public SampleThread() {
    super("线程名称");  //线程名称可通过getName()获取。
}

public void run() {
    //...
}
</code></pre>

<p>}
```</p>

<p>自管理的Runnable</p>

<p>```java
public class SelfManaged implements Runnable {</p>

<pre><code>private Thread t = new Thread(this);
public SelfManaged() {
    t.start();  //注，不建议在构造器中启动线程，可能会有问题，建议使用Executor
}

public void run() {
    //...
}

public static void main(String[] args) {
    new SelfManaged();
}
</code></pre>

<p>}
```</p>

<h3>1.9 加入一个线程</h3>

<p>某个线程在另一个线程t上调用<code>t.join()</code>方法，此线程被挂起，直到t线程结束（即<code>t.isActive() == false</code>）。join方法也可以加超时参数，表示如果时间到期还未结束的话，join()方法总能返回。</p>

<h3>1.10 捕获异常</h3>

<p>线程中的未捕获的异常会导致系统不稳定，但常规方法并不能在外面捕获这些异常，因此需要借助特殊处理。下面的例子创建了一个新类型的ThreadFactory，它将在每个新创建的Thread对象上附着一个Thread.UncaughtExceptionHandler。</p>

<p>```java
class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {</p>

<pre><code>@Override
public void uncaughtException(Thread t, Throwable e) {
    // TODO Auto-generated method stub
}
</code></pre>

<p>}</p>

<p>class HandlerThreadFactory implements ThreadFactory {</p>

<pre><code>@Override
public Thread newThread(Runnable r) {
    Thread t = new Thread(r);
    t.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());

    return t;
}
</code></pre>

<p>}</p>

<p>ExecutorService exec = Executors.newCachedThreadPool(new HandlerThreadFactory());
exec.execute(new SomeThread());
```</p>

<p>如果你知道将要在代码中处处使用相同的异常处理器，那么更简单的方式是在Thread类中设置一个表态域，示例如下：</p>

<p><code>
Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandler());
</code></p>

<h2>2. 共享受限资源</h2>

<h3>2.1  解决共享资源竞争</h3>

<p>Java提供了关键字synchronized，为防止资源冲突提供支持。如果某个线程处于一个对synchronized方法的调用中，那么这个线程在从该方法返回之前，其它所有调用类中任何synchronized方法的线程都会被阻塞。也就是说，对于某个特定对象来说，其所有synchronized方法共享同一个锁。</p>

<p>线程可以多次获得对象的锁，例如先调用synchronized方法获得锁后，又调用该类的其它方法获得锁。JVM会跟踪对象加锁的计数，每次调用加1，离开synchronized方法时减1。当计数变为0则锁被完全释放。</p>

<p>synchronized static方法可以在类的范围内防止对static数据的并发访问。</p>

<p>如果你正在写一个变量，它可能接下来被另一个线程读取，或者在读取一个上一次已经被另一个线程写过的变量，那么你必须使用同步，并且，读写线程都必须用相同的监视器锁同步。</p>

<p>Lock对象也用于解决共享资源竞争。它必须被显式地创建、锁定和释放。</p>

<p>```java
public class MutexEvenGenerator extends IntGenerator {</p>

<pre><code>private Lock lock = new ReentrantLock();
public int next() {
    lock.lock();
    try {
        //...

        //注意！必须在try中返回值，以避免lock.unlock之后将数据暴露给其它线程。
        return someValue; 
    } finally {
        lock.unlock();
    }

    //不要在这里返回值
}
</code></pre>

<p>}
```</p>

<p>Lock提供了更细粒度的控制能力。使用Lock，可以更加自由地控制锁。例如尝试获得锁，如果获取不到，可以先干点别的事：</p>

<p>```java
boolean captured = lock.tryLock();</p>

<p>//设置超时时间，超时则触发异常。
try {</p>

<pre><code>boolean captured = lock.tryLock(2, TimeUnit.SECONDS);
</code></pre>

<p>} catch(InterruptedException e) {
}</p>

<p>```</p>

<h3>2.2 原子性和易变性</h3>

<p>原子性可用于除long、double之外的所有基本类型上的“简单操作”（读取和写入）。可以保证它们会被当作不可分（原子）的操作来操作内存。但JVM在读取和写入64位（long和double变量）时，可以拆成两个32位操作。因此可能导致“字撕裂”。作为普通开发者，<strong>不要依赖原子操作而移除了同步，那会得不偿失。</strong></p>

<p>关键字<code>volatile</code>可以帮助获得原子性。<code>volatile</code>还确保了数据的可视性。当一个域声明为<code>volatile</code>时，那么只要对它进行了写操作，即使使用了本地缓存，其它读操作也可以看到这个修改。因为<code>volatile</code>域会被立即写入主内存中，而读取操作就发生在主存中。</p>

<p>非<code>volatile</code>域上的原子操作不必刷新到主存，因此其它任务读取该域时可能看不到新值（修改操作的任务可以看到新值）。如果多个任务(线程)在同时访问某个域，那么这个域就应该是<code>volatile</code>的，否则这个域就应该经由同步来访问。同步也会导致向主存刷新。</p>

<h3>2.3 原子类</h3>

<p>Java引入了AtomicInteger, AtomicLong, AtomicReference等特殊的原子性变量类，它们提供机器级别上的原子性。常规编程很少派上用场，但在涉及性能调优时，会有用武之地。</p>

<p>需要强调的是，Atomic类被设计用来构建java.util.concurrent中的类，因此只有在特殊情况下才在自己的代码中使用它们。通常依赖于锁（Lock, synchronized）更安全一些。</p>

<h3>2.4 临界区(Critical section)</h3>

<p>以下同步控制块就是临界区：</p>

<p>```java
synchronized(synObject) {</p>

<pre><code>//这部分代码一次只能被一个线程访问
</code></pre>

<p>}
```</p>

<p>使用同步控制块，可以防止整个方法都同步，显著提高性能。但要注意，上面例子中，只要没有退出同步控制块，那么被同步对象synObject的所有同步方法都无法被其它线程调用。</p>

<h3>2.5 线程本地存储</h3>

<p>去除变量共享，在线程本地存储也是防止共享资源冲突的一种方法。如果你有5个线程都要使用变量x所表示的对象，那么线程本地存储就会生成5个用于x的不同的存储块。ThreadLocal对象用于线程本地存储。</p>

<p>ThreadLocal对象通常当作静态域存储。示例如下：</p>

<p>```java
public class ThreadLocalVariableHolder {</p>

<pre><code>private static final ThreadLocal&lt;Integer&gt; value = new ThreadLocal&lt;Integer&gt;() {
    @Override
    protected synchronized Integer initialValue() {
        return 10;
    }
};

public static int get() {
    return value.get();
}

public static void increment() {
    value.set(value.get() + 1);
}
</code></pre>

<p>}</p>

<p>public class Accessor implements Runnable {</p>

<pre><code>@Override
public void run() {
    ThreadLocalVariableHolder.increment();
    //..
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Java - 异常]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/28/effective-java-yi-chang/"/>
    <updated>2014-08-28T23:15:18+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/28/effective-java-yi-chang</id>
    <content type="html"><![CDATA[<p>Effective Java 通用程序设计，读书笔记：</p>

<ol>
<li>只对异常情况才使用异常</li>
<li>对可恢复的情况使用受检异常，对编程错误使用运行时异常</li>
<li>避免不必要地使用受检的异常</li>
<li>优先使用标准的异常</li>
<li>抛出与抽象相对应的异常</li>
<li>每个方法抛出的异常都要有文档</li>
<li>在细节消息中包含能捕获失败的消息</li>
<li>努力使失败保持原子性</li>
<li>不要忽略异常</li>
</ol>


<!--more-->


<h2>57 只对异常情况才使用异常</h2>

<p>永远不要将异常用于正常的控制流。下面的代码试图使用异常退出循环，这是有问题的：</p>

<p>```java
//有问题的代码
try {</p>

<pre><code> int i = 0;
 while(true)
      range[i++].climb();
</code></pre>

<p>} catch (ArrayIndexOutOfBoundsException e) {
}
```</p>

<p>设计良好的API不应该强迫客户端为了正常的控制流而使用异常。可以考虑提供“状态测试”方法，例如Iterator的next()方法有一个对应的“状态测试方法” hasNext()。</p>

<h2>58 对可恢复的情况使用受检异常，对编程错误使用运行时异常</h2>

<p>如果期望调用者能够适当地恢复，应该使用受检的异常。对于程序错误，则使用运行时异常。对于受检异常，可以提供一些辅助方法，通过这些方法调用者可以获得一些有助于恢复的信息。例如用户取款时余额不足，可以提供一个方法获取余额。</p>

<h2>59 避免不必要地使用受检的异常</h2>

<p>当以下两个条件都成立时，才使用受检异常：</p>

<ol>
<li>正确地使用API并不能阻止这种异常条件的产生（例如网络、文件）。</li>
<li>一旦产生异常，使用API的程序员可以立即采取有用的动作，这种负担被认为是正当的。</li>
</ol>


<p>把受检异常变成运行时异常的一种方法是，把这个抛出异常的方法分成两个方法，其中一个返回boolean，表明是否应该抛出异常。例如前述的hasNext()。</p>

<h2>60 优先使用标准的异常</h2>

<p>使用标准的异常至少有以下好处：</p>

<ol>
<li>API更加易于学习和使用</li>
<li>可读性更好</li>
<li>异常类越少，内存印迹（footprint）就越少，装载这些类的时间开销也越少。</li>
</ol>


<p>常见的可重用异常包括：</p>

<ol>
<li>IllegalArgumentException 非Null的参数值不正确</li>
<li>IllegalStateException 对于方法调用而言，对象状态不合适。</li>
<li>NullPointException</li>
<li>IndexOutOfBoundsException</li>
<li>ConcurrentModificationException 禁止并修改时，检测到对象的并发修改</li>
<li>UnsupportedOperationException</li>
</ol>


<h2>61 抛出与抽象相对应的异常</h2>

<p>更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常。这种做法也就是<strong>异常转译</strong>。</p>

<p>如果低层的异常对于调试导致高层异常的问题非常有帮助，使用异常链就很合适。大多数标准异常都支持链的构造器，如果不支持，可以利用Throwable的initCause方法设置原因。下面代码展示了异常转译和异常链：</p>

<p>```java
try{
&hellip;
} catch(LowerLevelException cause) {</p>

<pre><code> throw new HigherLevelException(cause);
</code></pre>

<p>}</p>

<p>class HigherLevelException extends Exception {</p>

<pre><code> HigherLevelException(Throwable cause) {
      super(cause);
 }
</code></pre>

<p>}
```</p>

<h2>62 每个方法抛出的异常都要有文档</h2>

<p>始终要单独地声明受检的异常，并利用Javadoc的<code>@throws</code>标记，准确地记录下抛出每个异常的条件 。如果一个方法可能抛出多个异常，不要使用“快捷方式”，声明它们的某个父类。永远不要声明一个方法“throws Exception”，因为它不仅没有提供任何有用的信息，而且掩盖了其它可能抛出的异常。</p>

<p>对于接口中的方法，在文档中记录下它可能抛出的未受检异常也很重要。也就是用Javadoc的<code>@throws</code>标记进行说明，但在方法的声明中不使用throws关键字。</p>

<h2>63 在细节消息中包含能捕获失败的消息</h2>

<p>为了捕获失败，异常的细节信息应该包含所有“对该异常有贡献”的参数和域的值。例如IndexOutOfBoundsException就包括了三个信息：上界、下界以及不在界内的下标值。但是包含大量的描述信息也没有什么意义，因为堆栈轨迹的用途是与源文件结合起来使用的。</p>

<p>异常的细节消息不应该与“用户层次的错误信息”混为一谈。</p>

<p>为了确保异常的细节消息中包含足够的能捕获失败的消息，通常在异常的构造器中引入这些信息。如：</p>

<p>```java
public IndexOutOfBoundsException(int lowerBound, int upperBound, int index) {</p>

<pre><code> ...
</code></pre>

<p>}
```</p>

<h2>64 努力使失败保持原子性</h2>

<p>一般而言，失败的方法调用应该使对象保持在被调用之前的状态。具有这种属性的方法称为具有失败原子性。</p>

<p>要实现失败原子性，最简单的办法是设计不可变对象。对于可变对象，可采取的办法包括：</p>

<ol>
<li>执行操作前，检查参数的有效性。</li>
<li>调整计算处理的顺序，使任何可能会失败的计算部分在对象状态被修改之前发生。</li>
<li>编写一段恢复代码。（这种办法主要用于永久性的数据结构，如磁盘）</li>
<li>在对象的一份临时拷贝上执行操作，操作完成后再用临时拷贝中的结果替换对象的内容。</li>
</ol>


<h2>65 不要忽略异常</h2>

<p>空的catch块会使异常达不到应有的目的。如果确实需要空catch块，至少也要包含一条说明，为什么可以忽略此异常。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Java-通用程序设计]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/22/effective-java-tong-yong-cheng-xu-she-ji/"/>
    <updated>2014-08-22T20:06:07+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/22/effective-java-tong-yong-cheng-xu-she-ji</id>
    <content type="html"><![CDATA[<p>Effective Java 通用程序设计，读书笔记：</p>

<ol>
<li>将局部变量的作用域最小化</li>
<li>for-each循环优先于传统的for循环</li>
<li>使用类库</li>
<li>如果需要精确值，就避免使用float和double</li>
<li>基本类型优先于装箱基本类型</li>
<li>如果其它类型更合适，则尽量避免使用字符串</li>
<li>小心字符串拼接的性能问题</li>
<li>通过接口引用对象</li>
<li>接口优先于反射机制</li>
<li>谨慎使用本地方法</li>
<li>谨慎进行优化</li>
<li>遵守普遍接受的命名惯例</li>
</ol>


<!--more-->


<h2>45 将局部变量的作用域最小化</h2>

<p>局部变量只在第一次使用它的地方声明。每个局部变量的声明都应该包含一个初始化表达式。</p>

<h2>46 for-each循环优先于传统的for循环</h2>

<p><code>for(String str : list)</code>这样的for-each语句在简洁性和预防Bug方面有着传统for循环无法比拟的优势，并且没有性能损失。但如果在遍历时删除、替换、前移等操作时，无法使用for-each语句。</p>

<h2>47 使用类库</h2>

<p>不要重新发明轮子，尽量使用标准类库。例如随机数应该使用Random.nextInt(int)，而不是自己去写一个生成随机数的类。Java程序员应该精通java.lang, java.util包中的内容，还应该熟悉java.io, Collection, concurrent类库。</p>

<h2>48 如果需要精确值，就避免使用float和double</h2>

<p>要计算精确的结果，可以使用BigDecimal，它还包括8种舍入模式。但是它的缺点是不太方便并且有性能上的损失。也可以自己处理小数点和舍入，使用int, long。数据数值没有超过9位十进制数字，可以使用int，如果不超过18位数字，可以使用long。如果可能超过18位，就必须使用BigDecimal</p>

<h2>49 基本类型优先于装箱基本类型</h2>

<p>也就是int，boolean等优先于Integer和Boolean等。下面方法的返回值是多少？</p>

<p>```java
public int compare(Integer first, Integer second) {</p>

<pre><code> return first &lt; second ? -1 : (first == second ? 0 : 1);
</code></pre>

<p>}</p>

<p>compare(new Integer(42), new Integer(42));  //结果为1
```</p>

<p>原因是装箱类型是对象引用，<code>first == second</code> 为false。除此之外，需要注意的是装箱类型可能是null，可能因此引起一些潜在隐患。而装箱类型的性能也可能是个问题（如创建和销毁对象中第5条“避免创建不必要的对象”中提到的循环累计时的Long性能不如long）/blog/2014/06/27/effective-java-chuang-jian-he-xiao-hui-dui-xiang/</p>

<h2>50 如果其它类型更合适，则尽量避免使用字符串</h2>

<ol>
<li>字符串不适合代替其它的值类型，例如从文件中的int值以字符串存在，读出后就应该还原成int类型。</li>
<li>字符串不适合代替枚举类型</li>
<li>字符串不适合代替聚集类型。如用001_003代表两个东西，更好的办法是用一个私有静态成员类。</li>
</ol>


<h2>51 小心字符串拼接的性能问题</h2>

<h2>52 通过接口引用对象</h2>

<p>养成用接口作为类型的习惯。如果没有合适的接口存在，完全可以用（基）类来引用对象。</p>

<h2>53 接口优先于反射机制</h2>

<p>反射机制是一种功能强大的机制，对于特定的复杂系统编程任务，它是非常必要的，但它也有一些缺点：</p>

<ol>
<li>丧失了编译时类型检查的好处</li>
<li>执行反射访问所需的代码笨拙而冗长</li>
<li>性能损失</li>
</ol>


<p>因此，如果你编写的程序必须要与编译时未知的类一起工作，如有可能，就应该仅仅使用反射机制来实例化对象，而访问对象时则使用编译时已知的某个接口或者父类。例如未知的类实现了Set，则可以用反射机制实例化它，但访问它的方法时，使用Set的方法。</p>

<h2>54 谨慎使用本地方法</h2>

<p>Java Native Interface(JNI)允许Java调用本地方法（指本地程序设计语言如C, C++编写的特殊方法）。Java早期时，本地方法的用途是访问特定平台的能力（如注册表）、访问遗留代码库和提高性能。但现在已经没有太大必要了。</p>

<h2>55 谨慎进行优化</h2>

<p>不要费力去编写快速的程序，应该努力编写好的程序。在设计API、数据格式时，一定要考虑性能的因素。例如API，如果后期将公有的类型变成可变的（mutable），可能会导致大量不必要的保护性拷贝，影响性能。同样地，在适合使用复合模式的公有类使用了继承，会把这个类永远与父类绑在一起，人为地限制了子类的性能。如果在API中使用实现类型而不是接口，就会被束缚在一个具体的实现上，即使将来出现了更快的实现你也无法使用。</p>

<h2>56 遵守普遍接受的命名惯例</h2>

<p>对于类型参数：</p>

<ul>
<li>T表示任意类型</li>
<li>E表示集合的元素类型</li>
<li>K和V表示Map的键和值</li>
<li>X表示异常</li>
<li>任何类型的序列可以是T, U, V或者T1, T2, T3</li>
</ul>


<p>对于转换对象的方法，返回不同类型的独立对象的方法，通常被称为toType，如toString, toArray。返回视图的方法通常称为asType，如asList。静态工厂的常用名称为valueOf, of, getInstance, newInstance, getType和newType。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Java-方法]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/20/effective-java-fang-fa/"/>
    <updated>2014-08-20T19:32:51+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/20/effective-java-fang-fa</id>
    <content type="html"><![CDATA[<p>读书笔记：</p>

<ol>
<li>检查参数的有效性</li>
<li>必要时进行保护性拷贝</li>
<li>谨慎设计方法签名</li>
<li>慎用重载</li>
<li>慎用可变参数</li>
<li>返回零长度的数组或者集合，而不是null
44. 为所有导出的API元素编写文档注释</li>
</ol>


<!--more-->


<h2>38 检查参数的有效性</h2>

<p>检查方法参数的有效性，以便更早地发现问题。对于公有方法，要用Javadoc的@throw标签在文档中说明违反参数限制时会抛出的异常。例如：IllegalArgumentException, IndexOutOfBundsException或NullPointerException。对于非公有方法，一般采用断言来检查参数。</p>

<p>通常在计算过程之前，应该进行有效性检查。但如果有效性检查工作成本较高，或者有效性检查已经隐含在计算过程中，那么就不用先进行检查。但计算过程中由于参数的问题造成的异常可能不是方法文档中标明的那个异常，此时可以使用异常转译（第61条）技术，将其转换为正确的异常。</p>

<h2>39 必要时进行保护性拷贝</h2>

<p>如果类的内部状态使用了客户端传入的对象，而该对象是可变的，那么尽量不要直接引用这个外部对象，而是将其复制一份。对于构造器的每个可变参数进行保护性拷贝是必要的。而且保护性拷贝应该在有效性检查之前进行。如果参数类型可以被不可信任方子类化，那么不要使用clone方法进行保护性拷贝。</p>

<p>对于访问方法(如get)，为了防御类似的攻击，可以返回内部属性的保护性拷贝。例如对于Date类属性，在返回时，可以新建一个Date对象返回。另一种方式是返回Date.getTime()，即返回long基本类型的时间。访问方法在进行保护性拷贝时，允许使用clone方法，原因是我们知道返回类型时什么，只要它不会是其他某个潜在不可信子类，就可以使用clone方法。</p>

<p>对于内部长度非零的数组，在返回给客户端之前，应该总是进行保护性拷贝。另一种解决方案是，返回数组的不可变视图。（见第13条）</p>

<p>如果类信任它的调用者不会修改内部组件，例如在同一个包中，那么不进行保护性拷贝也是可以的，但类文档中应该清楚说明，调用者绝不能修改受到影响的参数或返回值。</p>

<h2>40 谨慎设计方法签名</h2>

<ol>
<li>谨慎选择方法的名称。</li>
<li>不要过于追求提供便利的方法。每个方法都应该尽其所能，方法太多会使类难以学习。只有某一项操作经常使用时，才考虑为其提供快捷方式。</li>
<li>避免过长的参数列表。解决方法：一是将方法分解成多个方法；二是创建辅助类（一般为静态成员类），保存这些参数。三是使用Builder模式。</li>
</ol>


<p>对于参数类型，优先使用接口。</p>

<p>对于boolean参数，优先使用两个元素的枚举类型。它使代码更易于阅读和编写。而且未来扩展时，可以轻易增加更多状态。</p>

<h2>41 慎用重载</h2>

<p>下面的代码执行结果可能与预期不同：
```java
public static String classify(List&lt;?> list) {</p>

<pre><code> return "List";
</code></pre>

<p>}</p>

<p>public static String classify(Collection&lt;?> c) {</p>

<pre><code> return "Collection";
</code></pre>

<p>}</p>

<p>public static void main(String[] args) {</p>

<pre><code> Collection&lt;?&gt; c = new ArrayList&lt;BigInteger&gt;();
 System.out.println(classify(c));
 //结果是Collection
</code></pre>

<p>}
```</p>

<p>原因是重载(overload)方法的选择是静态的，即在编译期决定。而被覆盖(override)的方法的选择是动态的，即在运行时决定。在上面的例子中，程序编译时，参数的类型是Collection，所以打印的结果是Collection。正如<a href="/blog/2014/08/19/she-ji-mo-shi-fang-wen-zhe-mo-shi">访问者模式</a>提到的：</p>

<blockquote><p>Java语言支持静态的多分派和动态的单分派。对于Java方法重载（Overload），在编译期会根据方法的接收者类型和方法的所有参量类型进行分派，因此是静态多分派。而方法覆盖（Override），是在运行时仅仅根据方法的接收者类型进行分派。</p></blockquote>

<p>因此，安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法。如果方法使用了可变参数，最好是不要重载它。例如ObjectOutputStream类中，没有使用重载方法，而是对于每种类型都提供了read和write方法: writeBoolean(boolean), writeInt(int)。对于构造器，没有办法使用不同的方法名称，但可以使用静态工厂方法或者Builder模式。</p>

<p>Java 1.5的自动装箱出现之后，重载也导致了一些麻烦。例如下面的代码：</p>

<p>```java
List<Integer> list = new ArrayList<Integer>();
for(int i = -3; i &lt; 3; i++) {</p>

<pre><code> list.add(i);
</code></pre>

<p>}</p>

<p>for(int i= 0; i &lt; 3; i++) {</p>

<pre><code> list.remove(i);
</code></pre>

<p>}</p>

<p>System.out.println(&ldquo;list: &rdquo; + list);
//打印结果：list: [-2, 0, 2]
```</p>

<p>原因是List.remove是重载方法：<code>remove(int i); remove(Object o);</code> 所以为了达到预期效果，要改为：<code>list.remove((Integer)i);</code></p>

<p>因此，能够重载方法并不意味着就应该重载方法。请慎用重载方法。</p>

<h2>42 慎用可变参数</h2>

<p>可变参数接受0或多个指定类型的参数。如果希望参数最少要1个，则可以这样定义方法：</p>

<p><code>java
public void someOperation(int a, int... otherArgs) {
}
</code></p>

<h2>43 返回零长度的数组或者集合，而不是null</h2>

<p>如果返回null，那么客户端始终要进行null判断。返回零长度的数组或集合时，不用在这个级别担心性能问题。</p>

<h2>44 为所有导出的API元素编写文档注释</h2>

<p>其中要注意的是，文档注释也应该描述类或者方法的线程安全性。</p>
]]></content>
  </entry>
  
</feed>
