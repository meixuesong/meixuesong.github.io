<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2015-01-31T19:44:35+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JVM字节码执行引擎]]></title>
    <link href="http://blog.ubone.com/blog/2015/01/20/jvmzi-jie-ma-zhi-xing-yin-qing/"/>
    <updated>2015-01-20T06:40:46+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/01/20/jvmzi-jie-ma-zhi-xing-yin-qing</id>
    <content type="html"><![CDATA[<p>JVM执行引擎输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。本文从概念模型的角度学习栈帧结构、方法调用和字节码执行。</p>

<!--more-->


<h2>1. 运行时栈帧结构</h2>

<p>栈帧（Stack Frame）是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素，是支持虚拟机进行方法调用和方法执行的数据结构。每个方法从调用开始到执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p>

<p>每个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和额外的附加信息。在编译生成字节码时，栈帧中需要多大的局部变量表、多深的操作数栈就已经完全确定并保存在方法表的Code属性中。</p>

<p>一个线程中的方法调用链可能很长，很多方法同时处于执行状态。但对执行引擎来说，活动线程中，只有栈顶的栈帧才是有效的，称为当前栈帧。与当前栈帧相关联的方法称为当前方法。执行引擎运行的所有字节码指令都只针对当前栈帧操作。</p>

<p><img src="/myresource/images/image_blog_-2015-01-20_06.59.02.jpg" alt="image" /></p>

<h3>1.1 局部变量表</h3>

<p>局部变量表用于存放方法参数和方法内局部变量，其容量以Variable Slot为最小单位。每个Slot可以存放32位以内的数据类型，包括boolean、byte、char、short、int、float、reference和returnAddress，对于64位的数据类型long和double，会分配2个连续的Slot。由于虚拟机栈是线程的私有数据，因此操作2个Slot不会引起数据安全问题。</p>

<p>虚拟机通过索引定位的方式使用局部变量表，索引值从0到最大Slot数量。在方法执行时，局部变量表完成参数值到数量变量列表的传递过程。如果执行的是实例方法（非static），关键字"this"是隐含参数，位于第0个索引，其余参数按照参数表顺序排列。</p>

<p>为了节省栈帧空间，Slot是可以重用的，因为方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用。但这也会有一些副作用，示例如下：</p>

<p>```java
public static void main(String[] args) {</p>

<pre><code>{
    byte[] placeholder = new byte[64*1024*1024];//64MB
}

int a = 0; //!
System.gc();
</code></pre>

<p>}
```</p>

<p>上面的代码，如果没有<code>int a</code>那一行，从逻辑上讲应该能够回收placeholder的内存，但实际上并非如此。原因就是代码虽然已经离开了placeholder的作用域，但在此之后，没有任何对局部变量表的读写操作，placeholder占用的Slot还没有被其他变量复用，所以GC Roots一部分的局部变量表仍然保持对它的关联。因此加上<code>int a</code>那一行就能够正常回收了。</p>

<p>因此，如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用大量内存，实际上已经不再会使用的变量，手动将其设置为null以帮助内存回收也是有意义的。需要注意的是，在日常编程时，没必要过度依赖将变量设置为null，因为编译器优化和JIT编译都可能使赋null语句被优化掉。</p>

<p>此外，局部变量并没有类变量和实例变量那样存在“准备阶段”，因此不会自动赋予系统初始值。</p>

<h3>1.2 操作数栈</h3>

<p>操作数栈（Operand Stack）也常称为操作栈，它是后入先出（LIFO）栈。当一个方法开始执行时，它的操作数栈是空的。在方法执行过程中，会有各种字节码指令往操作数栈写入和提取内容。</p>

<p>在概念模型中，两个栈帧是完全独立的。但大多虚拟机实现都会做优化，让两个栈帧出现一部分重叠。让下面的栈帧的部分操作数栈与上面的栈帧的部分局部变量表重叠在一起，无须进行额外的参数复制。</p>

<h3>1.3 动态连接</h3>

<p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。</p>

<h3>1.4 方法返回地址</h3>

<p>当方法开始执行后，有两种方式退出。一是遇到方法返回的字节码指令；二是遇到异常并且这个异常没有在方法体内得到处理。无论哪种退出方式，方法退出之后都要返回到方法被调用的位置。一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是通过异常处理器表来确定的，栈帧中一般不会保存此信息。</p>

<p>方法退出的过程就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，修改PC计数器的值以指向后一条指令等。</p>

<h3>1.5 附加信息</h3>

<p>各虚拟实现时会增加一些规范中没有描述的信息放到栈帧中，例如与调试相关的信息。</p>

<h2>2. 方法调用</h2>

<p>方法调用并不是方法执行，此阶段的唯一任务是确定被调用方法的版本，即调用哪一个方法。</p>

<h3>2.1 解析（Resolution）</h3>

<p>所有方法调用中的目标方法在Class文件里都是一个常量池中的符号引用。在解析阶段，会将其中一部分符号引用转化为直接引用：如果方法在真正运行之前就有一个可确定的调用版本，并且这个调用版本在运行期是不可改变的，那么就会被转化为直接引用。</p>

<p>符合这个条件的有静态方法、私有方法、实例构造器和父类方法4类。这4类方法和final方法都称为非虚方法。非虚方法在编译期间就完成了解析调用，将符号引用转变为可确定的直接引用。</p>

<h3>2.2 分派（Dispatch）</h3>

<p>分派与解析相反，要在运行时确定调用哪个版本的方法。这是多态特性的体现。分派可能是静态或动态的，根据分派的依据又分为单分派和多分派。</p>

<h4>2.2.1 静态分派</h4>

<p>首先明确什么是静态类型和实际类型，看下面的代码：</p>

<p>```java
public class Human{&hellip;}
public class Man extends Human{&hellip;}
public class Woman extends Human{&hellip;}</p>

<p>public void sayHello(Human h) {print(&ldquo;human&rdquo;);}
public void sayHello(Man h) {print(&ldquo;man&rdquo;);}
public void sayHello(Woman h) {print(&ldquo;woman&rdquo;);}</p>

<p>public static void main(String[] args) {</p>

<pre><code>Human man = new Man();
syaHello(man); //会打印什么呢？
</code></pre>

<p>}
```</p>

<p>在main方法中，Human称为变量的Static类型或Apparent类型，而Man则为变量的实际类型。</p>

<p>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是方法重载(Overload)。虚拟机在重载时通过参数的静态类型而不是实际类型作为判定依据。并且静态类型是编译期可知的，因此在编译阶段，编译器会根据参数的静态类型决定使用哪个方法的重载版本。所以main方法中会打印human.</p>

<h4>2.2.2 动态分派</h4>

<p>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。典型应用是方法重写(Override)。</p>

<h4>2.2.3 单分派与多分派</h4>

<p>方法的接收者和方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以分为单分派和多分派。单分派根据一个宗量对目标方法进行选择，而多分派则根据多于一个宗量对目标方法进行选择。</p>

<p>根据上面的知识，可以得知：Java是一门静态多分派，动态单分派的语言。</p>

<h4>2.2.4 虚拟机动态分派的实现</h4>

<p>由于动态分派是非常频繁的动作，需要在运行时中确定，因此虚拟机的实现基于性能考虑，并不会进行频繁的搜索，而是采用虚方法表来提高性能。</p>

<p>虚方法表中存放了各个方法的实际入口。如果某个方法在子类中没有被重写，那么子类的虚方法表里面的地址入口与父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类重写了这个方法，则子类方法表中的地址将会替换为指向子类实现版本的入口地址。</p>

<p>方法表一般在类加载的连接阶段进行初始化，类的变量初始值后，会把该类的方法表也初始化。</p>

<h2>3. 基于栈的字节码解释执行引擎</h2>

<p>虚拟机执行Java代码时有解释执行和编译执行。先学习一下解释执行。</p>

<p>Java编译器输出的指令流，基本是一种基于栈的指令集架构（Instruction Set Architecture, ISA），指令流中的指令大部分是零地址指令，它们依赖操作数栈工作。相对应的，x86使用的是基于寄存器的指令集。</p>

<p>基于栈的指令集主要优点是可移植，但缺点是执行速度会稍慢一些，因为出栈入栈操作本身就产生了相当多的指令数量，而且栈实现是在内存中，比寄存器的速度慢了很多。</p>

<p>通过一段代码来学习基于栈的解释器执行过程。</p>

<p>```java
public int calc() {</p>

<pre><code>int a = 100;
int b = 200;
int c = 300;
return (a+b) *c;
</code></pre>

<p>}
```</p>

<p>对应的字节码：</p>

<p><code>
public int calc();
Code:
stack=2, Locals=4, Args_size=1
0: bipush 100       //将单字节的整数常量值(-128~`17)推入操作数栈
2: istore_1     //将操作数栈顶的整形值出栈并存放到第1个局部变量Slot中
3: sipush 200       //与0类似
6: istore_2
7: sipush 300       
10:istore_3
11:iload_1      //将局部变量表第1个Slot的整型值复制到操作数栈顶
12:iload_2      //将局部变量表第2个Slot的整型值复制到操作数栈顶
13:iadd     //将操作数栈中的头两个栈顶出栈，相加，再将结果入栈
14:iload_3      //把第3个Slot的300压入操作数栈
15:imul     //将操作数栈中头两个栈顶出栈，相乘，将结果入栈
16:ireturn      //结束方法执行，将操作数栈顶的整数返回
</code></p>

<p>上面的示例可以看出中间变量都以操作数栈的入栈和出栈为信息交换途径。以上执行过程只是概念模型，实际执行时虚拟机会做优化。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM监控与故障处理工具]]></title>
    <link href="http://blog.ubone.com/blog/2015/01/04/jvmjian-kong-yu-gu-zhang-chu-li-gong-ju/"/>
    <updated>2015-01-04T21:42:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/01/04/jvmjian-kong-yu-gu-zhang-chu-li-gong-ju</id>
    <content type="html"><![CDATA[<p>本文介绍常用的Java虚拟机性能监控与故障处理工具。</p>

<!--more-->


<h2>1. JDK命令行工具</h2>

<h3>1.1 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jps.html">jps</a></h3>

<p>与Unix下的ps命令相似，可以列出正在运行的虚拟机进程并显示主类（main()函数所在类）类名以及LVMID(Local Virtual Machine Identifier)。LVMID与PID是一致的。命令格式：</p>

<p><code>jps [options] [hostid]</code></p>

<table>
<thead>
<tr>
<th>选项 </th>
<th> 用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>-q </td>
<td> 只输出LVMID</td>
</tr>
<tr>
<td>-m </td>
<td> 输出JVM启动时传递给主类main()函数的参数</td>
</tr>
<tr>
<td>-l </td>
<td> 输出主类全名</td>
</tr>
<tr>
<td>-v </td>
<td> 输出JVM启动时的JVM参数</td>
</tr>
</tbody>
</table>


<h3>1.2 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html">jstat</a>，虚拟机统计信息监视工具</h3>

<p>在<a href="/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>中已经有描述。</p>

<h3>1.3 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jinfo.html">jinfo</a>, Java配置信息工具</h3>

<p>用于实时查看和调整虚拟机各项参数。</p>

<h3>1.4 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jmap.html">jmap</a>, Java内存映像工具</h3>

<p>在<a href="/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>中已经有描述。</p>

<h3>1.5 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jhat.html">jhat</a>， 堆转储快照分析工具</h3>

<p>用于分析堆转储快照，内置一个微型HTTP服务器，分析结果后可在浏览器中查看。但这个工具并不常用。</p>

<h3>1.6 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstack.html">jstack</a>, Java堆栈跟踪工具</h3>

<p>用于生成虚拟机当前时刻的线程快照（threaddump），即当前每一条线程正在执行的方法堆栈集合。主要目的是定位线程出现长时间停顿的原因，如死锁、死循环、请求外部资源等。</p>

<p>当线程出现停顿时，通过jstack查看各线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么。</p>

<table>
<thead>
<tr>
<th>选项 </th>
<th> 用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>-F </td>
<td> 当正常输出的请求不被响应时，强制输出线程堆栈</td>
</tr>
<tr>
<td>-l </td>
<td> 除堆栈外，显示关于锁的附加信息</td>
</tr>
<tr>
<td>-m </td>
<td> 如果调用本地方法的话，显示C/C++堆栈</td>
</tr>
</tbody>
</table>


<h2>2. JDK的可视化工具</h2>

<h3>2.1 JConsole</h3>

<p>基于JMX的可视化监视、管理工具。直接通过集令后运行jconsol。</p>

<h3>2.2 <a href="http://visualvm.java.net/">VisualVM</a>，多合一故障处理工具</h3>

<p>VisualVM Is Designed For You:</p>

<ul>
<li><strong>Application Developer</strong>: Monitor, profile, take thread dumps, browse heap dumps</li>
<li><strong>System Administrator</strong>: Monitor and control Java applications across the entire network</li>
<li><strong>Java Application User</strong>: Create bug reports containing all the necessary information</li>
</ul>


<p>在命令行执行<code>jvisualvm</code>即可</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java垃圾收集与内存分配]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/26/la-ji-shou-ji-qi-yu-nei-cun-fen-pei-ce-lue/"/>
    <updated>2014-12-26T20:20:12+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/26/la-ji-shou-ji-qi-yu-nei-cun-fen-pei-ce-lue</id>
    <content type="html"><![CDATA[<p>在<a href="/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>中，了解了Java的内存管理和垃圾收集。本文再深入学习垃圾收集算法和HotSpot中垃圾收集的实现。</p>

<!--more-->


<h2>1. 什么是垃圾</h2>

<p>Java并没有使用引用计数法来识别对象是否为垃圾，而是采用可达性分析（Reachability Analysis）判断对象是否存活。其基本思路就是通过GC Roots对象为起点，搜索其引用链，只要是通过它们可达的对象就是活对象。GC Roots对象包括以下几种：</p>

<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI(即Native方法)引用的对象</li>
</ul>


<p>而Java的引用又分为多种类型，对象是否存活也与引用类型有关：</p>

<ul>
<li>强引用：普通引用都是强引用，只要强引用还存在，对象就不会被回收。</li>
<li>软引用：SoftReference关联的对象是还有用，但不是必须的对象。在系统将要发生内存溢出异常之前，会把这些对象列入回收范围进行第二次回收。</li>
<li>弱引用：WeakReference与SoftReference更弱，它关联的对象只能生成到下一次垃圾收集发生之前（无论内存是否足够，都会被回收）。</li>
<li>虚引用：PhantomReference是最弱的一种引用，对生存时间完全没有影响，也无法通过虚引用来取得一个对象实例。其唯一目的就是在回收时收到一个系统通知。</li>
</ul>


<p>真正宣告一个对象的死亡，要经历至少两次标记过程。当扫描发现对象与GC Roots没有引用链，将进行第一次标记，并判断对象是否有必要执行finalize()方法（如果对象没有覆盖该方法，或者方法已经被调用过，视为没有必要执行）。如果有必要执行finalize()方法，虚拟机将该对象放入F-Queue队列，稍后自动由低优先级的Finalizer线程执行该方法。之后GC还会对F-Queue中的对象进行第二次标记，如果对象在finalize()方法中重新建立了一个有效引用，就会被移除出“即将回收”的集合，逃脱回收。</p>

<p>但注意finalize()方法是没有保障的，JVM只会触发它执行，并不保证它会运行结束。试想如果finalize()方法中有死循环，会造成整个内存回收系统崩溃。所以正如<a href="/blog/2014/06/27/effective-java-chuang-jian-he-xiao-hui-dui-xiang/">Effective Java-创建和销毁对象</a>中提到的，你就当Java没有finalize()方法吧!</p>

<p>方法区（通常所指的永久代）也是<strong>可以（非必须）</strong>垃圾收集的。主要回收废弃常量和无用的类。对于常量，例如“abc”已经进入常量池，但当前没有任何一个String对象是“abc”，那么这个常量可能会被清理出去。如何判断无用的类则要苛刻许多，需要同时满足以下条件：</p>

<ul>
<li>该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例。</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>


<p>方法区的对象仅仅是可以回收，并不是必然会回收。在大量使用反射、动态代理、CGLib等字节码框架、动态JSP和OSGi这类频繁自定义ClassLoader场景下，虚拟机需要具备类卸载的功能。</p>

<p>HotSpot提供了参数<code>-Xnoclassgc</code>参数控制方法区回收。在Product版JVM中还可以使用<code>-verbose:class</code>和<code>-XX:+TraceClassLoading</code>查看类加载信息。FastDebug版的JVM还支持<code>-XX:+TraceClassUnLoading</code>查看卸载信息。</p>

<h2>2. 垃圾收集算法</h2>

<p>各平台的虚拟机操作内存的方法各不相同，常见的垃圾收集算法说明如下：</p>

<h3>2.1 常见的垃圾收集算法</h3>

<h4>标记-清除算法(Mark-Sweep)</h4>

<p>这是最基础的收集算法，分为标记和清除两个阶段。首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。它有两个主要问题：一是效率不高，另一个是空间问题，会产生大量不连续的内存碎片。</p>

<h4>复制算法(Copying)</h4>

<p>复制算法的思路是将内存分为大小相等的两块，每次只使用其中一块，永远有一块是空的。当一块用完了，就将存活对象复制到另一块上，把前者内存空间一次清理掉。</p>

<p>复制算法特别适合那些短命的对象，现代虚拟机都采用这个算法来回收新生代。将内存分为较大的Eden区和两个较小的Survivor，每次使用Eden和其中一个Survivor。回收时，将Eden和Survivor存活的对象复制到另一个Survivor，最后清理掉Eden和前一个Survivor空间。HotSpot默认的Eden和Survivor比例是8：1. 如果另一个Survivor空间不足以放下存活对象，那些经历多少GC仍存活的对象会被放入老年代。</p>

<h4>标记-整理算法（Mark-Compact）</h4>

<p>对于长命的对象，复制算法的效率就变得太低。标记-整理算法就适合老年代。其思路是标记后，将活对象向一端移动，然后清理掉边界以外的内存。</p>

<h4>分代收集算法(Generational Collection)</h4>

<p>这个算法没有特殊之处，就是将堆分为新生代和老年代，然后根据各年代的特点选择最适当的算法。在新生代使用复制算法，在老年代使用“标记-清理”或者“标记-整理”算法。</p>

<h3>2.2 HotSpot的算法实现</h3>

<p>结合前面的垃圾收集算法，看看HotSpot是如何实现的。</p>

<h4>2.2.1 枚举GC Roots</h4>

<p>前面说到GC Roots主要是在全局性的引用和执行上下文（如栈帧中的本地变量表）中，但HotSpot并不需要逐个检查这里面的引用，因为这样的效率太低了。</p>

<p>HotSpot使用一组称为OopMap的数据结构，在类加载完成时，就把对象内各偏移量上是什么类型的数据计算出来了，因此GC扫描时，可以直接得到这些信息，并准确判断堆上的数据是否还可能被使用。</p>

<h4>2.2.2 安全点</h4>

<p>当GC时，线程会停在安全点，常见的安全点包括方法调用、循环跳转、异常跳转等。如何让线程停在安全点，有两种方案：抢先式中断和主动式中断。抢先式指中断所有线程，如果发现某个线程不在安全点，则恢复线程让它跑到安全点。但几乎所有虚拟机都没有采用这个方法。</p>

<p>主动式中断的思路是GC需要中断线程时，设置一个标志，各线程执行时会在安全点和创建对象需要分配内存的地方轮询这个标志，如果为真就把自己挂起。</p>

<p>对于那些处于Sleep或Blocked状态的线程，无法跑到安全点，则需要安全区域来解决。安全区域中任何地方GC都是安全的。当线程执行到安全区域中的代码时，先标识自己已经进入安全区，这时GC就不管这些线程了。当线程要离开安全区时，它要检查系统是否已经完成了根节点枚举或GC过程，如果完成则继续执行，否则继续等待直到收到可安全离开的信号。</p>

<h4>2.2.3 垃圾收集器</h4>

<p><a href="https://blogs.oracle.com/jonthecollector/entry/our_collectors">下图</a>展示了HotSpot用于不同年代的7种收集器，如果两个收集器间有连线，说明它们可以搭配使用。</p>

<p><img src="/myresource/images/image_blog_2014-12-26-Collectors.jpg" alt="image" /></p>

<h5>Serial收集器</h5>

<p>这是一个单线程的收集器，工作于年轻代，使用复制算法。当它工作时，会把所有用户线程全部停下来。它现在仍然是Client模式下的默认收集器。它比其他收集器简单但高效，没有了线程交互的开销。桌面应用由于分配的内存相对较少，收集时停顿时间可控制在几十到一百多毫秒，对桌面应用是可以接受的。</p>

<h5>ParNew收集器</h5>

<p>它其实就是Serial收集器的多线程版本，对于单核CPU的环境下，绝对不会比Serial更好。但它适合于在服务端模式时与CMS配合(CMS用于老年代，ParNew用于年轻代)。</p>

<h5>Parallel Scavenge收集器</h5>

<p>这是一个年轻代的收集器，使用复制算法，是并行的多线程收集器。</p>

<ul>
<li>并行(Parallel):指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li>并发(Concurrent): 指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行）。</li>
</ul>


<p>Parallel Scavenge收集器与其它收集器不同，它的目标是达到一个可控制的吞吐量，即CPU用于运行用户代码的时间与CPU总消耗时间的比值。因此适合于不需要太多交互，主要是后台运算的场景。</p>

<h5>Serial Old收集器</h5>

<p>这是Serial收集器的老年代版本，同样是单线程收集器，使用“标记-整理”算法。其主要意义也是Client模式的虚拟机中使用。如果在Server模式下，主要是在JDK1.5及之前的版本中与Parallel Scavenge搭配使用，以及作为CMS的后备预案。</p>

<h5>Parallel Old收集器</h5>

<p>这是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。从JDK1.6开始提供，主要用于与Parallel Scavenge搭配使用，作为“吞吐量优先”的组合。</p>

<h5>CMS收集器(Concurrent Mark Sweep)</h5>

<p>这是一种以获取最短回收停顿时间为目标的收集器。也是基于“标记-清除”算法实现，整个过程分为4步：</p>

<ol>
<li>初始标记：标记GC Roots能直接关联到的对象，时间很快。</li>
<li>并发标记：进行GC Roots Tracing，时间很长。</li>
<li>重新标记：修正并发标记期间因用户程序继续运行而导致标记发生变化的那一部分对象的标记记录，比第一步稍长。</li>
<li>并发清除</li>
</ol>


<p>第1、3步需要Stop the World，而耗时最长的第2、4步可以与用户线程一起工作。</p>

<p>CMS是非常优秀的垃圾收集器，是Java 5推荐的高性能收集器，在Java 6仍保持了旺盛的生命力。但它的主要缺点是：</p>

<ol>
<li>对CPU资源非常敏感。在并发标记阶段，虽然用户程序不用停顿，但CMS占用了一部分CPU资源而导致应用变慢，总吞吐量降低。</li>
<li>无法处理浮动垃圾，可能出现“Concurrent Mode Failure”，导致另一次Full GC。浮动垃圾就是在并发清除阶段，用户线程还在运行并产生新的垃圾。CMS需要预留一部分内存空间给用户线程使用。如果预留的空间无法满足程序需要，就会出现“Concurrent Mode Failure”，导致JVM临时启用Serial Old收集器来重新进行老年代收集，停顿时间就很长了。</li>
<li>由于使用“标记-清除”算法，因此会有碎片产生，有时不得不提前触发一次Full GC。</li>
</ol>


<h5>G1收集器</h5>

<p>这是面向服务端应用的垃圾收集器，可用于替换CMS。具备如下特点：</p>

<ol>
<li>并行与并发：充分利用多CPU、多核优势，缩短Stop the world时间。</li>
<li>分代收集：仍保留分代概念，可以独立管理整个GC堆。</li>
<li>空间整合：G1整体上是基于“标记-清除”，但从局部看是基于“复制”算法，不会产生内存碎片。</li>
<li>可预测的停顿：G1能建立可预测的停顿时间模型，可指定一个长度为M毫秒的时间片段，G1分将停顿时间尽量控制在该时间范围内。</li>
</ol>


<p>G1将整个堆划分为多个大小相等的独立区域（Region），虽然保留分代概念，但新生代和老年代不是物理隔离的，它们是一部分Region的集合（不需要连续）。</p>

<p>它的实现方式是跟踪每个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及所需时间的经验值），维护一个优先列表，每次根据停顿目标值，回收价值最大的Region。保证在有限的时间内获得尽可能高的收集效率。</p>

<p>每个Region都有一个对应的Remembered Set，用于记录跨Region的引用。因此进行内存回收时，只需要在GC Roots枚举范围内加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SecureRandom导致Tomcat启动过慢]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/20/%5B%3F%5D-ci-jie-jue-tomcatqi-dong-guo-man-de-jing-li/"/>
    <updated>2014-12-20T12:08:33+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/20/[?]-ci-jie-jue-tomcatqi-dong-guo-man-de-jing-li</id>
    <content type="html"><![CDATA[<p>昨天晚上在Tomcat上部署一个小应用时，Tomcat启动非常慢，有时甚至需要10分钟。查看日志，发现一直停在Deploying阶段：</p>

<!--more-->


<p><code>
INFO: Starting service Catalina
Dec 19, 2014 9:56:33 AM org.apache.catalina.core.StandardEngine startInternal
INFO: Starting Servlet Engine: Apache Tomcat/7.0.52 (Ubuntu)
Dec 19, 2014 9:56:33 AM org.apache.catalina.startup.HostConfig deployWAR
INFO: Deploying web application archive /usr/mxs/kindleinstance/webapps/kindlegen.war
</code></p>

<p>难道是war文件有问题？检查了md5校验码，尝试了解压缩，完全没问题啊！到底是什么原因呢？等了十分钟后，发现Tomcat已经启动完成，可以使用了。再次查看日志：</p>

<p><code>
INFO: Deploying web application archive /usr/mxs/kindleinstance/webapps/kindlegen.war
Dec 19, 2014 10:11:25 AM org.apache.catalina.util.SessionIdGenerator createSecureRandom
INFO: Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [888,934] milliseconds.
Dec 19, 2014 10:11:25 AM org.apache.coyote.AbstractProtocol start
INFO: Starting ProtocolHandler ["http-bio-9090"]
Dec 19, 2014 10:11:25 AM org.apache.catalina.startup.Catalina start
INFO: Server startup in 892334 ms
</code></p>

<p>原来是“Creation of SecureRandom instance for session ID”消耗了888秒，这个SecureRandom实例是什么呢？在<a href="http://wiki.apache.org/tomcat/HowTo/FasterStartUp">How do I make Tomcat startup faster?</a>中，有这样的描述：</p>

<blockquote><p>Tomcat 7+ heavily relies on SecureRandom class to provide random values for its session ids and in other places. Depending on your JRE it can cause delays during startup if entropy source that is used to initialize SecureRandom is short of entropy.</p></blockquote>

<p>也就是说，Tomcat 7之后严重依赖SecureRandom类来提供随机数用于Session ID。当Tomcat启动时，取决于你使用的JRE，如果用来初始化SecureRandom的熵值（Entropy）资源是一个短熵时，将可能导致延时。</p>

<p>再看看JDK中关于<a href="http://docs.oracle.com/javase/7/docs/api/java/security/SecureRandom.html">SecureRandom类</a>:</p>

<blockquote><p>This class provides a cryptographically strong random number generator (RNG). A cryptographically strong random number minimally complies with the statistical random number generator tests specified in FIPS 140-2, Security Requirements for Cryptographic Modules, section 4.9.1. Additionally, SecureRandom must produce non-deterministic output. Therefore any seed material passed to a SecureRandom object must be unpredictable, and all SecureRandom output sequences must be cryptographically strong, as described in RFC 1750: Randomness Recommendations for Security.</p></blockquote>

<p>该类提供保密性强的随机数生成器（RNG）。一个保密性强的随机数应最低限度遵循FIPS 140-2指定的统计随机数发生器测试和4.9.1节的加密模块安全要求。并且SecureRandom必须产出非确定性的输出。因此，正如RFC 1750中描述的，传递给SecureRandom对象的任何材料必须是不可预测的，并且所有SecureRandom输出序列必须是保密性强的的。</p>

<p>在<a href="http://www.cigital.com/justice-league-blog/2014/01/06/issues-when-using-java-securerandom/">ISSUES TO BE AWARE OF WHEN USING JAVA’S SECURERANDOM</a>中，提到了使用SecureRandom可能存在的问题，主要包括三个方面：调用顺序、阻塞和内部Seeding机制。其中说明了阻塞是如何产生的：</p>

<blockquote><p>Some SecureRandom implementations in the Oracle JRE for *nix use /dev/random to get entropy at certain times. Since /dev/random can block if sufficient entropy is not available, your code will stop executing if you call certain SecureRandom methods at times when /dev/random does not have sufficient entropy available.</p></blockquote>

<p>这样看来，我的Ubuntu 14中的OpenJDK(OpenJDK Runtime Environment (IcedTea 2.5.3) (7u71-2.5.3-0ubuntu0.14.04.1))正是使用了操作系统的<code>/dev/random</code>作为信息源，而它又没有提供足够的熵，所以导致阻塞。</p>

<p>按照前文<a href="http://wiki.apache.org/tomcat/HowTo/FasterStartUp">How do I make Tomcat startup faster?</a>中给出的次安全的解决办法，改为使用<code>-Djava.security.egd=file:/dev/./urandom</code>，即在setenv.sh中加入一行：</p>

<p>```</p>

<h1>!/bin/sh</h1>

<p>export CATALINA_OPTS=&ldquo;-Djava.security.egd=file:/dev/./urandom&rdquo;
```</p>

<p>然后再重启Tomcat，这次非常快了，整个启动只用了3秒多：</p>

<p><code>
INFO: Starting service Catalina
Dec 19, 2014 10:51:55 PM org.apache.catalina.core.StandardEngine startInternal
INFO: Starting Servlet Engine: Apache Tomcat/7.0.52 (Ubuntu)
Dec 19, 2014 10:51:55 PM org.apache.catalina.startup.HostConfig deployWAR
INFO: Deploying web application archive /usr/mxs/kindleinstance/webapps/kindlegen.war
Dec 19, 2014 10:51:58 PM org.apache.coyote.AbstractProtocol start
INFO: Starting ProtocolHandler ["http-bio-9090"]
Dec 19, 2014 10:51:58 PM org.apache.catalina.startup.Catalina start
INFO: Server startup in 3418 ms
</code></p>

<p>修改后的<code>/dev/urandom</code>没有默认的<code>dev/random</code>安全吗？似乎也不一定，博文<a href="http://www.2uo.de/myths-about-urandom/">Myths about /dev/urandom</a>对两者进行了全面的分析，值得一看。最后作者认为用<code>/dev/urandom</code>就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java运行时数据区与内存溢出异常]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/15/javayun-xing-shi-shu-ju-qu-yu-nei-cun-yi-chu-yi-chang/"/>
    <updated>2014-12-15T21:55:31+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/15/javayun-xing-shi-shu-ju-qu-yu-nei-cun-yi-chu-yi-chang</id>
    <content type="html"><![CDATA[<p>JVM定义了各种运行时数据区用于程序执行。有些数据区随着JVM启动而创建，当JVM退出时销毁。另一些数据区则是随着线程而存亡。每个数据区都是内存，因此就存在内存溢出的异常。本文学习JVM有哪些数据区以及常见的内存溢出异常。</p>

<!--more-->


<h2>1. 运行时数据区（Run-Time Data Areas）</h2>

<p>根据<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5">JVM规范</a>，运行时数据区主要分为以下部分。</p>

<h3>1.1 程序计数器（Program Counter Register）</h3>

<p>每个JVM线程拥有自己的程序计数器，各线程之间计数器互不影响，这部分区域可以称为线程私有的内存。在任何时间点，一个CPU核心都只会执行一个线程中某个方法的指令，这就是当前方法：</p>

<ul>
<li>如果当前方法不是Native方法，程序计数器包含正在执行的虚拟机字节码指令的地址。</li>
<li>如果是Native方法计数器值为Undefined。</li>
</ul>


<p>程序计数器所占内存非常小，也是唯一没有规定任何内存溢出异常的区域。</p>

<h3>1.2 虚拟机栈（JVM Stacks）</h3>

<p>每个线程同时也有一个私有的虚拟机栈，因此虚拟机栈的生命周期与线程相同。每个栈包括帧（frames），帧与方法调用相关，每当方法被调用，就会创建一个新的帧。当方法结束，帧也就被销毁。帧包括局域变量、自己的操作栈和当前方法的运行时常量池引用。</p>

<p>虚拟机栈与C语言中的栈相似，它包括局域变量和部分结果，并在方法调用和返回中扮演角色。除了push和pop帧，虚拟机栈并不提供其它直接操作。帧可能是在堆中分配内存。虚拟机栈的内存并不需要是连续的。</p>

<p>通常人们把Java内存分为堆和栈，其中栈就是虚拟机栈。虚拟机栈的内存可以是固定大小或者根据计算动态扩展。虚拟机栈涉及两个异常：</p>

<ul>
<li>StackOverflowError: 如果线程请求的栈深度大于允许的深度。</li>
<li>OutOfMemoryError：如果栈是动态扩展的，扩展时无法申请足够的内存。</li>
</ul>


<p>本地方法栈（Native Method Stack）与虚拟机栈发挥着相似的作用，但它是为Native方法服务。JVM规范并没有对其强制规定。HotSpot直接把本地方法栈和虚拟栈合二为一，相同对待。</p>

<p>栈虽然有两个异常，但实验时，如果是单线程操作，无论是栈帧太大还是虚拟机栈容量太小，基本只会出现StackOverflowError，示例如下：</p>

<p>```java
/<em>*
* -Xss128k
</em>/
public class JavaVMStackSOF {</p>

<pre><code>private int stackLength = 1;
public void stackLeak() {
    stackLength++;
    stackLeak();
}

public static void main(String[] args) {
    JavaVMStackSOF oom = new JavaVMStackSOF();
    try {
        oom.stackLeak();
    } catch(Throwable e) {
        ...
    }
}
</code></pre>

<p>}
```</p>

<p>实验中，只有多线程时，才会出现OutOfMemoryError。通过不停地创建线程，并且每个线程不停止，当线程足够多时就可以重现此异常。</p>

<h3>1.3 堆（Heap）</h3>

<p>堆是在JVM所管理的内存中最大的一块，它是所有线程共享的区域。当JVM启动时会创建此区域。所有对象实例和数组都在堆上分配（现在也有例外，参见<a href="/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">逸出分析</a>）。</p>

<p>堆中存储的对象由垃圾收集器负责回收。堆的大小可以是固定或者动态扩展。堆不需要连续内存空间，只要逻辑上连续即可。根据垃圾收集器的不同，堆内存有不同的管理方式。例如CMS采用分代收集算法，将堆分为年轻代和老年代；而G1则将堆分成大小相同的区域。详见<a href="/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>。</p>

<p>堆涉及的内存异常为OutOfMemoryError，如果堆中没有内存用于实例分配并且无法再扩展时，就会抛出此异常。堆内存溢出很容易模拟，示例如下：</p>

<p>```java
/<em>*
* -Xms20m -Xmx20m
</em>/
public static void main(String[] args) {</p>

<pre><code>List&lt;SomeObject&gt; list = new ArrayList&lt;&gt;();
while(true) {
    list.add(new SomeObject());
}
</code></pre>

<p>}
```</p>

<h3>1.4 方法区（Method Area）</h3>

<p>方法区也是所有线程共享的内存区域。它存储了每个类的信息，例如运行时常量池、属性和方法数据、方法和构造方法代码，包括类和实例初始化和接口初始化的特殊方法。</p>

<p>方法区随着虚拟机启动而创建。逻辑上它是堆的一部分，但JVM实现可以选择不对它进行垃圾收集或者压缩。JVM规范并没有强制规定它的位置和管理已编译代码的策略。它可以是固定大小或者动态扩展，也不需要是连续的。</p>

<p>对于HotSpot虚拟机来说，开发者更愿意把方法区称为永久代（Permanent Generation），但本质上两者并不等价。这仅仅是因为HotSpot设计团队使用永久代来实现方法区而已。但其它虚拟机（如Bea JRocket, IBM J9）并没有永久代的概念。</p>

<p>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。如果一些框架使用CGLib这类字节码技术，增强的类过多，或者JVM上的动态语言（如Groovy）持续创建类来实现语言动态特性，可能出现此异常。</p>

<h3>1.5 运行时常量池</h3>

<p>在<a href="/blog/2014/12/04/lei-wen-jian-yu-zi-jie-ma/">类文件与字节码</a>中介绍了类文件的常量池，运行时常量池就是这个常量池的运行时表示。运行时常量池相对于类文件常量池主要有两个区别：</p>

<ul>
<li>除了类文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</li>
<li>运行时常量池可以在运行期间将新的常量加入池中。</li>
</ul>


<p>运行时常量池的内存是从方法区分配出来的。当JVM创建类或接口时，会为它创建运行时常量池。因此它的内存受方法区内存限制，也可能抛出OutOfMemoryError异常。</p>

<h3>1.6 直接内存</h3>

<p>直接内存（Direct Memory）并不是JVM运行时数据区的一部分，也不是JVM规范定义的内存区域。但它也被频繁使用，可能导致OutOfMemoryError异常。</p>

<p>JDK 1.4中加入NIO类，引入了基于Channel与Buffer的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过DirectByteBuffer对象作为这块内存的引用进行操作。由于避免了Java堆与Native堆之间复制数据，在一些场景能显著提高性能。</p>

<p>这部分内存虽然不受Java堆大小限制，但肯定会受本机总内存和寻址空间限制。因此动态扩展时可能出现OutOfMemoryError异常。</p>

<h2>2. 内存Dump分析</h2>

<p>在<a href="/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>中介绍了jmap, jstat等工具可以查看内存映射和垃圾收集活动。这里介绍另一个工具Eclipse Memory Analyzer可以对堆内存溢出问题进行分析。首先需要生成堆转储文件。通过启用参数：</p>

<p><code>-XX:+HeapDumpOnOutOfMemoryError</code></p>

<p>JVM 就会在发生内存泄露时抓拍下当时的内存状态，也就是我们想要的堆转储文件。也可以在未溢出时用jmap创建转储文件。</p>

<p>有了转储文件，利用Eclipse Memory Analyzer tool打开该文件，就可以进行分析了。分析通常分为三步：</p>

<ul>
<li>对内存状态获取一个整体印象。</li>
<li>找到最有可能导致内存泄露的元凶，通常也就是消耗内存最多的对象。</li>
<li>进一步查看这个内存消耗大户的具体情况，看看是否有什么异常行为。</li>
</ul>


<p><img src="/myresource/images/image_blog_2014-12-17-20.30.59.jpg" alt="image" /></p>
]]></content>
  </entry>
  
</feed>
