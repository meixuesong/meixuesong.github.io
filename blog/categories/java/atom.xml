<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2015-03-15T22:14:14+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java Collections]]></title>
    <link href="http://blog.ubone.com/blog/2015/03/14/java-collections/"/>
    <updated>2015-03-14T20:51:05+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/03/14/java-collections</id>
    <content type="html"><![CDATA[<p>Java提供了一套完整的Collection框架，能够帮助我们减少开发工作量、提高程序运行速度和代码质量。本文学习Java Collection框架。</p>

<!--more-->


<h2>1. 接口层级结构</h2>

<p>核心Collection接口封装了各种类型的集合，它是Java Collections框架的基石。接口继承层次如下图所示：</p>

<p><img src="/myresource/images/image_blog_2015-03-14-colls-coreInterfaces.png" alt="image" /></p>

<p>注意，从上图可以看出，Map并不是真正的Collection。所有核心Collection接口都支持泛型。在声明Collection实例时，你可以也应该指明集合的元素类型，让编译器帮你校验放入集合的元素类型是否匹配，从而降低运行时错误。</p>

<h2>2. Collection接口</h2>

<p>Collection类都有很方便的构造器。例如你有一个<code>Collection&lt;String&gt; c</code>，它可能是一个List、Set或其它Collection类型。通过构造方法可以转换成另一种Collection：</p>

<p><code>java
List&lt;String&gt; list = new ArrayList&lt;String&gt;(c);
</code></p>

<p>基本的Collection操作包括：</p>

<ul>
<li><code>int size()</code></li>
<li><code>boolean isEmpty()</code></li>
<li><code>boolean contains(Object element)</code></li>
<li><code>boolean add(E element)</code></li>
<li><code>boolean remove(Object element)</code></li>
<li><code>Iterator&lt;E&gt; iterator()</code></li>
</ul>


<p>操作整个Collection的相关方法：</p>

<ul>
<li><code>boolean containsAll(Collection&lt;?&gt; c)</code></li>
<li><code>boolean addAll(Collection&lt;? extends E&gt; c)</code></li>
<li><code>boolean removeAll(Collection&lt;?&gt; c)</code></li>
<li><code>boolean retainAll(Collection&lt;?&gt; c</code>)（交集，只保留c中存在的元素）</li>
<li><code>void clear()</code></li>
</ul>


<p>此外还有数组的操作：<code>Object[] toArray()</code>,  <code>&lt;T&gt; T[] toArray(T[] a)</code></p>

<h3>2.1 遍历Collection</h3>

<p>有三种方法遍历Collection：聚合操作、for-each和Iterator。</p>

<h4>2.1.1 聚合操作</h4>

<p>JDK8之后，推荐使用聚合操作来遍历Collection。聚合操作常常与lambda表达式一起让代码更具表达力。下面的代码完成遍历并打印红色的对象的name:</p>

<p>```java
myShapesCollection.stream()</p>

<pre><code>.filter(e -&gt; e.getColor() == Color.RED)
.forEach(e -&gt; System.out.println(e.getName()));
</code></pre>

<p>```</p>

<p>对多核系统，还可以请求并行流，这对超大Collection有帮助：</p>

<p>```java
myShapesCollection.parallelStream()</p>

<pre><code>.filter(e -&gt; e.getColor() == Color.RED)
.forEach(e -&gt; System.out.println(e.getName()));
</code></pre>

<p>```</p>

<p>更多例子：</p>

<p>```java
//将Collection中的元素转换成一个String，用逗号分隔：
String joined = elements.stream()</p>

<pre><code>.map(Object::toString)
.collect(Collectors.joining(", "));
</code></pre>

<p>//计算合计
int total = employees.stream()</p>

<pre><code>.collect(Collectors.summingInt(Employee::getSalary)));
</code></pre>

<p>```</p>

<h4>2.1.2 for-each</h4>

<p>```java
for (Object o : collection)</p>

<pre><code>System.out.println(o);
</code></pre>

<p>```</p>

<h4>2.1.3 Iterator</h4>

<p>```java
public interface Iterator<E> {</p>

<pre><code>boolean hasNext();
E next();
void remove(); //optional
</code></pre>

<p>}
```</p>

<p>注意remove方法删除最后一次next()方法返回的对象。因此，每调用一次remove方法之前都必须调用next方法，否则会抛出异常。remove方法也是迭代过程中唯一安全的修改Collection的方法。以下场景需要使用Iterator而不是for-each:</p>

<ul>
<li>删除当前元素</li>
<li>并行遍历多个Collection</li>
</ul>


<p>下面的代码演示了如何使用Iterator过滤Collection:</p>

<p>```java
static void filter(Collection&lt;?> c) {</p>

<pre><code>for (Iterator&lt;?&gt; it = c.iterator(); it.hasNext(); )
    if (!cond(it.next()))
        it.remove();
</code></pre>

<p>}
```</p>

<h3>2.2 Collection批量操作</h3>

<p>Collection批量操作的方法大部分返回值都是boolean，如果Collection有变化则返回true:</p>

<ul>
<li><code>boolean containsAll(Collection&lt;?&gt; c)</code></li>
<li><code>boolean addAll(Collection&lt;? extends E&gt; c)</code></li>
<li><code>boolean removeAll(Collection&lt;?&gt; c)</code></li>
<li><code>boolean retainAll(Collection&lt;?&gt; c)</code>（取交集）</li>
<li><code>void clear()</code>.</li>
</ul>


<p>Collections.singleton(T o)用于创建包含一个元素“o”的Set，类似的方法还包括：<code>List&lt;T&gt; singletonList(T o)</code>， <code>&lt;K,V&gt; Map&lt;K,V&gt; singletonMap(K key, V value)</code>。示例：</p>

<p><code>
//移除某个元素的所有实例
c.removeAll(Collections.singleton(e));
//移除所有null
c.removeAll(Collections.singleton(null));
</code></p>

<h3>2.3 Collections工具类</h3>

<p>除了singleton方法，Collections工具类还有一些常用的方法，如：</p>

<ul>
<li><code>unmodifiableXXX()</code>返回一个只读视图。(xxx可能是Collection, List, Map, Set, SortedMap, SortedSet)</li>
<li><code>synchronizedXXX()</code>返回一个同步（线程安全）的Collection。</li>
<li><code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>方法</li>
<li><code>shuffle</code>方法（打乱顺序）</li>
<li><code>min/max</code> 可传Comparator</li>
<li><code>copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</code> 复制所有元素到另一个List。dest的数量必须大于等于src，操作完成后，src中的所有元素会覆盖dest中相应位置（index）的元素。</li>
<li><code>int frequency(Collection&lt;?&gt; c,Object o)</code> 返回c中o出现的次数。</li>
<li><code>fill(List&lt;? super T&gt; list, T obj)</code> 将所有元素替换成obj。</li>
</ul>


<h3>2.4 Array操作</h3>

<p>Collection提供了toArray()方法，用于转换成数组。示例：</p>

<p><code>
Object[] a = c.toArray();
</code></p>

<p>如果已知Collection中的元素是字符串类型，如Collection<String> c，则可以直接转换成字符串数组：</p>

<p><code>
String[] a = c.toArray(new String[0]);  //0没有意义，只是和new String一起表示是字符串数组。
</code></p>

<h2>3. Set</h2>

<p>Set是一种不能包含重复元素的Collection。Set接口只继承了Collection接口的方法，并增加了禁止重复元素的限制，它依赖于equals和hashCode方法的行为。Set包括三种类型：</p>

<ul>
<li>HashSet 元素保存在hash表中，高性能，但无法保证迭代顺序。</li>
<li>TreeSet 元素保存在红黑树中，有序，但比HashSet慢不少。</li>
<li>LinkedHashSet hash表加linked list实现，顺序为插入顺序。避免HashSet顺序的不确定性，同时性能接近HashSet。</li>
</ul>


<p>对于HashSet，需要注意的是遍历性能与entry数量和bucket数量(容量)之和成线性关系。如果初始容量太大，则浪费空间和时间；反过来，如果初始容量太小则浪费增容时的复制时间。如果不指定初始容量，默认值为16. 过去通过指定一个初始容量能提高性能，但现在已经没必要了。LinkedHashSet的迭代时间与容量没有关系。</p>

<p>除了上面三种标准Set实现，还有两个特殊的Set实现：EnumSet和CopyOnWriteArraySet.</p>

<p>EnumSet是用于枚举类型的高性能Set实现。所有元素必须是同一种枚举类型。内部采用bit-vector实现，通常是一个long。它支持在指定范围内遍历，也可以替代传统的标志位。示例如下：</p>

<p>```
for (Day d : EnumSet.range(Day.MONDAY, Day.FRIDAY))</p>

<pre><code>System.out.println(d);
</code></pre>

<p>EnumSet.of(Style.BOLD, Style.ITALIC)
```</p>

<p>CopyOnWriteArraySet是由copy-on-write数组实现的Set. 所有修改操作，如add, set, remove都会复制一个新的数组拷贝，因此不需要锁。只适合于很少修改、但频繁遍历的Set。</p>

<p>HashSet、TreeSet和LinkedHashSet的实现并不是同步的。因此如果多个线程同时访问一个Set，且有线程会修改Set，就必须进行同步处理，或者使用Collections.synchronizedSet方法对其封装。最好在创建时就完成此操作，以HashSet为例：</p>

<p><code>
Set s = Collections.synchronizedSet(new HashSet(...));
</code></p>

<h3>3.1 基本操作</h3>

<p>假设你有一个Collection c，下面的代码可以让你方便地去除重复：</p>

<p>```java
Collection<Type> noDups = new HashSet<Type>&copy;;
//如果要保持原来的顺序，可以：
Collection<Type> noDups = new LinkedHashSet<Type>&copy;;</p>

<p>//如果是JDK8，你还可以这么玩：
c.stream().collect(Collectors.toSet()); // no duplicates
//另一个例子，将姓名放到一个TreeSet中
Set<String> set = people.stream()
.map(Person::getName)
.collect(Collectors.toCollection(TreeSet::new));
```</p>

<table>
<thead>
<tr>
<th>方法 </th>
<th> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>int size() </td>
<td> 返回元素数量</td>
</tr>
<tr>
<td>boolean isEmpty() </td>
<td> 是否为空</td>
</tr>
<tr>
<td>boolean add() </td>
<td> 增加元素，如果之前不存在，返回true</td>
</tr>
<tr>
<td>boolean remove() </td>
<td> 删除元素，如果之前存在此元素，返回true</td>
</tr>
<tr>
<td><code>Iterator&lt;E&gt; iterator()</code> </td>
<td> 迭代器</td>
</tr>
</tbody>
</table>


<p>JDK8聚合操作与for-each操作示例：</p>

<p>```java
//JDK8
public class FindDups {</p>

<pre><code>public static void main(String[] args) {
    Set&lt;String&gt; distinctWords = Arrays.asList(args).stream()
        .collect(Collectors.toSet()); 
    System.out.println(distinctWords.size()+ 
          " distinct words: " + distinctWords);
}
</code></pre>

<p>}
//for-each
public class FindDups {</p>

<pre><code>public static void main(String[] args) {
    Set&lt;String&gt; s = new HashSet&lt;String&gt;();
    for (String a : args)
       s.add(a);
    System.out.println(s.size() + " distinct words: " + s);
}
</code></pre>

<p>}
//运行
java FindDups i came i saw i left
//结果：
4 distinct words: [left, came, saw, i]
```</p>

<p>上面的代码使用的是HashSet，所以顺序是乱的。如果你改成TreeSet/LinkedHashSet，则结果变为：</p>

<p><code>
//TreeSet
4 distinct words: [came, i, left, saw]
//LinkedHashSet
4 distinct words: [i, came, saw, left]
</code></p>

<h3>3.2 批量操作</h3>

<p>Set的批量操作并没有什么特殊的方法，但是利用Set元素不会重复这个特性，可以做一些有意思的事情。例如修改FindDups，找到不重复的单词和重复的单词：</p>

<p>```
public class FindDups2 {</p>

<pre><code>public static void main(String[] args) {
    Set&lt;String&gt; uniques = new HashSet&lt;String&gt;();
    Set&lt;String&gt; dups    = new HashSet&lt;String&gt;();

    for (String a : args)
        if (!uniques.add(a))
            dups.add(a);

    // Destructive set-difference
    uniques.removeAll(dups);

    System.out.println("Unique words:    " + uniques);
    System.out.println("Duplicate words: " + dups);
}
</code></pre>

<p>}</p>

<p>//output:
Unique words:    [left, saw, came]
Duplicate words: [i]
```</p>

<h3>3.3 HashSet</h3>

<p>HashSet通过hash table（实际上就是一个HashMap实例）实现。允许null元素。基本方法（如add, remove, contains, size）为常量时间，而遍历性能则与元素数量加桶数量之和成正比。因此，如果迭代性能要求高的话，不要将初始容量设置得太大。</p>

<h3>3.4 TreeSet</h3>

<p>TreeSet是基于TreeMap的NavigableSet实现。元素按natural ordering或Comparator排序。注意要正确地实现Set接口，就应该让Comparable与equals接口实现保持一致。因为Set不重复由equals决定，而顺序由Comparable决定。TreeSet提供降序或升序视图，但升序一般比降序性能更优。</p>

<p>TreeSet允许null元素，但一些方法的返回值也可能是null（不存在时），这样就会造成混乱。因此建议不要加入null元素。基本操作（add, remove, contains）的时间成本为log(n). TreeSet增加了NavigableSet接口的方法，常用方法如下表：</p>

<table>
<thead>
<tr>
<th>方法 </th>
<th> 说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>E ceiling(E e) </td>
<td> 返回大于等于e的最小元素，如果没有返回null</td>
</tr>
<tr>
<td>E higher(E e) </td>
<td> 返回大于e的最小元素，如果没有返回null</td>
</tr>
<tr>
<td>E floor(E e) </td>
<td> 返回小于等于e的最大元素，如果没有返回null</td>
</tr>
<tr>
<td>E lower(E e) </td>
<td> 返回小于e的最大元素，如果没有返回null</td>
</tr>
<tr>
<td><code>Iterator&lt;E&gt;</code> descendingIterator() </td>
<td> 返回降序迭代器。</td>
</tr>
<tr>
<td><code>NavigableSet&lt;E&gt;</code> descendingSet() </td>
<td> 返回降序视图</td>
</tr>
<tr>
<td>E first() </td>
<td> 返回第一个（最小的）元素</td>
</tr>
<tr>
<td>E last() </td>
<td> 返回最后一个（最大的）元素</td>
</tr>
<tr>
<td><code>NavigableSet&lt;E&gt;</code> headSet(E toElement, boolean inclusive) </td>
<td> 返回小于toElement的元素，如果inclusive=true表示返回结果包含toElement。</td>
</tr>
<tr>
<td><code>NavigableSet&lt;E&gt;</code> tailSet(E fromElement, boolean inclusive) </td>
<td> 返回大于（等于，如果inclusive=true）的元素。</td>
</tr>
<tr>
<td>E pollFirst() </td>
<td> Retrieves and removes the first (lowest) element, or returns null if this set is empty.</td>
</tr>
<tr>
<td>E pollLast() </td>
<td> Retrieves and removes the last (highest) element, or returns null if this set is empty.</td>
</tr>
<tr>
<td><code>NavigableSet&lt;E&gt;</code> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) </td>
<td> 取子集。</td>
</tr>
<tr>
<td>Object clone() </td>
<td> 返回TreeSet实例的浅拷贝</td>
</tr>
</tbody>
</table>


<h3>3.5 LinkedHashSet</h3>

<p>LinkedHashSet会保持插入的顺序，但是如果多次添加一个元素，并不会改变元素原来的的位置。允许null元素。</p>

<p>与HashSet一样，有两个参数影响其性能：初始容量和load factor。</p>

<h3>3.6 EnumSet</h3>

<p>EnumSet的所有元素必须是同一个枚举类型的值，不允许null元素。它的效率很高，是替代传统标志位的推荐方案，用long实现。Iterator按自然顺序（枚举中声明的顺序）返回元素。常用方法如下表：</p>

<table>
<thead>
<tr>
<th>方法</th>
<th> 说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt;  allOf(Class&lt;E&gt; elementType)</code> </td>
<td> 创建一个包括枚举类型所有值的EnumSet</td>
</tr>
<tr>
<td><code>EnumSet&lt;E&gt; clone()</code> </td>
<td> 复制一份。</td>
</tr>
<tr>
<td><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; complementOf(EnumSet&lt;E&gt; s)</code> </td>
<td> 创建一个同类型的EnumSet，其中的元素为枚举类型所有值减去s中的值。</td>
</tr>
<tr>
<td><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; copyOf(Collection&lt;E&gt; c)</code> </td>
<td> 创建EnumSet，元素来自c。</td>
</tr>
<tr>
<td><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType)</code> </td>
<td> 创建一个空的EnumSet</td>
</tr>
<tr>
<td><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; of(E e, E... rest)</code> </td>
<td> 创建包括指定元素的EnumSet</td>
</tr>
<tr>
<td><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; range(E from, E to)</code> </td>
<td> 创建指定元素范围的EnumSet</td>
</tr>
</tbody>
</table>


<h3>3.7 CopyOnWriteArraySet</h3>

<p>CopyOnWriteArraySet内部使用CopyOnWriteArrayList来实现所有操作。因此：</p>

<ul>
<li>最适合那些size小，读操作远多于修改操作，在遍历中需要防止其它线程干扰的场景。</li>
<li>它是线程安全的。</li>
<li>修改操作成本较高，因为通常要复制整个数组。</li>
<li>Iterator不支持remove操作。</li>
<li>通过iterator遍历很快，不会受其它线程影响，因为它依赖一个在iterator创建时的数组只读镜像。</li>
</ul>


<p>示例代码：</p>

<p>```
class Handler { void handle(); &hellip; }</p>

<p>class X {
   private final CopyOnWriteArraySet<Handler> handlers</p>

<pre><code> = new CopyOnWriteArraySet&lt;Handler&gt;();
</code></pre>

<p>   public void addHandler(Handler h) { handlers.add(h); }</p>

<p>   private long internalState;
   private synchronized void changeState() { internalState = &hellip;; }</p>

<p>   public void update() {</p>

<pre><code> changeState();
 for (Handler handler : handlers)
   handler.handle();
</code></pre>

<p>   }
}
```</p>

<h2>4. List接口</h2>

<p>List接口继承自Collection，它比后者增加了以下类型的方法：</p>

<ul>
<li>Positional access 基于位置的访问方法，如get, set, addAll</li>
<li>Search 搜索指定对象并返回数字索引，如indexOf, lastIndexOf</li>
<li>Iteration 继承Iterator，增加增了List的特性。ListIterator。</li>
<li>Rang-View sublist方法提供range相关操作。</li>
</ul>


<p>Java提供两种普通List实现：ArrayList和LinkedList，前者通常有更好的性能，后者在特定场景有更好性能。如果你需要频繁地在List的起始位置插入元素，或者频繁遍历元素并删除，则使用LinkedList更合适。</p>

<p>另一个特殊的实现是CopyOnWriteArrayList，与CopyOnWriteArraySet类似。无需同步操作，不会有ConcurrentModificationException.</p>

<p>Arrays工具类提供了<code>asList()</code>方法，这样可以用List的方式查看数组。但是该操作并不是复制整个数组，对List的修改操作将会影响array，反过来也是如此。因此这个List并不是真正的List，它没有add, remove方法，因为数组不是变长的。如果List是定长的，也没有containsAll之类的bulk操作，可以考虑使用Arrays.asList。</p>

<p>ListIterator提供两个方向迭代的能力，因此多了hasPrevious和previous方法。ListIterator的构造方法有两种格式，默认格式不带参数，表示从头遍历。带int参数的格式表示从指定位置遍历。ListIterator提供了安全的修改方法add, remove和set。它们能够在迭代的过程中安全地修改List的内容。</p>

<ul>
<li>add()方法，在List当前位置插入一个对象。所谓当前位置就是：add方法增加对象后，调用previous()方法将返回这个对象。</li>
<li>remove()方法，将当前元素删除。所谓当前元素就是：如果刚调用了next()或previous()方法，当前元素就是它们返回的元素。注：每调用一次remove()，都需要先调用一次next()或者previous()，如果刚调用了add()，也必须先调用一次next()或者previous()。</li>
<li>set()方法，更新当前元素。当前元素的定义与remove()方法相同。每次set()之前，也必须调用next()或previous()。</li>
</ul>


<p><code>subList(int fromIndex, int toIndex)</code>方法提供了range-view操作。由于subList返回的只是List的一个view，因此对返回结果的修改会影响原List。例如下面的代码删除指定范围内的数据：</p>

<p><code>
list.subList(fromIndex, toIndex).clear();
</code></p>

<h3>4.1 LinkedList</h3>

<p>Doubly-linked列表，实现了List和Deque接口。由于是链表结构，因此基于索引的操作将导致从头遍历。常用的方法：</p>

<table>
<thead>
<tr>
<th>方法 </th>
<th> 说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void addFirst(E e)</code> </td>
<td> 在最前面插入</td>
</tr>
<tr>
<td><code>void addLast(E e)</code> </td>
<td> 加到最后面</td>
</tr>
<tr>
<td><code>boolean offer(E e)</code>, <code>boolean offerFirst(E e)</code>, <code>boolean offerLast(E e)</code> </td>
<td> 增加操作。默认是加到最后。如果操作成功返回true</td>
</tr>
<tr>
<td><code>E element()</code> </td>
<td> 获取但不删除第1个元素</td>
</tr>
<tr>
<td><code>E getFirst()/getLast()</code> </td>
<td> 返回第1个/最后一个元素</td>
</tr>
<tr>
<td><code>E peek()</code> </td>
<td> 获取但不移除第一个元素</td>
</tr>
<tr>
<td><code>E peekFirst()/peakLast()</code> </td>
<td> 获取但不移除第一个/最后一个元素，如果list为空则返回null</td>
</tr>
<tr>
<td><code>E poll()</code> </td>
<td> 获取并删除第1个元素, 如果list为空则抛出NoSuchElementException</td>
</tr>
<tr>
<td><code>E pollFirst()/pollLast()</code> </td>
<td> 获取并删除第一个/最后一个元素，如果list为空则返回null, 如果list为空则抛出NoSuchElementException</td>
</tr>
<tr>
<td><code>E pop()</code> </td>
<td> stack pop</td>
</tr>
<tr>
<td><code>void push(E e)</code> </td>
<td> stack push</td>
</tr>
<tr>
<td><code>boolean remove(Object o)</code>, <code>E removeFirst()</code>, <code>boolean removeFirstOccurrence(Object o)</code>, <code>E removeLast()</code>, <code>boolean removeLastOccurrence(Object o)</code> </td>
<td> 与删除相关的操作，如果list为空则抛出NoSuchElementException</td>
</tr>
</tbody>
</table>


<h3>4.2 Stack</h3>

<table>
<thead>
<tr>
<th>方法 </th>
<th> 说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>boolean empty()</code> </td>
<td> Tests if this stack is empty.</td>
</tr>
<tr>
<td><code>E peek()</code> </td>
<td> Looks at the object at the top of this stack without removing it from the stack.</td>
</tr>
<tr>
<td><code>E pop()</code> </td>
<td> Removes the object at the top of this stack and returns that object as the value of this function.</td>
</tr>
<tr>
<td><code>E push(E item)</code> </td>
<td> Pushes an item onto the top of this stack.</td>
</tr>
<tr>
<td>int search(Object o) </td>
<td> Returns the 1-based position where an object is on this stack</td>
</tr>
</tbody>
</table>


<h2>5. Queue接口</h2>

<p>Queue接口增加了以下方法，它们的返回值有两种类型：抛出异常、返回特殊值：</p>

<p>```
public interface Queue<E> extends Collection<E> {</p>

<pre><code>E element();
boolean offer(E e);
E peek();
E poll();
E remove();
</code></pre>

<p>}
```</p>

<table>
<thead>
<tr>
<th>操作类型 </th>
<th> 抛出异常 </th>
<th> 返回特殊值</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入操作 </td>
<td> add(e) </td>
<td> offer(e) 成功返回true</td>
</tr>
<tr>
<td>删除操作 </td>
<td> remove() 队列为空时异常 </td>
<td> poll() 队列为空返回null</td>
</tr>
<tr>
<td>检查操作 </td>
<td> element() 队列为空时异常 </td>
<td> peek() 队列为空返回null</td>
</tr>
</tbody>
</table>


<p>队列通常是FIFO的行为，但优先队列的顺序取决于它的值。java.util.concurrent下的一些队列有数量限制（bounded），但java.util下的队列没有数量限制。java.util.concurrent.BlockingQueue 继承自Queue，提供了阻塞的机制。</p>

<h3>5.1 普通队列</h3>

<p>LinkedList实现了Queue接口，提供FIFO队列操作add, poll等等。优先队列PriorityQueue的顺序取决于元素的natural ordering或构造方法的Comparator参数。</p>

<h3>5.2 多线程队列</h3>

<p>java.util.concurrent.BlockingQueue继承自Queue，其实现是线程安全的。所有队列方法使用内部锁或其它多线程控制实现原子操作。但是bulk操作，如addAll, containsAll, retainAll, removeAll并没有实现原子操作。例如<code>addAll(c)</code>执行时，如果另一线程在c中添加了元素则会导致addAll失败。</p>

<p>BlockingQueue不支持null元素。它可能有数量限制，否则最大为Integer.MAX_VALUE。它的方法有四种模式：</p>

<table>
<thead>
<tr>
<th>操作类型 </th>
<th>Throws exception </th>
<th> Special value </th>
<th> Blocks </th>
<th> Times out</th>
</tr>
</thead>
<tbody>
<tr>
<td>Insert</td>
<td>add(e) </td>
<td> offer(e)</td>
<td> put(e) </td>
<td> offer(e, time, unit)</td>
</tr>
<tr>
<td>Remove</td>
<td>remove() </td>
<td> poll() </td>
<td> take() </td>
<td> poll(time, unit)</td>
</tr>
<tr>
<td>Examine</td>
<td>element() </td>
<td> peek() </td>
<td> not applicable </td>
<td> not applicable</td>
</tr>
</tbody>
</table>


<p>JDK提供了以下实现：</p>

<ul>
<li>LinkedBlockingQueue — an optionally bounded FIFO blocking queue backed by linked nodes</li>
<li>ArrayBlockingQueue — a bounded FIFO blocking queue backed by an array</li>
<li>PriorityBlockingQueue — an unbounded blocking priority queue backed by a heap</li>
<li>DelayQueue — a time-based scheduling queue backed by a heap</li>
<li>SynchronousQueue — a simple rendezvous mechanism that uses the BlockingQueue interface</li>
<li>LinkedTransferQueue — an unbounded TransferQueue based on linked nodes</li>
</ul>


<h2>6. Deque接口</h2>

<p>音（deck），支持从两端插入和删除的队列。它同时包含了Queue和Stack接口方法。ArrayDeque和LinkedList实现了Deque接口。Deque支持FIFO和LIFO。</p>

<p>相关的方法参考LinkedList。LinkedBlockingDeque实现了多线程Deque。</p>

<h2>7. Map接口</h2>

<p>Java提供了三种通用的Map实现：HashMap, TreeMap和LinkedHashMap。它们的行为与HashSet, TreeSet和LinkedHashSet相似。如果你想要有序的Map，能够提供有序的keySet，使用TreeMap；如果想要最优性能，使用HashMap。如果既想要高性能，又想保持插入的顺序，使用LinkedHashSet。</p>

<p>JDK8中引入了相关的聚合操作，示例如下：</p>

<p>```
// Group employees by department
Map&lt;Department, List<Employee>> byDept = employees.stream()</p>

<pre><code>.collect(Collectors.groupingBy(Employee::getDepartment));
</code></pre>

<p>// Compute sum of salaries by department
Map&lt;Department, Integer> totalByDept = employees.stream()</p>

<pre><code>.collect(Collectors.groupingBy(Employee::getDepartment, Collectors.summingInt(Employee::getSalary)));
</code></pre>

<p>// Partition students into passing and failing
Map&lt;Boolean, List<Student>> passingFailing = students.stream()</p>

<pre><code>.collect(Collectors.partitioningBy(s -&gt; s.getGrade()&gt;= PASS_THRESHOLD)); 
</code></pre>

<p>// Classify Person objects by city
Map&lt;String, List<Person>> peopleByCity</p>

<pre><code>= personStream.collect(Collectors.groupingBy(Person::getCity));
</code></pre>

<p>//cascade two collectors to classify people by state
Map&lt;String, Map&lt;String, List<Person>>> peopleByStateAndCity</p>

<pre><code>= personStream.collect(Collectors.groupingBy(Person::getState,
</code></pre>

<p>  Collectors.groupingBy(Person::getCity)))
```</p>

<p>Map提供了Collecton view，有三种方法：</p>

<ul>
<li>keySet 所有key的集合</li>
<li>values 所有值。这不是一个Set，因为value会有重复。</li>
<li>entrySet 所有key-value的集合</li>
</ul>


<p>Map的遍历方法有多种：</p>

<p>```
for (KeyType key : m.keySet())</p>

<pre><code>System.out.println(key);
</code></pre>

<p>// Filter a map based on some
// property of its keys.
for (Iterator<Type> it = m.keySet().iterator(); it.hasNext(); )</p>

<pre><code>if (it.next().isBogus())
    it.remove();
</code></pre>

<p>for (Map.Entry&lt;KeyType, ValType> e : m.entrySet())</p>

<pre><code>System.out.println(e.getKey() + ": " + e.getValue());            
</code></pre>

<p>```</p>

<p>不用担心Map创建Collection view的性能。通过Collecton view iterator遍历时，可以调用Iterator的remove方法来删除map中的键值对。利用Map.Entry遍历时也可以调用entry.setValue方法来修改值。Collection view支持remove, removeAll, retainAll, clear, Iterator.remove操作。例如，以下命令会清空所有数据：</p>

<p><code>
Set&lt;Integer&gt; set = map.keySet();
set.clear();
</code></p>

<p>Map的Collection view在很多场合能起到便利作用。以下是一些示例：</p>

<p>```
//判断一个Map的key是否包含另一个Map的key
if (m1.entrySet().containsAll(m2.entrySet())) {</p>

<pre><code>...
</code></pre>

<p>}</p>

<p>//判断两个Map的key是否相同
if (m1.keySet().equals(m2.keySet())) {</p>

<pre><code>...
</code></pre>

<p>}</p>

<p>//判断两个Map的key交集（注意新建了一个set，避免对Map产生影响）
Set<KeyType>commonKeys = new HashSet<KeyType>(m1.keySet());
commonKeys.retainAll(m2.keySet());
```</p>

<h3>7.1 LinkedHashMap</h3>

<p>LinkedHashMap的顺序通常是插入顺序，同一元素多次重复插入并不会修改它的位置。</p>

<p>LinkedHashMap还提供了一个特殊的构造方法，它创建的LinkedHashMap顺序是entry被访问的顺序。元素的访问时间越近，则它越靠前。因此这种LinkedHashMap非常适合做LRU(least recently used)缓存。构造方法如下：</p>

<p>```
public LinkedHashMap(int initialCapacity,</p>

<pre><code>                 float loadFactor,
                 boolean accessOrder)
</code></pre>

<p>```</p>

<p>影响这种LinkedHashMap元素顺序的访问方法包括：put, putInfoAbsent, get, getOrDefault, compute, computeIfAbsent, computeIfPresent, merge, replace(如果之前存在，替换动作成功)和putAll方法。其中putAll方法会对指定map中的所有元素都产生一次访问，访问的顺序取决于指定map的entryset iterator。除了以上方法外，其他方法都不会影响元素顺序，特别是作用于Collection view的方法也不会对元素顺序产生影响。</p>

<p>覆盖removeEldestEntry(Map.Entry)方法可以在Map移除旧Entry时自定义一些策略。</p>

<p>LinkedHashMap性能接近于HashMap，在遍历时性能比HashMap更优。因为LinkedHashMap的迭代性能只与size相关，而HashMap还与容量相关。</p>

<h3>7.2 其它Map实现类</h3>

<p>除了HashMap, TreeMap和LinkedHashMap, 还有一些其它的Map实现：</p>

<ul>
<li>EnumMap与EnumSet类似。</li>
<li>WeakHashMap 弱引用，便于垃圾收集</li>
<li>IdentityHashMap 在此Map中，当且仅当k1==k2时，认为两个key是相等的。（HashMap判断相等使用的是equals）很少用。</li>
<li>ConcurrentHashMap 高并发、高性能的Map。线程安全。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Web中文编码]]></title>
    <link href="http://blog.ubone.com/blog/2015/02/23/java-webzhong-wen-bian-ma/"/>
    <updated>2015-02-23T15:57:18+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/02/23/java-webzhong-wen-bian-ma</id>
    <content type="html"><![CDATA[<p>介绍常见的编码格式，以及Java Web和JavaScript相关的字符集编码。</p>

<!--more-->


<h2>1. 常见的编码格式</h2>

<table>
<thead>
<tr>
<th>编码 </th>
<th> 说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ASCII </td>
<td> 共128个，用1个字节表示。0～31为控制字符，如换行、回车等。32～126为打印字符。</td>
</tr>
<tr>
<td>ISO-8859-1 </td>
<td> 扩展ASCII编码，仍然是单字节，共256个字符。</td>
</tr>
<tr>
<td>GB2312 </td>
<td> 双字节编码，A1~A9是符号区，共682个符号；B0~F7是汉字区，共6763个汉字</td>
</tr>
<tr>
<td>GBK </td>
<td> 为Win95所制定的汉字内码规范，扩展GB2312，与GB2312兼容，能表示21003个汉字。</td>
</tr>
<tr>
<td>GB18030 </td>
<td> 可能是单字节、双字节或者四字节编码，与GB2312兼容。虽然是国家标准，但未广泛使用。</td>
</tr>
<tr>
<td>UTF-16 </td>
<td> 定义了Unicode字符在计算机中的存取方法。Unicode是ISO试图创建一个全新的超语言字典，世界上所有语言都可以通过这个字典相互翻译。Unicode是Java和XML的基础。UTF-16用两个字节来表示Unicode的转化格式，采用定长的表示方法。</td>
</tr>
<tr>
<td>UTF-8 </td>
<td> 避免UTF-16的空间浪费，采用变长技术，每个编码区域有不同的字码长度。不同类型的字符可以由1～6个字节组成。</td>
</tr>
</tbody>
</table>


<p>UTF-8的编码规则：</p>

<ul>
<li>如果是1个字节，最高位（第8位）为0，表示1个ASCII字符。</li>
<li>如果是1个字节，以11开着，则连续的1的个数表示这个字符的字节数。例如110xxxxx表示它是双字节UTF-8字符的首字节。</li>
<li>如果1个字节，以10开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节。</li>
</ul>


<h2>2. Java中的编码场景</h2>

<h3>2.1 在I/O中编码</h3>

<p>在磁盘和网络I/O中，都涉及字节与字符的转换。Reader类是Java的I/O中读字符的父类，而InputStream类是读字节的父类。两者之间的转换由StreamDecoder和StreamEncoder完成。在编、解码过程中必须指定Charset，否则使用本地环境默认字符集，如中文环境使用GBK。</p>

<p>在实际开发过程中，只要保持编码的一致就不会造成乱码：</p>

<p>```java
String charset = &ldquo;UTF-8&rdquo;;
String file = &ldquo;c:/stream.txt&rdquo;;</p>

<p>FileOutputStream fos = new FieOutputStream(file);
OutputStreamWriter writer = new OutputStreamWriter(fos, charset);</p>

<p>&hellip;
InputStreamReader reader = new InputStreamReader(inputStream, charset);
```</p>

<h3>2.2 在内存中编码</h3>

<p>String类提供了字符和字节的转换方法：</p>

<p><code>java
String s= "这是一段中文";
byte[] b = s.getBytes("UTF-8");
String n = new String(b, "UTF-8");
</code></p>

<p>另一种方法是使用Charset类：</p>

<p><code>java
Charset charset = Charset.forName("UTF-8");
ByteBuffer byteBuffer = charset.encode("abcd");
CharBuffer charBuffer = charset.decode(byteBuffer);
</code></p>

<h2>3. Java Web中的编解码</h2>

<p>用户从浏览器发起一个HTTP请求，需要编码的地方包括URL、Cookie和Parameter。</p>

<h3>3.1 URL的编解码</h3>

<p>URL <code>http://localhost:8080/examples/servlets/servlet/books?author=jason</code> 可分解为：</p>

<ul>
<li>URI: <code>/examples/servlets/servlet/books</code></li>
<li>schema: http</li>
<li>domain: localhost</li>
<li>port: 8080</li>
<li>contextPath: examples</li>
<li>servletPath: servlets/servlet</li>
<li>PathInfo: books</li>
<li>QueryString: author=jason</li>
</ul>


<p>对于Tomcat，对URL的URI部分进行解码的字符集是在Connector中定义的。如果没有定义，那么默认为ISO-8859-1。QueryString的解码字符集要么是Header中ContentType定义的Charset，要么是默认的ISO-8859-1。要使用ContentType定义的编码，需要设置Connector。因此Tomcat一般会设置：</p>

<p><code>&lt;Connector URIEncoding="UTF-8" useBodyEncodingForURI="true" /&gt;</code></p>

<h3>3.2 HTTP Header的编解码</h3>

<p>除了URL外，还可能在Header中传递其它参数，如Cookie、redirectPath等。不要在Header中传递非ASCII字符，如果一定要传递，可以先用URLEncoder编码，再添加到Header中。</p>

<h3>3.3 其它编解码</h3>

<p>POST表单也是通过ContentType的Charset编码。用JDBC来存取数据时要和数据的内置编码保持一致，可以通过设置JDBC URL来指定，如MySQL: url=&ldquo;jdbc:mysql://localhost:3306/DB?useUnicode=true&amp;characterEncoding=GBK"。</p>

<h2>4. Javascript中的编码问题</h2>

<p>如果Javascript文件的编码格式与当前页面不一致，需要指定字符集，否则可能出现乱码：<code>&lt;script src="abc.js" charset="gbk"/&gt;</code>。在Javascript中处理URL可以使用<code>encodeURI()</code>和<code>encodeURIComponent()</code>。后者编码得更彻底，除了<code>!</code>、<code>'</code>、<code>(</code>、<code>)</code>、<code>*</code>、<code>-</code>、<code>.</code>、<code>_</code>、<code>~</code>、<code>0-9</code>、<code>a-z</code>和<code>A-Z</code>之外，对其他所有字符都编码，因此通常用于将一个URL当作一个参数放在另一个URL中。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java内存模型与线程]]></title>
    <link href="http://blog.ubone.com/blog/2015/01/31/javanei-cun-mo-xing-yu-xian-cheng/"/>
    <updated>2015-01-31T19:45:39+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/01/31/javanei-cun-mo-xing-yu-xian-cheng</id>
    <content type="html"><![CDATA[<p>学习并发编程，需要了解Java内存模型与线程。</p>

<!--more-->


<h2>1. 硬件的基础</h2>

<p>为了提高效率，现在的CPU都有一层读写速度接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存中。</p>

<p>对于多处理器系统，每个处理器都有自己的高速缓存，而它们又共享同一个主内存。因此就存在缓存一致性的问题。当多个处理器的运算任务都涉及同一块主内存区域时，就可能导致各自的缓存数据不一致。为了解决一致性问题，需要遵循一些协议（如MSI, MESI, MOSI等）。</p>

<p><img src="/myresource/images/image_blog_-2015-01-31-19.55.58.png" alt="image" /></p>

<p>乱序执行（Out-Of-Order Execution）优化。为了使处理器内部的运算单元能尽量充分利用，处理器可能会对代码进行乱序执行优化，在计算之后将结果重组，保证该结果与顺序执行的结果一致。也就是处理器并不保证各条语句执行的先后顺序与输入顺序一致。JIT也有类似的指令重排序（Instruction Recorder）优化。</p>

<h2>2. Java内存模型</h2>

<h3>2.1 主内存与工作内存</h3>

<p>JVM规范定义了Java内存模型来屏蔽各种硬件和OS的内存访问差异。该模型规定所有变量都存储在主内存（仅是虚拟机内存的一部分）中，每条线程还有自己的工作内存，线程的工作内存保存了该线程使用到的变量（不是对象，而是对象的引用）的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p>

<p><img src="/myresource/images/image_blog_-2015-01-31-20.27.06.png" alt="image" /></p>

<h3>2.2 内存间交互操作</h3>

<p>关于主内存与工作内存之间的交互，Java内存模型定义了8种操作来完成，每种操作都是原子操作。</p>

<ul>
<li>lock: 作用于主内存变量，把一个变量标识为一条线程独占状态</li>
<li>unlock: 作用于主内存变量，释放一个锁定的变量，可以被其他线程锁定</li>
<li>read: 作用于主内存变量，把一个变量的值从主内存传输到线程的工作内存中，以便load动作使用。</li>
<li>load: 作用于工作内存变量，把read操作从主内存中得到的变量值放入工作内存变量副本中。</li>
<li>use: 作用于工作内存变量，把工作内存中的变量的值传递给执行引擎。每当虚拟机遇到一个需要使用变量的值的字节码指令时会执行这个操作。</li>
<li>assign: 作用于工作内存变量，把从执行引擎接收到的值赋给工作内存变量。每当虚拟机遇到一个给变量赋值的字节码指令时执行此操作。</li>
<li>store: 作用于工作内存变量，把工作内存中一个变量的值传送到主内存中，以便write操作使用。</li>
<li>write: 作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>


<h3>2.3 volatile变量</h3>

<h4>2.3.1 可见性</h4>

<p>对于volatile变量，具备两个特性：一是保证此变量对所有线程的可见性，即当一个线程修改了这个变量的值，新值对于其他线程来说可以立即得知。实际上volatile变量在各线程的工作内存中也可以存在不一致的情况，但是由于使用之前都要先刷新，因此可以认为不存在一致性问题。但由于Java中的运算不是原子操作，因此volatile在并发下也不一定是安全的。例如下面的代码：</p>

<p>```java
public static volatile int race = 0;</p>

<p>public static void increase() {</p>

<pre><code>race++;
</code></pre>

<p>}</p>

<p>//测试代码：
for(int i = 0; i &lt; 20; i++) {</p>

<pre><code>...//用20个线程调用increase()方法
public void run() {
    for(int j = 0; j &lt; 10000; j++) {
        increase();
    }
}
</code></pre>

<p>}</p>

<p>//当20个线程结束后，race的值通常会少于20万。
```</p>

<p>volatile变量与普通变量的区别在于，前者保证新值能立即同步到主内存，并且每次使用前都立即从主内存刷新。对于volatile变量，如果不符合以下两条规则，则仍然要通过加锁来实现同步：</p>

<ol>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ol>


<h4>2.3.2 禁止指令重排序优化</h4>

<p>volatile变量也用于禁止指令重排序。直接看伪代码：</p>

<p>```java
volatile boolean initialized = false;</p>

<p>//线程A
initConfig() //做一些初始化的工作
initialized = true;</p>

<p>//线程B
while(! initialized) { sleep();}
//使用线程A中初始化好的配置信息
doSomethingWithConfig();
```</p>

<p>如果变量initialized不声明为volatile，则指令重排序后，有可能线程A中的<code>initialized = true</code>比<code>initConfig()</code>提前执行。导致线程B无法正确获取配置信息。</p>

<h2>3. Java与线程</h2>

<p>主流操作系统都提供了线程实现，Java语言则提供了在不同硬件和操作系统平台下对线程操作的统一处理。线程实现主要有3种方式：</p>

<h3>3.1 使用内核线程实现</h3>

<p>内核线程是由操作系统内核（Kernel）支持的线程。程序并不直接使用内核线程，而是使用轻量级进程（Light Weight Process, LWP）。LWP就是我们通常意义上所讲的线程。每个LWP与内核线程是1：1关系。</p>

<p>内核线程的缺点是调用代价高，需要在用户态和内核态来回切换。同时LWP要消耗一定的内核资源。因此一个系统支持LWP的数量是有限的。</p>

<h3>3.2 使用用户线程实现</h3>

<p>用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核帮助。因此可以支持更大的线程数量，不需要切换到内核，快速且消耗低。进程与用户线程的关系为1：N关系。</p>

<p>由于没有系统内核支援，所有线程操作都需要用户程序自己处理，因此程序比较复杂。Java曾经使用过用户线程，但最终放弃使用它。</p>

<h3>3.3 使用用户线程加LWP混合实现</h3>

<p>这种混合实现方式即存在用户线程，也存在LWP。用户线程还是完全建立在用户空间中，因此创建、切换等操作依然廉价，并且可以支持大规模用户线程并发。而操作系统提供支持的LWP则作为用户线程与内核线程之间的桥梁，可以使用内核提供的线程调度功能及处理器映射，用户线程的系统调用通过LWP完成，大大降低了整个进程被完全阻塞的风险。用户线程与LWP的数量比不定，即N:M的关系。</p>

<h3>3.4 Java线程的实现</h3>

<p>JDK1.2之前使用用户线程实现。从1.2开始，线程模型基于操作系统原生线程模型来实现。对于SunJDK，Windows和Linux版都是使用1：1的线程模型，即一条Java线程映射到一条LWP。而Solaris，HP-UX等则由于操作系统的线程特性，可以同时支持1：1及N:M模型。</p>

<h2>4. 线程安全</h2>

<p>Brian Goetz对线程安全的定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。</p>

<h3>4.1 Java语言中的线程安全</h3>

<h4>4.1.1 不可变</h4>

<p>Java中不可变的对象一定是线程安全的。如果共享的数据是一个基本数据类型，只要在定义时使用了final关键字就可以保证它是不可变的。如果共享数据是一个对象，则需要保证对象的行为不会对其状态产生任何影响。</p>

<h4>4.1.2 绝对线程安全</h4>

<p>Java API中标注为线程安全的类，大多数都不是绝对的线程安全。例如java.util.Vector是线程安全的容器，其get(), remove()和size()方法都是同步的。但如果不在方法调用端做额外的同步措施，代码仍然是不安全的：</p>

<p>```java
//如果一个线程在操作Vector时，另一个线程删除了了个元素，导致i元素不可再用，就会抛出异常。
private static Vector<Integer> vector = new Vector<Integer>();</p>

<p>public static void main(String[] args) {</p>

<pre><code>while(true) {
    for(int i = 0; i &lt; 10; i++) {vector.add(i);}

    Thread removeThread = new Thread(new Runnable(){
        public void run() {
            for(int i = 0; i &lt; vector.size(); i++) {
                vector.remove(i);
            }
        }
    });

    Thread printThread = new Thread(new Runnable(){
        public void run() {
            for(int i = 0; i &lt; vector.size(); i++) {
                System.out.println((vector.get(i)));
            }
        }
    });

    removeThread.start();
    printThread.start();

    while(Thread.activeCount() &gt; 20);
}
</code></pre>

<p>}
```</p>

<h4>4.1.3 相对线程安全</h4>

<p>这就是我们平时说的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用时不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p>

<h4>4.1.4 线程兼容</h4>

<p>对象本身并不是线程安全的，但是可以在调用端正确使用同步手段来保证对象在并发环境下可以安全使用。</p>

<h4>4.1.5 线程对立</h4>

<p>无论调用端是否采取了同步措施，都无法在多线程环境中并发使用。Java中这种代码很少，但Thread的suspend()和resume()方法就是个例子。如果并发情况下，一个尝试中断，另一个尝试恢复线程，无论调用时是否进行了同步，目标线程都存在死锁风险。这两个方法已经声明为Deprecated.</p>

<h3>4.2 线程安全的实现方法</h3>

<h4>4.2.1 互斥同步</h4>

<p>Java中最基本的互斥同步手段是synchronized关键字。这是一个相对重量级的操作，因为需要进行用户态和核心态的转换。</p>

<p>ReentranLock是另一个同步实现方法。它与synchronized相比，有以下高级功能：</p>

<ul>
<li>等待可中断：如果持有锁的线程长期不释放锁，正在等待锁的线程可以选择放弃。</li>
<li>公平锁：多个线程在等待同一个锁时，必须按照申请的顺序依次获得锁。（synchronized是非公平的。 ReentranLock默认也是非公平的，但通过参数可以要求用公平锁）</li>
<li>锁绑定多个条件：一个ReentranLock对象可以同时绑定多个Condition对象。</li>
</ul>


<p>JDK6之后，虚拟机对synchronized性能进行了优化，已经与ReentranLock持平了，未来优化还会偏向于synchronized。因此如果性能满足需要时，可以优先考虑使用synchronized来同步。</p>

<h4>4.2.2 非阻塞同步</h4>

<p>互斥同步是一种悲观的并发策略，因为不论是否真的存在竞争，它都会加锁。随着硬件指令集的发展，有了另一种选择。基于冲突检测的乐观并发策略，就是先进行操作，如果没有其他线程急用共享数据，那操作就成功。如果产生了冲突，再采取其他的补偿措施。这种乐观的并发策略不需要把线程挂起，因此称为非阻塞同步。</p>

<p>非阻塞同步需要了解CAS指令。它有3个操作数，分别是内存位置（V）、旧的预期值(A)和新值（B）。CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则它就不执行更新。但是无论是否更新了V的值，都会返回V的旧值，这是一个原子操作。</p>

<p>CAS指令看起来很美，但可能产生“ABA”问题。如果V初次读取时是A，并且在准备赋值时检查到它仍然是A，并不能说明它没有被其他线程修改过。因此在此过程中，它可能被改为B，然后再改为A。这时候CAS操作就误以为它从来没有被改变过。当然大部分情况下ABA问题不会影响程序的正确性。</p>

<h3>4.3 JDK的锁优化</h3>

<h4>4.3.1 自旋锁与自适应自旋</h4>

<p>互斥同步对性能最大的影响是阻塞的实现，因为线程挂起和恢复操作都要转入内核态中完成。很多应用中共享数据的锁定状态只会持续很短的时间，为了这个时间去挂起和恢复线程并不值得。因此不妨让后面的请求线程“稍等一下”，执行一个忙循环（自旋），这就是自旋锁。</p>

<p>自旋锁如果占用时间长了，就失去了自旋的意义，因此JDK6之前的自旋锁超过10次仍然没有成功获得锁，就会改用传统的方式去挂起线程。</p>

<p>JDK6引入了自适应的自旋锁，也就是自旋的时间不固定了，会根据前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。例如前几次成功了，就认为后面也会成功。如果自旋很少成功，以后就可能直接省略自旋，避免浪费资源。</p>

<h4>4.3.2 锁消除</h4>

<p>通常基于逃逸分析，如果堆上的数据不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁就无须进行。</p>

<h4>4.3.3 锁粗化</h4>

<p>大部分情况下，我们都要将同步代码块限制得尽量小。但是如果一系列的连续操作导致对同一个对象反复加锁、解锁，虚拟机会把加锁同步的范围扩大，只需要加一次锁就行了。</p>

<h4>4.3.4 轻量级锁</h4>

<p>轻量级锁的依据是：对于绝大部分锁，在整个同步周期内都是不存在竞争的。因此可以在没有多线程竞争的前提下，减少传统重量级锁使用操作系统互斥量产生的性能消耗。实现原理是在对象头（Object Header）的内存中加入锁标志位，利用CAS操作来实现。</p>

<h4>4.3.5 偏向锁</h4>

<p>如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM字节码执行引擎]]></title>
    <link href="http://blog.ubone.com/blog/2015/01/20/jvmzi-jie-ma-zhi-xing-yin-qing/"/>
    <updated>2015-01-20T06:40:46+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/01/20/jvmzi-jie-ma-zhi-xing-yin-qing</id>
    <content type="html"><![CDATA[<p>JVM执行引擎输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。本文从概念模型的角度学习栈帧结构、方法调用和字节码执行。</p>

<!--more-->


<h2>1. 运行时栈帧结构</h2>

<p>栈帧（Stack Frame）是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素，是支持虚拟机进行方法调用和方法执行的数据结构。每个方法从调用开始到执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p>

<p>每个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和额外的附加信息。在编译生成字节码时，栈帧中需要多大的局部变量表、多深的操作数栈就已经完全确定并保存在方法表的Code属性中。</p>

<p>一个线程中的方法调用链可能很长，很多方法同时处于执行状态。但对执行引擎来说，活动线程中，只有栈顶的栈帧才是有效的，称为当前栈帧。与当前栈帧相关联的方法称为当前方法。执行引擎运行的所有字节码指令都只针对当前栈帧操作。</p>

<p><img src="/myresource/images/image_blog_-2015-01-20_06.59.02.jpg" alt="image" /></p>

<h3>1.1 局部变量表</h3>

<p>局部变量表用于存放方法参数和方法内局部变量，其容量以Variable Slot为最小单位。每个Slot可以存放32位以内的数据类型，包括boolean、byte、char、short、int、float、reference和returnAddress，对于64位的数据类型long和double，会分配2个连续的Slot。由于虚拟机栈是线程的私有数据，因此操作2个Slot不会引起数据安全问题。</p>

<p>虚拟机通过索引定位的方式使用局部变量表，索引值从0到最大Slot数量。在方法执行时，局部变量表完成参数值到数量变量列表的传递过程。如果执行的是实例方法（非static），关键字"this"是隐含参数，位于第0个索引，其余参数按照参数表顺序排列。</p>

<p>为了节省栈帧空间，Slot是可以重用的，因为方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用。但这也会有一些副作用，示例如下：</p>

<p>```java
public static void main(String[] args) {</p>

<pre><code>{
    byte[] placeholder = new byte[64*1024*1024];//64MB
}

int a = 0; //!
System.gc();
</code></pre>

<p>}
```</p>

<p>上面的代码，如果没有<code>int a</code>那一行，从逻辑上讲应该能够回收placeholder的内存，但实际上并非如此。原因就是代码虽然已经离开了placeholder的作用域，但在此之后，没有任何对局部变量表的读写操作，placeholder占用的Slot还没有被其他变量复用，所以GC Roots一部分的局部变量表仍然保持对它的关联。因此加上<code>int a</code>那一行就能够正常回收了。</p>

<p>因此，如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用大量内存，实际上已经不再会使用的变量，手动将其设置为null以帮助内存回收也是有意义的。需要注意的是，在日常编程时，没必要过度依赖将变量设置为null，因为编译器优化和JIT编译都可能使赋null语句被优化掉。</p>

<p>此外，局部变量并没有类变量和实例变量那样存在“准备阶段”，因此不会自动赋予系统初始值。</p>

<h3>1.2 操作数栈</h3>

<p>操作数栈（Operand Stack）也常称为操作栈，它是后入先出（LIFO）栈。当一个方法开始执行时，它的操作数栈是空的。在方法执行过程中，会有各种字节码指令往操作数栈写入和提取内容。</p>

<p>在概念模型中，两个栈帧是完全独立的。但大多虚拟机实现都会做优化，让两个栈帧出现一部分重叠。让下面的栈帧的部分操作数栈与上面的栈帧的部分局部变量表重叠在一起，无须进行额外的参数复制。</p>

<h3>1.3 动态连接</h3>

<p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。</p>

<h3>1.4 方法返回地址</h3>

<p>当方法开始执行后，有两种方式退出。一是遇到方法返回的字节码指令；二是遇到异常并且这个异常没有在方法体内得到处理。无论哪种退出方式，方法退出之后都要返回到方法被调用的位置。一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是通过异常处理器表来确定的，栈帧中一般不会保存此信息。</p>

<p>方法退出的过程就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，修改PC计数器的值以指向后一条指令等。</p>

<h3>1.5 附加信息</h3>

<p>各虚拟实现时会增加一些规范中没有描述的信息放到栈帧中，例如与调试相关的信息。</p>

<h2>2. 方法调用</h2>

<p>方法调用并不是方法执行，此阶段的唯一任务是确定被调用方法的版本，即调用哪一个方法。</p>

<h3>2.1 解析（Resolution）</h3>

<p>所有方法调用中的目标方法在Class文件里都是一个常量池中的符号引用。在解析阶段，会将其中一部分符号引用转化为直接引用：如果方法在真正运行之前就有一个可确定的调用版本，并且这个调用版本在运行期是不可改变的，那么就会被转化为直接引用。</p>

<p>符合这个条件的有静态方法、私有方法、实例构造器和父类方法4类。这4类方法和final方法都称为非虚方法。非虚方法在编译期间就完成了解析调用，将符号引用转变为可确定的直接引用。</p>

<h3>2.2 分派（Dispatch）</h3>

<p>分派与解析相反，要在运行时确定调用哪个版本的方法。这是多态特性的体现。分派可能是静态或动态的，根据分派的依据又分为单分派和多分派。</p>

<h4>2.2.1 静态分派</h4>

<p>首先明确什么是静态类型和实际类型，看下面的代码：</p>

<p>```java
public class Human{&hellip;}
public class Man extends Human{&hellip;}
public class Woman extends Human{&hellip;}</p>

<p>public void sayHello(Human h) {print(&ldquo;human&rdquo;);}
public void sayHello(Man h) {print(&ldquo;man&rdquo;);}
public void sayHello(Woman h) {print(&ldquo;woman&rdquo;);}</p>

<p>public static void main(String[] args) {</p>

<pre><code>Human man = new Man();
syaHello(man); //会打印什么呢？
</code></pre>

<p>}
```</p>

<p>在main方法中，Human称为变量的Static类型或Apparent类型，而Man则为变量的实际类型。</p>

<p>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是方法重载(Overload)。虚拟机在重载时通过参数的静态类型而不是实际类型作为判定依据。并且静态类型是编译期可知的，因此在编译阶段，编译器会根据参数的静态类型决定使用哪个方法的重载版本。所以main方法中会打印human.</p>

<h4>2.2.2 动态分派</h4>

<p>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。典型应用是方法重写(Override)。</p>

<h4>2.2.3 单分派与多分派</h4>

<p>方法的接收者和方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以分为单分派和多分派。单分派根据一个宗量对目标方法进行选择，而多分派则根据多于一个宗量对目标方法进行选择。</p>

<p>根据上面的知识，可以得知：Java是一门静态多分派，动态单分派的语言。</p>

<h4>2.2.4 虚拟机动态分派的实现</h4>

<p>由于动态分派是非常频繁的动作，需要在运行时中确定，因此虚拟机的实现基于性能考虑，并不会进行频繁的搜索，而是采用虚方法表来提高性能。</p>

<p>虚方法表中存放了各个方法的实际入口。如果某个方法在子类中没有被重写，那么子类的虚方法表里面的地址入口与父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类重写了这个方法，则子类方法表中的地址将会替换为指向子类实现版本的入口地址。</p>

<p>方法表一般在类加载的连接阶段进行初始化，类的变量初始值后，会把该类的方法表也初始化。</p>

<h2>3. 基于栈的字节码解释执行引擎</h2>

<p>虚拟机执行Java代码时有解释执行和编译执行。先学习一下解释执行。</p>

<p>Java编译器输出的指令流，基本是一种基于栈的指令集架构（Instruction Set Architecture, ISA），指令流中的指令大部分是零地址指令，它们依赖操作数栈工作。相对应的，x86使用的是基于寄存器的指令集。</p>

<p>基于栈的指令集主要优点是可移植，但缺点是执行速度会稍慢一些，因为出栈入栈操作本身就产生了相当多的指令数量，而且栈实现是在内存中，比寄存器的速度慢了很多。</p>

<p>通过一段代码来学习基于栈的解释器执行过程。</p>

<p>```java
public int calc() {</p>

<pre><code>int a = 100;
int b = 200;
int c = 300;
return (a+b) *c;
</code></pre>

<p>}
```</p>

<p>对应的字节码：</p>

<p><code>
public int calc();
Code:
stack=2, Locals=4, Args_size=1
0: bipush 100       //将单字节的整数常量值(-128~`17)推入操作数栈
2: istore_1     //将操作数栈顶的整形值出栈并存放到第1个局部变量Slot中
3: sipush 200       //与0类似
6: istore_2
7: sipush 300       
10:istore_3
11:iload_1      //将局部变量表第1个Slot的整型值复制到操作数栈顶
12:iload_2      //将局部变量表第2个Slot的整型值复制到操作数栈顶
13:iadd     //将操作数栈中的头两个栈顶出栈，相加，再将结果入栈
14:iload_3      //把第3个Slot的300压入操作数栈
15:imul     //将操作数栈中头两个栈顶出栈，相乘，将结果入栈
16:ireturn      //结束方法执行，将操作数栈顶的整数返回
</code></p>

<p>上面的示例可以看出中间变量都以操作数栈的入栈和出栈为信息交换途径。以上执行过程只是概念模型，实际执行时虚拟机会做优化。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM监控与故障处理工具]]></title>
    <link href="http://blog.ubone.com/blog/2015/01/04/jvmjian-kong-yu-gu-zhang-chu-li-gong-ju/"/>
    <updated>2015-01-04T21:42:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/01/04/jvmjian-kong-yu-gu-zhang-chu-li-gong-ju</id>
    <content type="html"><![CDATA[<p>本文介绍常用的Java虚拟机性能监控与故障处理工具。</p>

<!--more-->


<h2>1. JDK命令行工具</h2>

<h3>1.1 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jps.html">jps</a></h3>

<p>与Unix下的ps命令相似，可以列出正在运行的虚拟机进程并显示主类（main()函数所在类）类名以及LVMID(Local Virtual Machine Identifier)。LVMID与PID是一致的。命令格式：</p>

<p><code>jps [options] [hostid]</code></p>

<table>
<thead>
<tr>
<th>选项 </th>
<th> 用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>-q </td>
<td> 只输出LVMID</td>
</tr>
<tr>
<td>-m </td>
<td> 输出JVM启动时传递给主类main()函数的参数</td>
</tr>
<tr>
<td>-l </td>
<td> 输出主类全名</td>
</tr>
<tr>
<td>-v </td>
<td> 输出JVM启动时的JVM参数</td>
</tr>
</tbody>
</table>


<h3>1.2 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html">jstat</a>，虚拟机统计信息监视工具</h3>

<p>在<a href="/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>中已经有描述。</p>

<h3>1.3 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jinfo.html">jinfo</a>, Java配置信息工具</h3>

<p>用于实时查看和调整虚拟机各项参数。</p>

<h3>1.4 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jmap.html">jmap</a>, Java内存映像工具</h3>

<p>在<a href="/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>中已经有描述。</p>

<h3>1.5 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jhat.html">jhat</a>， 堆转储快照分析工具</h3>

<p>用于分析堆转储快照，内置一个微型HTTP服务器，分析结果后可在浏览器中查看。但这个工具并不常用。</p>

<h3>1.6 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstack.html">jstack</a>, Java堆栈跟踪工具</h3>

<p>用于生成虚拟机当前时刻的线程快照（threaddump），即当前每一条线程正在执行的方法堆栈集合。主要目的是定位线程出现长时间停顿的原因，如死锁、死循环、请求外部资源等。</p>

<p>当线程出现停顿时，通过jstack查看各线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么。</p>

<table>
<thead>
<tr>
<th>选项 </th>
<th> 用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>-F </td>
<td> 当正常输出的请求不被响应时，强制输出线程堆栈</td>
</tr>
<tr>
<td>-l </td>
<td> 除堆栈外，显示关于锁的附加信息</td>
</tr>
<tr>
<td>-m </td>
<td> 如果调用本地方法的话，显示C/C++堆栈</td>
</tr>
</tbody>
</table>


<h2>2. JDK的可视化工具</h2>

<h3>2.1 JConsole</h3>

<p>基于JMX的可视化监视、管理工具。直接通过集令后运行jconsol。</p>

<h3>2.2 <a href="http://visualvm.java.net/">VisualVM</a>，多合一故障处理工具</h3>

<p>VisualVM Is Designed For You:</p>

<ul>
<li><strong>Application Developer</strong>: Monitor, profile, take thread dumps, browse heap dumps</li>
<li><strong>System Administrator</strong>: Monitor and control Java applications across the entire network</li>
<li><strong>Java Application User</strong>: Create bug reports containing all the necessary information</li>
</ul>


<p>在命令行执行<code>jvisualvm</code>即可</p>
]]></content>
  </entry>
  
</feed>
