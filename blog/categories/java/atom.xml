<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2014-08-03T00:47:03+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[分布式系统的基础知识]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/22/fen-bu-shi-xi-tong-de-ji-chu-zhi-shi/"/>
    <updated>2014-07-22T20:04:40+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/22/fen-bu-shi-xi-tong-de-ji-chu-zhi-shi</id>
    <content type="html"><![CDATA[<p>这是一篇学习笔记，内容为《大型网站系统与Java中间件实践》的第一章。</p>

<p>组成计算机的5要素为：输入、输出、运算器、控制器、存储器（内存、外存）。分布式系统也一样，可以分为这5个要素。因此这本书会对分布式系统中，这5个要素的变化进行说明。</p>

<!--more-->


<p>阿姆达尔定律（Amdahl&rsquo;s law）说明程序中可以并行的代码的比例，决定了你增加处理器能带来的速度提升的上限。</p>

<p>```
S(N) = 1 / ((1 &ndash; P) + P / N)</p>

<p>P: 可并行的程序在单核上执行时间的占比
N: 处理器的个数
S(N): 程序在N个处理器（总核心数）相对于单个处理器中的速度提升比。</p>

<p>当P=0.2, S(N)的上限为1.25
当P=0.5, S(N)的上限为2
```</p>

<p>根据阿姆达尔定律，提升P非常的重要！</p>

<h2>1.多线程模式</h2>

<p>这里所说的多线程，是指单进程内的多线程。</p>

<h3>1.1互不通信的多线程模式</h3>

<p>线程之间没有交集，各自执行各自的任务和逻辑。这种模式的编程最简单，与单线程差不多。</p>

<h3>1.2基于共享容器的多线程模式</h3>

<p>例如多个线程共用一个队列。对于存储数据的容器或者对象，分为线程安全和线程不安全。</p>

<ul>
<li>如果是线程不安全的，一般可以通过加锁或者Copy On Write（COW）的方式控制并发。对于加锁的情况，如果是读多写少，可以用读写锁而不是互斥锁。</li>
<li>如果是线程安全的，就可以直接使用。</li>
</ul>


<h3>1.3通过事件协同的多线程模式</h3>

<p>某个线程需要等到某个状态或者事件发生后才能继续自己的工作，而这个状态或者事件与另一个线程有关，这时候就需要完成线程间的协调。<strong>为了防止死锁，一般要原子性地获取所需的多个锁，或者注意以相同的顺序获取多个锁。</strong></p>

<p>```java
//原子性地获取多个锁
Thread 1
GetLocks(A, B); //伪代码，一次性获取两个锁，不同平台支持不同。</p>

<p>Thread 2
GetLocks(A, B);</p>

<p>//或者同样的顺序获取多个锁
Thread 1
A.lock();</p>

<pre><code>B.lock();
</code></pre>

<p>Thread 2
A.lock();</p>

<pre><code>B.lock();
</code></pre>

<p>//两个线程的加锁顺序一致，如果Thread 2中的顺序反过来，则很可能造成锁死。</p>

<p>```</p>

<h2>2.多进程模式</h2>

<p>进程之间的内存空间是独立的，因此多进程相对会容易一些。但也正因为内存空间独立，因此数据共享就涉及序列化和反序列化。</p>

<p>对于多进程，单个进程的问题不会造成整体的不可用。</p>

<h2>3.网络基础</h2>

<h3>3.1 OSI七层模型</h3>

<p>OSI七层模型还记得？从上到下依次是：</p>

<ul>
<li>应用层：为应用程序（如Email）提供网络服务。</li>
<li>表示层：确保一个应用层发送的信息可被另一个系统的应用层读取。</li>
<li>会话层：通过传输层建立数据传输的通路。</li>
<li>传输层：定义传输数据的协议和端口。</li>
<li>网络层：在位于不同位置的网络中的两个主机系统之间提供连接和路径选择。</li>
<li>数据链路层：定义如何让格式化数据以进行传输。</li>
<li>物理层：定义物理设备标准，传输比特流。</li>
</ul>


<h3>3.2 网络IO实现方式</h3>

<ul>
<li>BIO（Blocking IO），阻塞方式，一个Socket需要一个线程来处理。</li>
<li>NIO（Nonblocking IO），基于事件驱动思想，采用Reactor模式。</li>
<li>AIO (Asynchronous IO)，异步IO，采用Proactor模式。</li>
</ul>


<p>Reactor模式和Proactor模式，后续要再研究一下。</p>

<h2>4.从单机到分布式</h2>

<h3>4.1 输入、输出设备的变化</h3>

<p>除了传统意义的人机交互输入、输出设备，分布式环境中的其它节点也可以看作是输入或输出设备。</p>

<h3>4.2 控制器的变化</h3>

<p>在单机中，控制器是CPU中的控制器。在分布式系统中，控制器是控制方式。</p>

<ol>
<li>使用硬件负载均衡</li>
<li>使用软件负载均衡，如LVS</li>
<li>通过名称服务器</li>
<li>通过规则服务器</li>
<li>Master + Worker的方式</li>
</ol>


<p>前面两种一般称为透明代理。有两种缺点，一是增加了流量，即代理服务器与请求处理服务器之间多了一次发送和返回。当然，LVS通过配置，可以将请求的处理结果直接返回给客户端，不通过中间代理。二是如果代理出现问题，会影响到所有请求。</p>

<p>第三、四种控制方式，都是客户端先访问名称服务器或者规则服务器，得到真正的请求处理服务器地址，然后直接与该地址进行连接。</p>

<p>第五种一般用来管理任务，由Master把任务分给不同的Worker处理。</p>

<h3>4.3 运算器的变化</h3>

<p>分布式系统中的运算器包括多个节点的计算能力。</p>

<ol>
<li>通过DNS解析，实现调度和控制</li>
<li>使用负载均衡设备或软件</li>
<li>使用Master+Worker方式</li>
<li>使用规则服务器等。</li>
</ol>


<h3>4.4 存储器的变化</h3>

<p>与前面的类似，也可以通过：</p>

<ol>
<li>直接访问存储服务器</li>
<li>通过代理服务器访问存储服务器</li>
<li>使用名称服务</li>
<li>使用规则服务</li>
<li>使用Master控制。但没有Worker了。与规则服务不同，这里的Master根据请求返回存储服务器的地址，而不是返回所有地址。</li>
</ol>


<h2>5. 分布式系统的难点</h2>

<ol>
<li>缺乏全局时钟</li>
<li>面对故障独立性。故障独立性指整个系统的一部分有问题，而其他部分正常。</li>
<li>处理单点故障。如果某个功能或角色只有一台单机在支撑，这个节点就称为单点。它发生的故障就是单点故障（SPoF, Single Point of Failure）</li>
<li>事务的挑战。即ACID和CAP。</li>
</ol>


<p>后续将研究文中提到的COW、读写锁、互斥锁，以及Reactor模式和Proactor模式。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java注解]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/09/javazhu-jie/"/>
    <updated>2014-07-09T22:22:10+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/09/javazhu-jie</id>
    <content type="html"><![CDATA[<p>本文记录Java注解的基本用法。</p>

<!--more-->


<p>注解类型声明与接口声明的唯一区别是，在interface之前增加了一个@符：</p>

<p><code>java
public @interface TestMethod {
}
</code></p>

<p>判断方法是否有某个注解：</p>

<p>```java</p>

<pre><code>for(Method method: testClass.getDeclaredMethods())
    if (method.isAnnotationPresent(TestMethod.class)) {
        ...
    }           
</code></pre>

<p>```</p>

<h3>保留(Retention)</h3>

<p>注解信息的保留策略：</p>

<ul>
<li>RetentionPolicy.SOURCE 在编译时丢弃。</li>
<li>RetentionPolicy.CLASS（缺省） 保存在类文件中，运行时可被VM丢弃。</li>
<li>RetentionPolicy.RUNTIME 保存在类文件中，运行时由VM保留。</li>
</ul>


<p><code>java
@Retention(RetentionPolicy.RUNTIME)
public @interface TestMethod {
}
</code></p>

<h3>注解的目标（Annotation Target）</h3>

<p><code>java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface TestMethod {
}
</code></p>

<p>目标的类别包括：TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, ANNOTATION_TYPET和PACKAGE。如果没有指定目标，则注解可以修饰任何Java元素。</p>

<h3>单值注解</h3>

<p>为了在注解类型中支持单个参数，需要提供一个名为value的方法，返回适当的类型并且没有任何参数。</p>

<p>```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Ignore {</p>

<pre><code>String value();
</code></pre>

<p>}</p>

<p>//使用示例
@Ignore(&ldquo;忽略&rdquo;)
public void testC() {}
```</p>

<p>不能将null作为注解的值（value）。</p>

<h3>数组参数</h3>

<p>可指定value方法的返回值为数组：</p>

<p>```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Ignore {</p>

<pre><code>String[] value();
</code></pre>

<p>}</p>

<p>//使用示例
@Ignore({&ldquo;忽略&rdquo;, &ldquo;房价涨了&rdquo;})
public void testC() {}</p>

<p>//如果数组只有一个成员，也可以这样写：
@Ignore(&ldquo;房价涨了&rdquo;)
public void testC() {}
```</p>

<h3>多个参数的注解</h3>

<p>注解有多个参数时，注解类型的成员名与注解声明的名称一致，如下例中的reasons和initials：</p>

<p>```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Ignore {</p>

<pre><code>String[] reasons();
String initials();
</code></pre>

<p>}</p>

<p>//使用示例
@Ignore(reasons={&ldquo;just because&rdquo;, &ldquo;and why not&rdquo;}, initials=&ldquo;jjl&rdquo;)
```</p>

<h3>缺省值</h3>

<p>```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Ignore {</p>

<pre><code>String[] reasons() default "房价涨了";
String initials();
</code></pre>

<p>}
```</p>

<h3>附加返回类型与复式注解类型</h3>

<p>注解值可以是基本类型、枚举、Class引用、注解类型本身，或者任意这些类型的数组。我们以注解类型为例：</p>

<p>```java
public @interface Date {</p>

<pre><code>int month();
int day();
int year();
</code></pre>

<p>}</p>

<p>@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Ignore {</p>

<pre><code>Date date();
</code></pre>

<p>}</p>

<p>//使用示例
@Ignore(date=@Date(month=1, day=2, year=2014))
public void testC() {}
```</p>

<h3>包注解</h3>

<p>注解的目标除了方法、属性等外，还可以是包，那么包注解写在哪呢？方法在在包对应的目录中，创建一个名为package-info.java的源文件，这个文件应该包含所有的包注解，后面跟随适当的package语句。除此之外，这个文件不能够包含其它任何东西。示例如下：</p>

<p><code>java
@TestPackage(isPerformance=true) package sis.testing;
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Java-类和接口]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/08/effective-java-lei-he-jie-kou/"/>
    <updated>2014-07-08T18:58:31+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/08/effective-java-lei-he-jie-kou</id>
    <content type="html"><![CDATA[<p>本文总结《Effective Java》中“类和接口”的论述。</p>

<!--more-->


<h2>13.使类和成员的可访问性最小化</h2>

<p>最小化可访问性的目的是隐藏信息，隐藏信息的原因主要是为了模块解耦。正确地使用修饰符（private, protected和public）很重要。</p>

<p>第一条规则是：尽可能地使每个类或者成员不被外界访问。对于顶层（非嵌套）类和接口，应该只有两种可能的访问级别：包级私有（即没有修饰符时）和public。包级私有仍然是这个包的实现的一部分，以后可以对它进行修改，无需担心客户端。但如果是public，则有责任永远支持它。</p>

<p>如果一个包级私有的顶层类/接口只在某一个类的内部被使用，仍应该考虑将它变成那个类的私有嵌套类。</p>

<p>长度非零的数组总是可变的，所以，类具有公有的静态final数组域，或者返回这种域的访问方法，这几乎总是错误的！</p>

<p>```java</p>

<p>//潜在安全漏洞
public static final Thing[] VALUES = {&hellip;};</p>

<p>//可改为：
private static final Thing[] PRIVATE_VALUES = {&hellip;};
public static final List<Thing> VALUES =</p>

<pre><code>Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
</code></pre>

<p>//或者返回一个数组的备份：
private static final Thing[] PRIVATE_VALUES = {&hellip;};
public static final Thing[] values {</p>

<pre><code>return PRIVATE_VALUES.clones();
</code></pre>

<p>}</p>

<p>```</p>

<h2>14.在public类中使用访问方法而非公有域</h2>

<p>简单说，就是public类的属性不要public，而是提供访问方法（如getter, setter）。如果属性不是final的，直接公开属性将表示放弃对该值的控制。即使该属性是final，但如果它引用了可变对象，一样会存在问题。</p>

<h2>15.使可变性最小化</h2>

<p>不可变类是其实例无法修改的类。不可变类不容易出错，本质上是线程安全的，不要求同步。要使类成为不可变，要遵循以下五条规则：</p>

<ol>
<li>不提供任何会修改对象状态的方法。</li>
<li>保证类不会被扩展。</li>
<li>使所有域都是final的。</li>
<li>使所有域都成为私有的。</li>
<li>确保对任何可变组件的互斥访问。如果类中有指向可变对象的域，必须确保客户端无法获得指向这些对象的引用。<strong>永远不要用客户端提供的对象引用来初始化这样的域，也不要从任何访问方法返回该对象的引用。</strong>可使用保护性拷贝技术。</li>
</ol>


<p>不可变类唯一的缺点是，对每个不同的值都需要一个单独的对象。对大型对象代价会很高。</p>

<p>其中第2条，保证类不会被扩展，除了使类成为final外，也可以将类的构造器为私有或者包级私有，然后提供静态工厂。</p>

<p>如果你选择让自己的不可变类实现Serializable接口，并且它包含指向可变对象的域，就必须提供一个显式的readObject或者readResolve方法，或者使用ObjectOutputStream.writeUnshared和ObjectInputStream.readUnshared方法。否则攻击者可能从不可变类创建可变的实例。</p>

<p>如果类不能被做成不可变的，仍然应该尽可能地限制它的可变性。尽量使域/属性成为final。</p>

<p>构造器应该创建完全初始化的对象。尽量不要在构造器或者静态工厂之外再提供公有的初始化方法。同时也不应该提供“重新初始化”方法。</p>

<h2>16.复合优先于继承</h2>

<p>继承打破了封装性。子类依赖于父类中特定功能的实现细节。父类的实现有可能会随着发行版本的不同而有所变化。</p>

<p>通过复合（Composition），现有类变成了新类的一个组件，新类提供方法调用现有类实例中对应的方法，并返回它的结果。这被称为转发。</p>

<p>包装类几乎没有缺点。但包装类不适用于回调框架中。在回调框架中，对象把自己的引用传递给其他对象，用于后续调用。而被包装起来的对象并不知道它外面的包装对象，所以它传递一个指向自身的引用（this），回调时避开了外面的包装对象。这被称为<strong>SELF问题</strong>。</p>

<p>只有当子类真正是父类的子类型时，即它们是“is-a”的关系时，才适合用继承。</p>

<h2>17.要么为继承而设计，并提供文档说明，要么就禁止继承</h2>

<p>文档必须精确地描述覆盖每个方法所带来的影响。
对于为了继承而设计的类，唯一的测试方法就是编写子类。
<strong>为了允许继承，构造器决不能调用可被覆盖的方法，无论是直接调用还是间接调用！</strong>
对于为了继承而设计的类，实现Cloneable和Serializable这两个接口都不是好主意，因为将实际负担转嫁给了扩展这个类的程序员身上。还要注意clone和readObject这两个方法非常类似于构造器，也不能调用可覆盖的方法，不管是直接还是间接调用。如果实现了Serializable，并且该类还有readResolve或writeReplace方法，就必须将该方法成为protected方法，不能是private。</p>

<p>对于那些并非为了安全地进行子类化而设计和编写文档的类，要禁止子类化。有两种办法：声明为final或者将所有构造器都变成私有或包级私有，并增加一个公有静态工厂。</p>

<h2>18.接口优于抽象类</h2>

<h2>19.接口只用于定义类型</h2>

<p>书中建议不要用接口来定义常量，这是接口的不良使用。接口应该只用于定义类型，而常量可以通过以下方法实现：</p>

<ul>
<li>如果某些常量与某个现有类或接口紧密相关，就应该把这些常量加到这个类或接口中。例如Integer的MIN_VALUE常量。</li>
<li>如果这些常量最好被看作是枚举类型的成员，就应该使用枚举类型。</li>
<li>否则应该使用不可实例化的工具类来定义这些常量，例如：</li>
</ul>


<p>```java
public class PhysicalConstants {</p>

<pre><code>private PhysicalConstants() {} //避免实例化
public static final double AVOGADROS_NUMBER = 6.0221419e23;
...
</code></pre>

<p>}
```</p>

<h2>20.类层次优于标签类</h2>

<p>标签类（Tagged class）是指那些用一个类来表示多种对象的类。例如用一个类来表示矩形和圆。通过一个标签来区分当前实例是矩形还是圆。</p>

<p>标签类过于冗长，容易出错，而且效率低下。这种情况应该通过类层次来定义。</p>

<h2>21.用函数对象表示策略</h2>

<p>如果一个类，它的方法执行其他对象的操作，这个类仅导出一个这样的方法，它的实例就等同于一个指向该方法的指针。这样的实例就称为函数对象（function object）。例如：</p>

<p>```java
class StringLengthComparator {</p>

<pre><code>public int compare(String s1, String s2) {
    return s1.length() - s2.length();
}
</code></pre>

<p>}
```</p>

<p>上面这个类没有属性，因此适合于单例。为了把该类的实例传递给方法，应该定义一个接口，并让类实现这个接口。这就是一个策略接口：</p>

<p>```java
public interface Comparator<T> {</p>

<pre><code>public int compare(T t1, T t2);
</code></pre>

<p>}
```</p>

<p>函数指针的主要用途就是实现策略模式。为了在Java中实现这种模式，要声明一个接口来表示该策略，并且为每个具体策略声明一个实现了该接口的类。当一个具体策略只使用一次时，通常使用匿名类，如果可以重复使用，通常实现为私有的静态成员类，并通过公有的静态final属性导出，其类型为该策略接口。</p>

<h2>22.优先使用静态成员类</h2>

<p>嵌套类（nested class）有四种：静态成员类、非静态成员类、匿名类和局部类。后面三种都被称为内部类（inner class）。</p>

<p>非静态成员类的每个实例都隐含着与一个外围实例的关联，在其内部可以调用外围实例的方法。非静态成员类的一种常见用法是定义一个Adapter。</p>

<p>如果成员类不要求访问外围实例，就要始终把static放在它的声明中，使它成为静态成员类。</p>

<p>匿名类的适用性受到很多限制，它没有名字，不是外围类的成员。它在使用的同时被声明和实例化。不能实现多个接口或者扩展一个类，并同时扩展类和实现接口。它们必须保持简短，大约10行或更少。它主要用于：</p>

<ul>
<li>创建函数对象，例如匿名的Comparator实例。</li>
<li>创建过程对象，例如Runnable, Thread或者TimerTask实例。</li>
<li>在静态工厂方法的内部。参考第18条。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java泛型]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/02/javafan-xing/"/>
    <updated>2014-07-02T22:24:37+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/02/javafan-xing</id>
    <content type="html"><![CDATA[<p>Java泛型功能强大，用起来也很简单。看到一些代码，有时候用?号，有时候又可以直接使用<code>&lt;T&gt;</code>，都有哪些区别呢？系统地了解一下吧。</p>

<!--more-->


<h2>1.参数化类型</h2>

<p>参数化类型，也就是泛型。</p>

<p>```java
List<String> list = new ArrayList<String>();</p>

<p>Map&lt;String, Date> map = new HaspMap&lt;String, Date>();
```</p>

<p>上面这些都是很常见的用法。或者我们创建一个参数化的类型：</p>

<p>```java
public class MultiHashMap&lt;K, V> {</p>

<pre><code>private Map&lt;K, List&lt;V&gt;&gt; map = new HashMap&lt;&gt;();  //Java 7中可以省略类型了。 
public void put(K key, V value) {
    List&lt;V&gt; values = map.get(key);
    ...
}
</code></pre>

<p>}
```</p>

<h2>2.擦拭法</h2>

<p>要实现参数化类型，有多种方法。C++采用的方法是为每种参数化类都创建一个全新的类型定义。例如<code>MultiHashMap&lt;Date, String&gt;</code>将会创建一个新类：</p>

<p>```java
//注：这不是Java的做法。
public class MultiHashMap&lt;Date, String> {</p>

<pre><code>...
</code></pre>

<p>}</p>

<p>```</p>

<p>但这不是Java的做法。Java使用一种叫做“擦拭法”的方法。每个类型参数缺省使用顶级类如Object，客户端的绑定信息被擦去。例如MultiHashMap会被翻译成：</p>

<p>```java
public class MultiHashMap {</p>

<pre><code>private Map map = new HashMap();

public void put(K key, V value) {
    List values = (List)map.get(key);
    ...
}
</code></pre>

<p>} <br/>
```</p>

<p>这个上限也可以指定，例如：</p>

<p>```java
public class EventMap<K extends java.util.Date, V> {</p>

<p>}
```</p>

<p>表示K必须是Date或者其子类。</p>

<h2>3.通配符</h2>

<p>假设你有个方法想对某种类型的List进行遍历处理：</p>

<p>```java</p>

<pre><code>public static String concatenate(List&lt;Object&gt; list) {

｝   
</code></pre>

<p>```</p>

<p>一旦你如上面一样定义了<code>List&lt;Object&gt;</code>参数，则无法将其它类型的列表传入。你可以向<code>List&lt;Object&gt;</code>加入Object及其子类的对象，例如：<code>list.add(new Date())</code>。因为Date是Object的子类。但是，当一个方法的参数是<code>List&lt;Object&gt;</code>时，你不能将<code>List&lt;Date&gt;</code>类型的变量作为参数传入这个方法。原因是<code>List&lt;Date&gt;</code>不是<code>List&lt;Object&gt;</code>的子类！例如将<code>List&lt;String&gt;</code>类型作为参数传入将导致无法编译。这时候你可以使用通配符：</p>

<p>```java</p>

<pre><code>public static String concatenate(List&lt;?&gt; list) {
    //遍历时就可以使用Object了。
    for(Object item : list) {
        ...
    }
｝
</code></pre>

<p>```</p>

<p>但通配符也隐含了一些问题。例如，下面的代码编译错误：</p>

<p>```java
public static void pad(List&lt;?> list, Object object, int count) {</p>

<pre><code>for (int i = 0; i &lt; count; i ++) {
    list.add(object);
}
</code></pre>

<p>}
```</p>

<p>错误的原因是<code>List&lt;?&gt;</code>指示了一个未知的类型，编译器无法判断指定的操作是否安全，因此它就全部禁止了。</p>

<blockquote><p><code>List&lt;?&gt;</code>声明了List中包含的元素类型是未知的。通配符所代表的其实是一组类型，但具体的类型是未知的。<code>List&lt;?&gt;</code>所声明的就是所有类型都是可以的。但是<code>List&lt;?&gt;</code>并不等同于<code>List&lt;Object&gt;</code>。<code>List&lt;Object&gt;</code>实际上确定了List中包含的是Object及其子类，在使用的时候都可以通过Object来进行引用。而<code>List&lt;?&gt;</code>则其中所包含的元素类型是不确定。其中可能包含的是String，也可能是 Integer。如果它包含了String的话，往里面添加Integer类型的元素就是错误的。正因为类型未知，就不能通过<code>new ArrayList&lt;?&gt;()</code>的方法来创建一个新的ArrayList对象。因为编译器无法知道具体的类型是什么。</p></blockquote>

<p>那么应该如何解决这个问题呢？可以使用泛型方法：</p>

<p>```java
public class SomeClass {</p>

<pre><code>public static &lt;T&gt; void pad(List&lt;T&gt; list, T object, int count) {
    for(int i = 0; i &lt; count; i++) {
        list.add(object);
    }
}

public static void main(String[] args) {
    List&lt;String&gt; list = new ArrayList&lt;String&gt;();
    pad(list, "Hello", 5);

    System.out.println(list);
}
</code></pre>

<p>}</p>

<p>//结果为：
[Hello, Hello, Hello, Hello, Hello]
```</p>

<p>再来个例子，将通配符与泛型方法结合起来用，将一个List从头至尾交换一遍：</p>

<p>```java</p>

<pre><code>static void inPlaceReverse(List&lt;?&gt; list) {
    int len = list.size();
    for(int i = 0; i &lt; len; i++) {
        swap(list, i, len - 1 - i);
    }
}

private static &lt;T&gt; void swap(List&lt;T&gt; list, int i, int opposite) {
    T temp = list.get(i);
    list.set(i, list.get(opposite));
    list.set(opposite, temp);
}
</code></pre>

<p>```</p>

<p><strong>通配符的上、下界</strong>，super和extends</p>

<p>因为对于<code>List&lt;?&gt;</code>中的元素只能用Object来引用，在有些情况下不是很方便。在这些情况下，可以使用上下界来限制未知类型的范围。 如<code>List&lt;? extends Number&gt;</code>说明List中可能包含的元素类型是Number及其子类。而<code>List&lt;? super Number&gt;</code>则说明List中包含的是Number及其父类。当引入了上界之后，在使用类型的时候就可以使用上界类中定义的方法。比如访问 <code>List&lt;? extends Number&gt;</code>的时候，就可以使用Number类的intValue等方法。</p>

<h2>总结</h2>

<p>擦拭法是理解问题的关键。</p>

<h2>参考</h2>

<ul>
<li>《Agile Java》</li>
<li><a href="http://www.infoq.com/cn/articles/cf-java-generics">http://www.infoq.com/cn/articles/cf-java-generics</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[安全HTTP，SSL证书及申请]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/02/an-quan-http,sslzheng-shu-ji-shen-qing/"/>
    <updated>2014-07-02T08:34:08+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/02/an-quan-http,sslzheng-shu-ji-shen-qing</id>
    <content type="html"><![CDATA[<p>由于iOS 7.1无法安装企业应用的原因是url必须是https，因此需要将原Tomcat服务器增加SSL支持。总结一下基础知识和配置过程。</p>

<!--more-->


<p>HTTPS是位于安全层之上的HTTP，如下图所示：</p>

<p><img src="/myresource/images/img_blog_20140702_1.jpg" alt="image" /></p>

<h2>1.基础知识</h2>

<p>数字加密的一些概念：</p>

<ul>
<li>密码</li>
<li>密钥：改变密码行为的数字化参数。例如，加密算法是循环移位N个字符，那么密钥控制N的值。</li>
<li>对称密钥加密系统：加密和解密都使用相同的密钥。</li>
<li>不对称密钥加密系统：加密和解密都使用不同的密钥。</li>
<li>公开密钥加密系统：一种能够使数百万计算机便捷发送机密报文的系统。</li>
<li>数字签名：用加密系统对报文进行签名，说明是谁编写的报文，同时证明报文未被篡改。</li>
<li>数字证书：由受信任组织提供的身份证明。</li>
</ul>


<h3>1.1对称密钥加密技术</h3>

<p>常见的对称密钥加密算法包括：DES、Triple-DES、RC2和RC4。</p>

<p>它们的编、解码算法都是公开的，因此密钥是唯一保密的东西。可用密钥值的数量取决于位数。位数越长则破解难度越大。下表是书中列举的，以1995年的技术进行破解的成本：</p>

<p><img src="/myresource/images/img_blog_20140702_3.jpg" alt="image" /></p>

<p>对称密钥加密技术的缺点之一是发送和接收者在对话之前，一定要有一个共享的保密密钥。如果在Internet上，Web服务器要与每个用户的浏览器进行安全对话，采用这种加密技术将是一个噩梦。</p>

<h3>1.2公开密钥加密技术</h3>

<p>公开密钥加密技术使用两个非对称密钥：一个用来编码，另一个用来解码。编码密钥是公开的，而解码密钥只有主机自己知道。因此所有用户都可以拥有某个主机的编码密钥，当他向主机发送报文时，使用该主机的公钥进行编码，主机使用自己的解码密钥进行解码。</p>

<p>公开密钥架构（Public-Key Infrastructure, PKI）标准，用于标准化公开密钥技术包。</p>

<p>RSA算法是一个公开密钥加密算法。由麻省理工学院发明，RSA公司将其商业化。</p>

<h3>1.3数字签名</h3>

<p>签名就是为了说明谁编写的报名，并证明其未被篡改过。它是加了密的校验和。下图展示了从节点A向节点B发送一条报文的过程：</p>

<p><img src="/myresource/images/img_blog_20140702_3.jpg" alt="image" /></p>

<p>节点A对报文提取为定长摘要，将对摘要使用“签名”函数，这个函数接收用户的私有密钥作为参数。计算出签名后，将其附加在报文的末尾，一同发给B。</p>

<p>节点B如何确定报文确实是A写的，而且没被篡改过？B使用公开密钥的反函数，确认拆包后的摘要与自己的摘要版本一致。</p>

<p><a href="http://baike.baidu.com/view/7626.htm?fr=aladdin">百度百科</a>关于签名过程的描述：</p>

<blockquote><p>发送报文时，发送方用一个哈希函数从报文文本中生成报文摘要,然后用自己的私人密钥对这个摘要进行加密，这个加密后的摘要将作为报文的数字签名和报文一起发送给接收方，接收方首先用与发送方一样的哈希函数从接收到的原始报文中计算出报文摘要，接着再用发送方的公用密钥来对报文附加的数字签名进行解密，如果这两个摘要相同、那么接收方就能确认该数字签名是发送方的。</p></blockquote>

<h3>1.4数字证书</h3>

<p>数字证书就是互联网通讯中标志通讯各方身份信息的一串数字，提供了一种在Internet上验证通信实体身份的方式，其作用类似于司机的驾驶执照或日常生活中的身份证。它是由一个由权威机构——CA机构，又称为证书授权（Certificate Authority）中心发行的，人们可以在网上用它来识别对方的身份。数字证书是一个经证书授权中心数字签名的包含公开密钥拥有者信息以及公开密钥的文件。最简单的证书包含一个公开密钥、名称以及证书授权中心的数字签名。</p>

<p>证书的主要内容包括：对象的名称（人、服务器、组织等）、过期时间、证书发布者和来自证书发布者的数字签名。</p>

<p>证书的格式没有全球标准，但大多数以X.509 v3作为标准格式。</p>

<h4>服务器证书（SSL证书）</h4>

<p>在服务器上安装服务器证书后，客户端浏览器可以与服务器证书建立SSL连接，在SSL连接上传输的任何数据都会被加密。同时，浏览器会自动验证服务器证书是否有效，验证所访问的站点是否是假冒站点，服务器证书保护的站点多被用来进行密码登录、订单处理、网上银行交易等。全球知名的服务器证书品牌有Globlesign，Verisign，Thawte，Geotrust等。</p>

<p>SSL支持双向认证。将服务器证书承载回客户端，再将客户端的证书回送给服务器。但目前，大部分用户都没有自己的客户端证书，所以服务器很少会要求客户端证书。</p>

<h2>2.为Tomcat安装SSL证书</h2>

<h3>2.1申请SSL证书</h3>

<p>建议使用<a href="https://www.startssl.com/">StartSSL</a>申请一个SSL证书，可以使用一年期免费的证书。必须使用域名！过程主要包括：</p>

<ul>
<li>在StartSSL上注册（Sign-up）。所填资料应是真实的，或者至少看起来是真的。</li>
<li>注册成功后会下载个证书，要导入到浏览器中。</li>
<li>然后就可以进入StartSSL的控制面板了。</li>
<li>验证完Email地址和域名所有权后，申请证书。</li>
<li>按照StartSSL的向导，申请完证书后，本地应该有这么几个文件：</li>
</ul>


<p><img src="/myresource/images/img_blog_20140702_5.png" alt="image" /></p>

<h3>2.2Tomcat安装SSL证书</h3>

<p>首先要创建pkcs12文件，使用StartSSL ToolBox中的Create PKCS#12 (PFX) File。其中Private Key就是ssl.key的内容，而Certificate则是ssl.crt的内容。创建完后将其保存为out.p12</p>

<p>第二步是生成Keystore文件。利用java的keytool工具：</p>

<p><code>
//XXXXXX为密码
keytool -importkeystore -deststorepass  XXXXXX -destkeystore mykeystore.jks -srckeystore out.p12 -srcstoretype PKCS12 -srcstorepass XXXXXX
</code></p>

<p>第三步，导入CA证书：</p>

<p><code>
keytool -import -alias startsslca -file sub.class1.server.ca.pem -keystore mykeystore.jks
</code></p>

<p>最后一步，配置Tomcat，修改server.xml，将8443端口取消注释：</p>

<p>```xml
&lt;Connector port=&ldquo;8443&rdquo; protocol=&ldquo;HTTP/1.1&rdquo;</p>

<pre><code>SSLEnabled="true" maxThreads="150" 
scheme="https" secure="true" 
clientAuth="false" sslProtocol="TLS" 
keystoreFile="/Users/mxs/mykeystore.jks" 
keystorePass="XXXXXX"/&gt; &lt;!--XXXXXX是密码--&gt;
</code></pre>

<p>```</p>

<p>如果启动时报apr错误，可修改server.xml，加上注释：</p>

<p>```xml</p>

<!--<Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="on" />-->


<p>```</p>

<h2>文件类型说明</h2>

<p>PKCS#12是“个人信息交换语法”，常用的后缀有.P12 .PFX。它可以用来将x.509的证书和证书对应的私钥打包，进行交换。比如你在windows下，可以将IE里的证书连带私钥导出，并设置一个口令保护。这个pfx格式的文件，就是按照pkcs#12的格式打包的。当然pkcs#12不仅仅只是作以上用途的。它可以用来打包交换任何信息。你可以和张三李四用PKCS#12来交换私人数据，包括x.509证书和私钥。</p>

<p>.CRT  扩展名CRT用于证书。证书可以是二进制的DER编码，也可以是文本的PEM编码。扩展名CER和CRT几乎是同义词。这种情况在各种unix/linux系统中很常见。</p>

<p>.CER  CRT证书的微软型式。可以用微软的工具把CRT文件转换为CER文件（CRT和CER必须是相同编码的，DER或者PEM）。扩展名为CER的文件可以被IE识别并作为命令调用微软的cryptoAPI（具体点就是rudll32.exe cryptext.dll, CyrptExtOpenCER），进而弹出一个对话框来导入并/或查看证书内容。</p>

<p>.KEY  扩展名KEY用于PCSK#8的公钥和私钥。这些公钥和私钥可以是DER编码或者PEM编码。本文中的ssl.key，以文本方式打开可以看到第一行是：&mdash;&mdash;-BEGIN RSA PRIVATE KEY&mdash;&mdash;-表示私钥。在StartSSL的向导中，先生成的是加密的key，然后使用命令：openssl rsa -in ssl.key -out ssl.key 将其解密。</p>

<h2>参考：</h2>

<p>《HTTP权威指南》
<a href="http://baike.baidu.com/view/7626.htm?fr=aladdin">百度百科</a>
<a href="http://fengfan.blog.163.com/blog/static/13478622013713114942896/">博客1</a>
<a href="http://blog.csdn.net/googling/article/details/6698255">博客2</a></p>
]]></content>
  </entry>
  
</feed>
