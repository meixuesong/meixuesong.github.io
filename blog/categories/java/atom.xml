<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 码出人生]]></title>
  <link href="http://blog.ubone.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2014-12-05T23:52:09+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[类文件与字节码]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/04/lei-wen-jian-yu-zi-jie-ma/"/>
    <updated>2014-12-04T20:40:02+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/04/lei-wen-jian-yu-zi-jie-ma</id>
    <content type="html"><![CDATA[<p>本篇学习类加载过程、类文件的分析工具和字节码。</p>

<!--more-->


<h2>1. 类加载和类对象</h2>

<p>一个.class文件定义了JVM的一种类型。类加入到JVM当前运行态中，首先要加载并连接，进行大量验证，然后提供一个代表该类型的Class对象给正在运行的系统，用于创建新的实例。</p>

<h4>加载</h4>

<p>加载的过程首先要读取类文件的字节数据流，创建一个字节数组，然后产生对应的Class对象。这个过程会进行一些基本检查。加载结束时，Class对象还不成熟，类也不可用。</p>

<h4>连接</h4>

<p>加载完成后，类必须连接起来。这分为三个步骤：验证、准备和解析。验证类文件符合预期，不会引起系统运行时错误。准备阶段会分配内存，准备好初始化类中的静态变量（但不会现在初始化变量）。解析阶段会检查类中引用的类型是否有未知类型，如果有会加载进来。一旦需要加载的其他类型全部定位并完成解析，VM就可以初始化这个类。这时所有静态变量都可以被初始化，所有静态初始化代码块都会运行。类的加载全部完成，已经可以使用了。</p>

<h4>Class对象</h4>

<p>加载和连接过程的最终结果是一个Class对象，可以使用这个新类型创建实例了。Class对象可以和反射API一起实现对方法、域和构造方法等类成员的间接访问，通过getSuperClass()返回其父类。</p>

<h4>类加载器</h4>

<p>Java平台有几个经典的类加载器：</p>

<ul>
<li>根（或引导）类加载器：通常在VM启动后不久实例化，一般用本地代码实现。可视为VM的一部分。负责加载系统的基础JAR(主要是rt.jar),而且不做验证工作。</li>
<li>扩展类加载器：用来加载安装时自带的标准扩展。一般包括安全性扩展。</li>
<li>应用（或系统）类加载器：应用最广泛的类加载器，负责加载应用类。</li>
<li>定制类加载器：在更复杂的环境，如EE或比较复杂的SE框架，通常会有些附加（即定制）的类加载器。</li>
</ul>


<h2>2. 方法句柄</h2>

<p>反射代码有很多套路，要捕获各种讨厌的异常，代码看起来也不直观。Java 7为间接调用方法引入了java.lang.invoke包，即方法句柄，可以提高安全性和代码的可读性。</p>

<h4>MethodHandle</h4>

<p>它是对可直接执行的方法（或域、构造方法等）的类型化引用，是一个有能力安全调用方法的对象。</p>

<p>```java
MethodHandle mh = getTwoArgMH();
MyType ret;
try {</p>

<pre><code>//调用obj对象的句柄，传入参数arg0, arg1
ret = mh.invokeExact(obj, arg0, arg1);
</code></pre>

<p>} catch(Throwable e) {</p>

<pre><code>//...
</code></pre>

<p>}
```</p>

<h4>MethodType</h4>

<p>它表示方法签名类型的不可变对象。每个方法句柄都有一个MethodType实例，用来指明方法的返回类型和参数类型。但它没有方法的名称和接收者类型。通过工厂方法可以得到MethodType实例：</p>

<p><code>java
//第一个参数为返回类型，随后是方法参数的类型。
//toString()
MethodType mtToString = MethodType.methodType(String.class);
//setter方法
MethodType mtSetter = MethodType.methodType(void.class, Object.class);
//Comparator&lt;String&gt;定义的compareTo()方法
MethodType mtStringComparator = MethodType.methodType(int.class, String.Class, String.class);
</code></p>

<h4>查找方法句柄</h4>

<p>通过lookup对象，你给出持有所需方法的类、方法名称以及你所需方法签名相匹配的MethodType，就可以得到方法句柄：</p>

<p>```java
public MethodHandle getToStringMH() {</p>

<pre><code>MethodHandle mh;
MethodType mt = MethodType.methodType(String.class);
MethodHandles.Lookup lk = MethodHandles.lookup();

try {
    mh = lk.findVirtual(getClass(), "toString", mt);
} catch(NoSuchMethodException | IllegalAccessException mhx) {
    //...
}

return mh;
</code></pre>

<p>}
```</p>

<blockquote><p>如果不是从当前类中查找，则只能看到或取得public方法的句柄。方法句柄总是在安全管理之下安全使用。没有反射中setAccessible()那种破解方法。</p></blockquote>

<p>有了方法句柄，就可以执行它了。执行方法有两个：invokeExact()和invoke()。前者要求参数类型完全匹配，后者可以在不太匹配时做些修改后执行（如装箱或拆箱）。</p>

<h4>示例：反射、代理和方法句柄的使用对比</h4>

<p>现在通过一个实例来对比这三种方法。下面的代码演示了如何通过这三种方法来访问私有方法cancel()：</p>

<p>```java
public class ThreadPoolManager {</p>

<pre><code>//...
private void cancel(final ScheduledFuture&lt;?&gt; hndl) {
    //...
}

/* 反射方法
* 使用方法简单示例：
* Method meth = manager.makeReflective();
* meth.invoke(hndl);
*/
public Method makeReflective() {
    Method method = null;
    try {
        Class&lt;?&gt; argTypes = new Class[] {ScheduledFuture.class};
        method = ThreadPoolManager.class.getDeclaredMethod("cancel", argTypes);
        method.setAccessible(true);
    } catch(IllegalArgumentException | NoSuchMethodException | SecurityException e) {
        //...
    }

    return method;
}

/* 代理方法
*  使用方法简单示例：
*  CancelProxy proxy = manager.makeProxy();
*  proxy.invoke(manager, hndl);
*/
public static class CancelProxy {
    private CancelProxy() {}
    public void invoke(ThreadPoolManager mae, ScheduledFuture&lt;?&gt; hndl) {
        mae.cancel(hndl);
    }
}

public CancelProxy makeProxy() {
    return new CancelProxy();
}

/* 方法句柄
* 使用方法简单示例：
* MethodHandle mh = manager.makeMh();
* mh.invokeExact(manager, hndl);
*/
public MethodHandle makeMh() {
    MethodHandle mh;
    MethodType desc = MethodType.methodType(void.class, ScheduledFuture.class);
    try {
        mh = MethodHandles.lookup().findVirtual(ThreadPoolManager.class, "cancel", desc);
    } catch(NoSuchMethodException | IllegalAccessException e) {
        //...
    }

    return mh;
}
</code></pre>

<p>}
```</p>

<p>三种方法的比较：</p>

<table>
<thead>
<tr>
<th>方法 </th>
<th> 访问控制 </th>
<th> 类型纪律 </th>
<th> 性能  </th>
</tr>
</thead>
<tbody>
<tr>
<td>反射 </td>
<td> 必须使用setAccesible。会被安全管理器禁止 </td>
<td> 不匹配就抛异常 </td>
<td> 较慢</td>
</tr>
<tr>
<td>代理 </td>
<td> 内部类可以访问受限方法 </td>
<td> 静态，为了代理全部代理类，可能需要更多PermGen </td>
<td> 跟其他方法一样快</td>
</tr>
<tr>
<td>方法句柄 </td>
<td> 取决于上下文，与安全管理器没有冲突 </td>
<td> 运行时是类型安全的，不占用PermGen </td>
<td> 力求跟其他方法调用一样快</td>
</tr>
</tbody>
</table>


<p>方法句柄还有一个特性，可以在静态上下文中确定当前类。例如下面的代码改写了logger的创建方式，可以不用将类名写死：</p>

<p><code>java
Logger logger = LoggerFactory.getLogger(MyClass.class);
//可改为：
Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
</code></p>

<h2>3. 了解类文件</h2>

<p>有时候有必要查看类文件，但它是二进制文件，和它打交道并不容易。Oracle JVM的javap这个工具可以用来探视类文件内部和反编译。</p>

<p>我们以一个简单的Java类作为示例：</p>

<p>```java
public class Sample {</p>

<pre><code>private byte b;
private char c;
private double d;
private float f;
private int i;
private Integer Int;
private long l;
private String s;
private boolean bl;
private int[] array;

//getter, setter
</code></pre>

<p>```</p>

<h3>查看类文件的方法和属性</h3>

<p><code>java
$ javap  Sample.class
Compiled from "Sample.java"
public class com.ubone.tdd.chapter1.javaio.Sample {
  public com.ubone.tdd.chapter1.javaio.Sample();
  public byte getB();
  public void setB(byte);
  public char getC();
  //其它getter, setter方法...
}
</code></p>

<p>javap默认显示public, protected和包级protected级别的方法和属性。加上-p选项后可以显示private方法和属性。</p>

<h3>方法签名的内部形式</h3>

<p>JVM内部用的方法签名使用紧凑形式，例如int用I表示。这称为类型描述符：</p>

<ul>
<li>B: byte</li>
<li>C: char(16位Unicode字符)</li>
<li>D: double</li>
<li>F: float</li>
<li>I: int</li>
<li>J: long</li>
<li>L&lt;类型名称>: 引用类型，如：Ljava/lang/String</li>
<li>S: short</li>
<li>Z: boolean</li>
<li>[: array-of</li>
</ul>


<p>使用javap -s可以输出签名的类型描述符：</p>

<p>```java
$ javap -s Sample.class
Compiled from &ldquo;Sample.java&rdquo;
public class com.ubone.tdd.chapter1.javaio.Sample {
  public com.ubone.tdd.chapter1.javaio.Sample();</p>

<pre><code>Signature: ()V
</code></pre>

<p>  public byte getB();</p>

<pre><code>Signature: ()B
</code></pre>

<p>  public void setB(byte);</p>

<pre><code>Signature: (B)V
</code></pre>

<p>  public char getC();</p>

<pre><code>Signature: ()C
</code></pre>

<p>  public void setC(char);</p>

<pre><code>Signature: (C)V
</code></pre>

<p>  public double getD();</p>

<pre><code>Signature: ()D
</code></pre>

<p>  public void setD(double);</p>

<pre><code>Signature: (D)V
</code></pre>

<p>  public float getF();</p>

<pre><code>Signature: ()F
</code></pre>

<p>  public void setF(float);</p>

<pre><code>Signature: (F)V
</code></pre>

<p>  public int getI();</p>

<pre><code>Signature: ()I
</code></pre>

<p>  public void setI(int);</p>

<pre><code>Signature: (I)V
</code></pre>

<p>  public java.lang.Integer getInt();</p>

<pre><code>Signature: ()Ljava/lang/Integer;
</code></pre>

<p>  public void setInt(java.lang.Integer);</p>

<pre><code>Signature: (Ljava/lang/Integer;)V
</code></pre>

<p>  public long getL();</p>

<pre><code>Signature: ()J
</code></pre>

<p>  public void setL(long);</p>

<pre><code>Signature: (J)V
</code></pre>

<p>  public java.lang.String getS();</p>

<pre><code>Signature: ()Ljava/lang/String;
</code></pre>

<p>  public void setS(java.lang.String);</p>

<pre><code>Signature: (Ljava/lang/String;)V
</code></pre>

<p>  public boolean isBl();</p>

<pre><code>Signature: ()Z
</code></pre>

<p>  public void setBl(boolean);</p>

<pre><code>Signature: (Z)V
</code></pre>

<p>  public int[] getArray();</p>

<pre><code>Signature: ()[I
</code></pre>

<p>  public void setArray(int[]);</p>

<pre><code>Signature: ([I)V
</code></pre>

<p>}
```</p>

<h3>常量池</h3>

<p>常量池是为类文件中的其他（常量）元素提供快捷访问方式的区域。通过javap -v可以查看常量池的信息：</p>

<p><code>
Constant pool:
   #1 = Class              #2             //  com/ubone/tdd/chapter1/javaio/Sample
   #2 = Utf8               com/ubone/tdd/chapter1/javaio/Sample
   #3 = Class              #4             //  java/lang/Object
   #4 = Utf8               java/lang/Object
   #5 = Utf8               b
   #6 = Utf8               B
   #7 = Utf8               c
   #8 = Utf8               C
   #9 = Utf8               d
  #10 = Utf8               D
  #11 = Utf8               f
  #12 = Utf8               F
  #13 = Utf8               i
  #14 = Utf8               I
  #15 = Utf8               Int
  #16 = Utf8               Ljava/lang/Integer;
  #17 = Utf8               l
  #18 = Utf8               J  
  ...
  #70 = Utf8               getL
  #71 = Utf8               ()J
  #72 = Fieldref           #1.#73         //  com/ubone/tdd/chapter1/javaio/Sample.l:J
  #73 = NameAndType        #17:#18        //  l:J
  #74 = Utf8               setL
  #75 = Utf8               (J)V
  ...
</code></p>

<p>如上所示，常量池的条目是带有类型的，它们还会相互引用。例如类型为Class的条目会引用类型为Utf8的条目。后者是个字符串，因此第1行为类的名称。</p>

<p>72行的Fieldref定义了一个域，解析这个域需要名称、类型和它所在的类。<code>#1.#73</code>表示来自类<code>#1</code>,域为<code>#73</code>。<code>#73</code>的NameAndType描述名称和类型，分别来自17和18，即类型J(Long)，名称为<code>l</code>。</p>

<h2>4. 字节码</h2>

<p>字节码的基本特性：</p>

<ul>
<li>字节码是程序的中间表示形式，介于人类可读的源码和机器码之间。</li>
<li>字节码由javac产生。</li>
<li>某些高级语言特性在编译时已经从字节码去掉。例如for语句在字节码中被转换成分支指令。</li>
<li>每个操作码都由一个字节表示（因此叫做字节码）。</li>
<li>字节码可以进一步编译成机器码，也就是“即时编译”。</li>
</ul>


<h3>反编译类</h3>

<p>javap可以用于反编译类：</p>

<p>```
$ javap -c -p Sample.class
Compiled from &ldquo;Sample.java&rdquo;
public class com.ubone.tdd.chapter1.javaio.Sample {
  private byte b;</p>

<p>  private char c;
  &hellip;</p>

<pre><code>public com.ubone.tdd.chapter1.javaio.Sample();
Code:
   0: aload_0       
   1: invokespecial #28                 // Method java/lang/Object."&lt;init&gt;":()V
   4: return        
</code></pre>

<p>  &hellip;</p>

<p>  public long getL();</p>

<pre><code>Code:
   0: aload_0       
   1: getfield      #72                 // Field l:J
   4: lreturn       
</code></pre>

<p>  public void setL(long);</p>

<pre><code>Code:
   0: aload_0       
   1: lload_1       
   2: putfield      #72                 // Field l:J
   5: return        
</code></pre>

<p>```</p>

<p>代码前的数字表示从方法开始算起的字节码偏移量。先看构造方法，由于void构造方法总会隐式调用父类的构造方法。因此有invokespecial指令。对于方法getL()和setL()也可以看到相应的操作码和参数。</p>

<p>javac产生的字节码没有经过特别优化，是非常简单的表示形式。大部分优化工作由JIT编译器来完成。</p>

<h3>运行时环境</h3>

<p>JVM没有处理器寄存器，而是使用堆栈机完成所有的计算和操作，所以理解堆栈机的操作对理解字节码至关重要。方法在运行时需要一块内存区域作为计算堆栈来计算新值。另外，每个运行的线程都需要一个调用堆栈来记录当前正在执行的方法。来看下面的代码是如何完成计算的：</p>

<p><code>return 3 + petRecords.getNumberOfPets("Ben");</code></p>

<p>系统首先会把3压入操作数栈，然后把接收对象（petRecords）压入计算堆栈，传入的参数尾随其后。然后invoke操作符会调用方法getNumberOfPets，把控制权移交给被调用的方法。进入新方法后，需要启用不同的操作数栈，所以已经在调用者操作数栈中的值不可能影响被调用方法的计算结果。</p>

<p>当getNumberOfPets完成时，返回结果会被放到调用者的操作数栈中，进程中与getNumberOfPets相关的部分也会从调用堆栈中移走。然后相加运算得到结果。</p>

<h3>操作码</h3>

<p>JVM字节码由操作码（opcode）序列构成，每个指令后可能会跟一些参数。每个操作码由一个单字节值表示，所以最多有255个操作码。目前用了200个左右。大致可以分为以下几类，摘要说明如下：</p>

<blockquote><ul>
<li>参数：操作码参数。如果参数出现在括号中，表示可选。以i打头的参数用来作为常量池或局部变量中的查询索引的几个字节。如果有多个此类参数，会合并在一直。例如i1,i2表示从这两个字节生成一个16位的索引。</li>
<li>堆栈布局：展示栈在操作码执行前后的状态。</li>
<li>表中操作码并不全，只用于示例。</li>
</ul>
</blockquote>

<p>加载和储存操作码，这个族系负责将值加载到栈或者检索值。有很多不同形式的变体。如dload操作码把双精度数从局部变量加载到栈上。</p>

<p><img src="/myresource/images/image_blog_2014-12-05-5-4.jpg" alt="image" /></p>

<p>数学运算操作码用来执行数学运算。</p>

<p><img src="/myresource/images/image_blog_2014-12-05-5-5.jpg" alt="image" /></p>

<p><img src="/myresource/images/image_blog_2014-12-05-5-6.jpg" alt="image" /></p>

<p><img src="/myresource/images/image_blog_2014-12-05-5-7.jpg" alt="image" /></p>

<p><strong>平台操作操作码</strong></p>

<p>在字节码这一级，构造方法被转换成带有特殊名称<init>的方法。不能由用户代码调用，但可以由字节码调用。这便形成了一个与对象创建直接相关的不同的字节码模式：new之后跟着一个dup，然后是一个调用<init>方法的invokespecial.</p>

<p><img src="/myresource/images/image_blog_2014-12-05-5-8.jpg" alt="image" /></p>

<blockquote><p>为了节省字节，很多字节码都有快捷方式。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java并发编程(四)]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/01/javabing-fa-bian-cheng-si/"/>
    <updated>2014-12-01T22:43:50+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/01/javabing-fa-bian-cheng-si</id>
    <content type="html"><![CDATA[<p>在学习了《Java编程思想》中关于<a href="/blog/2014/09/02/javabing-fa-bian-cheng-san/">并发编程</a>的内容后，继续学习Java并发编程。</p>

<!--more-->


<h2>1. 常用的并发构件</h2>

<h3>为什么是synchronized?</h3>

<p>这个单词的意思是同步，那么Java中synchronized表示什么意思呢？其实就是同步被锁定对象的主内存块。</p>

<ul>
<li>当进入一个synchronized代码块时，持有锁的线程和被锁定对象主内存中的视图会进行同步。</li>
<li>当synchronized代码块执行完之后，被锁定对象所做的任何修改会在线程锁释放之前刷回到主内存中。</li>
</ul>


<p>而volatile变量，在使用之前总是会从主内存中再读出来。线程所写的值总会在指令完成之前被刷回到主内存中。volatile变量不会引入线程锁，是真正线程安全的。<strong>但只有写入时不依赖当前状态（读取的状态）的变量才应该声明为volatile变量。对于要关注当前状态的变量，只能借助线程锁保证绝对安全性。</strong></p>

<h3>Lock有什么好处？</h3>

<ul>
<li>添加不同类型的锁，比如读取锁和写入锁。</li>
<li>对锁的阻塞没有限制，即允许在一个方法中上锁，在另一个方法中解锁。</li>
<li>如果线程得不到锁，比如锁由另外一个线程持有，就允许该线程后退或继续执行，或者做点别的事情——运用tryLock()方法。</li>
<li>允许线程尝试取锁，并可以在超过等待时间后放弃。</li>
</ul>


<p>Lock接口的两个实现类：</p>

<ul>
<li>ReentranLock: 本质上与同步块一样，但更灵活些。</li>
<li>ReentranReadWriteLock: 在读多写入的时候，性能更好。</li>
</ul>


<h3>ConcurrentHashMap</h3>

<p>ConcurrentHashMap是HashMap的并发版本，改进了Collections.synchronizedMap()功能。它是concurrent包中最有用的类之一，不仅提供了多线程的安全性，而且性能更优。它提供了原子操作的新方法：</p>

<ul>
<li>putIfAbsent(): 如果没有对应键，则将键值对添加到HashMap中。</li>
<li>remove(): 如果键存在，且值与当前状态相等，则用原子方式移除键值对。</li>
<li>replace(): 当键存在时，进行原子替换。</li>
</ul>


<h3>CopyOnWriteArrayList</h3>

<p>它是标准ArrayList的替代品，通过copy-on-write来实现线程安全性，对修改列表的任何操作都会创建一个新复本。当快速、一致的数据快照（不同的读取器读到的数据偶尔可能会不一样）比完美的同步以及性能上的突破更重要时，这种共享数据的方法非常理想，经常出现在非关键任务中。</p>

<h3>Queue</h3>

<p>Java有些多线程编程模型在很大程度上依赖于Queue实现线程安全性。BlockingQueue是最简单的实现。向队列put()时，如果队列满则放入线程会等待。从队列take()时，如果队列空，则取出线程阻塞。</p>

<p>Queue接口全是泛型<code>Queue&lt;E&gt;</code>，利用这一点把工作项封装到一个人工容器中会更方便。例如工作单元MyAwesomeClass，与其用<code>BlockingQueue&lt;MyAwesomeClass&gt;</code>不如使用<code>BlockingQueue&lt;WorkUnit&lt;MyAwesomeClass&gt;&gt;</code>：</p>

<p>```java
public class WorkUnit<T> {</p>

<pre><code>private final T workUnit;
public T getWork() {return workUnit;}
public WorkUnit(T workUnit) {
    this.workUnit = workUnit;
}
</code></pre>

<p>}
```</p>

<p>有了这层间接引用，可以添加额外的元数据而不用牺牲MyAwesomeClass的完整性。例如在WorkUnit中添加用于测试、性能指标和运行时系统信息等。</p>

<p>除了基本的put()和take()方法，BlockingQueue还提供了还超时的放入和取出方法：offer(E e, long timeout, TimeUnit unit)和poll(long timeout, TimeUnit unit)。</p>

<p>Java 7还引入了TransferQueue，本质上是多了transfer()操作的BlockingQueue。在BlockingQueue中，当上游线程池比下游快时，可能会引发一些问题，导致LinkedBlockingQueue溢出。反之，如果下游比上游快，则可能队列经常空着。TransferQueue可以优化这种情况，调控上/下游的速度。当消费线程在等待时，transfer()操作会马上把工作项传给它，否则就会阻塞直到取走工作项的线程出现。可以把这看做“挂号信”选项，即正在处理工作项的线程在交付当前工作项之前不会开始其他工作项的工作。</p>

<p>用TransferQueue取代BlockingQueue的代码性能可能会更好，因为前者的实现考虑了现代编译器和处理器的特性，执行效率更高。</p>

<h2>2. 控制执行</h2>

<p>如果每个工作单元都启动一个新线程执行，效率会太低。因此可以利用线程池来执行工作单元/任务。</p>

<h3>任务建模</h3>

<p>任务建模可以采用三种办法：Callable, Future接口和FutureTask类。</p>

<h4>Callable接口</h4>

<p>Callable接口代表一段可以调用并返回结果的代码，典型用法是匿名实现类：</p>

<p>```java
final MyObject obj = new MyObject();</p>

<p>Callable<String> cb = new Callable<String>() {</p>

<pre><code>public String call() throws Exception {
    return obj.someMethod();
}
</code></pre>

<p>};</p>

<p>String s = cb.call();
```</p>

<h4>Future接口</h4>

<p>Future接口用来表示异步任务。主要有三个方法：</p>

<ul>
<li>get()，获取结果，如果没执行完会阻塞，直到能取得结果。</li>
<li>cancel()，在结束前取消。</li>
<li>isDonw()，判断是否结束。</li>
</ul>


<p>```java
interface ArchiveSearcher { String search(String target); }
 class App {
   ExecutorService executor = &hellip;
   ArchiveSearcher searcher = &hellip;
   void showSearch(final String target)</p>

<pre><code>   throws InterruptedException {
 Future&lt;String&gt; future
   = executor.submit(new Callable&lt;String&gt;() {
     public String call() {
         return searcher.search(target);
     }});
 displayOtherThings(); // do other things while searching
 try {
   displayText(future.get()); // use future
 } catch (ExecutionException ex) { cleanup(); return; }
</code></pre>

<p>   }
 }
```</p>

<h4>FutureTask类</h4>

<p>FutureTask类是Future接口的常用实现类，实现了Runnable接口，因此可以由执行者调度。它提供的方法基本是Future和Runnable接口的组合：get(), cancel(), isDone(), isCancelled()和run()。它还提供了两个很方便的构造器：一个以Callable为参数，另一个以Runnable为参数。</p>

<p>```java
FutureTask<String> future =</p>

<pre><code>   new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() {
     public String call() {
       return searcher.search(target);
   }});
</code></pre>

<p>executor.execute(future);
```</p>

<h3>ScheduledThreadPoolExecutor(STPE)</h3>

<p>STPE是Executors类工厂方法的众多执行者之一。它有以下特点：</p>

<ul>
<li>可以预定线程池大小，也可自适应</li>
<li>所安排的任务可以定期执行，也可只运行一次。</li>
</ul>


<p>```java
ScheduledExecutorService stpe = Executors.newScheduledThreadPool(2);</p>

<p>final Runnable msgReader = new Runnable() {</p>

<pre><code>public void run() {
    //...
}
</code></pre>

<p>};</p>

<p>//每10毫秒唤醒一个线程。该线程可以尝试poll一个队列&hellip;
ScheduledFuture&lt;?> hndl = stpe.scheduleAtFixedRate(msgReader, 10, 10, TimeUnit.MILLISECONDS);
```</p>

<h2>3.分支/合并框架</h2>

<p>这是Java 7重点突出的框架之一，用于轻量级并发，实现线程池中任务的自动调度。</p>

<p>先来看看之前的并发算法可能存在的问题。如果某个线程的运行队列都是小任务，而另一个全是大任务。那么小任务的线程可能会空闲很多。而基于Work-Stealing（工作窃取）算法的ForkJoin则可以很好地解决此问题。</p>

<p><img src="/myresource/images/image_blog_2014-12-02-fork-join.GIF" alt="image" /></p>

<ul>
<li>分支/合并框架引入一种新的执行者服务，称为ForkJoinPool</li>
<li>ForkJoinPool处理比线程更小的并发单元ForkJoinTask</li>
<li>ForkJoinTask是一种由ForkJoinPool以更轻量化的方式所调度的抽象</li>
<li>通常使用两种任务（尽管都表示为ForkJoinTask实例）：“小型”任务是无需耗费太多时间就可以直接执行的任务；“大型”任务是需要分解（可能多次分解）后再执行的任务。</li>
</ul>


<p>这个框架的关键特性之一就是这些轻量的任务都能生成新的ForkJoinTask实例，而这些实例将仍由执行它们父任务的线程池来安排调度。这就是分而治之。例如在归并算法中，就可以将左侧、右侧的排序任务视为一个ForkJoinTask，在递归过程中，不断产生小型任务执行。下面的示例是一个对微博按时间归并排序的例子：</p>

<p>```java
//RecursiveAction继承自ForkJoinTask<Void>
public class MicroBlogUpdateSorter extends RecursiveAction {
  private static final int SMALL_ENOUGH = 32;
  private final Update[] updates;
  private final int start, end;
  private final Update[] result;</p>

<p>  public MicroBlogUpdateSorter(Update[] updates_) {</p>

<pre><code>this(updates_, 0, updates_.length);
</code></pre>

<p>  }</p>

<p>  public MicroBlogUpdateSorter(Update[] upds<em>, int startPos</em>, int endPos_) {</p>

<pre><code>start = startPos_;
end = endPos_;
updates = upds_;
result = new Update[updates.length];
</code></pre>

<p>  }</p>

<p>  private void merge(MicroBlogUpdateSorter left<em>, MicroBlogUpdateSorter right</em>) {</p>

<pre><code>int i = 0;
int lCt = 0;
int rCt = 0;
while (lCt &lt; left_.size() &amp;&amp; rCt &lt; right_.size()) {
  result[i++] = (left_.result[lCt].compareTo(right_.result[rCt]) &lt; 0) ? left_.result[lCt++]
      : right_.result[rCt++];
}
while (lCt &lt; left_.size())
  result[i++] = left_.result[lCt++];
while (rCt &lt; right_.size())
  result[i++] = right_.result[rCt++];
</code></pre>

<p>  }</p>

<p>  public int size() {</p>

<pre><code>return end - start;
</code></pre>

<p>  }</p>

<p>  public Update[] getResult() {</p>

<pre><code>return result;
</code></pre>

<p>  }</p>

<p>  @Override
  protected void compute() {</p>

<pre><code>  //如果数组太小，就用系统排序
if (size() &lt; SMALL_ENOUGH) {
  System.arraycopy(updates, start, result, 0, size());
  Arrays.sort(result, 0, size());
} else {
  int mid = size() / 2;
  MicroBlogUpdateSorter left = new MicroBlogUpdateSorter(updates, start,
      start + mid);
  MicroBlogUpdateSorter right = new MicroBlogUpdateSorter(updates, start
      + mid, end);
  invokeAll(left, right);
  merge(left, right);
}
</code></pre>

<p>  }</p>

<pre><code>public static void main() {
List&lt;Update&gt; lu = new ArrayList&lt;Update&gt;();
String text = "";
final Update.Builder ub = new Update.Builder();
final Author a = new Author("Tallulah");

for (int i = 0; i &lt; 256; i++) {
  text = text + "X";
  long now = System.currentTimeMillis();
  lu.add(ub.author(a).updateText(text).createTime(now).build());
  try {
    Thread.sleep(1);
  } catch (InterruptedException e) {
  }
}
Collections.shuffle(lu);
Update[] updates = lu.toArray(new Update[0]); // Avoid allocation by passing
                                              // zero-sized array
MicroBlogUpdateSorter sorter = new MicroBlogUpdateSorter(updates);
ForkJoinPool pool = new ForkJoinPool(4);
pool.invoke(sorter);

for (Update u : sorter.getResult()) {
  System.out.println(u);
}
</code></pre>

<p>  }
}
```</p>

<p>如果下面这些问题答案是肯定的，那么就适合于使用分支/合并框架：</p>

<ul>
<li>问题的子任务是否无需与其他子任务有显式的协作或同步也可以工作？</li>
<li>子任务是不是不会对数据进行修改，只是经过计算得出结果？</li>
<li>对于子任务来说，分而治之是不是很自然的事？子任务是不是会创建更多的子任务，而且它们要比派生出它们的任务粒度更细？</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java NIO.2]]></title>
    <link href="http://blog.ubone.com/blog/2014/11/23/java-nio-dot-2/"/>
    <updated>2014-11-23T10:59:37+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/11/23/java-nio-dot-2</id>
    <content type="html"><![CDATA[<p>Java 7提供了新的NIO(或称为NIO.2, JSR-203)，这是一组新的类和方法，用于取代File类与文件系统的交互，提供新的异步处理类并简化Socket与通道的编码工作。</p>

<!--more-->


<p>在Java 1.4之前，Java缺乏对非阻塞I/O的支持，1.4引入了非阻塞I/O，为I/O操作抽象出缓冲区和通道层；提供字符集的编码和解码能力；能够将文件映射为内存数据；实现正则表达式。Java 7进一步扩展了NIO的能力。</p>

<h2>1. PATH</h2>

<p>Path相关的类包括：</p>

<ul>
<li>Path：获取路径信息</li>
<li>Paths：工具类，提供返回一个路径的辅助方法</li>
<li>FileSystem：与文件系统交互的类</li>
<li>FileSystems：工具类，提供各种方法。</li>
</ul>


<p>Path不仅用于传统的文件系统，也能表示zip或jar这样的文件系统。</p>

<p>```java
//创建Path
Path listing = Paths.get(&ldquo;/user/bin/zip&rdquo;)；
//相当于
Path listing = FileSystems.getDefault().getPath(&ldquo;/user/bin/zip&rdquo;);</p>

<p>//获取Path信息：
listing.getFileName(): zip
listing.getNameCount(): 3
listing.subpath(0, 2): /user/bin
listing.getParent(): /user/bin
listing.getRoot(): /
```</p>

<p>如果Path是一个文件的路径，有时需要去除冗余信息。例如去除表示当前路径的<code>./</code>，或者该文件只是个符号链接，指向了另一个真正的位置，此时需要得到真实路径。</p>

<p>```java
//移除冗余
Path testPath = Paths.get(&ldquo;./test.java&rdquo;);
Path normalizedPath = testPath.normalize();</p>

<p>//获取绝对路径
Path absolutePath = testPath.toAbsolutePath();
//获取绝对路径并去除冗余信息，或者获取符号连接的真实路径
Path realPath = testPath.toRealPath();
```</p>

<p>合并路径与路径比较。</p>

<p>```java
//合并
Path prefix = Paths.get(&ldquo;/usr&rdquo;);
Path completePath = prefix.resolve(&ldquo;mxs&rdquo;);
//completePath: /usr/mxs</p>

<p>//比较
Path path1 = Paths.get(&ldquo;/Users/mxs/Documents/Blog/&rdquo;);
Path path2 = Paths.get(&ldquo;/Users/mxs&rdquo;);
path1.relativize(path2): ../..
path2.relativize(path1): Documents/Blog
```</p>

<p>新的API完全替换了java.io.File类，在处理遗留代码时，可能将其进行互换：</p>

<p><code>java
File file = new File("../abcd.txt");
Path listing = file.toPath();
file = listing.toFile();
</code></p>

<h2>2. 处理目录与目录树</h2>

<p>新的DirectoryStream<T>接口实现了目录相关的操作：</p>

<ul>
<li>循环遍历目录中的子项</li>
<li>用glob表达式（如<code>*Foobar*</code>）进行目录子项的匹配和MIME内容检测（如text/xml文件）</li>
<li>用walkFileTree实现递归移动、复制和删除操作</li>
</ul>


<p><strong>在目录中查找文件：</strong></p>

<p>```java
Path dir = Paths.get(&ldquo;/user/mxs/Documents&rdquo;);</p>

<p>try(DirectoryStream<Path> stream = Files.newDirectoryStream(dir, &ldquo;*.properties&rdquo;)) {</p>

<pre><code>for(Path entry : stream){
    System.out.println(entry.getFileName());    
}
</code></pre>

<p>} catch(IOException e) {</p>

<pre><code>//...
</code></pre>

<p>}
```</p>

<p><strong>遍历目录树。</strong>Files.walkFileTree方法是遍历目录树的关键，该方法定义如下：</p>

<p><code>Files.walkFileTree(Path startingDir, FileVisitor&lt;? super Path&gt; visitor);
</code></p>

<p>其中Visitor是一个接口，包括5个方法，但一般使用Java的默认实现SimpleFileVisitor就可以了。</p>

<p>```java
public void walk() {</p>

<pre><code>Path dir = Paths.get("/code/src");
Files.walkFileTree(dir, new FindJavaVisitor());
</code></pre>

<p>}</p>

<p>private static class FindJavaVisitor extends SimpleFileVisitor<Path> {</p>

<pre><code>@Override
public FileVisitresult visitFile(Path file, BasicFileAttributes attrs) {
    if (file.toString().endsWith(".java")) {
        //...
    }

    return FileVisitResult.CONTINUE;
}
</code></pre>

<p>}
```</p>

<p>需要注意的是，walkFileTree方法不会自动跟随符号链接（为了确保递归等操作的安全性）。因此如果你需要跟随符号链接，就需要检查相应属性并执行相应操作。</p>

<h2>3. 文件系统I/O</h2>

<p>在NIO.2中，Files和WatchService是两个重要的基础类。前者用于复制、移动、删除或处理文件，后者用于监视文件或目录，发出定制通知等。</p>

<h3>3.1 创建和删除文件</h3>

<p><code>java
Path target = Paths.get("/Users/mxs/Document/mystuff.txt");
Path file = Files.createFile(target);
</code></p>

<p>如果需要设置文件属性，如读、写和执行的权限，则需要设置FileAttribute，但文件属性与操作系统相关，因此要使用与操作系统相关的文件权限类。以下是POSIX文件系统的示例(其它文件系统参考java.nio.file.attribute.*FilePermission类)：</p>

<p><code>java
Set&lt;PosixFilePermission&gt; perms = PosixFilePermissions.fromString("rw-rw-rw-");
FileAttribute&lt;Set&lt;PosixFilePermission&gt;&gt; attr = PosixFilePermissions.asFileAttribute(perms);
Files.createFile(target, attr);
</code></p>

<p>删除文件只需要调用<code>Files.delete(target)</code>方法。</p>

<h3>3.2 文件复制与移动</h3>

<p>```java
Path source = Paths.get(&ldquo;c:\My Documents\stuff.txt&rdquo;);
Path target = Paths.get(&ldquo;D:\backup\stuff.txt&rdquo;);
Files.copy(source, target);</p>

<p>//复制时还可以设置CopyOptions选项（变参，可多个。ATOMIC_MOVE确保两边都成功，否则回滚）
import static java.nio.file.StandardCopyOption.*;
Files.copy(source, target, REPLACE_EXISTING, COPY_ATTRIBUTES, ATOMIC_MOVE);</p>

<p>//移动
Files.move(source, target);
Files.move(source, target, CopyOptions);
```</p>

<h3>3.3 文件属性</h3>

<p>由于不同的文件系统属性不同，因此Java中的文件属性分为基本文件属性、特定文件属性。前者是各文件系统通用的文件属性。</p>

<p><code>java
Path zip = Paths.get("/usr/bin/zip");
Files.getLastModifiedTime(zip);
Files.size(zip);
Files.isSymbolicLink(zip);
Files.isDirectory(zip);
Files.readAttributes(zip, "*"); //批量读取属性
</code></p>

<p>特定文件属性独立于某个操作系统。以POSIX文件系统为例：</p>

<p>```java
//获取文件属性
PosixFileAttributes attrs = Files.readAttributes(zip, PosixFileAttributes.class);</p>

<p>//修改属性
Set<PosixFilePermission> permissions = attrs.permissions();
permissions.clear;
permissions.add(GROUP_READ);
//&hellip;
Files.setPosixFilePermissions(zip, permissions);
```</p>

<p>符号链接的处理：</p>

<p>```java
Path file = Paths.get(&ldquo;/opt/platform/java&rdquo;);
if (Files.isSymbolicLink(file)) {</p>

<pre><code>file = Files.readSymbolicLink(file);
</code></pre>

<p>}
//继续处理文件相关操作
Files.readAttributes(file, BasicFileAttributes.class);
```</p>

<h3>3.4. 快速读写数据</h3>

<p>Files工具类提供了更方便的方法来读写数据：</p>

<p>```java
Path logFile = Paths.get(&ldquo;/tmp/app.log&rdquo;);
try(BufferedReader reader =</p>

<pre><code>Files.newBufferedReader(logFile, StandardCharsets.UTF_8)) {
String line;
while((line = reader.readLine()) != null) {
    //...
}
</code></pre>

<p>}</p>

<p>//写入
try(BufferedWriter writer =</p>

<pre><code>Files.newBufferedWrite(logFile, StandardCharsets.UTF_8, StandardOpenOption.WRITE)) //变参，可多个
</code></pre>

<p>{</p>

<pre><code>writer.write("Hello!");
</code></pre>

<p>}
```</p>

<p>Files工具类提供的方法还有<code>newInputStream()</code>, <code>newOutputStream()</code>等方法，用于配合现有IO类。还有更方便的方式：</p>

<p><code>java
List&lt;String&gt; lines = Files.readAllLines(logFile, StandardCharsets.UTF_8);
byte[] bytes = Files.readAllBytes(logFile);
</code></p>

<h3>3.5. 文件修改通知</h3>

<p>WatchService可用于监测文件或目录的变化，可监测的事件包括：ENTRY_CREATE, ENTRY_DELETE, OVERFLOW(事件已经丢弃或丢失)。</p>

<p>```java
import static java.nio.file.StandardWatchEventKinds.*;</p>

<p>try {</p>

<pre><code>WatchService watcher = FileSystems.getDefault().newWatchService();
Path dir = FileSystems.getDefault().getPath("/usr/mxs");
WatchKey key = dir.register(watcher, ENTRY_MODIFY);

while(!shutdown ) { //一个标志，判断循环是否该结束
    key = watcher.take();
    for (WatchEvent&lt;?&gt; event: key.pollEvents()) {
        if (event.kind() == ENTRY_MODIFY) {
            //dir changed
        }
    }
    key.reset(); 
}
</code></pre>

<p>} catch(IOException | InterruptedException e) {</p>

<pre><code>//...
</code></pre>

<p>}
```</p>

<h3>3.6 SeekableByteChannel</h3>

<p>这是Java 7引入的新接口，用于改变字节通道的位置和大小。例如用多个线程去分析一个大型日志文件的字节通道。FileChannel是这个接口的一种实现，下面的示例读取日志文件的最后1000个字符：</p>

<p><code>java
Path logFile = Paths.get("c:\\temp.log");
ByteBuffer buffer = ByteBuffer.allocate(1024);
FileChannel channel = FileChannel.open(logFile, StandardOpenOption.READ);
channel.read(buffer, channel.size() - 1000);
</code></p>

<h2>4. 异步I/O操作</h2>

<p>异步I/O操作主要有两种方式：Future和回调。Java 7提供了三个新的异步通道：</p>

<ul>
<li>AsynchronousFileChannel 用于文件I/O</li>
<li>AsynchronousSocketChannel 用于Socket I/O, 支持超时</li>
<li>AsynchronousServerSocketChannel 用于Socket接受异步连接</li>
</ul>


<h3>4.1 Future方式</h3>

<p>```java
try {</p>

<pre><code>Path file = Paths.get("/usr/mxs/foobar.txt");
AsynchronousFileChannel channel = AsynchronousFileChannel.open(file);

//读取100 000字节
ByteBuffer buffer = ByteBuffer.allocate(100_1000); 
Future&lt;Integer&gt; result = channel.read(buffer, 0);//返回值为Integer

//如果未结束
while(! result.isDone()) {
    //...干点别的事。
}

//获取结果
Integer byteRead = result.get();
</code></pre>

<p>} catch(IOException | ExecutionException | InterruptedException e) {</p>

<pre><code>//...
</code></pre>

<p>}
```</p>

<h3>4.2 回调方式</h3>

<p>CompletionHandler&lt;V, A>是回调的接口。V表示结果类型，A是提供结果的附着对象。</p>

<p>```
try {</p>

<pre><code>Path file = Paths.get("/usr/mxs/foobar.txt");
AsynchronousFileChannel channel = AsynchronousFileChannel.open(file);
//读取100 000字节
ByteBuffer buffer = ByteBuffer.allocate(100_1000); 

channel.read(buffer, 0, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;(){
    public void completed(Integer result, ByteBuffer attachment) {
        //完成时的回调方法
    }

    public void failed(Throwable exception, ByteBuffer attachment) {
        //失败时的回调方法
    }
});
</code></pre>

<p>} catch(IOException e) {</p>

<pre><code>//...
</code></pre>

<p>}
```</p>

<h2>5. Socket与Channel整合</h2>

<p>NetworkChannel把Socket和Channel结合起来，更好地应对网络编程。而MulticastChannel则可以用于像BitTorrent这样的多播编程。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 7的6个新特性]]></title>
    <link href="http://blog.ubone.com/blog/2014/11/18/java-7de-6ge-xin-te-xing/"/>
    <updated>2014-11-18T22:20:52+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/11/18/java-7de-6ge-xin-te-xing</id>
    <content type="html"><![CDATA[<p>Java 8早都出来了，现在来了解一下Java 7语言上的几个新特性。 :) switch语句支持String、数字常量的新形式、改进的异常处理、TWR语句、钻石语法和变参警告位置的修改。</p>

<!--more-->


<h2>1. switch语句支持String</h2>

<p>```java
public void printDay(String dayOfWeek) {</p>

<pre><code>switch(dayOfWeek) {
    case "Sunday": System.out.println("周日"); break;
    case "Saturday": System.out.println("周六"); break;
    ...
    default: System.out.println("不知道"); break;
}
</code></pre>

<p>}
```</p>

<h2>2. 更强的数值文本表示法</h2>

<p><code>java
int x = 0b1100110; //0b表示二进制
int bitPattern = 0b0001_1100_0011; //也可以加下划线
long longValue = 2_111_000_888L; //加下划线便于阅读
</code></p>

<h2>3. 改善的异常处理</h2>

<p>```java
try {</p>

<pre><code>String fileText = getFile(fileName);
cfg = verifyConfig(parseConfig(fileText));
</code></pre>

<p>} catch(FileNotFoundException | ParseException | ConfigurationException e) {</p>

<pre><code>//可以用或来表示可能的异常
...
</code></pre>

<p>} catch(IOException iox) {</p>

<pre><code>...
</code></pre>

<p>}
```
另一个新语法对需要重新抛出异常时很有用：</p>

<p>```java
try {</p>

<pre><code>doSomethingWhichMightThrowIOException();
doSomethingElseWhichMightThrowSQLException();
</code></pre>

<p>} catch (final Exception e) {</p>

<pre><code>...
//不再是抛出笼统的Exception，而是抛出实际的异常。
//final不是必须的，但留着提个醒有好处。
throw e;
</code></pre>

<p>}
```</p>

<h2>4. TWR(try-with-resources)</h2>

<p>这个很有用，特别是io操作时，可以抛掉大串丑陋的代码了。</p>

<p>```java
try (</p>

<pre><code>OutputStream out = new FileOutputStream(file);
InputStream is = url.openStream()
</code></pre>

<p>) {</p>

<pre><code>byte[] buf = new byte[4096];
int len;
while (len = is.read(buf)) &gt; 0)
    out.write(buf, 0, len);
</code></pre>

<p>}
```</p>

<p>上面的代码将资源放在try的圆括号内，当处理完后会自动关闭！但一定要注意不要嵌套创建，否则可能无法正确关闭。一定要声明变量。例如下面的代码就应该修改：</p>

<p>```java
try (ObjectInputStream in =</p>

<pre><code>new ObjectInputStream(
    new FileInputStream("someFile.bin"))) {
...
</code></pre>

<p>}</p>

<p>//要改为：
try (</p>

<pre><code>FileInputStream fin = new FileInputStream("someFile.bin");
ObjectInputStream in = new ObjectInputStream(fin)) {
...
</code></pre>

<p>}</p>

<p>```</p>

<p>TWR特性依赖于try从句中的资源类实现新接口AutoCloseable。Java 7平台的大多数资源都已经修改过了。</p>

<h2>5. 钻石语法</h2>

<p>```java
//不用这么麻烦了：
Map&lt;Integer, Map&lt;String, String>> userList = new HashMap&lt;Integer, Map&lt;String, String>>();</p>

<p>//可以直接写成：
Map&lt;Integer, Map&lt;String, String>> userList = new HashMap&lt;>();
```</p>

<h2>6. 简化变参方法调用</h2>

<p>在Java 7之前，如果泛型和变参结合起来会怎么样？</p>

<p>```java
public static <T> Collection<T> doSomething(T&hellip; entries) {</p>

<pre><code>...
</code></pre>

<p>}
```</p>

<p>Java处理变参实际上是把它放到一个编译器自动创建的数组中。但我们知道泛型的实现其实是通过<a href="/blog/2014/07/02/javafan-xing/">擦拭法</a>实现的。所以Java数组不支持泛型:</p>

<p>```java
HashMap&lt;String, String>[] a = new HashMap&lt;String, String>[3]; //编译错误</p>

<p>HashMap&lt;String, String>[] a = new HashMap[3]; //编译可通过，但会有警告：
//Type safety: The expression of type HashMap[] needs unchecked conversion to conform to HashMap&lt;String,String>[]
```</p>

<p>因此，当泛型遇到变参时，编译器只好给你个警告。但这个问题更应该由API的设计者去关注，而不是API使用者。所以Java 7把警告信息挪到了定义API的地方。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[再读《重构》]]></title>
    <link href="http://blog.ubone.com/blog/2014/09/19/zhong-gou/"/>
    <updated>2014-09-19T20:04:48+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/09/19/zhong-gou</id>
    <content type="html"><![CDATA[<p>数年前读过Martin Fowler的《重构——改善既有代码的设计》，被这本经典著作所折服。当时读的是英文电子版，今天拿到一本中文版，就想再读一遍，温故而知新。哪成想，读来已经不是当年的感觉了。现在觉得这本经典著作提到的重构方法很普通，都是日常使用的方法。而内容却已经太过时，毕竟作者写书时是Java1.2即将发布，而现在Java 9都快要出来了。像集合与之前比有了质的飞跃，而泛型的使用则更好地提高了代码质量和可读性。这些年设计模式的普及也对重构形成了更有力的理论支撑。所有这些都对重构方法产生了影响。</p>

<p>不论如何，既然又读了一遍，那么就记录于此吧。</p>

<!--more-->


<h2>1. 代码的坏味道</h2>

<p>代码有哪些坏的味道，相应地有哪些重构方法？下面列出了常见的坏味道代码以及相应的重构方法：</p>

<p><strong>重复代码</strong></p>

<blockquote><p>Extract Method, Pull Up Method, Form Template Method, Substitute Algorithm</p></blockquote>

<p><strong>过长函数</strong></p>

<blockquote><p>Extract Method, Replace Temp with Query, Introduce Parameter Object, Preserve Whole Object, Replace Method with Method Object, Decompose Conditional</p></blockquote>

<p><strong>过大的类</strong></p>

<blockquote><p>Extract Class/Subclass/Interface, Dulplicate Observed Data</p></blockquote>

<p><strong>过长参数列</strong></p>

<blockquote><p>Replace Parameter with Method, Preserve Whole Object, Introduce Parameter Object</p></blockquote>

<p><strong>发散式变化</strong></p>

<blockquote><p> Extract Class</p></blockquote>

<p><strong>霰弹式修改</strong></p>

<blockquote><p>Move Method/Field, Inline class</p></blockquote>

<p><strong>依恋情绪</strong></p>

<blockquote><p> Move Method, Extract Method</p></blockquote>

<p><strong>数据泥团</strong></p>

<blockquote><p>Extract Class, Introduce Parameter Object, Preserve Whole Object</p></blockquote>

<p><strong>基本类型偏执</strong></p>

<blockquote><p>Replace Data Value with Object, Replace Type Code with Class/Subclass, Replace Type Code with State/Strategy, Extract Class, Introduce Parameter Object, Replace Array with Object</p></blockquote>

<p><strong>switch惊悚现身</strong></p>

<blockquote><p>Extract Method, Move Method, Replace Type Code with Subclasses/State/Strategy, Replace Conditional with Polymorphism, Replace Parameter with Explicit Methods, Introduce Null Object</p></blockquote>

<p><strong>平行继承体系</strong></p>

<blockquote><p>Move Method, Move Field</p></blockquote>

<p><strong>Lazy Class</strong></p>

<blockquote><p>Collapse Hierarchy, Inline Class</p></blockquote>

<p><strong>夸夸其谈未来性</strong></p>

<blockquote><p>Collapse Hierarchy, Inline Class, Remove Parameter, Rename Method</p></blockquote>

<p><strong>令人迷惑的暂时字段</strong></p>

<blockquote><p>Extract Class, Introduce Null Object</p></blockquote>

<p><strong>过度耦合的消息链</strong></p>

<blockquote><p>Hide Delegate, Extract Method, Move Method</p></blockquote>

<p><strong>中间人</strong></p>

<blockquote><p>Remove Middle Man, Inline Method, Replace Delegation with Inheritance</p></blockquote>

<p><strong>狎昵关系</strong></p>

<blockquote><p>Move Method, Move Field, Change Bidirectional Association to Unidirectional, Extract Class, Hide Delegate, Replace Inheritance with Delegation</p></blockquote>

<p><strong>异曲同工的类</strong></p>

<blockquote><p>Rename Method, Move Method, Extract Superclass</p></blockquote>

<p><strong>不完美的类库</strong></p>

<blockquote><p>Introduce Foreign Method, Introduce Local Extension</p></blockquote>

<p><strong>Data Class</strong></p>

<blockquote><p>Encapsulate Field, Encapsulate Collection, Remove Setting Method, Move Method, Extract Method, Hide Method</p></blockquote>

<p><strong>被拒绝的遗赠</strong></p>

<blockquote><p>Replace Inheritance with Delegation</p></blockquote>

<p><strong>过多的注释</strong></p>

<blockquote><p>避免代码逻辑复杂而加注释。Extract Method, Rename Method, Introduce Assertion</p></blockquote>

<h2>2. 构筑测试体系</h2>

<p>了解了坏味道的代码，在重构之前要拥有一个可靠的测试环境。否则你如何验证重构后有没有问题？不仅如此，<strong>每当你收到bug报告，也请先写一个单元测试来重现bug。</strong></p>

<p><strong>单元测试与功能测试的区别？</strong>功能测试是从客户的角度保障质量，一般是把整个系统当作一个黑箱。对拥有GUI的待测系统，它们通过GUI来操作该系统。对数据库，功能测试只观察特定输入所导致的数据变化。</p>

<p>JUnit就是一个测试框架，其用途是单元测试。关于JUnit，必须知道的知识包括：</p>

<p>```java
//必须继承TestCase
class FileReaderTest extends TestCase {</p>

<pre><code>protected void setUp() {...} //用于在每次测试前准备相应环境
protected void tearDown() {...} //用于测试完后大扫除，例如关闭文件。
public void testXXX() {//注意必须是返回void, 方法名test开始
    //...
    assertEquals(...); //然后就可以assertXXX了
}       
</code></pre>

<p>}
```</p>

<p>执行每一个test测试方法前，都会先运行setUp()。每一个test测试方法执行结束都会运行tearDown()。</p>

<p>别忘了检查预期的异常是否如期出现，例如，如果尝试在关闭流后再读取它，就应该得到一个IOException，这也应该被测试出来：</p>

<p>```java
_input.close();
try{</p>

<pre><code>_input.read();
fail("no exception for read past end");
</code></pre>

<p>} catch(IOException io) {</p>

<pre><code>//...
</code></pre>

<p>}</p>

<p>```</p>

<p>当测试类越来越多，就用得上TestSuite了。TestSuite可以用于只执行某一些测试类，或者某一些测试方法。示例如下：</p>

<p>```java
public class TestAllSort {</p>

<pre><code>public static Test suite() {
    TestSuite suite = new TestSuite("测试分组名称");

    //测试类SortTest的所有测试方法都会运行
    suite.addTestSuite(SortTest.class);

    //只运行测试类SortTest的指定测试方法testSelectSort
    suite.addTest(new SortTest("testSelectSort"));

    return suite;
}
</code></pre>

<p>}</p>

<p>public class SortTest extends TestCase {</p>

<pre><code>//如果要执行指定的测试方法，那么这个构造方法是必须的。name对应测试方法名
public SortTest(String name) {
    super(name);
}

public void testSelectSort() {
    //...
}
</code></pre>

<p>} <br/>
```</p>

<p><strong>边界条件是最容易出错的地方，要把火力集中在那！</strong></p>

<p><strong>重构的基本技巧是：小步前进、频繁测试！</strong></p>

<p>下面开始重构方法的介绍。</p>

<h2>3. 重新组织函数</h2>

<p>几乎所有的问题都源于过长的函数，因此重新组织函数很有必要！</p>

<h3>3.1 Extract Method</h3>

<p>Extract Method是最常用的重构手法之一。</p>

<ol>
<li>如果每个函数的粒度都很小，那么函数被复用的机会就更大。</li>
<li>使得高层的函数读起来就像一系列的注释。</li>
<li>如果函数都是细粒度，覆写也会更容易。</li>
</ol>


<p>关键点：函数名和函数本体之间的语义要匹配。</p>

<p>```java</p>

<pre><code>//before
void printOwing(double amount) {
    printBanner();

    //print details
    System.out.println("name: " + _name);
    System.out.print("amount: " + amount);
}

//after
void printOwing(double amount) {
    printBanner();

    printDetails(amount);
}

void printDetails(double amount) {
    System.out.println("name: " + _name);
    System.out.print("amount: " + amount);
}
</code></pre>

<p>```</p>

<h3>3.2 Inline Method</h3>

<p>如果函数内容和其名称同样清晰，就应该去掉这个函数。</p>

<p>```java</p>

<pre><code>//before
int getRating() {
    return (moreThanFiveLateDeliveries()) ? 2 : 1;
}

boolean moreThanFiveLateDeliveries() {
    return numberOfLateDeliveries &gt; 5;
}

//after
int getRating() {
    return (numberOfLateDeliveries &gt; 5) ? 2 : 1;
}
</code></pre>

<p>```</p>

<h3>3.3 Inline Temp</h3>

<p>适用于一个临时变量，只被一个简单表达式赋值一次，而它妨碍了其他重构手法。</p>

<p>```java
//before
double basePrice = anOrder.basePrice();
return (basePrice > 1000);</p>

<p>//after
return (anOrder.basePrice() > 1000);
```</p>

<h3>3.4 Replace Temp with Query</h3>

<p>你的程序以一个临时变量保存某一表达式的运算结果。将这个表达式提炼到一个独立函数中。</p>

<p>```java</p>

<pre><code>//before
double basePrice = quantity * itemPrice;
if (basePrice &gt; 1000) 
    return basePrice * 0.95;
else
    return basePrice * 0.98;

//after
if (basePrice() &gt; 1000) 
    return basePrice() * 0.95;
else
    return basePrice() * 0.98;

//...

double basePrice() {
    return quantity * itemPrice;
}
</code></pre>

<p>```</p>

<p>如果你担心性能问题，先不管它，因为十有八九根本不会造成任何影响。如果真有问题，在优化时解决它。</p>

<h3>3.5 Introduce Explaining Variable</h3>

<p>你有一个复杂的表达式，可以将该复杂表达式（或其中一部分）的结果放进一临时变量，以此变量名称来解释用途。</p>

<p>```java
//before
if ((platform.toUpperCase().indexOf(&ldquo;MAC&rdquo;) > -1) &amp;&amp;</p>

<pre><code>    (browser.toUpperCase().indexOf("IE") &gt; -1) &amp;&amp;
    wasInitialized() &amp;&amp; resize &gt; 0) {
//do something
</code></pre>

<p>}</p>

<p>//after
final boolean isMacOs = platform.toUpperCase().indexOf(&ldquo;MAC&rdquo;) > -1;
final boolean isIEBrowser = browser.toUpperCase().indexOf(&ldquo;IE&rdquo;) > -1;
final boolean wasResized = resize > 0;</p>

<p>if (isMacOs &amp;&amp; isIEBrowser &amp;&amp; wasInitialized() &amp;&amp; wasResized) {</p>

<pre><code>//do something
</code></pre>

<p>}
```</p>

<p>这种重构方法虽然很常见，但几乎总是可以用Extract Method来处理。因此常在Extract Method难以解决，或需要花费更大工作量时使用。</p>

<h3>3.6 Split Temporary Variable</h3>

<p>如果某个临时变量被赋值超过一次，即不是循环变量，也不是用于收集计算结果，那么可以针对每次赋值创建一个独立的临时变量。</p>

<p>```java
// before
double temp = 2 * (height + width);
System.out.println(temp);
temp = height * widht;
System.out.println(temp);</p>

<p>// after
final double perimeter = 2 * (height + width);
System.out.println(perimeter);
final double area = height * widht;
System.out.println(area);
```</p>

<p>临时变量有各种不同的用途，如果同一临时变量被多次赋值，且意义不同，就会令代码难以阅读。</p>

<h3>3.7 Remove Assignments to Parameters</h3>

<p>不要对参数赋值。因为Java对于参数传递的处理方式是按值传递。对参数赋值同样容易让人犯糊涂。</p>

<p>```java
//before
int discount(int inputVal, int quantity, int yearToDate) {</p>

<pre><code>if (inputVal &gt; 50) inputVal -= 2;
</code></pre>

<p>}</p>

<p>//after
int discount(int inputVal, int quantity, int yearToDate) {</p>

<pre><code>int result = inputVal;
if (inputVal &gt; 50) result -= 2;
</code></pre>

<p>}
```</p>

<h3>3.8 Replace Method with Method Object</h3>

<p>对于一个大型函数，其中的局域变量使你无法采用Extract Method时，可以将这个函数放进一个单独对象中。</p>

<p>```java
class Order&hellip;</p>

<pre><code>double price() {
    double basePrice;
    double secondPrice;
    double otherPrice;
    //复杂的运算
}
</code></pre>

<p>```</p>

<p>上面的代码可以这样重构：</p>

<p><img src="/myresource/images/image_blog_20140920_235546.jpg" alt="image" /></p>

<h3>3.9 Substitute Algorithm（替换算法）</h3>

<p>如果发现一件事可以有更清晰的方式（更好的解决方案/算法），就应该以较清晰的方式取代复杂的方式。</p>

<p>```java
//before
String foundPerson(String[] people) {</p>

<pre><code>for (int i = 0; i &lt; people.length; i++) {
    if (people[i].equals("Don")) {
        return "Don";
    }
    if (people[i].equals("John")) {
        return "John";
    }
    if (people[i].equals("Kent")) {
        return "Kent";
    }
}

return "";
</code></pre>

<p>}</p>

<p>//after
String foundPerson(String[] people) {</p>

<pre><code>List candidates = Arrays.asList(new String[]{"Don", "John", "Kent"});
for(String str : people) {
    if (candidates.contains(str)) {
        return str;
    }
}

return "";
</code></pre>

<p>}
```</p>

<h2>4. 在对象之间搬移特性</h2>

<p>在对象的设计过程中，“决定把责任放在哪儿”是最重要的事情之一。</p>

<h3>4.1 Move Method</h3>

<p>如果某个函数与另一个类进行更多交流，调用它或者被它调用。那么可以在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或者将旧函数完全移除。</p>

<h3>4.2 Move Field</h3>

<p>如果某个字段被另一个类更多地用到，那么可以在目标类新建一个字段，修改源字段的所有用户，令它们改用新字段。</p>

<h3>4.3 Extract Class</h3>

<p>如果某个类做了应该由两个类做的事，那么可以新建一个类，将相关的字段和函数搬移到新类。</p>

<p>例如订单包括地址的详细信息（城市、街道、邮编等等），可以考虑新建一个地址类。</p>

<h3>4.4 Inline Class</h3>

<p>与Extract Class正好相反，如果某个类不再承担责任，不再有单独存在的理由，可以考虑将这个类的所有特性搬移到另一个类中，然后移除原类。</p>

<p><img src="/myresource/images/image_blog_20140921_171841.jpg" alt="image" /></p>

<h3>4.5 Hide Delegate</h3>

<p>当客户通过一个委托类来调用另一个对象，可以在服务类上建立客户所需的所有函数，用以隐藏委托关系。</p>

<p><img src="/myresource/images/image_blog_20140921_180822.jpg" alt="image" /></p>

<p>封装意味着每个对象都应该尽可能少了解系统的其它部分。这其实也是迪米特法则的不和陌生人说话。</p>

<h3>4.6 Remove Middle Man</h3>

<p>如果某个类做了过多的简单委托动作，可以让客户直接调用受托类。这与Hide Delegate正好相反：</p>

<p><img src="/myresource/images/image_blog_20140921_180823.jpg" alt="image" /></p>

<h3>4.7 Introduce Foreign Method</h3>

<p>你需要为提供服务的类增加一个函数，但你无法修改这个类。此时，可以在客户类中建立一个函数，并以第一个参数形式传入一个服务类实例。</p>

<p>```java
//before
Date newStart = new Date(previousEnd.getYear(), previousEnd.getMonth(), previousEnd.getDate() + 1);</p>

<p>//after
Date newStart = nextDay(previousEnd);</p>

<p>private static Date nextDay(Date arg) {</p>

<pre><code>return new Date(arg.getYear(), arg.getMonth(), arg.getDate() + 1);
</code></pre>

<p>}
```</p>

<p>你正在使用一个类，它工作得很好。但你又需要一项新服务，这个类无法提供。如果可以修改代码，你就可以自行添加一个函数。但如果不能，你就得在客户端编码，补足你要的那个函数。如果需要多次使用，就应该放到同一个函数中。</p>

<p>如果发现自己为一个服务类建立了大量外加函数，或者发现有许多类都需要同样的外加函数，就不应该使用本项重构，而是应该使用下面这个重构方法：Introduce Local Extension。</p>

<h3>4.8 Introduce Local Extension</h3>

<p>你需要为服务类提供一些额外函数，但你无法修改这个类。此时你可以建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或包装类。</p>

<p><img src="/myresource/images/image_blog_20140921_184031.jpg" alt="image" /></p>

<p>其实就是通过聚合或者继承扩展一个类。</p>

<h2>5. 重新组织数据</h2>

<h3>5.1 Self Encapsulate Field</h3>

<p>就是不要直接访问域，而是通过方法，如getter/setter访问。</p>

<h3>5.2 Replace Data Value with Object</h3>

<p>例如早期类Order有个String类型的属性customer表示客户姓名，随着开发的进行，customer可能需要变成一个类，用customer.name表示姓名。</p>

<h3>5.3 Change Value to Reference</h3>

<p>就是值对象改为引用对象。当组合变为聚合时，就需要将值对象改为引用。</p>

<h3>5.4 Change Reference to Value</h3>

<p>与前一方法正好相反。</p>

<h3>5.5 Replace Array with Object</h3>

<p>在Effective Java中，对数组也有较多描述。数组是不安全的类型，而泛型则安全得多。而此处所说的方法，则是说应该用面向对象的类去取代数组，以及依附于数组的操作。这样做具有更好的安全性和可读性。</p>

<h3>5.6 Duplicate Observed Data</h3>

<p>一个分层良好的系统，应该将处理用户界面和处理业务逻辑的代码分开。因为你可能需要使用不同的用户界面来表现相同的业务逻辑，与GUI隔离之后，领域对象的维护和演化都会更容易。尽管可以轻松地将“行为”划分到不同部分，“数据”却往往不能如此。将界面数据复制到一个领域对象中，建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据。</p>

<h3>5.7 Change Unidirectional Association to Bidirectional</h3>

<p>将两个类之间的单向关联改为双向关联。</p>

<h3>5.8 Change Bidirectional Association to Unidirectional</h3>

<p>将两个类之间的双向关联改为单向关联。双向关联很有用，但你必须为它付出代价，那就是维护双向连接、确保对象被正确创建和删除而增加的复杂度。只在必要的时候才使用双向关联。</p>

<h3>5.9 Replace Magic Number with Symbolic Constant</h3>

<p>以字面常量取代魔法数。魔法数是指拥有特殊意义，却又不能明确表现出这种意义的数字。</p>

<p>```java
//before
double potentialEnergy(double mass, double height) {</p>

<pre><code>return mass * 9.81 * height;
</code></pre>

<p>}</p>

<p>//after
static final double GRAITATIONAL_CONSTANT = 9.81;</p>

<p>double potentialEnergy(double mass, double height) {</p>

<pre><code>return mass * GRAITATIONAL_CONSTANT * height;
</code></pre>

<p>}
```</p>

<h3>5.10 Encapsulate Field</h3>

<p>如果类中存在public的属性，将它声明为private，并提供相应的访问函数（如getter, setter方法）。</p>

<h3>5.11 Encapsulate Collection</h3>

<p>让函数只返回集合的只读副本(例如Collection.unmodifiableXXX())，并提供添加/删除元素的函数。</p>

<p><img src="/myresource/images/image_blog_20140921_222518.jpg" alt="image" /></p>

<h3>5.12 Replace Record with Data Class</h3>

<p>将传统编程环境中的记录结构转换成数据类。</p>

<h3>5.13 Replace Type Code with Class</h3>

<p>这个重构方法有点过时了，更好的方式应该是使用枚举类型。</p>

<h3>5.14 Replace Type Code with Subclasses</h3>

<p>如果类型码会影响宿主类的行为，那么最好的办法就是借助多态来处理变化行为。即以类型码的宿主类为基类，针对每种类型建立相应的子类。例如针对员工类型建立子类（工程师，业务员）。</p>

<p>但有两种情况你不能那么做：类型码值在对象创建之后发生了改变；由于某些原因，宿主类已经有了子类。这时候可能需要状态模式或者策略模式。</p>

<h3>5.15 Replace Type Code with State/Strategy</h3>

<p>参考<a href="/blog/2014/08/18/she-ji-mo-shi-zhuang-tai-mo-shi/">状态模式</a>与<a href="/blog/2014/08/09/she-ji-mo-shi-ce-lue-mo-shi/">策略模式</a>。</p>

<h3>5.16 Replace Subclass with Fields</h3>

<p>建立子类的目的是为了增加新我或改变其行为。有一种变化行为称为“常量函数”，就是返回一个硬编码的值。你可以让不同的子类返回不同的值。但如果子类只有常量函数，则没有足够的存在价值，完全可以在父类中用一个属性来代替。</p>

<h2>6. 简化条件表达式</h2>

<h3>6.1 Decompose Conditional(分解条件表达式)</h3>

<p>从if, then, else三个段落中分别提炼出独立函数：</p>

<p>```java
//before
if (date.before(SUMMER_START) || date.after(SUMMER_END))</p>

<pre><code>charge = quantity * _winterRate + _winterServiceCharge;
</code></pre>

<p>else</p>

<pre><code>charge = quantity * _summerRate;
</code></pre>

<p>//after
if (notSummer(date))</p>

<pre><code>charge = winterCharge(quantity);
</code></pre>

<p>else</p>

<pre><code>charge = summerCharge(quantity);        
</code></pre>

<p>```</p>

<p>和任何大块头的代码一样，你可以将它分解为多个独立函数。</p>

<h3>6.2 Consolidate Conditional Expression（合并条件表达式）</h3>

<p>如果有一系列条件测试，都得到相同的结果，你可以将它们合并为一个表达式，并提炼成一个函数。</p>

<p>```java
//before
double disabilityAmount() {</p>

<pre><code>if (_seniority &lt; 2) return 0;
if (_monthsDisabled &gt; 12) return 0;
if (_isPartTime) return 0;
//...
</code></pre>

<p>}</p>

<p>//after
double disabilityAmount() {</p>

<pre><code>if (isNotEligibleForDisability()) return 0;
//...
</code></pre>

<p>}
```</p>

<h3>6.3 Consolidate Duplicate Conditional Fragments</h3>

<p>合并重复的条件片段。</p>

<p>```java
//before
if (isSpecialDeal()) {</p>

<pre><code>total = price * 0.95;
send();
</code></pre>

<p>} else {</p>

<pre><code>total = price * 0.98;
send();
</code></pre>

<p>}</p>

<p>//after
if (isSpecialDeal()) {</p>

<pre><code>total = price * 0.95;
</code></pre>

<p>} else {</p>

<pre><code>total = price * 0.98;
</code></pre>

<p>}
send();
```</p>

<h3>6.4 Remove Control Flag</h3>

<p>类似下面的代码，应该以break或return语句取代控制标记。</p>

<p>```
set done to false
while not down</p>

<pre><code>if (condition)
    do something
    set done to true
next step of loop
</code></pre>

<p>```</p>

<h3>6.5 Replace Nested Conditional with Guard Clauses</h3>

<p>```java
//before
double getPayAmount() {</p>

<pre><code>double result;
if (_isDead) 
    result = deadAmount();
else {
    if (_isSeparated)
        result = separatedAmount();
    else {
        if (_isRetired)
            result = retiredAmount();
        else
            result = normalPayAmount;
    }
}

return result;
</code></pre>

<p>}</p>

<p>//after
double getPayAmount() {</p>

<pre><code>if (_isDead) return deadAmount();
if (_isSeparated) return separatedAmount();
if (_isRetired) return retiredAmount();
return normalPayAmount();
</code></pre>

<p>}
```</p>

<h3>6.6 Replace Conditional with Polymorphism</h3>

<p>用多态取代条件表达式。例如下面的类</p>

<p>```java
//before
double getSpeed() {</p>

<pre><code>switch(type) {
    case EUROPEAN:
        return getBaseSpeed();
    case AFRICAN:
        return getBaseSpeed() - xxx;
    case NORWEGIAN_BLUE:
        return ...
}
</code></pre>

<p>}</p>

<p>//after, 以Bird为基类，European, African, Norwegian Blue为子类，实现多态方法getSpeed()。
```</p>

<h3>6.7 Introduce Null Object</h3>

<p>如果你需要再三检查某个对象是否为null，可以将null值替换为null对象。</p>

<p>```java
if (customer == null)</p>

<pre><code>plan = BillingPlan.basic();
</code></pre>

<p>else</p>

<pre><code>plan = customer.getPlan();
</code></pre>

<p>```</p>

<p>上面的代码可以重构为：</p>

<p><img src="/myresource/images/image_blog_20140922_200250.jpg" alt="image" /></p>

<p>其好处在于，你不必再向对象询问“你是什么类型”，你只管调用该行为就是了。空对象一定是常量，它们的任何成分都不会发生变化，因此可以用单例模式来实现。</p>

<p><strong>只有当大多数客户代码都要求空对象做出相同响应时，这样的重构才有意义。</strong></p>

<p>你可以针对不同的情况拥有几种不同的空对象。例如没有顾客、不知名顾客等。本质上这是一个比Null Object模式更大的模式：Special Case模式，即特例类，也就是某个类的特殊情况。</p>

<h3>6.8 Introduce Assertion</h3>

<p>断言是一个条件表达式，应该总是为真。如果它失败，表示程序员犯了错误。</p>

<p>注意不要滥用断言。不要使用它来检查“你认为应该为真”的条件，应该只使用它来检查“一定必须为真”的条件。你该问自己：如果断言所指示的约束条件不能满足，代码是否仍能正常运行？如果可以，就把断言拿掉。</p>

<h2>7. 简化函数调用</h2>

<p>前三个太简单的重构方法：Rename Method, Add Parameter, Remove Parameter。</p>

<h3>7.4 Separate Query from Modifier</h3>

<p>将查询函数和修改函数分离。如果某个函数即返回对象状态值，又修改对象状态，可以考虑建立两个不同的函数，其中一个负责查询，另一个负责修改。</p>

<p><strong>任何有返回值的函数，都不应该有看得到的副作用。</strong>请尽量遵守这条规则。</p>

<h3>7.5 Parameterize Method</h3>

<p>如果若干函数做了类似的工作，但函数体中却包含了不同的值，可以考虑建立一个单一函数，以参数形式表达那些不同的值。</p>

<p><img src="/myresource/images/image_blog_20140922_204225.jpg" alt="image" /></p>

<h3>7.6 Replace Parameter with Explicit Methods</h3>

<p>如果一个函数，其行为取决于参数值，那么可以考虑针对该参数的每一个可能值，建立一个独立函数。</p>

<p>```java
//before
void setValue(String name, int value) {</p>

<pre><code>if (name.equals("height")) {
    height = value;
    return;
}

if (name.equals("width")) {
    width = value;
    return;
}
</code></pre>

<p>}</p>

<p>//after
void setHeight(int value) {</p>

<pre><code>height = value;
</code></pre>

<p>}</p>

<p>void setWidth(int value) {</p>

<pre><code>width = value;
</code></pre>

<p>}
```</p>

<h3>7.7 Preserve Whole Object</h3>

<p>如果你从某个对象中取出若干值，将它们作为某一次函数调用时的参数，可以考虑改为传递整个对象。</p>

<p>```java
//before
int low = daysTempRange().getLow();
int hight = daysTempRange().getHigh();
withinPlan = plan.withinRange(low, high);</p>

<p>//after
withinPlan = plan.withinRange(daysTempRange());
```</p>

<h3>7.8 Replace Parameter with Methods</h3>

<p>对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能调用前一个函数。那么<strong>让参数接受者去除该项参数，并直接调用前一个函数。</strong></p>

<p>```java
//before
int basePrice = quantity * itemPrice;
discountLevel = getDiscountLevel();
double finalPrice = discountedPrice(basePrice, discountLevel);</p>

<p>//after
int basePrice = quantity * itemPrice;
double finalPrice = discountedPrice(basePrice);
```</p>

<p>如果函数本身可以通过其他途径获得参数值，那么它就不应该通过参数取得该值。应尽量缩短参数的数量。</p>

<h3>7.9 Introduce Parameter Object</h3>

<p>如果函数的参数数量太多，可以考虑用一个对象封装这些数据。</p>

<h3>7.10 Remove Setting Method</h3>

<p>类中的某个字段应该在对象创建时被设值，然后就不再改变，那么可以去掉该字段的所有setter方法。如果你提供了setter方法，就暗示这个字段值可以改变。去除setter方法，改为构造方法中传入就是一种好的重构方法。</p>

<h3>7.11 Hide Method</h3>

<p>如果一个函数，从来没有被其他任何类用到，可以考虑将其修改为private。</p>

<p>理想情况下，可以使用工具检查所有函数，指出可被隐藏起来的函数。</p>

<h3>7.12 Replace Constructor with Factory Method</h3>

<p>如果你希望在创建对象时，不仅仅是做简单的构建动作，可以考虑将构造方法替换为工厂方法。</p>

<h3>7.13 Encapsulate Downcast</h3>

<p>封装向下转型。如果某个函数返回的对象，需要由函数调用者执行向下转型，可以将向下转型动作移到函数中。</p>

<p>```java
//before
Object lastReading() {</p>

<pre><code>return readings.lastElement();
</code></pre>

<p>}</p>

<p>//after
Reading lastReading() {</p>

<pre><code>return (Reading) readings.lastElement();
</code></pre>

<p>}</p>

<p>```</p>

<p>向下转型也许是不可避免的，但仍然应该尽可能少做。通常在返回迭代器和集合的函数上会发生。</p>

<p>其实对于Java5之后，已经有泛型了，这条重构方法完全可以被泛型所取代。</p>

<h3>7.14 Replace Error Code with Exception</h3>

<p>某个函数返回一个特定的代码，用以表示错误情况，这种情况可以改用异常。</p>

<p>```java
//before
int withdraw(int amount) {</p>

<pre><code>if (amount &gt; balance)
    return -1;
else {
    balance -= amount;
    return 0;
}
</code></pre>

<p>}</p>

<p>//after
void withdraw(int amount) throws BalanceException {</p>

<pre><code>if (amount &gt; balance) throw new BalanceException();
balance -= amount; 
</code></pre>

<p>}
```</p>

<p>这种方式之所以更好，是因为它清楚地将普通程序和错误处理分开了，使程序更容易理解。</p>

<h3>7.15 Replace Exception with Test</h3>

<p>如果select()方法可能抛出异常，你可以将其变成两个方法：canSelect(), select()。如果你可以合理期望调用者在调用函数之前先检查某个条件，那么就应该提供一个测试方法。</p>

<h2>8. 处理继承关系</h2>

<p>几种常见的方法：</p>

<ul>
<li>将属性和方法上移：Pull Up Field, Pull Up Method, Pull Up Constructor Body</li>
<li>将属性和方法下移：Pull Down Field, Pull Down Method</li>
</ul>


<h3>8.6 Extract Subclass</h3>

<p>如果类中的某些属性只被某些（而非全部）实例用到，那么可以新建一个子类，将那些属性移到子类 中。</p>

<h3>8.7 Extract Superclass</h3>

<p>如果两个类有类似特性，就可以为它们建立一个父类，将相同特性移到父类。</p>

<h3>8.8 Extract Interface</h3>

<p>如果若干个客户使用类接口中的同一个子集，或者两个类的接口有部分相同，那么可以将相同的子集提炼到一个独立的接口中。</p>

<h3>8.9 Collapse Hierarchy</h3>

<p>如果超类和子类无太大区别，那么可以考虑将它们合并成一个类。</p>

<h3>8.10 Form Template Method</h3>

<p>说的就是模板方法模式。</p>

<h3>8.11 Replace Inheritance with Delegation</h3>

<p>说的就是组合/聚合模式。</p>

<h3>8.12 Replace Delegation with Inheritance</h3>

<p>与上一个正好相反。如果你发现自己需要使用受托类中的所有函数，并且费了很大力气编写所有极简的委托函数，那么你可以考虑回头使用继承。</p>
]]></content>
  </entry>
  
</feed>
