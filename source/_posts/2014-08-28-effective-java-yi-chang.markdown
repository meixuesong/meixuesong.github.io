---
layout: post
title: "Effective Java - 异常"
date: 2014-08-28 23:15:18 +0800
comments: true
categories: 
- java
---
Effective Java 通用程序设计，读书笔记：

57. 只对异常情况才使用异常
58. 对可恢复的情况使用受检异常，对编程错误使用运行时异常
59. 避免不必要地使用受检的异常
60. 优先使用标准的异常
61. 抛出与抽象相对应的异常
62. 每个方法抛出的异常都要有文档
63. 在细节消息中包含能捕获失败的消息
64. 努力使失败保持原子性
65. 不要忽略异常

<!--more-->

##57 只对异常情况才使用异常
永远不要将异常用于正常的控制流。下面的代码试图使用异常退出循环，这是有问题的：

```java
//有问题的代码
try {
     int i = 0;
     while(true)
          range[i++].climb();
} catch (ArrayIndexOutOfBoundsException e) {
}
```

设计良好的API不应该强迫客户端为了正常的控制流而使用异常。可以考虑提供“状态测试”方法，例如Iterator的next()方法有一个对应的“状态测试方法” hasNext()。

##58 对可恢复的情况使用受检异常，对编程错误使用运行时异常
如果期望调用者能够适当地恢复，应该使用受检的异常。对于程序错误，则使用运行时异常。对于受检异常，可以提供一些辅助方法，通过这些方法调用者可以获得一些有助于恢复的信息。例如用户取款时余额不足，可以提供一个方法获取余额。

##59 避免不必要地使用受检的异常
当以下两个条件都成立时，才使用受检异常：

1. 正确地使用API并不能阻止这种异常条件的产生（例如网络、文件）。
2. 一旦产生异常，使用API的程序员可以立即采取有用的动作，这种负担被认为是正当的。

把受检异常变成运行时异常的一种方法是，把这个抛出异常的方法分成两个方法，其中一个返回boolean，表明是否应该抛出异常。例如前述的hasNext()。

##60 优先使用标准的异常
使用标准的异常至少有以下好处：

1. API更加易于学习和使用
2. 可读性更好
3. 异常类越少，内存印迹（footprint）就越少，装载这些类的时间开销也越少。

常见的可重用异常包括：

1. IllegalArgumentException 非Null的参数值不正确
2. IllegalStateException 对于方法调用而言，对象状态不合适。
3. NullPointException
4. IndexOutOfBoundsException
5. ConcurrentModificationException 禁止并修改时，检测到对象的并发修改
6. UnsupportedOperationException

##61 抛出与抽象相对应的异常
更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常。这种做法也就是**异常转译**。

如果低层的异常对于调试导致高层异常的问题非常有帮助，使用异常链就很合适。大多数标准异常都支持链的构造器，如果不支持，可以利用Throwable的initCause方法设置原因。下面代码展示了异常转译和异常链：

```java
try{
...
} catch(LowerLevelException cause) {
     throw new HigherLevelException(cause);
}

class HigherLevelException extends Exception {
     HigherLevelException(Throwable cause) {
          super(cause);
     }
}
```

##62 每个方法抛出的异常都要有文档
始终要单独地声明受检的异常，并利用Javadoc的`@throws`标记，准确地记录下抛出每个异常的条件 。如果一个方法可能抛出多个异常，不要使用“快捷方式”，声明它们的某个父类。永远不要声明一个方法“throws Exception”，因为它不仅没有提供任何有用的信息，而且掩盖了其它可能抛出的异常。

对于接口中的方法，在文档中记录下它可能抛出的未受检异常也很重要。也就是用Javadoc的`@throws`标记进行说明，但在方法的声明中不使用throws关键字。

##63 在细节消息中包含能捕获失败的消息
为了捕获失败，异常的细节信息应该包含所有“对该异常有贡献”的参数和域的值。例如IndexOutOfBoundsException就包括了三个信息：上界、下界以及不在界内的下标值。但是包含大量的描述信息也没有什么意义，因为堆栈轨迹的用途是与源文件结合起来使用的。

异常的细节消息不应该与“用户层次的错误信息”混为一谈。

为了确保异常的细节消息中包含足够的能捕获失败的消息，通常在异常的构造器中引入这些信息。如：

```java
public IndexOutOfBoundsException(int lowerBound, int upperBound, int index) {
     ...
}
```

##64 努力使失败保持原子性
一般而言，失败的方法调用应该使对象保持在被调用之前的状态。具有这种属性的方法称为具有失败原子性。

要实现失败原子性，最简单的办法是设计不可变对象。对于可变对象，可采取的办法包括：

1. 执行操作前，检查参数的有效性。
2. 调整计算处理的顺序，使任何可能会失败的计算部分在对象状态被修改之前发生。
3. 编写一段恢复代码。（这种办法主要用于永久性的数据结构，如磁盘）
4. 在对象的一份临时拷贝上执行操作，操作完成后再用临时拷贝中的结果替换对象的内容。

##65 不要忽略异常
空的catch块会使异常达不到应有的目的。如果确实需要空catch块，至少也要包含一条说明，为什么可以忽略此异常。
