---
layout: post
title: "JVM字节码执行引擎"
date: 2015-01-20 06:40:46 +0800
comments: true
categories: 
- java
---
JVM执行引擎输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。本文从概念模型的角度学习栈帧结构、方法调用和字节码执行。

<!--more-->

## 1. 运行时栈帧结构
栈帧（Stack Frame）是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素，是支持虚拟机进行方法调用和方法执行的数据结构。每个方法从调用开始到执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。

每个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和额外的附加信息。在编译生成字节码时，栈帧中需要多大的局部变量表、多深的操作数栈就已经完全确定并保存在方法表的Code属性中。

一个线程中的方法调用链可能很长，很多方法同时处于执行状态。但对执行引擎来说，活动线程中，只有栈顶的栈帧才是有效的，称为当前栈帧。与当前栈帧相关联的方法称为当前方法。执行引擎运行的所有字节码指令都只针对当前栈帧操作。

![image](/myresource/images/image_blog_-2015-01-20_06.59.02.jpg)

### 1.1 局部变量表
局部变量表用于存放方法参数和方法内局部变量，其容量以Variable Slot为最小单位。每个Slot可以存放32位以内的数据类型，包括boolean、byte、char、short、int、float、reference和returnAddress，对于64位的数据类型long和double，会分配2个连续的Slot。由于虚拟机栈是线程的私有数据，因此操作2个Slot不会引起数据安全问题。

虚拟机通过索引定位的方式使用局部变量表，索引值从0到最大Slot数量。在方法执行时，局部变量表完成参数值到数量变量列表的传递过程。如果执行的是实例方法（非static），关键字"this"是隐含参数，位于第0个索引，其余参数按照参数表顺序排列。

为了节省栈帧空间，Slot是可以重用的，因为方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用。但这也会有一些副作用，示例如下：

```java
public static void main(String[] args) {
	{
		byte[] placeholder = new byte[64*1024*1024];//64MB
	}
	
	int a = 0; //!
	System.gc();
}
```

上面的代码，如果没有`int a`那一行，从逻辑上讲应该能够回收placeholder的内存，但实际上并非如此。原因就是代码虽然已经离开了placeholder的作用域，但在此之后，没有任何对局部变量表的读写操作，placeholder占用的Slot还没有被其他变量复用，所以GC Roots一部分的局部变量表仍然保持对它的关联。因此加上`int a`那一行就能够正常回收了。

因此，如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用大量内存，实际上已经不再会使用的变量，手动将其设置为null以帮助内存回收也是有意义的。需要注意的是，在日常编程时，没必要过度依赖将变量设置为null，因为编译器优化和JIT编译都可能使赋null语句被优化掉。

此外，局部变量并没有类变量和实例变量那样存在“准备阶段”，因此不会自动赋予系统初始值。

### 1.2 操作数栈
操作数栈（Operand Stack）也常称为操作栈，它是后入先出（LIFO）栈。当一个方法开始执行时，它的操作数栈是空的。在方法执行过程中，会有各种字节码指令往操作数栈写入和提取内容。

在概念模型中，两个栈帧是完全独立的。但大多虚拟机实现都会做优化，让两个栈帧出现一部分重叠。让下面的栈帧的部分操作数栈与上面的栈帧的部分局部变量表重叠在一起，无须进行额外的参数复制。

### 1.3 动态连接
每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。

### 1.4 方法返回地址
当方法开始执行后，有两种方式退出。一是遇到方法返回的字节码指令；二是遇到异常并且这个异常没有在方法体内得到处理。无论哪种退出方式，方法退出之后都要返回到方法被调用的位置。一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是通过异常处理器表来确定的，栈帧中一般不会保存此信息。

方法退出的过程就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，修改PC计数器的值以指向后一条指令等。

### 1.5 附加信息
各虚拟实现时会增加一些规范中没有描述的信息放到栈帧中，例如与调试相关的信息。

## 2. 方法调用
方法调用并不是方法执行，此阶段的唯一任务是确定被调用方法的版本，即调用哪一个方法。

### 2.1 解析（Resolution）
所有方法调用中的目标方法在Class文件里都是一个常量池中的符号引用。在解析阶段，会将其中一部分符号引用转化为直接引用：如果方法在真正运行之前就有一个可确定的调用版本，并且这个调用版本在运行期是不可改变的，那么就会被转化为直接引用。

符合这个条件的有静态方法、私有方法、实例构造器和父类方法4类。这4类方法和final方法都称为非虚方法。非虚方法在编译期间就完成了解析调用，将符号引用转变为可确定的直接引用。

### 2.2 分派（Dispatch）
分派与解析相反，要在运行时确定调用哪个版本的方法。这是多态特性的体现。分派可能是静态或动态的，根据分派的依据又分为单分派和多分派。

#### 2.2.1 静态分派
首先明确什么是静态类型和实际类型，看下面的代码：

```java
public class Human{...}
public class Man extends Human{...}
public class Woman extends Human{...}

public void sayHello(Human h) {print("human");}
public void sayHello(Man h) {print("man");}
public void sayHello(Woman h) {print("woman");}

public static void main(String[] args) {
	Human man = new Man();
	syaHello(man); //会打印什么呢？
}
```

在main方法中，Human称为变量的Static类型或Apparent类型，而Man则为变量的实际类型。

所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是方法重载(Overload)。虚拟机在重载时通过参数的静态类型而不是实际类型作为判定依据。并且静态类型是编译期可知的，因此在编译阶段，编译器会根据参数的静态类型决定使用哪个方法的重载版本。所以main方法中会打印human.

#### 2.2.2 动态分派
在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。典型应用是方法重写(Override)。

#### 2.2.3 单分派与多分派
方法的接收者和方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以分为单分派和多分派。单分派根据一个宗量对目标方法进行选择，而多分派则根据多于一个宗量对目标方法进行选择。

根据上面的知识，可以得知：Java是一门静态多分派，动态单分派的语言。

#### 2.2.4 虚拟机动态分派的实现
由于动态分派是非常频繁的动作，需要在运行时中确定，因此虚拟机的实现基于性能考虑，并不会进行频繁的搜索，而是采用虚方法表来提高性能。

虚方法表中存放了各个方法的实际入口。如果某个方法在子类中没有被重写，那么子类的虚方法表里面的地址入口与父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类重写了这个方法，则子类方法表中的地址将会替换为指向子类实现版本的入口地址。

方法表一般在类加载的连接阶段进行初始化，类的变量初始值后，会把该类的方法表也初始化。

## 3. 基于栈的字节码解释执行引擎
虚拟机执行Java代码时有解释执行和编译执行。先学习一下解释执行。

Java编译器输出的指令流，基本是一种基于栈的指令集架构（Instruction Set Architecture, ISA），指令流中的指令大部分是零地址指令，它们依赖操作数栈工作。相对应的，x86使用的是基于寄存器的指令集。

基于栈的指令集主要优点是可移植，但缺点是执行速度会稍慢一些，因为出栈入栈操作本身就产生了相当多的指令数量，而且栈实现是在内存中，比寄存器的速度慢了很多。

通过一段代码来学习基于栈的解释器执行过程。

```java
public int calc() {
	int a = 100;
	int b = 200;
	int c = 300;
	return (a+b) *c;
}
```

对应的字节码：

```
public int calc();
Code:
stack=2, Locals=4, Args_size=1
0: bipush 100		//将单字节的整数常量值(-128~`17)推入操作数栈
2: istore_1		//将操作数栈顶的整形值出栈并存放到第1个局部变量Slot中
3: sipush 200		//与0类似
6: istore_2
7: sipush 300		
10:istore_3
11:iload_1		//将局部变量表第1个Slot的整型值复制到操作数栈顶
12:iload_2		//将局部变量表第2个Slot的整型值复制到操作数栈顶
13:iadd		//将操作数栈中的头两个栈顶出栈，相加，再将结果入栈
14:iload_3		//把第3个Slot的300压入操作数栈
15:imul		//将操作数栈中头两个栈顶出栈，相乘，将结果入栈
16:ireturn		//结束方法执行，将操作数栈顶的整数返回
```

上面的示例可以看出中间变量都以操作数栈的入栈和出栈为信息交换途径。以上执行过程只是概念模型，实际执行时虚拟机会做优化。















