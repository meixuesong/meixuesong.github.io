---
layout: post
title: "散列表(HashTable)"
date: 2014-10-03 10:03:40 +0800
comments: true
categories: 
- 算法
---
散列表也是一种符号表，它通过算法将键转化为数组的索引来访问数组中的键值对。散列表查找的第一步是用散列函数将被查找的键转化为一数组索引，第二步是处理碰撞冲突。解决碰撞冲突的方法有拉链法和线性探测法。

<!--more-->
## 1. 散列函数
散列函数用于将键转化为数组的索引，它应该易于计算并且能够均匀分布所有的键。散列函数和键的类型有关，对于每种类型的键都需要一个与之对应的散列函数。

Java对正整数采用除留余数法计算散列值。选择大小为素数M的数组，对于任意正整数k，计算余数：`k%M`，能够有效地将键散布在0到M-1的范围内。素数又称为质数，是一个大于1的自然数，除了1和它本身外，不能被其他自然数整除（除0以外）的数。Java对浮点数会将键表示为二进制数然后再使用除留余数法。对字符串采用类似Homer方法，用N次乘法、加法和取余来计算散列值。

对Java程序，`hashCode()`和`equals()`方法必须一致。如果`equals()`返回`true`那么`hashCode()`返回值必须一致，反过来则可以不同。

## 2. 基于拉链法的散列表
当`hashCode()`返回值相同，但`equals()`为false时，就发生了碰撞。解决碰撞的一种方法是拉链法。拉链法是指数组中的每个元素都指向一个链表，链表中的每个结点都存储了散列值为该元素的索引的键值对。因此这样的散列表由数组+链表构成。查找时先根据散列值找到对应的链表，然后沿着链表顺序查找相应的键。

![image](/myresource/images/image_blog_2014-10-03_separate-chaining.png)

可以看出，散列表的查找性能与散列表的大小有很大关系，对N个元素来说，当散列表的大小M过小时，碰撞机率就会增加，链表的长度必然增加，从而降低了查找效率。因此在内存不紧张时，可以选择一个足够大的M，内存紧张时，选择尽量大的M。另一种方法是动态调整数据的大小以保持短小的链表。

执行删除操作时，先用散列值找到索引及对应的链表，然后调用链表的删除方法即可。

对于有序性相关的符号表操作，散列表都不是合适的选择，因为这些操作的运行时间都是线性的。

Java的TreeMap和HashMap分别是基于红黑树和拉链法的散列表的符号表实现。

## 3. 基于线性探测法的散列表
实现散列表的另一种方式是用大小为M的数组保存N个键值对，其中M>N。依靠数据中的空位解决碰撞冲突。基于这种策略的所有方法都统称为开放地址散列表。其中最简单的方法叫做线性探测法：当碰撞发生时，直接检查散列表的下一个位置（索引加1），可能产生三种结果：

* 命中，该位置的键和被查找的键相同；
* 未命中，键为空（该位置没有键）；
* 继续查找，该位置的键和被查找的键不同。

其核心思想是与其将内存用作链表，不如将它们作为散列表的空元素。即用散列函数找到索引，检查其中的键和被查找的键是否相同。如果不同则继续查找（增加索引，到达数组结尾后再折回数组开头），直到找到该键或者遇到一个空元素。过程如下图所示：

![image](/myresource/images/image_blog_2014-10-03_linear-probing.png)

在基于线性探测法的散列表中执行删除操作比较复杂，如果将该键所在位置为为null是不行的。需要将簇中被删除键的右侧的所有键重新插入散列表。

这种散列表的性能也依赖于N/M，但在这里表示散列表的利用率。如果利用率达到1，即散列表满了，会造成未命中的查找无限循环。为了保证性能，要动态调整数组的大小来保证利用率在1/8到1/2之间。

## 4. 数组的大小和内存使用
对于线性探测法，调整数组的大小是必需的。对于拉链法，如果你能准确估计所需的散列表大小N，调整数据的工作不是必需的，只需要根据查找耗时和`(1+N/M)`成正比来选取一个适当的M即可。

符号表的内存使用：

方法 | N个元素所需的内存（引用类型）
------|-----
基于拉链法的散列表 | ~48N + 32M
基于线性探测的散列表 | 在~32N和~128N之间
各种二叉查找树 | ~56N

## Q&A
Q: Java的Integer, Double和Long类型的hashCode()是如何实现的？
>Integer类型直接返回该整数的32位值。对Double和Long返回机器表示的前32位和后32位异或的结果。

Q: 为什么不将`hash(x)`实现为`x.hashCode() % M`?
>Java中，取余的结果可能是负数。

Q: 为什么不将`hash(x)`实现为`Math.abs(x.hashCode()) % M`?
>对于最大的整数`Math.abs()`会返回一个负值，这种溢出可能使程序崩溃。

Q: 在拉链法中，链表是否可以使用二叉查找树或者红黑树？
>一般来说，散列表碰撞机率越少越好，因此链表越短越好。所以链表的初级实现的性能一般会更好，特殊情况下最好由专家进行这种调优。

Q: 散列表的查找比红黑树更快吗？
>取决于键的类型，也就是hashCode()的计算成本是否大于compareTo()的比较成本。但通常散列表会比红黑树快得多。但散列表无法高效支持有序性相关的操作。