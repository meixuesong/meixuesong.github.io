---
layout: post
title: "Effective Java-类和接口"
date: 2014-07-08 18:58:31 +0800
comments: true
categories: 
- Java

---

本文总结《Effective Java》中“类和接口”的论述。

<!--more-->


##13.使类和成员的可访问性最小化

最小化可访问性的目的是隐藏信息，隐藏信息的原因主要是为了模块解耦。正确地使用修饰符（private, protected和public）很重要。

第一条规则是：尽可能地使每个类或者成员不被外界访问。对于顶层（非嵌套）类和接口，应该只有两种可能的访问级别：包级私有（即没有修饰符时）和public。包级私有仍然是这个包的实现的一部分，以后可以对它进行修改，无需担心客户端。但如果是public，则有责任永远支持它。

如果一个包级私有的顶层类/接口只在某一个类的内部被使用，仍应该考虑将它变成那个类的私有嵌套类。

长度非零的数组总是可变的，所以，类具有公有的静态final数组域，或者返回这种域的访问方法，这几乎总是错误的！

```java

//潜在安全漏洞
public static final Thing[] VALUES = {...};

//可改为：
private static final Thing[] PRIVATE_VALUES = {...};
public static final List<Thing> VALUES = 
	Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
	
//或者返回一个数组的备份：
private static final Thing[] PRIVATE_VALUES = {...};
public static final Thing[] values {
	return PRIVATE_VALUES.clones();
}	

```

##14.在public类中使用访问方法而非公有域

简单说，就是public类的属性不要public，而是提供访问方法（如getter, setter）。如果属性不是final的，直接公开属性将表示放弃对该值的控制。即使该属性是final，但如果它引用了可变对象，一样会存在问题。

##15.使可变性最小化

不可变类是其实例无法修改的类。不可变类不容易出错，本质上是线程安全的，不要求同步。要使类成为不可变，要遵循以下五条规则：

1. 不提供任何会修改对象状态的方法。
2. 保证类不会被扩展。
3. 使所有域都是final的。
4. 使所有域都成为私有的。
5. 确保对任何可变组件的互斥访问。如果类中有指向可变对象的域，必须确保客户端无法获得指向这些对象的引用。**永远不要用客户端提供的对象引用来初始化这样的域，也不要从任何访问方法返回该对象的引用。**可使用保护性拷贝技术。

不可变类唯一的缺点是，对每个不同的值都需要一个单独的对象。对大型对象代价会很高。

其中第2条，保证类不会被扩展，除了使类成为final外，也可以将类的构造器为私有或者包级私有，然后提供静态工厂。

如果你选择让自己的不可变类实现Serializable接口，并且它包含指向可变对象的域，就必须提供一个显式的readObject或者readResolve方法，或者使用ObjectOutputStream.writeUnshared和ObjectInputStream.readUnshared方法。否则攻击者可能从不可变类创建可变的实例。

如果类不能被做成不可变的，仍然应该尽可能地限制它的可变性。尽量使域/属性成为final。

构造器应该创建完全初始化的对象。尽量不要在构造器或者静态工厂之外再提供公有的初始化方法。同时也不应该提供“重新初始化”方法。

##16.复合优先于继承

继承打破了封装性。子类依赖于父类中特定功能的实现细节。父类的实现有可能会随着发行版本的不同而有所变化。

通过复合（Composition），现有类变成了新类的一个组件，新类提供方法调用现有类实例中对应的方法，并返回它的结果。这被称为转发。

包装类几乎没有缺点。但包装类不适用于回调框架中。在回调框架中，对象把自己的引用传递给其他对象，用于后续调用。而被包装起来的对象并不知道它外面的包装对象，所以它传递一个指向自身的引用（this），回调时避开了外面的包装对象。这被称为**SELF问题**。

只有当子类真正是父类的子类型时，即它们是“is-a”的关系时，才适合用继承。

##17.要么为继承而设计，并提供文档说明，要么就禁止继承

文档必须精确地描述覆盖每个方法所带来的影响。
对于为了继承而设计的类，唯一的测试方法就是编写子类。
**为了允许继承，构造器决不能调用可被覆盖的方法，无论是直接调用还是间接调用！**
对于为了继承而设计的类，实现Cloneable和Serializable这两个接口都不是好主意，因为将实际负担转嫁给了扩展这个类的程序员身上。还要注意clone和readObject这两个方法非常类似于构造器，也不能调用可覆盖的方法，不管是直接还是间接调用。如果实现了Serializable，并且该类还有readResolve或writeReplace方法，就必须将该方法成为protected方法，不能是private。

对于那些并非为了安全地进行子类化而设计和编写文档的类，要禁止子类化。有两种办法：声明为final或者将所有构造器都变成私有或包级私有，并增加一个公有静态工厂。

##18.接口优于抽象类

##19.接口只用于定义类型

书中建议不要用接口来定义常量，这是接口的不良使用。接口应该只用于定义类型，而常量可以通过以下方法实现：

* 如果某些常量与某个现有类或接口紧密相关，就应该把这些常量加到这个类或接口中。例如Integer的MIN_VALUE常量。
* 如果这些常量最好被看作是枚举类型的成员，就应该使用枚举类型。
* 否则应该使用不可实例化的工具类来定义这些常量，例如：

```java
public class PhysicalConstants {
	private PhysicalConstants() {} //避免实例化
	public static final double AVOGADROS_NUMBER = 6.0221419e23;
	...
}
```

##20.类层次优于标签类

标签类（Tagged class）是指那些用一个类来表示多种对象的类。例如用一个类来表示矩形和圆。通过一个标签来区分当前实例是矩形还是圆。

标签类过于冗长，容易出错，而且效率低下。这种情况应该通过类层次来定义。

##21.用函数对象表示策略

如果一个类，它的方法执行其他对象的操作，这个类仅导出一个这样的方法，它的实例就等同于一个指向该方法的指针。这样的实例就称为函数对象（function object）。例如：

```java
class StringLengthComparator {
	public int compare(String s1, String s2) {
		return s1.length() - s2.length();
	}
}
```

上面这个类没有属性，因此适合于单例。为了把该类的实例传递给方法，应该定义一个接口，并让类实现这个接口。这就是一个策略接口：

```java
public interface Comparator<T> {
	public int compare(T t1, T t2);
}
```

函数指针的主要用途就是实现策略模式。为了在Java中实现这种模式，要声明一个接口来表示该策略，并且为每个具体策略声明一个实现了该接口的类。当一个具体策略只使用一次时，通常使用匿名类，如果可以重复使用，通常实现为私有的静态成员类，并通过公有的静态final属性导出，其类型为该策略接口。

##22.优先使用静态成员类

嵌套类（nested class）有四种：静态成员类、非静态成员类、匿名类和局部类。后面三种都被称为内部类（inner class）。

非静态成员类的每个实例都隐含着与一个外围实例的关联，在其内部可以调用外围实例的方法。非静态成员类的一种常见用法是定义一个Adapter。

如果成员类不要求访问外围实例，就要始终把static放在它的声明中，使它成为静态成员类。

匿名类的适用性受到很多限制，它没有名字，不是外围类的成员。它在使用的同时被声明和实例化。不能实现多个接口或者扩展一个类，并同时扩展类和实现接口。它们必须保持简短，大约10行或更少。它主要用于：

* 创建函数对象，例如匿名的Comparator实例。
* 创建过程对象，例如Runnable, Thread或者TimerTask实例。
* 在静态工厂方法的内部。参考第18条。

