---
layout: post
title: "Effective Java-通用程序设计"
date: 2014-08-22 20:06:07 +0800
comments: true
toc: true
categories: 
- java
---
Effective Java 通用程序设计，读书笔记：

45. 将局部变量的作用域最小化
46. for-each循环优先于传统的for循环
47. 使用类库
48. 如果需要精确值，就避免使用float和double
49. 基本类型优先于装箱基本类型
50. 如果其它类型更合适，则尽量避免使用字符串
51. 小心字符串拼接的性能问题
52. 通过接口引用对象
53. 接口优先于反射机制
54. 谨慎使用本地方法
55. 谨慎进行优化
56. 遵守普遍接受的命名惯例

<!--more-->

##45 将局部变量的作用域最小化
局部变量只在第一次使用它的地方声明。每个局部变量的声明都应该包含一个初始化表达式。

##46 for-each循环优先于传统的for循环
`for(String str : list)`这样的for-each语句在简洁性和预防Bug方面有着传统for循环无法比拟的优势，并且没有性能损失。但如果在遍历时删除、替换、前移等操作时，无法使用for-each语句。

##47 使用类库
不要重新发明轮子，尽量使用标准类库。例如随机数应该使用Random.nextInt(int)，而不是自己去写一个生成随机数的类。Java程序员应该精通java.lang, java.util包中的内容，还应该熟悉java.io, Collection, concurrent类库。

##48 如果需要精确值，就避免使用float和double
要计算精确的结果，可以使用BigDecimal，它还包括8种舍入模式。但是它的缺点是不太方便并且有性能上的损失。也可以自己处理小数点和舍入，使用int, long。数据数值没有超过9位十进制数字，可以使用int，如果不超过18位数字，可以使用long。如果可能超过18位，就必须使用BigDecimal

##49 基本类型优先于装箱基本类型
也就是int，boolean等优先于Integer和Boolean等。下面方法的返回值是多少？

```java
public int compare(Integer first, Integer second) {
     return first < second ? -1 : (first == second ? 0 : 1);
}

compare(new Integer(42), new Integer(42));  //结果为1
```

原因是装箱类型是对象引用，`first == second` 为false。除此之外，需要注意的是装箱类型可能是null，可能因此引起一些潜在隐患。而装箱类型的性能也可能是个问题（如创建和销毁对象中第5条“避免创建不必要的对象”中提到的循环累计时的Long性能不如long）/blog/2014/06/27/effective-java-chuang-jian-he-xiao-hui-dui-xiang/

##50 如果其它类型更合适，则尽量避免使用字符串
1. 字符串不适合代替其它的值类型，例如从文件中的int值以字符串存在，读出后就应该还原成int类型。
2. 字符串不适合代替枚举类型
3. 字符串不适合代替聚集类型。如用001_003代表两个东西，更好的办法是用一个私有静态成员类。

##51 小心字符串拼接的性能问题

##52 通过接口引用对象
养成用接口作为类型的习惯。如果没有合适的接口存在，完全可以用（基）类来引用对象。

##53 接口优先于反射机制
反射机制是一种功能强大的机制，对于特定的复杂系统编程任务，它是非常必要的，但它也有一些缺点：

1. 丧失了编译时类型检查的好处
2. 执行反射访问所需的代码笨拙而冗长
3. 性能损失

因此，如果你编写的程序必须要与编译时未知的类一起工作，如有可能，就应该仅仅使用反射机制来实例化对象，而访问对象时则使用编译时已知的某个接口或者父类。例如未知的类实现了Set，则可以用反射机制实例化它，但访问它的方法时，使用Set的方法。

##54 谨慎使用本地方法
Java Native Interface(JNI)允许Java调用本地方法（指本地程序设计语言如C, C++编写的特殊方法）。Java早期时，本地方法的用途是访问特定平台的能力（如注册表）、访问遗留代码库和提高性能。但现在已经没有太大必要了。

##55 谨慎进行优化
不要费力去编写快速的程序，应该努力编写好的程序。在设计API、数据格式时，一定要考虑性能的因素。例如API，如果后期将公有的类型变成可变的（mutable），可能会导致大量不必要的保护性拷贝，影响性能。同样地，在适合使用复合模式的公有类使用了继承，会把这个类永远与父类绑在一起，人为地限制了子类的性能。如果在API中使用实现类型而不是接口，就会被束缚在一个具体的实现上，即使将来出现了更快的实现你也无法使用。

##56 遵守普遍接受的命名惯例
对于类型参数：

* T表示任意类型
* E表示集合的元素类型
* K和V表示Map的键和值
* X表示异常
* 任何类型的序列可以是T, U, V或者T1, T2, T3

对于转换对象的方法，返回不同类型的独立对象的方法，通常被称为toType，如toString, toArray。返回视图的方法通常称为asType，如asList。静态工厂的常用名称为valueOf, of, getInstance, newInstance, getType和newType。

