---
layout: post
title: "设计模式:备忘录模式"
date: 2014-08-13 23:00:58 +0800
comments: true
toc: true
categories: 
- 设计模式
---

备忘录(Memento)模式又叫做快照模式。备忘录对象是一个用来存储另外一个对象内部状态快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态存储在外部，从而在合适的时候把这个对象还原到原来的状态。通常系统不止存储一个状态，而是存储多个状态（快照）。每一个快照所处的位置就是Check Point。其结构如下图：

![image](/myresource/images/image_blog_20140813_231854.jpg)

<!--more-->

1. 备忘录(Memento)角色：一是将发起人(Originator)对象的内部状态存储起来；二是保护其内容不被发起人以外的任何对象所读取，即图中宽接口和窄接口的作用。
2. 发起人(Originator)角色：创建备忘录对象，并使用该对象存储其内部状态。
3. 负责人(Caretaker)角色：负责保存备忘录对象，不管备忘录对象的内容。

### 白箱实现
在Java中实现宽、窄两个接口并不容易，白箱实现就是只提供宽接口。类图示意如下：

![image](/myresource/images/image_blog_20140813_235928.jpg)

上面的发起人只有一个状态“state”，发起人创建备忘录对象，并传入state，而负责人可以保存和获得备忘录对象。上图中备忘录对负责人也是宽接口，因此负责人可以访问到state值。**所以，白箱实现的缺点是破坏了对发起人状态的封闭。**下面的Client的示意代码：

```java
Originator o = new Originator();
Caretaker c = new Caretaker();

o.setState("On");
Memento m = o.createMemento();
c.saveMemento(m);

o.setState("Off");
o.restoreMemento(c.retrieveMemento());
//此时o.state = "On"
```

### 双重接口实现（黑盒实现）
如何用Java实现宽、窄两个接口呢？也就是对发起人是宽接口，对其它任何对象都是窄接口。可以将备忘录对象作为发起人的内部类，因此发起人可以访问备忘录的所有属性和方法。而窄接口，是备忘录对象实现一个标识接口(MementoIF，没有任何方法的接口)，同时备忘录对象的方法为私有方法，所有其它对象都通过标识接口获得备忘录对象的引用，却无法访问备忘录对象的状态和方法。这就是双重接口的实现。如下图所示：

![image](/myresource/images/image_blog_20140814_220438.jpg)

客户端的代码与白盒实现完全相同，但是Caretaker再也无法访问备忘录对象的状态了。

上面的两种实现，都由客户端持有发起人和负责人的引用。实际上也可以由负责人完成备忘录对象的创建和必要时恢复发起人状态。

### 多重检查点
前面的例子都只存储一个状态，在实际业务中，常需要存储多个状态，也就是多个检查点。实现方式可以在备忘录对象中建立`List<String> states`存储多个检查点。

### “自述历史”模式
自述历史模式其实是指发起人角色兼任负责人角色时的备忘录模式。类图如下：

![image](/myresource/images/image_blog_20140815_221228.jpg)

Memento类是发起人的内部类。

### “假如”协议模式
备忘录的操作过程是，先创建备忘录对象保存发起人状态，然后修改发起人状态，如果需要的话，可以撤消这一步。也就是通过备忘录对象恢复发起人的状态。简单地说，就是先保存状态，然后执行修改，如果需要则恢复原状态。

而“假如”协议则是将发起人对象做一个拷贝，然后再拷贝上执行备忘录操作，如果成功并且状态有效，则在原对象上执行这个操作。如果失败或者状态无效，则扔掉拷贝并触发异常处理。

“假如”协议的优点是安全，相当于先试验没总是后才在原始对象上执行。缺点是同一个操作要执行两遍。因此“假如”协议适合于成功率较低的场景。

### 备忘录模式的优点
1. 有时一些发起人对象的内部信息必须保存在发起人对象以外的地方，但是必须要由发起人对象自己读取，这时，使用备忘录模式可以把复杂的发起人内部信息对其他的对象屏蔽起来，从而可以恰当地保持封装的边界。
2. 本模式简化了发起人。发起人不再需要管理和保存其内部状态的一个个版本，客户端可以自行管理他们所需要的这些状态的版本。
3. 当发起人角色的状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原。

### 备忘录模式的缺点：
1. 如果发起人角色的状态需要完整地存储到备忘录对象中，那么在资源消耗上面备忘录对象会很昂贵。
2. 当负责人角色将一个备忘录存储起来的时候，负责人可能并不知道这个状态会占用多大的存储空间，从而无法提醒用户一个操作是否很昂贵。
3. 当发起人角色的状态改变的时候，有可能这个协议无效。如果状态改变的成功率不高的话，不如采取“假如”协议模式。

——《Java与模式》读书笔记。
