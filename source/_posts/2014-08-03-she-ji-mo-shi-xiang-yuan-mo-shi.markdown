---
layout: post
title: "设计模式:享元模式"
date: 2014-08-03 19:10:40 +0800
comments: true
categories: 
- 设计模式
---

享元模式(Flyweight Pattern)以共享的方式支持大量的细粒度对象。Java的String类型其实就使用了享元模式。享元对象具有内部状态(Internal State)和外部状态(External State)。内部状态是享元对象内部的，一旦创建就不会再改变，因此具有内部状态的享元对象可以进行共享。外部状态是随环境改变而改变的，是不可以共享的状态。享元对象的外部状态必须由客户端保存，通常以方法参数的方式传给享元对象，以改变方法的行为，但不会改变内在状态。享元模式可以分为单纯享元模式和复合享元模式。结构图如下：

![image](/myresource/images/image_blog_20140803_193842.jpg)

<!--more-->

左边为单纯享元模式，右边为复合享元模式。复合享元模式只多了一个ConcreteCompositeFlyweight，它们的角色如下：

* 抽象享元角色(Flyweight)：定义公共接口。
* 具体享元角色(ConcreteFlyweight)：实现抽象享元角色接口，维护内部状态。内部状态必须与外部环境元关，一旦创建就不能修改。
* 享元工厂角色(FlyweightFactory)：负责创建和管理享元角色，保证享元对象可以被系统共享。当客户端调用工厂方法时，通常会判断是否有符合要求的享元对象，如果有就返回，如果没有则创建。此角色一般只有一个，可以使用单例模式。
* 客户端角色(Client)：调用享元工厂创建享元对象，维护享元对象的外部状态。
* 复合享元角色(ConcreteCompositeFlyweight)：由单纯的享元对象复合而成，因此提供了add这样的方法。由于聚焦元素是在复合享元对象创建之后加入的，因此复合享元对象的状态是可以改变的，所以此角色**不可以共享**。

**一些例子**

一个咖啡摊所售的咖啡只有固定的几种口味，一坏咖啡一旦生产出来它的口味就不会改变，其内部状态就是口味。因此系统不用为每一杯咖啡创建一个对象，可以使用享元模式为每种口味创建一个对象，然后进行共享。

又例如一个文字编辑器，输入的内部是固定的A..Z，但字母所处的位置、字体是变化的。如果用享元模式，内部状态就是字母，外部状态是位置和字体。

**什么情况下使用享元模式**

当以下条件都满足时，可以考虑使用享元模式：

1. 系统有大量的对象。
2. 这些对象耗费大量的内存。
3. 这些对象的大部分状态都可以外部化。
4. 这些对象可以按照内部状态分成很多组，剔除外部状态后，每一组都可以仅用一个对象代替。
5. 系统不依赖于这些对象的身份，即这些对象可以是不可分辨的。
6. 系统需要记录所有已有的享元对象，这需要消耗资源，因此应当在只有足够多的享元实例可供共享时才值得使用享元模式。

享元模式的优点是大幅降低内存中对象的数量，但享元模式可能使系统更复杂，需要将一些状态外部化，这可能使逻辑变得复杂。

