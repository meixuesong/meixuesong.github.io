<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[码出人生]]></title>
  <link href="http://blog.ubone.com/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2015-04-03T00:10:21+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[IntelliJ IDEA Mac快捷键]]></title>
    <link href="http://blog.ubone.com/blog/2015/04/02/intellij-idea-mackuai-jie-jian/"/>
    <updated>2015-04-02T11:12:07+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/04/02/intellij-idea-mackuai-jie-jian</id>
    <content type="html"><![CDATA[<p>准备从Eclipse抱成IntelliJ IDEA，备注一下常用的快捷键。</p>

<!--more-->


<table>
<thead>
<tr>
<th>快捷键 </th>
<th> 说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>^+space</code> </td>
<td> 代码提示</td>
</tr>
<tr>
<td><code>Shift+Command+回车</code> </td>
<td> 代码提示后的操作，Choose Lookup Item and Invoke Complete Statement</td>
</tr>
<tr>
<td><code>^+.</code> </td>
<td> 代码提示后的操作，Choose Lookup Item Dot</td>
</tr>
<tr>
<td><code>^+Shift+数字</code> </td>
<td> Toggle bookmark 0-9，然后再按^+数字可以返回此处</td>
</tr>
<tr>
<td><code>Command + [ or ]</code> </td>
<td> 将光标移到代码块的“｛”或者“｝”处。</td>
</tr>
<tr>
<td><code>Command + Shift + [ or ]</code> </td>
<td> 将光标移到代码块的“｛”或者“｝”处，同时完成选择操作。</td>
</tr>
<tr>
<td><code>Shift+Command+Return</code> </td>
<td> Complete Current Statement</td>
</tr>
<tr>
<td><code>Command+Y</code> </td>
<td> 删除当前行</td>
</tr>
<tr>
<td><code>Option+Delete</code> </td>
<td> 往前删除一个单词</td>
</tr>
<tr>
<td><code>Command+D</code> </td>
<td> 复制一行或者代码块</td>
</tr>
<tr>
<td><code>^+Shift+J</code> </td>
<td> 合并行</td>
</tr>
<tr>
<td><code>Command+左右箭头</code> </td>
<td> 光标移到行首或行尾，加上shift键可以选择</td>
</tr>
<tr>
<td><code>Command+上下箭头</code> </td>
<td> 屏幕上移一行或下移一行。</td>
</tr>
<tr>
<td><code>Command+Shift+上下箭头</code> </td>
<td> 将当前行上移或下移，交换位置</td>
</tr>
<tr>
<td><code>Option++左右箭头</code> </td>
<td> 光标左右移动，每次一个单词，加上shift键可以选择</td>
</tr>
<tr>
<td><code>Command+W</code> </td>
<td> 选中当前单词</td>
</tr>
<tr>
<td>菜单 </td>
<td> 菜单快捷键</td>
</tr>
<tr>
<td><code>^+N ^+Return</code> </td>
<td> 生成Getter/Setter等代码</td>
</tr>
<tr>
<td><code>Command+,</code> </td>
<td> preferences</td>
</tr>
<tr>
<td><code>Command+;</code> </td>
<td> Project structure</td>
</tr>
<tr>
<td><code>Command+S</code> </td>
<td> Save all</td>
</tr>
<tr>
<td><code>Option+Command+Y</code> </td>
<td> Synchronize</td>
</tr>
<tr>
<td><code>Command+Q</code> </td>
<td> Exit</td>
</tr>
<tr>
<td><code>Shift+Command+Z</code> </td>
<td> Redo</td>
</tr>
<tr>
<td><code>Command+F</code> </td>
<td> Find&hellip;</td>
</tr>
<tr>
<td><code>Command+R</code> </td>
<td> Replace&hellip;</td>
</tr>
<tr>
<td><code>F3</code> </td>
<td> Find next</td>
</tr>
<tr>
<td><code>Shift+F3</code> </td>
<td> Find Previous</td>
</tr>
<tr>
<td><code>Command+F3</code> </td>
<td> 查找当前单词</td>
</tr>
<tr>
<td><code>Control+Command+G</code> </td>
<td> Select All Occurrences</td>
</tr>
<tr>
<td><code>Control+G</code> </td>
<td> Select Next Occurrence</td>
</tr>
<tr>
<td><code>Control+Shift+G</code> </td>
<td> Unselect Occurrence</td>
</tr>
<tr>
<td><code>Control+Shift+F</code> </td>
<td> Find in Path</td>
</tr>
<tr>
<td><code>Control+Shift+R</code> </td>
<td> Replace in Path</td>
</tr>
<tr>
<td><code>Shift+Command+S</code> </td>
<td> Search Structurally</td>
</tr>
<tr>
<td><code>Option+F7</code> </td>
<td> Find Usages</td>
</tr>
<tr>
<td><code>Command+F7</code> </td>
<td> Find Usages in File</td>
</tr>
<tr>
<td><code>Command+1</code> </td>
<td> Tool Windows &ndash; Project</td>
</tr>
<tr>
<td><code>Command+2</code> </td>
<td> Tool Windows &ndash; Favorites</td>
</tr>
<tr>
<td><code>Command+3</code> </td>
<td> Tool Windows &ndash; Find</td>
</tr>
<tr>
<td><code>Command+4</code> </td>
<td> Tool Windows &ndash; Run</td>
</tr>
<tr>
<td><code>Command+5</code> </td>
<td> Tool Windows &ndash; Debug</td>
</tr>
<tr>
<td><code>Command+6</code> </td>
<td> Tool Windows &ndash; TODO</td>
</tr>
<tr>
<td><code>Command+7</code> </td>
<td> Tool Windows &ndash; Structure</td>
</tr>
<tr>
<td><code>Option+F12</code> </td>
<td> Terminal</td>
</tr>
<tr>
<td><code>Shift+Command+I</code> </td>
<td> Quick Definition. 快速显示光标所在方法名的定义/实现</td>
</tr>
<tr>
<td><code>Control+J</code> </td>
<td> 显示光标所在方法名的文档</td>
</tr>
<tr>
<td><code>Command+F1</code> </td>
<td> 显示光标所在代码的错误信息</td>
</tr>
<tr>
<td><code>F4</code> </td>
<td> 从当前方法名跳转到代码</td>
</tr>
<tr>
<td><code>Command+E</code> </td>
<td> 最近的文件</td>
</tr>
<tr>
<td><code>Command+Shift+E</code> </td>
<td> 最近修改的文件</td>
</tr>
<tr>
<td><code>Control+Command+F</code> </td>
<td> Toggle Full Screen</td>
</tr>
<tr>
<td>Navigate菜单 </td>
<td> 快捷键</td>
</tr>
<tr>
<td><code>Command+N</code> </td>
<td> 打开Class</td>
</tr>
<tr>
<td><code>Command+Shift+N</code> </td>
<td> 打开文件</td>
</tr>
<tr>
<td><code>Option+Shift+Command+N</code> </td>
<td> Symbol&hellip;</td>
</tr>
<tr>
<td><code>Option+Command+左箭头</code> </td>
<td> Back</td>
</tr>
<tr>
<td><code>Option+Command+右箭头</code> </td>
<td> Forward</td>
</tr>
<tr>
<td><code>Shift+Command+Backspace</code> </td>
<td> Last Edit Location</td>
</tr>
<tr>
<td><code>Option+F1</code> </td>
<td> Select In&hellip;</td>
</tr>
<tr>
<td><code>Command+B</code> </td>
<td> 跳转到方法声明</td>
</tr>
<tr>
<td><code>Option+Command+B</code> </td>
<td> 跳转到方法实现</td>
</tr>
<tr>
<td><code>Shift+Command+T</code> </td>
<td> Test</td>
</tr>
<tr>
<td><code>Command+F12</code> </td>
<td> 显示当前文件的结构（方法列表）</td>
</tr>
<tr>
<td><code>Control+H</code> </td>
<td> 显示当前类的继承结构</td>
</tr>
<tr>
<td><code>Shift+Command+H</code> </td>
<td> Method Hierarchy</td>
</tr>
<tr>
<td><code>Control+Alt+H</code> </td>
<td> Call Hierarchy</td>
</tr>
<tr>
<td><code>F2</code> </td>
<td> Next Highlighted Error</td>
</tr>
<tr>
<td><code>Shift+F2</code> </td>
<td> Previous Highlighted Error</td>
</tr>
<tr>
<td><code>Option+Command+上箭头</code> </td>
<td> Previous Occurrence</td>
</tr>
<tr>
<td><code>Option+Command+下箭头</code> </td>
<td> Next Occurrence</td>
</tr>
<tr>
<td>Code菜单 </td>
<td> 快捷键</td>
</tr>
<tr>
<td><code>Command+O</code> </td>
<td> Override Methods&hellip;</td>
</tr>
<tr>
<td><code>Command+I</code> </td>
<td> Implement Methods&hellip;</td>
</tr>
<tr>
<td><code>Option+Command+T</code> </td>
<td> Surround With&hellip;</td>
</tr>
<tr>
<td><code>Control+Space</code> </td>
<td> Basic Completion</td>
</tr>
<tr>
<td><code>Command+ +/-</code> </td>
<td> 将当前代码块卷起或展开</td>
</tr>
<tr>
<td><code>Command+J</code> </td>
<td> Insert Live Template&hellip;</td>
</tr>
<tr>
<td><code>Control+Shift+/</code> </td>
<td> Comment with Block Comment</td>
</tr>
<tr>
<td><code>Option+Command+L</code> </td>
<td> Reformat Code&hellip;</td>
</tr>
<tr>
<td><code>Option+Command+O</code> </td>
<td> Optimize Imports&hellip;</td>
</tr>
<tr>
<td>Refactor菜单 </td>
<td> 快捷键</td>
</tr>
<tr>
<td><code>Option+Shift+Command+T</code> </td>
<td> Refactor this&hellip;</td>
</tr>
<tr>
<td><code>Shift+F6</code> </td>
<td> Rename&hellip;</td>
</tr>
<tr>
<td><code>Command+F6</code> </td>
<td> Change Signature</td>
</tr>
<tr>
<td><code>F6</code> </td>
<td> Move&hellip;</td>
</tr>
<tr>
<td><code>F5</code> </td>
<td> Copy&hellip;</td>
</tr>
<tr>
<td><code>Command+Delete</code> </td>
<td> Safe Delete&hellip;</td>
</tr>
<tr>
<td><code>Option+Command+V</code> </td>
<td> Extract Variable&hellip;</td>
</tr>
<tr>
<td><code>Option+Command+C</code> </td>
<td> Extract Constant&hellip;</td>
</tr>
<tr>
<td><code>Option+Command+F</code> </td>
<td> Extract Field&hellip;</td>
</tr>
<tr>
<td><code>Option+Command+P</code> </td>
<td> Extract Parameter&hellip;</td>
</tr>
<tr>
<td><code>Option+Command+M</code> </td>
<td> Extract Method&hellip;</td>
</tr>
<tr>
<td>Build Run菜单 </td>
<td> 快捷键</td>
</tr>
<tr>
<td><code>Command+F9</code> </td>
<td> Make Project</td>
</tr>
<tr>
<td><code>Shift+F10</code> </td>
<td> Run</td>
</tr>
<tr>
<td><code>Option+Shift+F10</code> </td>
<td> Run&hellip;</td>
</tr>
<tr>
<td><code>Option+F9</code> </td>
<td> Run to Cursor</td>
</tr>
<tr>
<td><code>Shift+F9</code> </td>
<td> Debug</td>
</tr>
<tr>
<td><code>Option+Shift+F9</code> </td>
<td> Debug&hellip;</td>
</tr>
<tr>
<td><code>Command+F2</code> </td>
<td> Stop</td>
</tr>
<tr>
<td><code>F8</code> </td>
<td> Step Over</td>
</tr>
<tr>
<td><code>Option+Shift+F8</code> </td>
<td> Force Step Over</td>
</tr>
<tr>
<td><code>F7</code> </td>
<td> Step Into</td>
</tr>
<tr>
<td><code>Option+Shift+F7</code> </td>
<td> Force Step Into</td>
</tr>
<tr>
<td><code>F9</code> </td>
<td> Resume Program</td>
</tr>
<tr>
<td><code>Option+F8</code> </td>
<td> Evaluation Expression&hellip;</td>
</tr>
<tr>
<td><code>Option+F10</code> </td>
<td> Show Execution Point</td>
</tr>
<tr>
<td><code>Command+F8</code> </td>
<td> Toggle Line BreakPoint</td>
</tr>
<tr>
<td><code>Shift+Command+F8</code> </td>
<td> View Breakpoints&hellip;</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Crontab定时任务]]></title>
    <link href="http://blog.ubone.com/blog/2015/03/28/linux-crontabding-shi-ren-wu/"/>
    <updated>2015-03-28T21:04:50+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/03/28/linux-crontabding-shi-ren-wu</id>
    <content type="html"><![CDATA[<p>通过crontab命令可以固定的间隔时间循环执行指定的命令或shell脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的工作。</p>

<!--more-->


<h2>命令</h2>

<p>crontab有两种命令形式：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>crontab [ -u user ] file
crontab [ -u user ] [ -i ] { -e | -l | -r }</code></pre>


<ul>
<li>-u user：用来设定某个用户的crontab服务；</li>
<li>file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</li>
<li>-i：在删除用户的crontab文件时给确认提示。</li>
<li>-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</li>
<li>-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</li>
<li>-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</li>
</ul>


<h2>crontab文件格式</h2>

<pre  class='line-numbers language-bash'><code class='language-bash'># Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * command to be executed
  23 20 *  *  * shutdown  -r  now</code></pre>


<h2>建立cron任务</h2>

<pre  class='line-numbers language-bash'><code class='language-bash'>为当前用户建立cron任务
# crontab -e
为root建立cron任务
# sudo crontab -e</code></pre>


<p>系统会打开默认编辑器（如果没有会让你选择），然后进行任务编辑。</p>

<h2>cron任务示例</h2>

<pre  class='line-numbers language-bash'><code class='language-bash'>#实例1：每1分钟执行一次myCommand
* * * * * myCommand
#实例2：每5分钟执行一次myCommand
*/5 * * * * myCommand
#实例3：每小时的第3和第15分钟执行
3,15 * * * * myCommand
#实例4：在上午8点到11点的第3和第15分钟执行
3,15 8-11 * * * myCommand
#实例5：每隔两天的上午8点到11点的第3和第15分钟执行
3,15 8-11 */2  *  * myCommand
#实例6：每周一上午8点到11点的第3和第15分钟执行
3,15 8-11 * * 1 myCommand
#实例7：每晚的21:30重启smb
30 21 * * * /etc/init.d/smb restart
#实例8：每月1、10、22日的4 : 45重启smb
45 4 1,10,22 * * /etc/init.d/smb restart
#实例9：每周六、周日的1 : 10重启smb
10 1 * * 6,0 /etc/init.d/smb restart
#实例10：每天18 : 00至23 : 00之间每隔30分钟重启smb
0,30 18-23 * * * /etc/init.d/smb restart
#实例11：每星期六的晚上11 : 00 pm重启smb
0 23 * * 6 /etc/init.d/smb restart
#实例12：每一小时重启smb
* */1 * * * /etc/init.d/smb restart
#实例13：晚上11点到早上7点之间，每隔一小时重启smb
* 23-7/1 * * * /etc/init.d/smb restart</code></pre>


<h2>注意事项</h2>

<h3>环境变量问题</h3>

<p>我们手动执行某个任务时，是在当前shell环境下进行的，程序能找到环境变量。而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量。因此需要注意：</p>

<ul>
<li>脚本中涉及文件路径时写全局路径；</li>
<li>脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如:</li>
</ul>


<pre  class='line-numbers language-bash'><code class='language-bash'>cat start_cbp.sh
!/bin/sh
source /etc/profile
export RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf
/usr/local/jboss-4.0.5/bin/run.sh -c mev &</code></pre>


<ul>
<li>当手动执行脚本OK，但是crontab执行不成功时,很可能是环境变量惹的祸，可尝试在crontab中直接引入环境变量解决问题。如:</li>
</ul>


<pre  class='line-numbers language-bash'><code class='language-bash'>*/5 * * * * . /etc/profile;/bin/sh /usr/bin/gitupdateblog.sh</code></pre>


<h3>重定向问题</h3>

<p>每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，但如果没有配置电子邮件，通过日志会查看到提示信息：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'># grep CRON /var/log/syslog
Mar 28 08:30:01 Jasondroplet CRON[26905]: (CRON) info (No MTA installed, discarding output)</code></pre>


<p>也可将输出重定向，即在每条命令后面加上<code>/dev/null 2&gt;&amp;1</code>：</p>

<p><code>*/5 * * * * . /etc/profile;/bin/sh /usr/bin/gitupdateblog.sh  &gt;/dev/null 2&gt;&amp;1</code></p>

<p><code>/dev/null 2&gt;&amp;1</code>表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。</p>

<h3>系统级任务调度与用户级任务调度</h3>

<p>系统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么做），但是反过来却不行，root用户的任务调度操作可以通过”crontab –uroot –e”来设置，也可以将调度任务直接写入/etc/crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个定时重启系统的任务也是无效的。</p>

<h3>重启服务</h3>

<p><code># service cron restart</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读《谷歌和亚马逊如何做产品》]]></title>
    <link href="http://blog.ubone.com/blog/2015/03/25/du-gu-ge-he-ya-ma-xun-ru-he-zuo-chan-pin/"/>
    <updated>2015-03-25T10:08:11+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/03/25/du-gu-ge-he-ya-ma-xun-ru-he-zuo-chan-pin</id>
    <content type="html"><![CDATA[<p>最近读了《谷歌和亚马逊如何做产品》这本书，书的内容不多，但都是精华。作者曾先后在Amazon和Google担任研发经理和高级产品经理。该书主要讲软件的交付，分为两部分，一是介绍Amazon和Google如何交付软件产品，二是团队主管带领团队成功交付所需的技术、最佳实践和技能。</p>

<!--more-->


<h2>1. 步步为“赢”</h2>

<p>在介绍Amazon和Google如何交付软件产品时，作者强调了各个阶段的重点，也就是如何步步为“赢”。<strong>包括使命和策略、产品定义、用户体验、项目管理、测试、量化以及发布。</strong></p>

<h3>1.1 赢在使命和策略</h3>

<p>作者表示，成功交付的关键在于快速且充分地满足客户需求。（看起来是句废话？）因此使命就是解决客户的问题，而策略就是找到一种独特的方法来满足这个群体或细分市场的共同需求。</p>

<p>关于如何找到正确的需求，作者提到杰夫.贝索斯（Amazon CEO）一直强调的观点“以客户为导向，而不是以竞争为导向。”同样地，拉里.佩奇（Google CEO）也常说“立足客户，向外拓展。”，所以，<strong>团队应该始终积极地去解决客户的问题，而不是紧盯竞争对手，被动地做出反应。</strong></p>

<p>如何构建卓越的使命？作者表示团队一定要有自己的使命。如果对使命的理解不同而各自为战，就是导致冲突、混乱和痛苦。一个卓越的使命要符合三点要求：</p>

<ol>
<li>能够唤起人们的兴趣</li>
<li>提供言之有物且能指明方向的原则</li>
<li>适合印在T恤上。</li>
</ol>


<p>使命不需要面面俱到，而是要能够反映代表性产品或服务的使命。</p>

<p>如何制订正确的策略？策略是指在竞争对手的压力下，利用公司独特的优势来争取目标客户的粗略计划。需要阐明三件事：客户、公司和竞争。你需要特别注意如何才能长期为客户提供比竞争对手更优质的产品。</p>

<p>当你已经知道谁是产品的忠实用户，以及产品如何保持长期的竞争优势，那么你用最多三段文字写下来，然后再将这些想法的本质浓缩成一段文字。这就是你的策略。越简短的策略越容易实现，也越容易获得他人的认同。</p>

<h3>1.2 赢在产品定义</h3>

<p>通过制订使命和策略，你知道了你的客户是谁，他们的需求是什么，你也知道如何做才能比对手更出色、更具备差异性。然后你就可以细化产品方案。</p>

<p>在细化产品方案时，你会发现很多要解决的客户问题都是你主观臆断的，Amazon和Google都犯过这样的错误。所以要采用一些方法来证明臆断是否正确。即使它们十之八九是正确的，也要经过证明。最好的证明方法就是把产品提供给客户使用，然后听听他们的意见。这也是现在互联网产品常用的方法：最小化可行产品（MVP）。</p>

<p>产品定义过程分为10步：</p>

<h4>1.2.1 撰写新闻稿</h4>

<p>这是由杰夫率先倡导的方法，可以是新闻稿或博客。从用户的视角出发，简明扼要地描述产品是什么、什么时候发布以及为什么要做这个产品。主要包括六大要素：</p>

<ul>
<li>产品命名</li>
<li>发布时间</li>
<li>目标客户</li>
<li>解决了什么问题</li>
<li>如何解决（务必简明扼要）</li>
<li>CEO的公开赞辞</li>
</ul>


<h4>1.2.2 创建并不断更新FAQ文档</h4>

<p>随着产品方案的不断细化，遇到的问题也层出不穷，需要记录一个FAQ文档。它有两大好处：</p>

<ul>
<li>节省你大量回复邮件的时间、抵御一些内部责难（证明你是尽职的）</li>
<li>FAQ中的内部问题和外部问题，以后客户支持团队和科技写作团队需要用到。</li>
</ul>


<h4>1.2.3 绘制线框图和流程图</h4>

<p>在FAQ中撰写问题答案时，用流程图或线框图表述会更好一些，尤其涉及用户体验（UX）的细节时更是如此。</p>

<h4>1.2.4 撰写产品单页和制作10分钟的演示文稿</h4>

<p>接下来你要争取工程团队、管理层、风险投资人(VC)或其它利益相关方的初步支持，弄清楚他们对产品的认可程度，而不是等待第7步功能规格文档都快完成了，而他们还对产品的价值存有疑义。</p>

<p>这一步需要准备产品单页或10分钟的演示文稿，或者两样都要准备。这两份文档是新闻稿的延伸，应该包含5个要素：</p>

<ul>
<li>产品名称</li>
<li>目标客户 +数量有多少</li>
<li>解决了什么问题 + 这个问题对于目标客户来说有多大价值</li>
<li>解决方案 + 这个解决方案类似线上哪个产品，为什么你的方案能让竞争对手在长时间内都无法模仿</li>
<li>何时交付 + 主要的里程碑有哪些</li>
<li>团队背景 （仅针对VC）</li>
</ul>


<h4>1.2.5 在FAQ中增加API文档</h4>

<p>API文档用于说明你的团队如何与其他团队协作、外部开发者如何使用这套系统，以及你需要存储什么数据，也有助于你构建SOA体系。</p>

<h4>1.2.6 撰写功能规格文档</h4>

<p>功能规格文档的读者一般为工程团队、设计团队，偶尔还有市场营销团队。主要包括：</p>

<ol>
<li>简介</li>
<li>目标与非目标</li>
<li>用例或用户场景</li>
<li>原型图或线框图</li>
<li>API</li>
<li>负载规划</li>
<li>依赖</li>
<li>FAQ和开放问题</li>
<li>关键事件</li>
</ol>


<p>其中“非目标”用于告诉别人你不要做什么。例如“不用支持PC端。”用例是指用简要的语句描述那些用户必须执行的操作，用户场景则用叙述故事的方式来描述用户是如何体验产品的（类似于用例实现规约）。用例和用户场景都需要加上优先级，以方便工程团队排定任务。常见的优先级包括：</p>

<ul>
<li>P0 没有此功能产品无法演示</li>
<li>P1 没有此功能无法交付</li>
<li>P2 锦上添花的功能</li>
<li>P3 哈哈哈！</li>
</ul>


<p>负载规划是指对未来一段时间内用户的使用量进行粗略估计并制定应对计划。灾难并不可怕，可怕的是你没有任何准备。应该适当部署一些有效的危机管理系统，如流量限制系统。你需要了解当系统过载时是部分彻底不可用还是整体被拖慢。<strong>不要花太长时间在评估上，只需要花几个小时写个初稿，再找几个团队成员讨论下并将讨论出的数值翻倍就大功告成了。</strong></p>

<p>你需要将全部依赖方及负责人列出来，如果有应急方案也一并列出。功能规格定稿后应该发给各依赖方的负责人，让他们知道你需要他们的支持。</p>

<p>如果有一些硬性时间要求（例如某某开发者大会），这些时间也需要放入文档。最好列出主要事件的达成时间，如特性完成时间，可信测试者版发布时间。</p>

<h4>1.2.7 找出边界情况并得到团队认可</h4>

<p>这时候最困难的部分已经过去，你写了一份超级大的文档，可能没有人能全部读完。这时候你需要时间仔细地、创造性地思考用户会如何弄坏你的软件或者在某种意义上没有按照你的预期来使用软件。当你“漫步”时，请将想到的所有可能的边界情况以及应对策略写在FAQ或者产品需求文档中。</p>

<p>这一步充满风险。一方面你必须承认并整合所有你的团队找到的边界情况，另一方面还必须捍卫产品的核心原则。如果工程团队都不买账的产品，你如何指望你的客户会买账？你并不需要团队的每一个人都相信你的规划是完美的，而是需要他们同意朝一个方向前进并把产品视作是一个极有可能成功的实验！</p>

<h4>1.2.8 客户测试</h4>

<p>找一批现存的或潜在的客户，向他们介绍你的产品设想和原型，听听他们的反馈。在产品演示文稿准备妥当之后，应该马上安排持续3周，每周3至5次的面向潜在客户的产品演示。</p>

<h4>1.2.9 想清楚基本的商业要素——命名、定价和收益</h4>

<p>讨论名称是一件极其主观且争议较大的事情。其实名称并没有那么重要，它再出色也不能帮做成一个产品或者毁掉一个产品，不要浪费太多时间纠结，赶紧定一个！</p>

<p>产品定价有三个基本方法：按成本定价、按价值定价以及对比定价。软件业通常不适合按成本定价，因为难以统计也不知道明天的成本。按价值定价，你需要去调研客户，看什么价位他们愿意购买。但客户很少如实回答，这个方法看起来合理但不具备可操作性。对比定价与前面两个方法相比要合理得多。它有两个前提：1是有一个合理的比较目标；2是假定市场是弹性的，即产品会在价格下降时销量增加。</p>

<p>有了定价就可以制定收益模型，这也是一个拍脑袋出来的东西。可以做一个简单的Excel表格，设定相应的变量和计算步骤，反复进行预测。</p>

<h4>1.2.10 取得上层的认可</h4>

<p>在向位高权重的人汇报产品方案时，首先确保你了解产品的所有信息。如果你注定做不到这点，也需要尽力做好一些。万一问到你不清楚的问题时，不要试着糊弄过去，承认错误也没有什么大不了的，这不过是向他们证明作为一个菜鸟你无法理解他们有多优秀。</p>

<h4>1.2.11 去构建产品</h4>

<p>驱动你的团队在现实的重重困境中构建出可靠的软件。</p>

<h3>1.3 赢在用户体验</h3>

<p>首先了解一些概念：</p>

<ul>
<li>用户体验（UX, User Experience）通过制作流程图或原型图来说明用户体验。</li>
<li>用户界面（UI, User Interface）用户体验的旧称，更关注单个页面的设计。</li>
<li>视觉设计（VisD, Visual Design）通过一种既赏心悦目、夺人眼球又清晰明了的方式来展示内容。</li>
<li>用户体验研究（UXR, User Experience Research）专注于研究用户是如何看待你的产品。</li>
</ul>


<p>要交付一套卓越的用户体验，必须回答6个问题：</p>

<ol>
<li>该用户界面要求用户完成的最重要的任务是什么？</li>
<li>这是最简单的解决方案吗？</li>
<li>信息是否组织得当？</li>
<li>设计是否易用且一目了然？</li>
<li>标准是否一致？</li>
<li>是否减少用户点击次数？</li>
</ol>


<p>作者推荐使用<a href="https://www.omnigroup.com/omnigraffle">Omnigraffle</a>制作线框图，但可惜不是免费的。</p>

<h3>1.4 赢在测试</h3>

<p>如果你交付的软件无法工作，卖不出去是一方面，更糟糕的是你会因此蒙羞。遵循下面8个步骤可以对产品质量产生重大影响：</p>

<ol>
<li>坚持测试驱动开发（<strong>“调试过劳死，测试嗨翻天”</strong>）</li>
<li>围绕优秀的测试主管组建测试团队</li>
<li>亲自评审测试计划和测试用例</li>
<li>自动化测试</li>
<li>虔诚地推行内部试用（Dogfood，欲卖狗食，必先偿之。不要自己团队吃人食，让用户吃狗食）</li>
<li>开展找虫总动员</li>
<li>勤勉且有条理地处理Bug</li>
<li>任命可信测试者以构建最后一道防线。</li>
</ol>


<h3>1.5 赢在发布</h3>

<p>如何确保发布质量？</p>

<ol>
<li>对改动说不（发布手中有的，而非脑中想的）</li>
<li>开启作战室</li>
<li>营造紧迫的气氛</li>
<li>核查发布清单</li>
<li>撰写博文</li>
<li>发布软件</li>
<li>亲自验证软件</li>
<li>应对发布带来的各种影响</li>
</ol>


<p>关于应对发布带来的各种影响，书中提到需要做的5件事情：</p>

<ol>
<li>应对回滚（只要成功回滚，发布就还没有失败。最好的防守是制定周详的撤退计划。Google和Amazon也经常回滚，甚至回滚5次。）</li>
<li>处理产品危机（做事之前，先做准备）</li>
<li>演示产品</li>
<li>应对媒体和客户</li>
<li>庆祝发布</li>
</ol>


<h2>2. 掌握卓越技能</h2>

<p>产品经理在交付软件的过程中，应该努力学习多种技能，包括：团队、技术、沟通、决策和从容，然后在周期轮回中不断升华。</p>

<h3>2.1 胜在团队</h3>

<p>软件业中团队角色：</p>

<h4>项目集成经理</h4>

<p>项目集成经理的职责重点在于整合不同团队和不同工作职能，专注于“黏合与润滑”。通常他们比产品经理更少关注业务，比项目经理更少关注技术。</p>

<h4>产品经理</h4>

<p>通常产品经理的职责更偏重业务方面。如专注于品牌、定价、市场进入策略等。在谷歌，产品经理需要做除了写代码之外的任何事，甚至有些连代码也写过。</p>

<h4>项目经理</h4>

<p>项目经理主要职责在于排定项目计划和协调团队工作，通常称为技术项目经理。</p>

<h4>工程经理</h4>

<p>工程经理通常由老牌程序员担任。最佳的工程经理是那些由于热爱团队、善解人意、精通交付并乐于构建卓越产品而晋升到该职位的人。产品经理、项目集成经理或者项目经理，甚至技术项目经理都可以是工程经理的属下，但也可以是合作伙伴。每个工程团队都需要工程经理，但不一定需要产品经理、项目集成经理或项目经理。</p>

<h4>如何雇佣产品经理、项目集成经理或者工程经理</h4>

<p>有5条原则：</p>

<ol>
<li>雇佣比你聪明的人</li>
<li>雇佣懂得自己不是来当老板的人</li>
<li>雇佣表达清晰、言之有物的人</li>
<li>雇佣用数据说话的人</li>
<li>雇佣充满活力的人</li>
</ol>


<h3>2.2 其它</h3>

<p>关于如何做好演示，作者提出的建议是：</p>

<ol>
<li>将演示时间控制在15分钟内</li>
<li>永远传达且只传达一个信息</li>
<li>讲故事</li>
<li>制作“综述单页”</li>
<li>重点演示用户体验</li>
<li>极度专注倾听</li>
</ol>


<p>在演示时，如果你连关键信息是什么都不知道，还是取消演示吧。最好只传递一个信息，去掉与这个信息无关的数据或议题。</p>

<h2>3. 书中的有趣点</h2>

<p>书中提到了很多有趣的点，翻译也很赞！摘录如下：</p>

<p>强调测试驱动开发的重要性：</p>

<blockquote><p>调试过劳死，测试嗨翻天！</p></blockquote>

<p>关于沟通的技巧：</p>

<blockquote><p>狗屎三明治（The Shit Sandwich）是一种有效的反馈技巧。它是说当你给员工反馈时，你可以一开始先表扬他们（第一块面包），然后再给他们一些难以完成的挑战（狗屎夹心），最后提醒他们你有多么看好他们的能力（第二块面包）。</p></blockquote>

<p>关于如何咽下狗屎三明治并生存下去：</p>

<blockquote><p>在某些恶劣的环境中，你可能发现你无时无刻不在吃这些三明治，这不是一个好信号&hellip;在断定自己精神抑郁或缺乏自信之前，先确定你实际上没有被一群白痴包围&hellip;有时候你被要求咽下的三明治的数量和质量都是直接来自和你一起工作的白痴们。当碰到这种情况时，你该换个地方，换个产品去交付了。</p></blockquote>

<p>关于Scrum站会</p>

<blockquote><p>我在Google和Amazon的团队喜欢在11:30或12:00的时候开站会，时间不超过15分钟。因为大家都要吃午饭。
我不赞成Scrum中区分猪和鸡的做法，它只让猪（即开发者）说话&hellip;我的工程团队喜欢听关于业务拓展近况的30秒简述&hellip;我还喜欢让开发主管就项目状态做30秒简报。</p></blockquote>

<p>关于决策</p>

<blockquote><p>几乎所有特性或用户体验的争论最后就会变成像绑匪谈判。你控制了人家的孩子，或者人家控制了你的孩子，除非某一方开出的条件被接受，否则孩子就会被撕票。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TDD学习笔记]]></title>
    <link href="http://blog.ubone.com/blog/2015/03/17/tddxue-xi-bi-ji/"/>
    <updated>2015-03-17T11:42:46+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/03/17/tddxue-xi-bi-ji</id>
    <content type="html"><![CDATA[<p>本文是《测试驱动开发的艺术》的学习笔记。</p>

<!--more-->


<h2>1. TDD入门</h2>

<p>TDD周期包括三个步骤：写测试、添加恰巧能让测试通过的代码，最后进行彻底的重构以改善设计。</p>

<h3>1.1 什么是好的测试？</h3>

<p>编写（单元）测试时有许多准则可以遵循，例如“测试之间应该相互隔离，并且不依赖于执行顺序”，“测试应该能快速的执行”，“测试中不应该有手动的初始化工作”，等等。不过从把需求分解到测试的角度来看，有两点尤为重要：</p>

<ul>
<li>好测试是原子化的；</li>
<li>好测试是独立的。</li>
</ul>


<p>测试的“三角法”是指会从多个方向同时入手，共同确定出恰当的实现。我们可以称之为“找茬”（playing difficult），不过它真的可以帮助防止过早优化、功能蔓延以及总体上的过度设计。</p>

<p>若采用广度优先的方式，我们会集中实现高层的功能，实现过程中会暂时使用底层功能的伪实现。若采用深度优先的方式，我们会先实现底层功能，在所有底层功能都实现完后才会组合来实现出高层功能。通常我会把代码中任何可能的问题或者缺陷都写成新测试加到测试列表中。</p>

<h3>1.2 对异常的验证</h3>

<pre class='line-numbers language-java'><code class='language-java'>try {
    ...//应该触发异常的代码
    
    fail("evaluate() should throw an exception if " + "a variable was left without a value!"); 
} catch (MissingValueException expected) {
}</code></pre>


<p>JUnit 4带给我们一个方便的，基于注释语法的异常测试方法。若使用注释语法语法，测试可以改写成：</p>

<pre class='line-numbers language-java'><code class='language-java'>@Test(expected=MissingValueException.class) 
public void testMissingValueRaisesException() throws Exception { 
    new Template("${foo}").evaluate(); 
} </code></pre>


<p>虽然这个基于注释语法的测试看起来比try-catch结构的测试精炼，不过使用try-catch，我们能够验证异常的更多信息（例如其中包括的关键错误信息）。有些人喜欢使用注释语法，另一些人总是偏好使用try-catch模式。我在只测试异常类型时使用注释语法，希望发掘出更多的信息时使用try-catch模式。</p>

<h3>1.3 Spike</h3>

<p>Spike基本上是一种是以实验为目的的原型方法，目的是为了研究某个解决方法的可能性和可行性。</p>

<h3>1.4 一些概念</h3>

<p>学习完如何编写测试及通过测试的技巧后，我们将会讨论一些重要概念，包括“夹具”（fixture）、“测试替身”（test doubles），还会讨论到“基于状态的测试”（state-based testing）与“基于交互的测试”1（interaction-based testing）的区别。我们还会重点讨论如何用测试替身处理难缠的协作对象。我们也将会探究三种不同的测试替身，包括伪实现(fakes)、测试桩（stubs）及模拟对象（mock object）。</p>

<h2>2. 如何选择测试</h2>

<p>在衡量待选测试的各个特征时，我们需要依靠直觉，也需要注意收集各种带有启发性的线索。首先，下面四个技巧可以帮我们选择下一步的测试：</p>

<ul>
<li>深入细节与整体考虑</li>
<li>探索未知与轻车熟路</li>
<li>最大限度地获取价值与摘取现成的果实</li>
<li>走通基本功能路径与先处理出错情况</li>
</ul>


<h3>2.1 细节与整体</h3>

<p>我将这两种方法分别称为“细节优先”和“整体优先”。当然这两种方法各有优劣。细节优先有利于降低风险，例如“我们能够对用户提交上来的图片进行模式识别吗？”，不过从整体角度考虑，处理模式识别问题会耽搁总体进度。从另一方面考虑，整体优先能够很快的验证总体设计，同时不用过多操心细节。整体优先的劣势在于其推迟了细节方面的工作进度。 实际上，我们会对各种方法做出评估，通常会（但不总会，如下节所述）先解决我们最关心的问题。这样就引出第二个测试选择技巧——探索未知与轻车熟路。</p>

<h3>2.2 不确定与熟悉</h3>

<p>减少不确定性是我们选择测试时要考虑的因素之一。除此之外，我们还可以先挑选自己熟悉的测试，稍后再处理不确定因素较多的测试。处理不确定性的好处简单明了，因为把未知转化成已知能有效的降低风险。 一直在我们熟悉的设计领域工作有什么好呢？那又不会带来任何新的知识和信息。这种工作方式有什么好呢？可是，付出并不总会得到回报。虽然降低风险很有价值，但是比起爬到高高的枝头探索未知的空间，有时摘下唾手可得的果实更加实惠。</p>

<h3>2.3 高价值与现成果实</h3>

<p>理想情况下，我们应当挑选那些工作量最少，回报却最多的测试。不过通常待选测试之间的区别并不是很明显，我们需要在付出回报比差别不大的各个测试间做出选择。 测试对象的基本功能还是测试对象对null输入的处理，是高价值与现成果实的一个典型例子。开发基本功能需要更多的时间精力，价值也更大。防御出错的功能、处理null输入，这些都很容易实现，但价值也小得多。</p>

<h3>2.4 基本功能与出错情形</h3>

<p>通常，我会先设法完成基本功能，然后再处理出错情形，如第三方类库抛出的异常及非法的输入等。这样做的主要原因是出于价值的考虑。一个能够处理任何出错情况的异常健壮的系统，若不能提供基本功能，根本毫无用处。另一方面，若某个系统在网络出现问题时会崩溃，</p>

<p>话虽如此，有时候还是需要把基本功能放到一边，先处理所有的出错情况。若挨个处理出错情况相当自然并符合直觉，并且只有正确处理了所有错误情况后系统的价值方能得到体现，则应当使用这种策略。</p>

<p>现在我们已经学到了很多选择测试的技巧。不过，不必过多考虑哪个测试才是“正确”的选择，测试的选择并没有一个标准答案。你会逐渐消化那些测试选择技巧，使用起来也会更加得心应手。不过总体上，从简单的测试入手应该是个好主意。一旦完成了第一个测试，接下来的工作就会变得更有头绪了。</p>

<h2>3.　实现技巧</h2>

<p>在著名的Test-Driven Development by Example一书中，Kent Beck列举了3种实现方式：伪实现（faking it）、三角法（Triangulation）以及显而易见的实现（obvious implementation）。</p>

<h3>3.1 伪实现</h3>

<p>写完测试时，我们并不总是清楚如何正确的实现功能使测试通过。这时候，我们可能会先伪实现某个功能，尽快回到绿的状态。可能是因为我们步伐过大，或是触到了系统内的某个“边界”，不过无论是什么原因都需要尽快通过测试，回到稳固可靠的状态。而伪实现功能比停留在红的状态好得多。返回硬编码的值可能是最简单的伪实现方法。你可能还记得，我们在上一章开发模板引擎时曾用过这种方法。</p>

<p>在伪实现某个功能后，我们可以很容易地切换到“三角法”模式，因为产品代码中绝不能包含硬编码的值，所以要想方设法清除掉硬编码部分，使用真实的实现。当然，为了达到目的，我们需要写一个新的测试。</p>

<h3>3.2 三角法</h3>

<p>“三角法”，顾名思义，正如电视中的警察们利用手机信号追踪犯罪嫌疑人。警察们从多点监测疑犯的信号进行三角定位。已知观测点的位置，警察们就可以在地图上标出两条线，线的交点则为疑犯位置。</p>

<p>我们在使用三角法时，当然不会监测信号，也不会在地图上做标记。我们每写一个测试，都会在一个维度上约束了可能的解决方案。当测试足够多时，测试就能有效地缩减解空间，三角定位出我们期望的实现。</p>

<h3>3.3 显而易见地实现</h3>

<p>通过测试的方法通常都显而易见。当然我们并不是说像硬编码返回值那样显而易见，而是指正确的实现通常都很容易。在这种情况下，我们大可以快速前进，直接做实现，而不用像三角法或者做伪实现时那样谨小慎微。</p>

<h2>4 测试驱动的基本准则</h2>

<p>我们总结出以下几条指导准则：</p>

<ul>
<li>绝不跳过重构</li>
<li>尽快变绿</li>
<li>犯错后减慢速度</li>
</ul>


<p>测试驱动时，我们要用最简单的方法解决手中的问题。不过这不是编码阶段所追求的目的，编码阶段应当试图尽快回到绿的状态。重构时再考虑优化设计。</p>

<p>出错后放慢脚步 开发人员在实践TDD过程中会自然地逐渐增大步伐。不过有时候，我们前进步伐太大，以至于出现错误而前功尽弃。这时，我们应当意识到步伐已经太大了，修改已超出理解范围。我们需要小心行事，小步前行，并彻底地重构。</p>

<h2>5 重要的测试概念</h2>

<h3>5.1 夹具</h3>

<p>夹具是测试的上下文，我们把夹具定义为测试类中所有测试方法共有的初始条件。</p>

<p>首先讨论初始状态的各个组成部分及其成因。迄今为止，我们都是在某类初始化方法中创建相互关联的对象以及构建出各个测试方法所需的夹具的。不过夹具的范畴不仅如此。归结其本质，夹具是整个运行时的状态，而并非仅指测试类的成员变量值，或相关对象的内部状态。</p>

<p>夹具可消除重复。追求优良的设计，是重视夹具的部分原因。我们应当用产品代码的标准来衡量测试代码，没有重复可能是最关键的衡量标准之一。夹具把多个测试共享的状态移至一处，有效消除了重复。</p>

<p>光板夹具（clean slate fixture）是绝对要避免的反模式（anti-pattern）。光板夹具，指每个测试方法都从头构建出的夹具；各个测试方法的初始化过程毫无共性。这表明测试间要么存在大量重复，要么毫无内聚性。若是后者，则需要把测试类分成几个类。</p>

<p>夹具使测试更紧凑。熟练的TDD开发人员很容易写出紧凑的测试。其要诀是，利用夹具设置与测试相关的系统、对象，只用几行代码就可以完成验证逻辑。</p>

<p>测试方法只关注真正要测的东西，同时避免其他任何干扰，这样做的好处显而易见，因为我们不会被一叶障目而不见泰山。这样，我们不再反复阅读代码，企图弄清楚“那段逻辑”到底在哪儿。若夹具足够好，其本身就能直接给出上下文，这样测试代码就可以直指要害了。</p>

<h3>5.2　用测试替身替换依赖</h3>

<p>测试中遇到的困难不少是因为被测对象和其他对象之间存在协作，或存在其他类型的依赖关系。例如某个类的构造函数参数是一个java.sql.ResultSet对象。</p>

<p>我们可以用测试替身来替代真实对象。测试替身乔装打扮，使用者对此毫不察觉。无论从实际执行时间角度，还是从开发和维护测试所耗时间角度，测试替身通常都比真实对象更快。</p>

<p>我们通常这样使用测试替身：首先创建测试替身（数量多少根据需要而定），然后配置测试替身的状态、行为和期望，最后把测试替身传给待测类，验证执行结果。</p>

<h3>5.3　基于状态及基于交互的的测试</h3>

<p>在最高层面上，根据验证期望行为的方式不同，测试替身可分为两类：基于状态的测试以及基于交互的测试。</p>

<p><strong>基于状态的测试 </strong></p>

<p>基于状态的测试利用对象内部状态来验证执行结果的正确性。我们需要获取待测对象及其协作对象的状态，然后与期望的状态做对比，进行验证。</p>

<p><strong>测试交互 </strong></p>

<p>基于交互的测试的验证方法截然不同。基于交互的测试验证待测对象与其协作对象以我们期望的方式进行交互，而非验证这些对象的最终状态是否匹配。换句话说，我们并不关心对象的内部状态，而更在乎待测对象是否正确调用了协作对象的方法，是否使用了正确的参数。如果可能，还需要验证调用顺序是否正确。 要实现基于交互的测试，需要使用动态模拟对象库（dynamic mock objects library）。在Java中，这种库有EasyMock3、jMock4以及rMock5等。这些库都是开源的，用户也很多。</p>

<p><strong>各种方法的适用范围</strong></p>

<p>我们依赖基于交互的测试来验证待测对象如何与其协作类进行对话；用基于状态的测试验证对象如何做出回应”。</p>

<h2>6　近处观察测试替身</h2>

<p>下表总结了不同类型的模拟对象：</p>

<table>
<thead>
<tr>
<th> Mock类型 </th>
<th> 描　　述 </th>
</tr>
</thead>
<tbody>
<tr>
<td> 测试桩 </td>
<td> 测试桩实际上是给定接口最简单的实现。例如，测试桩内的方法通常返回硬编码的、无意义的值 </td>
</tr>
<tr>
<td> 伪实现</td>
<td> 伪实现比测试桩更复杂，通常可以认为是接口的另一种实现。换言之，虽然伪实现并不是鸭子，但是其外形和行走方式和鸭子并无二致。相比之下，测试桩只是看起来像鸭子而已 </td>
</tr>
<tr>
<td> 模拟对象 </td>
<td> 从实现角度而言，模拟对象更加复杂。模拟对象可以验证待测对象与其协作对象的交互。由于具体实现方式不同，有些模拟对象可以返回硬编码的值，而有些能够提供逻辑的伪实现。模拟对象通常由框架或类库（像EasyMock）动态产生，不过也可以手动实现</td>
</tr>
</tbody>
</table>


<p>在EasyMock中，所有的模拟对象，自创建时起就处于录制模式。在录制模式下，我们可以录制模拟对象与其协作对象的交互方式，以及模拟对象本身的行为。录制时，只需要调用模拟对象的方法，然后再告诉EasyMock模拟对象对该调用当做何反应，例如该返回什么值，或者该抛出何种异常。示例如下：</p>

<pre class='line-numbers language-java'><code class='language-java'>PricingService mock = createMock(PricingService.class); 
expect(mock.getDiscountPercentage(customer, product)).andReturn(discount); </code></pre>


<p>当录制完期望的协作及行为后，我们应当让EasyMock从录制模式切换到播放模式（replay），模拟对象开始监听各种事件。接着，我们把模拟对象传给待测对象，作为其协作对象。这时，待测类会与其协作对象交互，当然包括我们创建的模拟对象。当实际交互行为与录制的期望行为不符时，测试会失败。 最后，我们用模拟对象作为协作对象执行测试代码，若模拟对象没有因遇到非预期的调用而抛出任何异常，那我们就可以让模拟对象验证是否所有期望的调用都发生了。</p>

<h2>7　提高设计的可测试性的准则</h2>

<p>为了帮您避免可测试性问题，这里列举了一些值得注意的设计准则：</p>

<ul>
<li>尽量使用组合（composition）而非继承（inheritance）</li>
<li>避免使用static关键字，以及Singleton模式</li>
<li>隔离依赖（Isolate dependencies）</li>
<li>注入依赖（Inject dependencies）</li>
</ul>


<h3>7.1　尽量使用组合而非继承</h3>

<p>在测试中试图实例化对象时，对象的继承体系有时会带来不必要的麻烦。例如在Java中，我们可能只关注子类的特征，但却必须要提供只有其父类构造函数才需要的各项参数。如果这些参数本身又是很复杂的对象，需要费很多功夫才能初始化，那这项缺点就更加明显了。</p>

<p>另外，哪怕是极小的修改所产生的影响，都可能在整个继承体系内产生较大的影响，显然这样并不好。继承带来的限制过多，使测试很麻烦。这时，我们不得不考虑另一种替代方法，即组合。</p>

<p>组合是指通过组装一些稍简单的类来获得一个功能复杂的大类的过程。顶层的组合对象会把工作委托给其各个组成部分，而不是通过调用父类的方法来完成工作。实际上组合是基于对象级别的责任划分，而不是静态的、类级别上的划分。组合比继承稍显麻烦，代码量更多，不过组合能够提高可测试性、适应性以及可维护性，这些优点远大于多出几行代码所带来的麻烦。</p>

<h3>7.2　避免使用static关键字以及Singleton模式</h3>

<p>静态方法调用及Singleton模式也会影响可测试性。取决于待测代码与静态方法或Singleton模式的纠葛程度，在测试中用测试替身替换静态方法可能极其困难。或许很多时候我们用不着替换掉 Singleton或静态方法，但如果想这么做（例如在测试过程中，静态方法或者Singleton实例会试着连接远程服务器），可没那么容易。</p>

<p>很难用伪实现替换静态方法，因为类的类型信息已经硬编码在代码中了。同样，用getInstance()方法获取的Singleton类也很难用伪实现替换。其实Singleton模式本身并没错，而是其默认实现方式存在问题。有时，我们需要在测试过程中替换掉静态方法或者Singleton的实现。要完成替换，我们需要有一个静态方法，用于替换当前实现，在测试完成后，还需要把替换过的实现恢复原样。</p>

<h3>7.3　隔离依赖</h3>

<p>为了能够方便地用测试替身替换依赖，隔离依赖使其更容易替换非常关键。有几种方法可以解决这个问题：</p>

<p>把静态方法的访问移至成员方法，</p>

<pre class='line-numbers language-java'><code class='language-java'>//有味道的代码：通过调用静态方法获取依赖 
//这种方法并不好。我们把获取依赖与使用依赖的逻辑混在了一起。简言之，我们需要隔离依赖。
public class OrderProcessor { 
    public void process(Order order) { 
        PricingService service = PricingService.getInstance(); 
        // use the PricingService object for processing the order 
    } 
} 

//已消除了代码味道：静态方法的调用包装进了成员方法中 
public class OrderProcessor { 
    public void process(Order order) { 
        PricingService service = getPricingService(); 
        // 通过替换获取依赖 
        // use the PricingService object for processing the order 
    } 
    
    protected PricingService getPricingService() { 
        /*（以下3行）覆盖返回的测试替身*/ 
        return PricingService.getInstance(); 
    } 
}</code></pre>


<p>在Working Effectively with Legacy Code一书中，Michael Feather定义了接缝（seams）的概念：“不用修改直接影响行为的代码就能改变系统行为的那个点”。换言之，在测试期间可以在某个点用一段代码替换另一段代码，而无需修改待测试代码，这个点就是接缝。在上面的代码中，从测试用例调用process方法的角度来看，getPricingService方法的调用实际就是接缝。</p>

<p>接缝，根据其定义，由一个或几个入侵点（enabling points）构成，即入侵接缝的不同途径。getPricingService本身就是入侵点。我们可以使用代码清单4-6中的方法将其覆盖。</p>

<pre class='line-numbers language-java'><code class='language-java'>//入侵接缝 
public class OrderProcessor { 
    public void process(Order order) { 
        PricingService service = getPricingService(); 
        // 这就是接缝 
        // use the PricingService object for processing the order 
    } 
    
    protected PricingService getPricingService() { 
        // 入侵点 return PricingService.getInstance(); 
    } 
} 

public class OrderProcessorTest { 
    @Test 
    public void testOrderProcessorByExploitingTheSeam() throws exception { 
        OrderProcessor p = new OrderProcessor() { 
            protected PricingService getPricingService() { 
                return new FakePricingService(); 
                // 通过入侵点使用接缝 
            } 
        }; 
        ... 
    } 
}</code></pre>


<p>我们刚才看到的接缝属于对象接缝，利用面向对象功能，在调用代码中透明的覆盖方法。还有其他多种类型的接缝（每种语言都不一样），如预处理接缝、链接接缝等。</p>

<p>隔离依赖对可测试性及可维护性至关重要。</p>

<h3>7.4　注入依赖</h3>

<p>依赖注入（Dependency Injection，DI）是近来软件圈子里的热门话题之一。这种代码组织方式可以减少直接依赖，将其变为间接依赖，或者说把getter变为setter。这个概念最初叫做依赖反转（Inversion of Control），表示依赖反转了。ThoughtWorks公司的Martin Fowler引入了依赖注入这个术语来更好的表达出概念的本意，即注入依赖而非查找依赖。</p>

<pre class='line-numbers language-java'><code class='language-java'>//　有了依赖注入，测试代码可读性更强了 
public class OrderProcessorTest { 
    @Test 
    public void testOrderProcessorWithDependencyInjection() throws Exception { 
        OrderProcessor p = new OrderProcessor(); 
        p.setPricingService(new FakePricingService()); 
        ... 
    } 
}</code></pre>


<p><strong>依赖注入的不同类型 </strong></p>

<p>setter-based 依赖注入，通过调用setter注入所需的依赖。不过这不是唯一的依赖注入方式。</p>

<p>field-based依赖注入，及基于构造函数的依赖注入也很常见。 field-based注入实际和setter-based注入一样，唯一的区别是在field-based注入过程中，会直接给实例变量赋值，不通过setter，所以不能对注入的依赖进行任何操作。部分由于这个原因，field-based注入通常用在框架代码中，使用反射API给任意对象注入依赖，而不强求开发人员为纯依赖注入而写setter这种的样板代码。</p>

<p>基于构造函数的依赖注入是指用构造函数参数注入依赖。这种方法比setter-based注入方法要好，因为要使用setter-based注入，程序员必须要清楚以哪种顺序注入依赖。换句话说，用setter-based注入方法，可能会使目标对象处于未完全配置的状态。 基于构造函数的依赖注入方式也有不足，因为构造函数并不能体现在接口上，所以不能通过接口向对象注入依赖5。另外，把所需的各种依赖作为构造函数参数，可能会使构造函数参数列表过长，含义模糊（这有可能是设计缺陷的象征）。</p>

<h2>8　单元测试模式</h2>

<p>单元测试是TDD中的重要一环，所以了解单元测试的常用模式很有必要。在这一节中，我们将会了解不少模式，包括：</p>

<ul>
<li>写断言的模式</li>
<li>组织及构建夹具的模式</li>
<li>测试类总体模式。</li>
</ul>


<h3>8.1 断言模式</h3>

<h4>8.1.1 结果状态验证（Resulting State Assertion）</h4>

<p>结果状态验证是单元测试中最常用的方法。这种方式是指先调用对象的功能，然后验证其内部状态与期望的是否一致.</p>

<h4>8.1.2 防卫断言（Guard Assertion）</h4>

<p>防卫断言用来明确的验证调用功能前对夹具所做的各项假设。下面这个简单的例子表明了防卫断言的用途：</p>

<pre class='line-numbers language-java'><code class='language-java'>@Test 
public void listIsNoLongerEmptyAfterAddingAnItemToIt() throws Exception { 
    List&lt;String&gt; list = new ArrayList&lt;String&gt;(); 
    assertTrue(list.isEmpty()); 
    // guard assertion list.add("something"); 
    assertFalse(list.isEmpty()); 
    // state verification 
} </code></pre>


<p>请注意，在调用add方法前，防卫断言保证了空列表的isEmpty方法正确的返回了true，确保所测试的确实是期望的行为。</p>

<p>防卫断言模式常常与结果状态验证模式一同使用。这两种方法常常结合在一起，首先验证调用前状态与期望的一致，然后调用功能，验证结果状态，与上面的例子完全一样。 不过有时候，使用防卫断言是为了保证夹具的初始状态的正确性。这时，可以把防卫断言移至初始化方法的末尾，因为这些断言实际上是为了验证初始化方法。</p>

<h4>8.1.3 差值断言（Delta Assertion）</h4>

<p>有时在进行测试时我们需要在控制权不完全在自己手中的代码基础上工作。尤其是我们的测试可能并不能完全控制夹具。由此，在不能硬编码夹具状态的情况下，如何写出可靠、健壮及自检查的测试呢？解决方法是不要验证绝对值，而是验证代码执行前后的差值。</p>

<h4>8.1.4 自定义断言</h4>

<p>有时候用于验证期望的代码比调用待测对象所需的代码要多得多。这时（特别是当出现了不止一次时），可以从测试代码中提取出一个自定义断言，把复杂的验证逻辑封装进一个小巧的方法之中，以备测试代码调用。</p>

<p>自定义断言的一个常见用途是做不同类型的模糊匹配。例如，我们可能希望用对象的一部分属性来比对两个对象。另外一个常见原因是对象并没有正确的实现equals方法，同时我们还不能对其进行修改。此外，创建自定义断言可以在验证失败后能够提供更有意义的错误信息（注释21：有意义的出错信息非常有用，特别是测试变得过大时）。</p>

<h4>8.1.5 交互断言（Interaction Assertion）</h4>

<p>我们的最后一个验证模式称为交互断言。交互断言很有趣，其并不验证代码结果的正确性，而是验证代码与其协作对象的交互行为的正确性。</p>

<p>EasyMock等模拟对象库的内部工作机理。这些库把实际的方法调用及期望的方法调用记录到一个类似于列表的数据结构中，然后把期望的列表与实际列表相比较。</p>

<h3>8.2　夹具模式</h3>

<p>夹具是测试的重要组成部分。夹具的结构通常并不简单，我看到了不少巨大的夹具，用巨大的初始化方法创建出巨多的对象，这方法大到一屏都显示不下。无论在产品代码中，还是测试代码中，这种庞杂的代码都是个问题。还好，这些年来我们发现了不少模式，用于解决这类问题。</p>

<p>我们将会谈到3个此类模式。前两个模式关于在夹具中创建对象，第三个关于在测试结束时处理创建出的对象方法。准备好了吗？</p>

<h4>8.2.1 参数化创建方法</h4>

<p>典型的夹具中的大部分对象是所谓的实体对象（entity objects），用来表示业务领域中存在的实体或者实际概念。这类对象通常有很多属性，我见到的大多数糟糕的夹具就是因为填充这些属性，尽管不少属性对当前测试根本不重要。</p>

<p>参数化创建方法（Parameterized Creation Method）可以解决此问题，把不重要的属性从初始化方法中移到单独的创建方法中。此创建方法接受变量的属性值作为其参数，而把常量或者随机值直接赋给不重要的属性。</p>

<h4>8.2.2 对象母亲</h4>

<p>重构测试类，在类中加入创建方法从而消除重复，这种修改一开始效果会很好。不过不久我们就会发现不同类的创建方法间存在重复。接下来自然要把创建方法移到单独的类中以消除重复。对象母亲模式就是创建方法的聚合体。</p>

<p>总的来说，对象母亲模式是一个复杂的对象工厂，用于创建领域对象（domain object）的整个对象网络（object graph），还可以创建出不同状态下的实例。此外，对象母亲也可以提供方法修改某个领域对象，例如在对象间建立关联关系、移除关联关系、或者把对象设置为特征状态。</p>

<h4>8.2.3 自动清理</h4>

<p>在测试框架（如JUnit）中之所以需要清理方法，是为了执行测试后做必要的清除工作，例如在集成测试后删掉数据库中保存的数据，或者移除测试过程中创建出的文件。假如清理逻辑很复杂，或者需要清除的对象过多，我们的测试代码会变得很混乱，也很容易漏掉某些需要清除的对象。这会使后续的测试出现问题，而且极难调试或跟踪出问题的源头。</p>

<p>可以看出，在自动清理模式中，夹具的初始化方法不仅仅创建出了夹具对象，而且把这些对象添加到测试对象注册表中。这注册表只不过是一个对象引用的集合，当夹具的清理方法触动注册表时，注册表会清除每一个注册了的夹具对象。</p>

<h3>8.3　测试模式</h3>

<p>我们已经接触到了防卫断言到对象母亲等一系列测试相关模式。接下来我们会先学习一些更为通用的测试模式，然后学习如何在遗留代码上工作。</p>

<p>下面要介绍的这些模式主要是关于如何可使代码的可测试性更佳，以及使测试代码更紧凑，结构更好的Java语言技巧。</p>

<h4>8.3.1 参数化测试</h4>

<p>有时，我们会发现我们编写的测试几乎一模一样，只有个别输入值不同，而测试逻辑完全相同。这时，我们或许可以把这类测试重写成参数化测试。 这类测试的基本要点是，只编写一个测试方法，包含应用于测试数据的测试逻辑。当然，显然还需要一个方法提供参数化数据，再用一些代码绑定给定的测试数据到测试方法上。 还好，JUnit4为此提供了很多便利，要创建参数化测试只需要给测试类加上相应的注释（annotation）即可。下面的代码是在JUnit4中编写参数化测试的例子：</p>

<pre class='line-numbers language-java'><code class='language-java'>import org.junit.runner.RunWith; 
import org.junit.runners.Parameterized; 
import org.junit.runners.Parameterized.Parameters; 

@RunWith(Parameterized.class) 
public class ParameterizedTest { 　 
    @Parameters 
    /*❶（以下2行）提供参数化数据*/ 
    public static Collection&lt;Object[]&gt; parameters() { 
        Object[][] data = new Object[][] { 
            { 0, 0, 0 }, 
            { 1, 1, 0 }, 
            { 2, 1, 1 }, 
            { 3, 2, 1 }, 
            { 4, 3, 1 }, 
            { 5, 5, 0 }, 
            { 6, 8, -2 } 
        }; 
        return Arrays.asList(data); 
    } 　 
    
    public int expected, input1, input2; 
    　 
    public ParameterizedTest(int expected, int input1, int input2) { 
        // ❷数据通过构造函数绑定 
        this.expected = expected; 
        this.input1 = input1; 
        this.input2 = input2; 
    } 　 
    
    @Test 
    /*❸（以下2行）每个对象数组调用一切测试方法*/ 
    public void executeParameterizedTest() throws Exception { 
        assertEquals(expected, new Calculator().add(input1, input2)); 
    } 
}</code></pre>


<p>上面的参数化测试由三部分组成。首先，我们用一个标有@Parameters的静态方法提供参数化数据。此方法返回一个对象数组的集合，每一个数组都表示一个数据集或者一个测试实例❶。换句话讲，JUnit会为每一个对象数组都重新实例化一次测试类。JUnit❷会把对象数组作为构造函数参数传给测试类，通常测试类会把这个参数保存在内部变量中，在❸测试方法中使用。最后，JUnit会调用标有@Test的测试方法。这就是整个测试过程。</p>

<p>参数化测试模式（Parameterized Test Pattern）可以很好的用来实现数据驱动测试。一旦写好了一个类似于代码清单4-14中的架子，添加新测试就非常方便了，只要加新的对象数组就行。 不过，添加一个对象数组不是创建新测试用例的最佳方法。如果代码清单4-14中的测试，每一个测试用例都是一行代码的断言，那么可读性会好得多。确实，当测试数据量非常大，而且是从XML或ASCII文件类的外部数据源获得，那么使用参数化测试会很合适，解析外部数据源的工作可以交给标有@Paramters的方法做。这样，测试类难免会变得稍微有些复杂，不过好处是可以以更合适的语法和文件格式描述测试数据。 不过需要处理大量数据的测试毕竟是少数，我们接下来会讨论些更常见的东西。因为很多对象都和其他对象有依赖关系，或许接下来应该介绍自分流（Self-Shunt）模式。</p>

<h4>8.3.2 自分流</h4>

<p>前面我们讨论过几种不同的测试替身，不过没有提及自分流模式。自分流模式也是一种测试替身，同时也是我们的测试类。自分流模式首先由Micheal Feathers提出，这种模式是指在测试中，测试类本身充当测试替身。</p>

<pre class='line-numbers language-java'><code class='language-java'>//自分流模式的例子 
public class SelfShuntExample implements PricingService { 
    /*❶（以下5行）实现PricingService接口*/ 　 
    @Override 
    public float getDiscountPercentage(Customer c, Product p) { 
        return 10.0f; 
    } 　 
    
    @Test 
    public void testOrderProcessorWithMockObject() throws Exception { 
        // some setup omitted for brevity... 
        OrderProcessor processor = new OrderProcessor(); 
        processor.setPricingService(this); 
        // ❷ 将“this”传给待测对象 
        processor.process(new Order(customer, product));
        assertEquals(expectedBalance, customer.getBalance(), 0.001f); 
    } 
} </code></pre>


<p>从上面代码可以看出，测试类实现了PricingService接口❶，这样我们就可以直接给待测类传入this❷，作为其协作对象，而不用重新创建一个测试替身，或者写出匿名类这样的凌乱代码。对于这种简单的情况，匿名类也是个不错的选择，不过随着方法数量的增多，匿名类代码也会变得越加凌乱，这时最好能使用自分流模式，或者单独的测试替身类。</p>

<p>要想在需要的地方快速创建出简单的测试替身，Shelf-Shunt是个绝佳的工具。不过随着测试替身的逻辑变得更加复杂，把这些逻辑移到独立的测试替身中会更合适。即便如此，我们要知道，独立的测试替身也有缺点。如果我们想在测试方法间或者测试替身间共享对象及数据，无间内部类（Intimate Inner Class）也许是个更好的选择。</p>

<h4>8.3.3 无间内部类</h4>

<p>有时我们会想在测试类间或者测试替身间共享对象及数据。这问题有几种解决办法（例如添加个getter），无间内部类作为解决方法之一，可能并不很一目了然。不过这并不意味着这种方法不好。实际上，非静态内部类那能够读取和修改测试类成员变量的能力，可以使测试代码更紧凑，比起用getter暴露测试替身内部状态要好得多。 我们可以用一段代码展示无间内部类的作用。下面的示例代码测试的行为是，Server对象在初始化时会从ThreadFactory中获取一个Thread对象，停止时会挂起这个线程。解决办法是使用无间内部类，它将一个新创建的Thread实例赋给包含测试类的thread成员变量。</p>

<pre class='line-numbers language-java'><code class='language-java'>//无间内部类的例子 
public class IntimateAnonymousInnerClassExample { 　 
    private StartStopSynchronizedThread thread; 
    // ❶在测试类和测试替身间共享 　 
    @Test 
    public void testStartingAndStoppingThreadsThroughAnExecutorService() throws Exception { 
        Server server = new Server(); 
        server.setThreadFactory(new ThreadFactory() { 
            /*❷无间内部类*/ 
            public Thread newThread(Runnable task) { 
                thread = new StartStopSynchronizedThread(task); 
                // ❶在测试类和测试替身间共享 
                return thread; 
            } 
        }); 
        
        server.start(); 
        thread.shouldBeStartedWithin(1, TimeUnit.SECONDS); 
        // ❸测试即可访问共享域 
        server.stop(); 
        thread.shouldBeStoppedWithin(1, TimeUnit.SECONDS); 
        // ❸测试即可访问共享域 
    } 
} </code></pre>


<p>可以看到，无间内部类❶使用了测试类中的thread成员变量❷，这样测试中就可以访问thread的成员变量做验证了❸。从技术层面上，无间内部类可以实现为匿名类或者内嵌类。像上面代码中的内部匿名类，可能会变得不好控制，但是它可以访问创建它的方法中的final变量。相比之下，内嵌类更清楚一些，不过数据访问上存在限制。两种方式都可以访问测试类的成员变量。 说到访问成员变量，下一个模式专门介绍如何访问那些本不该被访问到的成员变量。</p>

<h4>8.3.4 特许访问（Privileged Access）</h4>

<p>有时候你可能想改变一点系统现有代码，以测试新添加的代码，但由于某种原因，不能够修改那些代码。这时，“侵犯”现有代码的隐私，通过反射（reflection）API直接读取内部数据，就可以绕过问题，写出测试了。 JUnit邮件列表的文件区有PrivilegedAccessor类的源代码，可以用来做这类工作。另外JUnit-Addons的开源库6里包含PrivateAccessor类、Langhing Panda社区开发的BeanInject工具，也有类似的功能。</p>

<h4>8.3.5 额外构造函数（Extra Constructor）</h4>

<p>计算机世界里面充斥着大段大段怪物般的代码。与这种代码一起工作，很容易头昏脑胀，因为要实例化一个类，可能需要准备一大堆其他对象。这问题很可能是因为没有正确地隔离依赖。当然相应的解决方法是恰当地隔离依赖，把整个架构往依赖注入方向引导，不过这需要花费很多时间。这时，可以使用额外构造函数模式作为临时解决方法。 因为我们没法从外部替换掉依赖，所以要从内部替换。因此，需要给待测类添加额外的构造函数，把依赖作为参数传入，保存到相应的成员变量中，替换真实的依赖。 若原先的构造函数会创建或配置依赖（若不是，我们也可以把依赖配置代码移至这里），我们则可以修改原先构造函数，使其调用新构造函数。</p>

<h3>8.4 小结</h3>

<p>一开始，我们探讨了如何编写测试，介绍了一些测试选择技巧。有了这些技巧，选择测试时有了更多的依据。然后我们转而讨论最为基础的技术，如何使测试通过。这些技术有：伪实现、用三角定位法逐渐逼近正确的功能实现、及时常遇见的显而易见的实现。接着，我们简要陈述了测试驱动的三项准则：毫无保留的重构，尽快变绿，出了问题后放慢速度。</p>

<p>我们也讨论了几个重要的测试概念。我们把夹具定义为测试执行的上下文环境。我们研究了测试替身的多彩世界，学习了它的分类，包括：伪实现、测试桩及模拟对象。接着，我们比较了基于状态的测试及更为复杂的基于交互的测试。 通过深入地探讨伪实现、测试桩，特别是模拟对象，我们对测试替身的理解也更加细致。然后我们转而讨论提高可测试性等更高层次的准则。我们讨论了继承及组合，讨论了静态方法和Singleton模式的潜在问题。</p>

<p>在讨论完用接缝解决依赖问题后，我们进一步讨论了依赖注入带来的好处。 在理解了测试的重要概念，及具有良好的可测试性的设计的准则后，我们回到了模式方面的讨论。这些模式不少源自Gerard Meszaros的xunitpaterns.com。我们探讨了单元测试的相关模式，从不同断言间的微小差别，到初始化及清除夹具的大家伙模式。 我们的模式乐园之旅正式结束啦。</p>

<h2>9. 其它测试</h2>

<h3>9.1 测试驱动Web组件</h3>

<h4>9.1.1　测试驱动Java Servlets</h4>

<p>HttpServlet类的service方法负责处理所有HTTP请求。我们的Servlet类会继承自这个HttpServlet类。HttpServlet的Service方法根据HTTP请求的类型把请求转发到相应的doXXX()方法上。</p>

<pre class='line-numbers language-java'><code class='language-java'>//为LoginServlet配置AuthenticationService 
public class TestLoginServlet { 　 
    private static final String CORRECT_PASSWORD = "correctpassword"; 
    private static final String VALID_USERNAME = "validuser";
    private LoginServlet servlet; 
    
    /* 将普通对象移到域中*/ 
    private FakeAuthenticationService authenticator; 
    private MockHttpServletRequest request; 
    private MockHttpServletResponse response; 　 
    @Before 
    public void setUp() { 
        authenticator = new FakeAuthenticationService(); 
        authenticator.addUser(VALID_USERNAME, CORRECT_PASSWORD); 　 
        servlet = new LoginServlet() { 
            @Override 
            protected AuthenticationService getAuthenticationService() { 
                return authenticator; 
            } 
        }; 
        
        request = new MockHttpServletRequest(); 
        response = new MockHttpServletResponse(); 
    } 　 
    
    @Test 
    public void wrongPasswordShouldRedirectToErrorPage() throws Exception { 
        request.addParameter("j_username", VALID_USERNAME); 
        request.addParameter("j_password", "wrongpassword"); 
        servlet.service(request, response); 
        assertEquals("/invalidlogin", response.getRedirectedUrl()); 
    } 　 
    
    @Test public void validLoginForwardsToFrontPageAndStoresUsername() throws Exception { 
        request.addParameter("j_username", VALID_USERNAME); 
        request.addParameter("j_password", CORRECT_PASSWORD); 
        servlet.service(request, response); assertEquals("/frontpage", response.getRedirectedUrl()); 
        assertEquals(VALID_USERNAME, request.getSession() .getAttribute("username")); 
    } 
} </code></pre>


<p>提取出公用初始化方法后，测试都通过了。不过j_username和j_password这两个字符串还存在重复，也可以重构成常量。虽然有时候可读性比“不能有重复”更重要，不过就这具体情况，我强烈建议做重构。这重复不但存在于测试方法之间，还存在于测试代码与产品代码之间，为此我们需要定义公共的常量，让产品代码和测试代码都使用此常量，这样就可以消除重复了。</p>

<p>现在来看看我们对AuthenticationService接口做了哪些工作。我们引入了AuthenticationService接口，这样LoginServlet就不用知道过多验证细节了。至于如何给Servlet注入AuthenticationService暂时不做考虑，先使用getter方法，做测试时可以覆盖这个方法。目前我们还没实现真正的AuthenticationService，只有一个伪实现。 采用分治法，我们可以保持Java Servlet的代码既干净，可测试性又好。使用意图编程，小步地通过测试，我们正在一步步地实现完整的功能。在LoginServlet例子中我们也看到了，用测试驱动的方法编写Servlet代码并不比写普通代码难多少。</p>

<pre class='line-numbers language-java'><code class='language-java'>//包含依赖注入的LoginController的完整实现 
public class LoginController implements Controller { 　 
    private AuthenticationService authenticator; 　 
    public void setAuthenticationService(AuthenticationService authService) { 
        this.authenticator = authService; 
    } 　 
    
    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { 
        String user = request.getParameter("j_username"); 
        String pass = request.getParameter("j_password"); 
        if (authenticator.isValidLogin(user, pass)) { 
            return new ModelAndView("frontpage"); 
        } 
        return new ModelAndView("wrongpassword"); 
    } 
} </code></pre>


<p>上面的代码没什么新东西。运行所有测试，当前有效登录的测试通过了，第一个测试却失败了。这是因为我们没有给第一个测试中的控制器注入AuthenticationService。我们可以把公共的初始化代码提取成一个成员方法，再给这个方法标记上@Before。这一步重构的结果就不在这里演示了，你可以自己试试，重构后代码会很简洁。 看完这些例子后，我想不会再有人认为现代MVC框架下测试驱动控制器类有任何麻烦或者困难了。这些实际上都只是普通的Java代码，只不过接口稍微大了一点而已。</p>

<h4>9.1.2　用JspTest测试驱动JSP</h4>

<p>JspTest里有一个叫做HtmlTestCase的抽象类，所有测试都需要继承这个类。HtmlTestCase提供了一些方法来模拟HTTP请求和渲染JSP文件以及做HTTP相关的验证等。</p>

<h3>9.2 测试驱动数据访问</h3>

<p>开发应用逻辑层（application logic layer）时，可以使用持久化逻辑伪实现。我们可以验证业务逻辑代码正确地调用了持久层方法，传入了正确的参数。那么我们在开发持久层时应该模拟JDBC API（或其他任何正在使用的持久化框架接口），还是该访问数据库？应该使用真实的数据库，还是使用轻量级，速度飞快的，但和真实数据库系统有一定差别的内存数据库？</p>

<h4>9.2.1　用DAO模式分层</h4>

<p>此模式是指每个持久化的领域对象（domain object）都应该有一个DAO接口负责其持久化工作。具体持久化方式有很多种，可以是关系数据库、对象数据库、或是文件系统上的一堆XML文件。对象本身及DAO的调用者并不知道对象从哪里来，到哪里去，以及是否具有持久性。因此，我们可以随意替换持久化的具体实现技术，而上层应用程序对此不会有一丝察觉。</p>

<pre class='line-numbers language-java'><code class='language-java'>//PersonDao接口对应用代码隐藏了实现细节 
public interface PersonDao { 
    Person find(Integer id); 
    void save(Person person); 
    void update(Person person); 
    void delete(Person person); 
    List&lt;Person&gt; findAll(); 
    List&lt;Person&gt; findByLastname(String lastname); 
}</code></pre>


<p>比起把数据访问代码与应用逻辑代码混在一起，使用DAO模式的好处显而易见。另外使用DAO模式还可以缩减代码量。如果使用了Hibernate或Spring框架的JdbcTemplate等现成的开源持久层框架，能够显著加快开发速度。好的框架能帮你做不少工作，开发人员就可以专心开发持久化逻辑，而不用在持久化技术细节上花太多功夫了。</p>

<h3>9.3 小结</h3>

<p>我们了解了如何测试驱动数据访问代码。这工作比想象的要容易得多。我们从两个角度阐述了这个问题——分别使用了单元测试和集成测试驱动产品代码的开发。 首先，我们讨论了为何数据访问代码与普通的应用程序代码或业务逻辑代码间存在一定差别，为何其会跨越许多层。然后我们了解了DAO模式，以及如何用这种模式解决代码臃肿的现实问题。 然后，我们尝试用3种不同的持久化技术实现一个简单的DAO类。这3种技术分别为：纯JDBC API、Spring框架提供的JdbcTemplate以及Hibernate API。因为使用3种技术实现同一种功能，我们很容易看出框架的可测试性风格对TDD过程的影响。 在学会用单元测试驱动数据访问代码后，我们转向了另一种方式：直接连接到HSQLDB内存数据库进行集成测试。我们讨论了在集成测试中使用轻量级数据库可能带来的问题，也讨论了在版本控制系统中维护各项配置的必要性。 我们学习了如何搭建集成测试的基础架构，好让集成测试编写工作变得飞快，讨论了用SQL脚本及Hibernate API来创建数据库模式，亦讨论了如何用事务夹具清理测试数据。我们也介绍了用DbUnit填充数据库，以及用外部XML数据文件中的内容进行结果验证。 在尝试测试驱动数据访问代码的两种不同方法后，我们发现两种方法各自的优势，并决定针对具体情况而使用不同的方法。</p>

<h2>10　JUnit 4简明教程</h2>

<pre class='line-numbers language-java'><code class='language-java'>import static org.junit.Assert.*; 
// ❶ 
import org.junit.*; 
import java.io.*; 

public class TestConsoleLogger { 
    // ❷ private static final String EOL = System.getProperty("line.separator"); 
    private ConsoleLogger logger; 
    /*❸ */ 
    private PrintStream originalSysOut, originalSysErr; 
    private ByteArrayOutputStream sysOut, sysErr; 
    
    @Before 
    public void createFixture() { 
        // ❹ 
        logger = new ConsoleLogger(); 
        /*❸*/ 
        originalSysOut = System.out; 
        originalSysErr = System.err; 
        sysOut = new ByteArrayOutputStream(); 
        sysErr = new ByteArrayOutputStream(); 
        System.setOut(new PrintStream(sysOut)); 
        System.setErr(new PrintStream(sysErr)); 
    } 
    
    @After 
    public void resetStandardStreams() { 
        // ❺ System.setOut(originalSysOut); 
        System.setErr(originalSysErr); 
    } 
    
    @Test /*❻❼ */
    public void infoLevelGoesToSysOut() throws Exception { 
        logger.info("msg"); 
        streamShouldContain("[INFO] msg" + EOL, sysOut.toString()); 
    } 
    
    @Test(timeout = 100) // ❽ 
    public void errorLevelGoesToSysErr() throws Exception { 
        // ❻❼ 
        logger.error("Houston..."); 
        streamShouldContain("[ERROR] Houston..." + EOL, sysErr.toString()); 
    } 
    
    /*❾ */
    private void streamShouldContain(String expected, String actual) { 
        /*❿ */ 
        assertEquals("Wrong stream content.", expected, actual); 
    } 
} </code></pre>


<p>❶ 通过静态导入的JUnit的Assert类获取断言方法。 ❷ 类名应该表明它是一个测试（例如名称中包含Test）。 ❸ 在@Before方法中设置的实例变量表示测试方法中常用的类具。 ❹ 通过为一个公有方法加上@Before注解来为测试准备一个已知状态。 ❺ 通过为一个公有方法加上@After注解来在测试之后执行清理操作。 ❻ 所有带@Test注解的public void方法均被视为JUnit 4 TestRunner的测试用例。 ❼ 测试方法可以声明任何异常——JUnit负责捕获它们。 ❽ @Test注解也可以用于计时测试、测试异常等。 ❾ 除测试方法外，还可以声明任意数量的辅助方法。</p>

<h2>11　EasyMock简明教程</h2>

<pre class='line-numbers language-java'><code class='language-java'>import static org.easymock.EasyMock.*; 
/*❶ */ 
import org.easymock.EasyMock; 
import org.junit.Test; 

public class TestInternetRelayChat { 
    @Test public void messagesAreOnlyDeliveredToOtherClients() throws Exception { 
        String msg = "Maisk Maisk!"; 
        Client koskela = EasyMock.createMock(Client.class); 
        /*❷*/ 
        Client freeman = EasyMock.createMock(Client.class); 
        Client himberg = EasyMock.createMock(Client.class); 
        /*❸ */
        expect(himberg.onMessage("lasse", msg)).andReturn(true); 
        freeman.onMessage("lasse", msg); /*❹*/ 
        expectLastCall().andReturn(true); 
        replay(freeman, koskela, himberg); // ❺ 
        InternetRelayChat irc = new InternetRelayChat(); /*❻ */ 
        irc.join("inhuman", freeman); 
        irc.join("vilbert", himberg); 
        Prompt prompt = irc.join("lasse", koskela); 
        prompt.say(msg); 
        verify(freeman, koskela, himberg); // ❼ 
    } 
} </code></pre>


<p>❶ 从EasyMock和类自身中导入静态辅助方法。 ❷ 让EasyMock为指定接口创建模拟对象。 ❸ 记录期望的交互操作。 ❹ 功能上与上一条语句等价，但语法不同。 ❺ 记录完期望的信息后，转换为应答模式。 ❻ 一切都准备好以后，做个练习。 ❼ 让模拟对象验证是否发生了期望的交互行为。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Collections]]></title>
    <link href="http://blog.ubone.com/blog/2015/03/14/java-collections/"/>
    <updated>2015-03-14T20:51:05+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/03/14/java-collections</id>
    <content type="html"><![CDATA[<p>Java提供了一套完整的Collection框架，能够帮助我们减少开发工作量、提高程序运行速度和代码质量。本文学习Java Collection框架。</p>

<!--more-->


<h2>1. 接口层级结构</h2>

<p>核心Collection接口封装了各种类型的集合，它是Java Collections框架的基石。接口继承层次如下图所示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2015-03-14-colls-coreInterfaces.png" alt="image" /></p>

<p>注意，从上图可以看出，Map并不是真正的Collection。所有核心Collection接口都支持泛型。在声明Collection实例时，你可以也应该指明集合的元素类型，让编译器帮你校验放入集合的元素类型是否匹配，从而降低运行时错误。</p>

<p>类结构图</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2015-03-14-colls-classdiagram.jpg" alt="image" /></p>

<h2>2. Collection接口</h2>

<p>Collection类都有很方便的构造器。例如你有一个<code>Collection&lt;String&gt; c</code>，它可能是一个List、Set或其它Collection类型。通过构造方法可以转换成另一种Collection：</p>

<pre class='line-numbers language-java'><code class='language-java'>List&lt;String&gt; list = new ArrayList&lt;String&gt;(c);</code></pre>


<p>基本的Collection操作包括：</p>

<ul>
<li><code>int size()</code></li>
<li><code>boolean isEmpty()</code></li>
<li><code>boolean contains(Object element)</code></li>
<li><code>boolean add(E element)</code></li>
<li><code>boolean remove(Object element)</code></li>
<li><code>Iterator&lt;E&gt; iterator()</code></li>
</ul>


<p>操作整个Collection的相关方法：</p>

<ul>
<li><code>boolean containsAll(Collection&lt;?&gt; c)</code></li>
<li><code>boolean addAll(Collection&lt;? extends E&gt; c)</code></li>
<li><code>boolean removeAll(Collection&lt;?&gt; c)</code></li>
<li><code>boolean retainAll(Collection&lt;?&gt; c</code>)（交集，只保留c中存在的元素）</li>
<li><code>void clear()</code></li>
</ul>


<p>此外还有数组的操作：<code>Object[] toArray()</code>,  <code>&lt;T&gt; T[] toArray(T[] a)</code></p>

<h3>2.1 遍历Collection</h3>

<p>有三种方法遍历Collection：聚合操作、for-each和Iterator。</p>

<h4>2.1.1 聚合操作</h4>

<p>JDK8之后，推荐使用聚合操作来遍历Collection。聚合操作常常与lambda表达式一起让代码更具表达力。下面的代码完成遍历并打印红色的对象的name:</p>

<pre class='line-numbers language-java'><code class='language-java'>myShapesCollection.stream()
    .filter(e -&gt; e.getColor() == Color.RED)
    .forEach(e -&gt; System.out.println(e.getName()));</code></pre>


<p>对多核系统，还可以请求并行流，这对超大Collection有帮助：</p>

<pre class='line-numbers language-java'><code class='language-java'>myShapesCollection.parallelStream()
    .filter(e -&gt; e.getColor() == Color.RED)
    .forEach(e -&gt; System.out.println(e.getName()));</code></pre>


<p>更多例子：</p>

<pre class='line-numbers language-java'><code class='language-java'>//将Collection中的元素转换成一个String，用逗号分隔：
String joined = elements.stream()
    .map(Object::toString)
    .collect(Collectors.joining(", "));
//计算合计
int total = employees.stream()
    .collect(Collectors.summingInt(Employee::getSalary)));</code></pre>


<h4>2.1.2 for-each</h4>

<pre class='line-numbers language-java'><code class='language-java'>for (Object o : collection)
    System.out.println(o);</code></pre>


<h4>2.1.3 Iterator</h4>

<pre class='line-numbers language-java'><code class='language-java'>public interface Iterator&lt;E&gt; {
    boolean hasNext();
    E next();
    void remove(); //optional
}</code></pre>


<p>注意remove方法删除最后一次next()方法返回的对象。因此，每调用一次remove方法之前都必须调用next方法，否则会抛出异常。remove方法也是迭代过程中唯一安全的修改Collection的方法。以下场景需要使用Iterator而不是for-each:</p>

<ul>
<li>删除当前元素</li>
<li>并行遍历多个Collection</li>
</ul>


<p>下面的代码演示了如何使用Iterator过滤Collection:</p>

<pre class='line-numbers language-java'><code class='language-java'>static void filter(Collection&lt;?&gt; c) {
    for (Iterator&lt;?&gt; it = c.iterator(); it.hasNext(); )
        if (!cond(it.next()))
            it.remove();
}</code></pre>


<h3>2.2 Collection批量操作</h3>

<p>Collection批量操作的方法大部分返回值都是boolean，如果Collection有变化则返回true:</p>

<ul>
<li><code>boolean containsAll(Collection&lt;?&gt; c)</code></li>
<li><code>boolean addAll(Collection&lt;? extends E&gt; c)</code></li>
<li><code>boolean removeAll(Collection&lt;?&gt; c)</code></li>
<li><code>boolean retainAll(Collection&lt;?&gt; c)</code>（取交集）</li>
<li><code>void clear()</code>.</li>
</ul>


<p>Collections.singleton(T o)用于创建包含一个元素“o”的Set，类似的方法还包括：<code>List&lt;T&gt; singletonList(T o)</code>， <code>&lt;K,V&gt; Map&lt;K,V&gt; singletonMap(K key, V value)</code>。示例：</p>

<pre class='line-numbers language-java'><code class='language-java'>//移除某个元素的所有实例
c.removeAll(Collections.singleton(e));
//移除所有null
c.removeAll(Collections.singleton(null));</code></pre>


<h3>2.3 Collections工具类</h3>

<p>除了singleton方法，Collections工具类还有一些常用的方法，如：</p>

<ul>
<li><code>unmodifiableXXX()</code>返回一个只读视图。(xxx可能是Collection, List, Map, Set, SortedMap, SortedSet)</li>
<li><code>synchronizedXXX()</code>返回一个同步（线程安全）的Collection。</li>
<li><code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>方法</li>
<li><code>shuffle</code>方法（打乱顺序）</li>
<li><code>min/max</code> 可传Comparator</li>
<li><code>copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</code> 复制所有元素到另一个List。dest的数量必须大于等于src，操作完成后，src中的所有元素会覆盖dest中相应位置（index）的元素。</li>
<li><code>int frequency(Collection&lt;?&gt; c,Object o)</code> 返回c中o出现的次数。</li>
<li><code>fill(List&lt;? super T&gt; list, T obj)</code> 将所有元素替换成obj。</li>
</ul>


<h3>2.4 Array操作</h3>

<p>Collection提供了toArray()方法，用于转换成数组。示例：</p>

<pre class='line-numbers language-java'><code class='language-java'>Object[] a = c.toArray();</code></pre>


<p>如果已知Collection中的元素是字符串类型，如Collection<String> c，则可以直接转换成字符串数组：</p>

<pre class='line-numbers language-java'><code class='language-java'>String[] a = c.toArray(new String[0]);  //0没有意义，只是和new String一起表示是字符串数组。</code></pre>


<h2>3. Set</h2>

<p>Set是一种不能包含重复元素的Collection。Set接口只继承了Collection接口的方法，并增加了禁止重复元素的限制，它依赖于equals和hashCode方法的行为。Set包括三种类型：</p>

<ul>
<li>HashSet 元素保存在hash表中，高性能，但无法保证迭代顺序。</li>
<li>TreeSet 元素保存在红黑树中，有序，但比HashSet慢不少。</li>
<li>LinkedHashSet hash表加linked list实现，顺序为插入顺序。避免HashSet顺序的不确定性，同时性能接近HashSet。</li>
</ul>


<p>对于HashSet，需要注意的是遍历性能与entry数量和bucket数量(容量)之和成线性关系。如果初始容量太大，则浪费空间和时间；反过来，如果初始容量太小则浪费增容时的复制时间。如果不指定初始容量，默认值为16. 过去通过指定一个初始容量能提高性能，但现在已经没必要了。LinkedHashSet的迭代时间与容量没有关系。</p>

<p>除了上面三种标准Set实现，还有两个特殊的Set实现：EnumSet和CopyOnWriteArraySet.</p>

<p>EnumSet是用于枚举类型的高性能Set实现。所有元素必须是同一种枚举类型。内部采用bit-vector实现，通常是一个long。它支持在指定范围内遍历，也可以替代传统的标志位。示例如下：</p>

<pre class='line-numbers language-java'><code class='language-java'>for (Day d : EnumSet.range(Day.MONDAY, Day.FRIDAY))
    System.out.println(d);
        
EnumSet.of(Style.BOLD, Style.ITALIC)</code></pre>


<p>CopyOnWriteArraySet是由copy-on-write数组实现的Set. 所有修改操作，如add, set, remove都会复制一个新的数组拷贝，因此不需要锁。只适合于很少修改、但频繁遍历的Set。</p>

<p>HashSet、TreeSet和LinkedHashSet的实现并不是同步的。因此如果多个线程同时访问一个Set，且有线程会修改Set，就必须进行同步处理，或者使用Collections.synchronizedSet方法对其封装。最好在创建时就完成此操作，以HashSet为例：</p>

<pre class='line-numbers language-java'><code class='language-java'>Set s = Collections.synchronizedSet(new HashSet(...));</code></pre>


<h3>3.1 基本操作</h3>

<p>假设你有一个Collection c，下面的代码可以让你方便地去除重复：</p>

<pre class='line-numbers language-java'><code class='language-java'>Collection&lt;Type&gt; noDups = new HashSet&lt;Type&gt;(c);
//如果要保持原来的顺序，可以：
Collection&lt;Type&gt; noDups = new LinkedHashSet&lt;Type&gt;(c);

//如果是JDK8，你还可以这么玩：
c.stream().collect(Collectors.toSet()); // no duplicates
//另一个例子，将姓名放到一个TreeSet中
Set&lt;String&gt; set = people.stream()
.map(Person::getName)
.collect(Collectors.toCollection(TreeSet::new));</code></pre>


<table>
<thead>
<tr>
<th>方法 </th>
<th> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>int size() </td>
<td> 返回元素数量</td>
</tr>
<tr>
<td>boolean isEmpty() </td>
<td> 是否为空</td>
</tr>
<tr>
<td>boolean add() </td>
<td> 增加元素，如果之前不存在，返回true</td>
</tr>
<tr>
<td>boolean remove() </td>
<td> 删除元素，如果之前存在此元素，返回true</td>
</tr>
<tr>
<td><code>Iterator&lt;E&gt; iterator()</code> </td>
<td> 迭代器</td>
</tr>
</tbody>
</table>


<p>JDK8聚合操作与for-each操作示例：</p>

<pre class='line-numbers language-java'><code class='language-java'>//JDK8
public class FindDups {
    public static void main(String[] args) {
        Set&lt;String&gt; distinctWords = Arrays.asList(args).stream()
            .collect(Collectors.toSet()); 
        System.out.println(distinctWords.size()+ 
              " distinct words: " + distinctWords);
    }
}
//for-each
public class FindDups {
    public static void main(String[] args) {
        Set&lt;String&gt; s = new HashSet&lt;String&gt;();
        for (String a : args)
           s.add(a);
        System.out.println(s.size() + " distinct words: " + s);
    }
}
//运行
java FindDups i came i saw i left
//结果：
4 distinct words: [left, came, saw, i]</code></pre>


<p>上面的代码使用的是HashSet，所以顺序是乱的。如果你改成TreeSet/LinkedHashSet，则结果变为：</p>

<pre class='line-numbers language-java'><code class='language-java'>//TreeSet
4 distinct words: [came, i, left, saw]
//LinkedHashSet
4 distinct words: [i, came, saw, left]</code></pre>


<h3>3.2 批量操作</h3>

<p>Set的批量操作并没有什么特殊的方法，但是利用Set元素不会重复这个特性，可以做一些有意思的事情。例如修改FindDups，找到不重复的单词和重复的单词：</p>

<pre class='line-numbers language-java'><code class='language-java'>public class FindDups2 {
    public static void main(String[] args) {
        Set&lt;String&gt; uniques = new HashSet&lt;String&gt;();
        Set&lt;String&gt; dups    = new HashSet&lt;String&gt;();

        for (String a : args)
            if (!uniques.add(a))
                dups.add(a);

        // Destructive set-difference
        uniques.removeAll(dups);

        System.out.println("Unique words:    " + uniques);
        System.out.println("Duplicate words: " + dups);
    }
}

//output:
Unique words:    [left, saw, came]
Duplicate words: [i]</code></pre>


<h3>3.3 HashSet</h3>

<p>HashSet通过hash table（实际上就是一个HashMap实例）实现。允许null元素。基本方法（如add, remove, contains, size）为常量时间，而遍历性能则与元素数量加桶数量之和成正比。因此，如果迭代性能要求高的话，不要将初始容量设置得太大。</p>

<h3>3.4 TreeSet</h3>

<p>TreeSet是基于TreeMap的NavigableSet实现。元素按natural ordering或Comparator排序。注意要正确地实现Set接口，就应该让Comparable与equals接口实现保持一致。因为Set不重复由equals决定，而顺序由Comparable决定。TreeSet提供降序或升序视图，但升序一般比降序性能更优。</p>

<p>TreeSet允许null元素，但一些方法的返回值也可能是null（不存在时），这样就会造成混乱。因此建议不要加入null元素。基本操作（add, remove, contains）的时间成本为log(n). TreeSet增加了NavigableSet接口的方法，常用方法如下表：</p>

<table>
<thead>
<tr>
<th>方法 </th>
<th> 说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>E ceiling(E e) </td>
<td> 返回大于等于e的最小元素，如果没有返回null</td>
</tr>
<tr>
<td>E higher(E e) </td>
<td> 返回大于e的最小元素，如果没有返回null</td>
</tr>
<tr>
<td>E floor(E e) </td>
<td> 返回小于等于e的最大元素，如果没有返回null</td>
</tr>
<tr>
<td>E lower(E e) </td>
<td> 返回小于e的最大元素，如果没有返回null</td>
</tr>
<tr>
<td><code>Iterator&lt;E&gt;</code> descendingIterator() </td>
<td> 返回降序迭代器。</td>
</tr>
<tr>
<td><code>NavigableSet&lt;E&gt;</code> descendingSet() </td>
<td> 返回降序视图</td>
</tr>
<tr>
<td>E first() </td>
<td> 返回第一个（最小的）元素</td>
</tr>
<tr>
<td>E last() </td>
<td> 返回最后一个（最大的）元素</td>
</tr>
<tr>
<td><code>NavigableSet&lt;E&gt;</code> headSet(E toElement, boolean inclusive) </td>
<td> 返回小于toElement的元素，如果inclusive=true表示返回结果包含toElement。</td>
</tr>
<tr>
<td><code>NavigableSet&lt;E&gt;</code> tailSet(E fromElement, boolean inclusive) </td>
<td> 返回大于（等于，如果inclusive=true）的元素。</td>
</tr>
<tr>
<td>E pollFirst() </td>
<td> Retrieves and removes the first (lowest) element, or returns null if this set is empty.</td>
</tr>
<tr>
<td>E pollLast() </td>
<td> Retrieves and removes the last (highest) element, or returns null if this set is empty.</td>
</tr>
<tr>
<td><code>NavigableSet&lt;E&gt;</code> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) </td>
<td> 取子集。</td>
</tr>
<tr>
<td>Object clone() </td>
<td> 返回TreeSet实例的浅拷贝</td>
</tr>
</tbody>
</table>


<h3>3.5 LinkedHashSet</h3>

<p>LinkedHashSet会保持插入的顺序，但是如果多次添加一个元素，并不会改变元素原来的的位置。允许null元素。</p>

<p>与HashSet一样，有两个参数影响其性能：初始容量和load factor。</p>

<h3>3.6 EnumSet</h3>

<p>EnumSet的所有元素必须是同一个枚举类型的值，不允许null元素。它的效率很高，是替代传统标志位的推荐方案，用long实现。Iterator按自然顺序（枚举中声明的顺序）返回元素。常用方法如下表：</p>

<table>
<thead>
<tr>
<th>方法</th>
<th> 说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt;  allOf(Class&lt;E&gt; elementType)</code> </td>
<td> 创建一个包括枚举类型所有值的EnumSet</td>
</tr>
<tr>
<td><code>EnumSet&lt;E&gt; clone()</code> </td>
<td> 复制一份。</td>
</tr>
<tr>
<td><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; complementOf(EnumSet&lt;E&gt; s)</code> </td>
<td> 创建一个同类型的EnumSet，其中的元素为枚举类型所有值减去s中的值。</td>
</tr>
<tr>
<td><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; copyOf(Collection&lt;E&gt; c)</code> </td>
<td> 创建EnumSet，元素来自c。</td>
</tr>
<tr>
<td><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType)</code> </td>
<td> 创建一个空的EnumSet</td>
</tr>
<tr>
<td><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; of(E e, E... rest)</code> </td>
<td> 创建包括指定元素的EnumSet</td>
</tr>
<tr>
<td><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; range(E from, E to)</code> </td>
<td> 创建指定元素范围的EnumSet</td>
</tr>
</tbody>
</table>


<h3>3.7 CopyOnWriteArraySet</h3>

<p>CopyOnWriteArraySet内部使用CopyOnWriteArrayList来实现所有操作。因此：</p>

<ul>
<li>最适合那些size小，读操作远多于修改操作，在遍历中需要防止其它线程干扰的场景。</li>
<li>它是线程安全的。</li>
<li>修改操作成本较高，因为通常要复制整个数组。</li>
<li>Iterator不支持remove操作。</li>
<li>通过iterator遍历很快，不会受其它线程影响，因为它依赖一个在iterator创建时的数组只读镜像。</li>
</ul>


<p>示例代码：</p>

<pre class='line-numbers language-java'><code class='language-java'>class Handler { void handle(); ... }

class X {
   private final CopyOnWriteArraySet&lt;Handler&gt; handlers
     = new CopyOnWriteArraySet&lt;Handler&gt;();
   public void addHandler(Handler h) { handlers.add(h); }

   private long internalState;
   private synchronized void changeState() { internalState = ...; }

   public void update() {
     changeState();
     for (Handler handler : handlers)
       handler.handle();
   }
}</code></pre>


<h2>4. List接口</h2>

<p>List接口继承自Collection，它比后者增加了以下类型的方法：</p>

<ul>
<li>Positional access 基于位置的访问方法，如get, set, addAll</li>
<li>Search 搜索指定对象并返回数字索引，如indexOf, lastIndexOf</li>
<li>Iteration 继承Iterator，增加增了List的特性。ListIterator。</li>
<li>Rang-View sublist方法提供range相关操作。</li>
</ul>


<p>Java提供两种普通List实现：ArrayList和LinkedList，前者通常有更好的性能，后者在特定场景有更好性能。如果你需要频繁地在List的起始位置插入元素，或者频繁遍历元素并删除，则使用LinkedList更合适。</p>

<p>另一个特殊的实现是CopyOnWriteArrayList，与CopyOnWriteArraySet类似。无需同步操作，不会有ConcurrentModificationException.</p>

<p>Arrays工具类提供了<code>asList()</code>方法，这样可以用List的方式查看数组。但是该操作并不是复制整个数组，对List的修改操作将会影响array，反过来也是如此。因此这个List并不是真正的List，它没有add, remove方法，因为数组不是变长的。如果List是定长的，也没有containsAll之类的bulk操作，可以考虑使用Arrays.asList。</p>

<p>ListIterator提供两个方向迭代的能力，因此多了hasPrevious和previous方法。ListIterator的构造方法有两种格式，默认格式不带参数，表示从头遍历。带int参数的格式表示从指定位置遍历。ListIterator提供了安全的修改方法add, remove和set。它们能够在迭代的过程中安全地修改List的内容。</p>

<ul>
<li>add()方法，在List当前位置插入一个对象。所谓当前位置就是：add方法增加对象后，调用previous()方法将返回这个对象。</li>
<li>remove()方法，将当前元素删除。所谓当前元素就是：如果刚调用了next()或previous()方法，当前元素就是它们返回的元素。注：每调用一次remove()，都需要先调用一次next()或者previous()，如果刚调用了add()，也必须先调用一次next()或者previous()。</li>
<li>set()方法，更新当前元素。当前元素的定义与remove()方法相同。每次set()之前，也必须调用next()或previous()。</li>
</ul>


<p><code>subList(int fromIndex, int toIndex)</code>方法提供了range-view操作。由于subList返回的只是List的一个view，因此对返回结果的修改会影响原List。例如下面的代码删除指定范围内的数据：</p>

<pre class='line-numbers language-java'><code class='language-java'>list.subList(fromIndex, toIndex).clear();</code></pre>


<h3>4.1 LinkedList</h3>

<p>Doubly-linked列表，实现了List和Deque接口。由于是链表结构，因此基于索引的操作将导致从头遍历。常用的方法：</p>

<table>
<thead>
<tr>
<th>方法 </th>
<th> 说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void addFirst(E e)</code> </td>
<td> 在最前面插入</td>
</tr>
<tr>
<td><code>void addLast(E e)</code> </td>
<td> 加到最后面</td>
</tr>
<tr>
<td><code>boolean offer(E e)</code>, <code>boolean offerFirst(E e)</code>, <code>boolean offerLast(E e)</code> </td>
<td> 增加操作。默认是加到最后。如果操作成功返回true</td>
</tr>
<tr>
<td><code>E element()</code> </td>
<td> 获取但不删除第1个元素</td>
</tr>
<tr>
<td><code>E getFirst()/getLast()</code> </td>
<td> 返回第1个/最后一个元素</td>
</tr>
<tr>
<td><code>E peek()</code> </td>
<td> 获取但不移除第一个元素</td>
</tr>
<tr>
<td><code>E peekFirst()/peakLast()</code> </td>
<td> 获取但不移除第一个/最后一个元素，如果list为空则返回null</td>
</tr>
<tr>
<td><code>E poll()</code> </td>
<td> 获取并删除第1个元素, 如果list为空则抛出NoSuchElementException</td>
</tr>
<tr>
<td><code>E pollFirst()/pollLast()</code> </td>
<td> 获取并删除第一个/最后一个元素，如果list为空则返回null, 如果list为空则抛出NoSuchElementException</td>
</tr>
<tr>
<td><code>E pop()</code> </td>
<td> stack pop</td>
</tr>
<tr>
<td><code>void push(E e)</code> </td>
<td> stack push</td>
</tr>
<tr>
<td><code>boolean remove(Object o)</code>, <code>E removeFirst()</code>, <code>boolean removeFirstOccurrence(Object o)</code>, <code>E removeLast()</code>, <code>boolean removeLastOccurrence(Object o)</code> </td>
<td> 与删除相关的操作，如果list为空则抛出NoSuchElementException</td>
</tr>
</tbody>
</table>


<h3>4.2 Stack</h3>

<table>
<thead>
<tr>
<th>方法 </th>
<th> 说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>boolean empty()</code> </td>
<td> Tests if this stack is empty.</td>
</tr>
<tr>
<td><code>E peek()</code> </td>
<td> Looks at the object at the top of this stack without removing it from the stack.</td>
</tr>
<tr>
<td><code>E pop()</code> </td>
<td> Removes the object at the top of this stack and returns that object as the value of this function.</td>
</tr>
<tr>
<td><code>E push(E item)</code> </td>
<td> Pushes an item onto the top of this stack.</td>
</tr>
<tr>
<td>int search(Object o) </td>
<td> Returns the 1-based position where an object is on this stack</td>
</tr>
</tbody>
</table>


<h2>5. Queue接口</h2>

<p>Queue接口增加了以下方法，它们的返回值有两种类型：抛出异常、返回特殊值：</p>

<pre class='line-numbers language-java'><code class='language-java'>public interface Queue&lt;E&gt; extends Collection&lt;E&gt; {
    E element();
    boolean offer(E e);
    E peek();
    E poll();
    E remove();
}</code></pre>


<table>
<thead>
<tr>
<th>操作类型 </th>
<th> 抛出异常 </th>
<th> 返回特殊值</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入操作 </td>
<td> add(e) </td>
<td> offer(e) 成功返回true</td>
</tr>
<tr>
<td>删除操作 </td>
<td> remove() 队列为空时异常 </td>
<td> poll() 队列为空返回null</td>
</tr>
<tr>
<td>检查操作 </td>
<td> element() 队列为空时异常 </td>
<td> peek() 队列为空返回null</td>
</tr>
</tbody>
</table>


<p>队列通常是FIFO的行为，但优先队列的顺序取决于它的值。java.util.concurrent下的一些队列有数量限制（bounded），但java.util下的队列没有数量限制。java.util.concurrent.BlockingQueue 继承自Queue，提供了阻塞的机制。</p>

<h3>5.1 普通队列</h3>

<p>LinkedList实现了Queue接口，提供FIFO队列操作add, poll等等。优先队列PriorityQueue的顺序取决于元素的natural ordering或构造方法的Comparator参数。</p>

<h3>5.2 多线程队列</h3>

<p>java.util.concurrent.BlockingQueue继承自Queue，其实现是线程安全的。所有队列方法使用内部锁或其它多线程控制实现原子操作。但是bulk操作，如addAll, containsAll, retainAll, removeAll并没有实现原子操作。例如<code>addAll(c)</code>执行时，如果另一线程在c中添加了元素则会导致addAll失败。</p>

<p>BlockingQueue不支持null元素。它可能有数量限制，否则最大为Integer.MAX_VALUE。它的方法有四种模式：</p>

<table>
<thead>
<tr>
<th>操作类型 </th>
<th>Throws exception </th>
<th> Special value </th>
<th> Blocks </th>
<th> Times out</th>
</tr>
</thead>
<tbody>
<tr>
<td>Insert</td>
<td>add(e) </td>
<td> offer(e)</td>
<td> put(e) </td>
<td> offer(e, time, unit)</td>
</tr>
<tr>
<td>Remove</td>
<td>remove() </td>
<td> poll() </td>
<td> take() </td>
<td> poll(time, unit)</td>
</tr>
<tr>
<td>Examine</td>
<td>element() </td>
<td> peek() </td>
<td> not applicable </td>
<td> not applicable</td>
</tr>
</tbody>
</table>


<p>JDK提供了以下实现：</p>

<ul>
<li>LinkedBlockingQueue — an optionally bounded FIFO blocking queue backed by linked nodes</li>
<li>ArrayBlockingQueue — a bounded FIFO blocking queue backed by an array</li>
<li>PriorityBlockingQueue — an unbounded blocking priority queue backed by a heap</li>
<li>DelayQueue — a time-based scheduling queue backed by a heap</li>
<li>SynchronousQueue — a simple rendezvous mechanism that uses the BlockingQueue interface</li>
<li>LinkedTransferQueue — an unbounded TransferQueue based on linked nodes</li>
</ul>


<h2>6. Deque接口</h2>

<p>音（deck），支持从两端插入和删除的队列。它同时包含了Queue和Stack接口方法。ArrayDeque和LinkedList实现了Deque接口。Deque支持FIFO和LIFO。</p>

<p>相关的方法参考LinkedList。LinkedBlockingDeque实现了多线程Deque。</p>

<h2>7. Map接口</h2>

<p>Java提供了三种通用的Map实现：HashMap, TreeMap和LinkedHashMap。它们的行为与HashSet, TreeSet和LinkedHashSet相似。如果你想要有序的Map，能够提供有序的keySet，使用TreeMap；如果想要最优性能，使用HashMap。如果既想要高性能，又想保持插入的顺序，使用LinkedHashSet。</p>

<p>JDK8中引入了相关的聚合操作，示例如下：</p>

<pre class='line-numbers language-java'><code class='language-java'>// Group employees by department
Map&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDepartment));

// Compute sum of salaries by department
Map&lt;Department, Integer&gt; totalByDept = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.summingInt(Employee::getSalary)));

// Partition students into passing and failing
Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream()
    .collect(Collectors.partitioningBy(s -&gt; s.getGrade()&gt;= PASS_THRESHOLD)); 

// Classify Person objects by city
Map&lt;String, List&lt;Person&gt;&gt; peopleByCity
    = personStream.collect(Collectors.groupingBy(Person::getCity));

//cascade two collectors to classify people by state 
Map&lt;String, Map&lt;String, List&lt;Person&gt;&gt;&gt; peopleByStateAndCity
    = personStream.collect(Collectors.groupingBy(Person::getState,
  Collectors.groupingBy(Person::getCity)))</code></pre>


<p>Map提供了Collecton view，有三种方法：</p>

<ul>
<li>keySet 所有key的集合</li>
<li>values 所有值。这不是一个Set，因为value会有重复。</li>
<li>entrySet 所有key-value的集合</li>
</ul>


<p>Map的遍历方法有多种：</p>

<pre class='line-numbers language-java'><code class='language-java'>for (KeyType key : m.keySet())
    System.out.println(key);
    
// Filter a map based on some 
// property of its keys.
for (Iterator&lt;Type&gt; it = m.keySet().iterator(); it.hasNext(); )
    if (it.next().isBogus())
        it.remove();
        
for (Map.Entry&lt;KeyType, ValType&gt; e : m.entrySet())
    System.out.println(e.getKey() + ": " + e.getValue());            </code></pre>


<p>不用担心Map创建Collection view的性能。通过Collecton view iterator遍历时，可以调用Iterator的remove方法来删除map中的键值对。利用Map.Entry遍历时也可以调用entry.setValue方法来修改值。Collection view支持remove, removeAll, retainAll, clear, Iterator.remove操作。例如，以下命令会清空所有数据：</p>

<pre class='line-numbers language-java'><code class='language-java'>Set&lt;Integer&gt; set = map.keySet();
set.clear();</code></pre>


<p></p>

<p>Map的Collection view在很多场合能起到便利作用。以下是一些示例：</p>

<pre class='line-numbers language-java'><code class='language-java'>//判断一个Map的key是否包含另一个Map的key
if (m1.entrySet().containsAll(m2.entrySet())) {
    ...
}

//判断两个Map的key是否相同
if (m1.keySet().equals(m2.keySet())) {
    ...
}

//判断两个Map的key交集（注意新建了一个set，避免对Map产生影响）
Set&lt;KeyType&gt;commonKeys = new HashSet&lt;KeyType&gt;(m1.keySet());
commonKeys.retainAll(m2.keySet());</code></pre>


<h3>7.1 LinkedHashMap</h3>

<p>LinkedHashMap的顺序通常是插入顺序，同一元素多次重复插入并不会修改它的位置。</p>

<p>LinkedHashMap还提供了一个特殊的构造方法，它创建的LinkedHashMap顺序是entry被访问的顺序。元素的访问时间越近，则它越靠前。因此这种LinkedHashMap非常适合做LRU(least recently used)缓存。构造方法如下：</p>

<pre class='line-numbers language-java'><code class='language-java'>public LinkedHashMap(int initialCapacity,
                     float loadFactor,
                     boolean accessOrder)</code></pre>


<p>影响这种LinkedHashMap元素顺序的访问方法包括：put, putInfoAbsent, get, getOrDefault, compute, computeIfAbsent, computeIfPresent, merge, replace(如果之前存在，替换动作成功)和putAll方法。其中putAll方法会对指定map中的所有元素都产生一次访问，访问的顺序取决于指定map的entryset iterator。除了以上方法外，其他方法都不会影响元素顺序，特别是作用于Collection view的方法也不会对元素顺序产生影响。</p>

<p>覆盖removeEldestEntry(Map.Entry)方法可以在Map移除旧Entry时自定义一些策略。</p>

<p>LinkedHashMap性能接近于HashMap，在遍历时性能比HashMap更优。因为LinkedHashMap的迭代性能只与size相关，而HashMap还与容量相关。</p>

<h3>7.2 其它Map实现类</h3>

<p>除了HashMap, TreeMap和LinkedHashMap, 还有一些其它的Map实现：</p>

<ul>
<li>EnumMap与EnumSet类似。</li>
<li>WeakHashMap 弱引用，便于垃圾收集</li>
<li>IdentityHashMap 在此Map中，当且仅当k1==k2时，认为两个key是相等的。（HashMap判断相等使用的是equals）很少用。</li>
<li>ConcurrentHashMap 高并发、高性能的Map。线程安全。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis学习笔记]]></title>
    <link href="http://blog.ubone.com/blog/2015/03/08/redisxue-xi-bi-ji/"/>
    <updated>2015-03-08T11:37:07+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/03/08/redisxue-xi-bi-ji</id>
    <content type="html"><![CDATA[<p>Redis是一个高性能的key-value数据库，完全开源免费，遵守BSD协议。它的主要优势：</p>

<ul>
<li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li>
<li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>
<li>原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li>
<li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li>
</ul>


<!--more-->


<h2>1. 简介</h2>

<p>Redis是Remote DIctionary Server（远程字典服务器）的缩写，它以字典结构存储数据，并允许其他应用通过TCP协议读写字典中的内容。到目前为止Redis支持的键值数据类型如下：</p>

<ul>
<li>字符串类型</li>
<li>散列类型</li>
<li>列表类型</li>
<li>集合类型</li>
<li>有序集合类型</li>
</ul>


<p>Redis数据库中的所有数据都存储在内存中。由于内存的读写速度远快于硬盘，因此Redis在性能上对比其他基于硬盘存储的数据库有非常明显的优势，不过 Redis提供了对持久化的支持，即将可以内存中的数据异步写入到硬盘中，同时不影响继续提供服务。</p>

<p>Redis可以为每个键设置生存时间（Time To Live，TTL），生存时间到期后键会自动被删除。</p>

<p>关于Redis和Memcached优劣的讨论一直是一个热门的话题。在性能上Redis是单线程模型，而Memcached支持多线程，所以在多核服务器上后者的性能更高一些。然而，前面已经介绍过，Redis的性能已经足够优异，在绝大部分场合下其性能都不会成为瓶颈。所以在使用时更应该关心的是二者在功能上的区别，如果需要用到高级的数据类型或是持久化等功能，Redis将会是Memcached很好的替代品。</p>

<p>作为缓存系统，Redis还可以限定数据占用的最大内存空间，在数据达到空间限制后可以按照一定的规则自动淘汰不需要的键。除此之外，Redis的列表类型键可以用来实现队列，并且支持阻塞式读取，可以很容易地实现一个高性能的优先级队列。同时在更高层面上，Redis还支持“发布/订阅”的消息模式，可以基于此构建聊天室等系统。</p>

<p>Redis提供了几十种不同编程语言的客户端库，这些库都很好地封装了Redis的命令，使得在程序中与Redis进行交互变得更容易。</p>

<h2>2. 初识Redis</h2>

<h3>2.1 安装</h3>

<p>在OS X系统中安装 OS X下的软件包管理工具Homebrew和MacPorts均提供了较新版本的Redis包，所以我们可以直接使用它们来安装Redis，省去了像其他POSIX系统那样需要手动编译的麻烦。下面以使用Homwbrew安装Redis为例。</p>

<h4>安装Homebrew</h4>

<p>通过终端安装：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</code></pre>


<p>如果之前安装过Homebrew，请执行brew update来更新Homebrew，以便安装较新版的Redis。</p>

<h4>通过Homebrew安装Redis</h4>

<p>使用brew install软件包名可以安装相应的包，此处执行:<code>brew install redis</code></p>

<p>OSX 系统从Tiger版本开始引入了launchd工具来管理后台程序，如果想让Redis随系统自动运行可以通过以下命令配置launchd：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>ln -sfv/usr/local/opt/redis/＊.plist ～/Library/LaunchAgents 
launchctl load ～/Library/LaunchAgents/homebrew.mxcl.redis.plist</code></pre>


<p>通过launchd运行的Redis会加载位于/usr/local/etc/redis.conf的配置文件。</p>

<h3>2.2 运行</h3>

<p>Redis提供的可执行文件：</p>

<table>
<thead>
<tr>
<th>文件名 </th>
<th> 说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>redis-server </td>
<td> Redis服务器</td>
</tr>
<tr>
<td>redis-cli </td>
<td> Redis命令行客户端</td>
</tr>
<tr>
<td>redis-benchmark </td>
<td> Redis性能测试工具</td>
</tr>
<tr>
<td>redis-check-aof </td>
<td> AOF文件修复工具</td>
</tr>
<tr>
<td>redis-check-dump </td>
<td> RDB文件检查工具</td>
</tr>
</tbody>
</table>


<p>我们最常使用的两个程序是redis-server和redis-cli，其中redis-server是Redis的服务器，启动Redis即运行redis-server；而redis-cli是Redis自带的Redis命令行客户端，是学习Redis的重要工具。</p>

<h4>启动</h4>

<p>启动Redis有直接启动和通过初始化脚本启动两种方式，分别适用于开发环境和生产环境。 以直接启动为例，执行命令：<code>$ redis-server</code>，或者加上参数，如修改默认端口6379为6380：<code>$ redis-server --port 6380</code>。</p>

<h4>执行客户端命令</h4>

<p>通过redis-cli向Redis发送命令有两种方式，一是执行<code>redis-cli 参数</code>，二是执行不带参数的redis-cli进入交互模式。交互模式示例如下：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>$ redis-cli
127.0.0.1:6379&gt; ping
PONG
127.0.0.1:6379&gt; keys *
(empty list or set)
127.0.0.1:6379&gt; echo hello
"hello"</code></pre>


<h4>停止</h4>

<p>考虑到Redis有可能正在将内存中的数据同步到硬盘中，强行终止Redis进程可能会导致数据丢失。正确停止Redis的方式应该是向Redis发送SHUTDOWN命令，方法为： <code>$ redis-cli SHUTDOWN</code></p>

<p>Redis可以妥善处理SIGTERM信号，所以使用“kill Redis进程的PID”也可以正常结束Redis，效果与发送SHUTDOWN命令一样。</p>

<h4>配置</h4>

<p>Redis支持通过配置文件来设置这些选项。启用配置文件的方法是在启动时将配置文件的路径作为启动参数传递给redis-server，如： <code>redis-server /path/to/redis.conf</code>。通过启动参数传递同名的配置选项会覆盖配置文件中相应的参数，就像这样： <code>redis-server /path/to/redis.conf --loglevel warning</code>。</p>

<p>Redis运行时通过CONFIG SET 命令在不重新启动Redis的情况下动态修改部分Redis配置。就像这样： <code>redis&gt;CONFIG SET loglevel warning</code>。</p>

<h4>多数据库</h4>

<p>一个Redis实例提供了多个用来存储数据的字典，客户端可以指定将数据存储在哪个字典中。每个数据库对外都是以一个从0开始的递增数字命名，Redis默认支持16个数据库，可以通过配置参数databases来修改这一数字。客户端与Redis建立连接后会自动选择0号数据库，不过可以随时使用SELECT命令更换数据库。但Redis不支持每个数据库自定义名字，所以都以编号命名。同时也不支持每个数据库设置不同的密码。</p>

<p>多个数据库之间并不是完全隔离的，比如FLUSHALL命令可以清空一个Redis实例中所有数据库中的数据。因此，这些数据库更像是一种命名空间，而不适宜存储不同应用程序的数据。</p>

<h3>2.3 Redis基础命令</h3>

<p>所有Redis命令都是原子操作，我们先来了解几个比较基础的命令作为热身，打开redis-cli，跟着样例亲自输入命令来体验一下吧！ （Redis命令不区分大小写。）</p>

<h4>2.3.1．获得符合规则的键名列表 KEYS pattern</h4>

<p>pattern支持glob风格通配符格式，具体规则如下表所示。</p>

<table>
<thead>
<tr>
<th>符号 </th>
<th> 含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>?</code> </td>
<td> 匹配一个字符</td>
</tr>
<tr>
<td><code>*</code> </td>
<td> 匹配任意个（包括0个）字符</td>
</tr>
<tr>
<td><code>[]</code> </td>
<td> 匹配括号间的任一字符，可以使用“-”表示一个范围，如a[b-d]可以匹配&#8221;ab&#8221;, &ldquo;ac&#8221;和&#8221;ad&#8221;等</td>
</tr>
<tr>
<td><code>\x</code> </td>
<td> 匹配字符x， 用于转义，如要匹配&#8221;?&ldquo;就需要使用<code>\?</code></td>
</tr>
</tbody>
</table>


<pre  class='line-numbers language-bash'><code class='language-bash'>127.0.0.1:6379&gt; keys *
(empty list or set)</code></pre>


<h4>2.3.2 SET</h4>

<p>建立一个名为bar的键：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>127.0.0.1:6379&gt; set bar 1
OK
127.0.0.1:6379&gt; keys *
1) "bar"
127.0.0.1:6379&gt; keys b??
1) "bar"
127.0.0.1:6379&gt; keys b?
(empty list or set)</code></pre>


<h4>2.3.3 EXISTS key</h4>

<p>判断一个键是否存在 EXISTS key:</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>127.0.0.1:6379&gt; exists bar
(integer) 1</code></pre>


<h4>2.3.4．删除键 DEL key [key …]</h4>

<pre  class='line-numbers language-bash'><code class='language-bash'>127.0.0.1:6379&gt; del bar
(integer) 1
127.0.0.1:6379&gt; del bar
(integer) 0</code></pre>


<p>批量删除时可以使用linux管道和xargs命令，例如要删除以“user:”开头的键:</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>redis-cli KEYS "user:*" | xargs redis-cli DEL</code></pre>


<h4>2.3.5．获得键值的数据类型 TYPE key</h4>

<pre  class='line-numbers language-bash'><code class='language-bash'>127.0.0.1:6379&gt; type user:1
string</code></pre>


<p>返回类型可能是：string, hash(散列类型), list, set, zset(有序集合)。</p>

<h2>3. 数据类型</h2>

<p>Redis支持的数据类型包括：字符串类型、散列类型、列表类型、集合类型和有序集合类型。</p>

<p>Redis对于键的命名并没有强制的要求，但比较好的实践是用“对象类型:对象ID:对象属性”来命名一个键，如使用键user:1:friends来存储ID为1的用户的好友列表。对于多个单词则推荐使用“.”分隔。</p>

<h3>3.1 字符串类型</h3>

<p>字符串类型是Redis中最基本的数据类型，它能存储任何形式的字符串，包括二进制数据。你可以用其存储用户的邮箱、JSON化的对象甚至是一张图片。一个字符串类型键允许存储的数据的最大容量是512MB(Redis 2.x)。</p>

<p>字符串类型是其他4种数据类型的基础，其他数据类型和它的区别从某种角度说只是组织字符串的形式不同。</p>

<table>
<thead>
<tr>
<th>命令 </th>
<th> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SET key value </td>
<td> 设置指定 key 的值</td>
</tr>
<tr>
<td>GET key </td>
<td> 获取指定 key 的值。</td>
</tr>
<tr>
<td>GETRANGE key start end </td>
<td> 返回 key 中字符串值的子字符</td>
</tr>
<tr>
<td>GETSET key value </td>
<td> 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td>
</tr>
<tr>
<td>GETBIT key offset </td>
<td> 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</td>
</tr>
<tr>
<td><code>MGET key1 [key2..]</code> </td>
<td> 获取所有(一个或多个)给定 key 的值。</td>
</tr>
<tr>
<td>SETBIT key offset value </td>
<td> 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</td>
</tr>
<tr>
<td>SETEX key seconds value </td>
<td> 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</td>
</tr>
<tr>
<td>SETNX key value </td>
<td> 只有在 key 不存在时设置 key 的值。</td>
</tr>
<tr>
<td>SETRANGE key offset value </td>
<td> 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</td>
</tr>
<tr>
<td>STRLEN key </td>
<td> 返回 key 所储存的字符串值的长度。如果键不存在则返回0。例如： <code>redis＞STRLEN key (integer)12 redis＞SET key 你好 OK redis＞STRLEN key (integer)6</code> 前面提到了字符串类型可以存储二进制数据，所以它可以存储任何编码的字符串。例子中Redis接收到的是使用UTF-8编码的中文，由于“你”和“好”两个字的UTF-8编码的长度都是3，所以此例中会返回6。</td>
</tr>
<tr>
<td><code>MSET key value [key value ...]</code> </td>
<td> 同时设置一个或多个 key-value 对。</td>
</tr>
<tr>
<td><code>MSETNX key value [key value ...]</code> </td>
<td> 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</td>
</tr>
<tr>
<td><code>PSETEX key milliseconds value</code> </td>
<td> 这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</td>
</tr>
<tr>
<td>INCR key </td>
<td> 将 key 中储存的数字值增一。在Redis中实现自增长ID可以通过另一种模式来实现：对于每一类对象使用名为对象类型(复数形式):count的键（如users:count）来存储当前类型对象的数量，每增加一个新对象时都使用INCR命令递增该键的值。由于使用INCR命令建立的键的初始键值是1，所以可以很容易得知，INCR命令的返回值既是加入该对象后的当前类型的对象总数，又是该新增对象的ID。</td>
</tr>
<tr>
<td>INCRBY key increment </td>
<td> 将 key 所储存的值加上给定的增量值（increment） 。</td>
</tr>
<tr>
<td>INCRBYFLOAT key increment </td>
<td> 将 key 所储存的值加上给定的浮点增量值（increment） 。</td>
</tr>
<tr>
<td>DECR key </td>
<td> 将 key 中储存的数字值减一。</td>
</tr>
<tr>
<td>DECRBY key decrement </td>
<td> key 所储存的值减去给定的减量值（decrement） 。</td>
</tr>
<tr>
<td>APPEND key value </td>
<td> 如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。</td>
</tr>
</tbody>
</table>


<h3>3.2 散列类型（HASH）</h3>

<p>我们现在已经知道Redis是采用字典结构以键值对的形式存储数据的，而散列类型（hash）的键值也是一种字典结构，其存储了字段（field）和字段值的映射，但字段值只能是字符串，不支持其他数据类型，换句话说，散列类型不能嵌套其他的数据类型。一个散列类型键可以包含至多2<sup>32</sup>-1个字段。(除了散列类型，Redis的其他数据类型同样不支持数据类型嵌套)。</p>

<p>散列类型适合存储对象：使用对象类别和ID构成键名，使用字段表示对象的属性，而字段值则存储属性值。例如要存储ID为2的汽车对象，可以分别使用名为color、name和price的3个字段来存储该辆汽车的颜色、名称和价格。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_-2015-03-08-14.26.49.png" alt="image" /></p>

<pre  class='line-numbers language-bash'><code class='language-bash'>redis&gt; HSET car:2 color white
(integer) 1
redis&gt; HSET car:2 name BMW
(integer) 1
redis&gt; HGET car:2 name
"BMW"
redis&gt; HGETALL car:2
1) "color"
2) "white"
3) "name"
4) "BMW"</code></pre>


<table>
<thead>
<tr>
<th>命令 </th>
<th> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>HDEL key field2 [field2]</code> </td>
<td> 删除一个或多个哈希表字段 </td>
</tr>
<tr>
<td>HEXISTS key field </td>
<td> 查看哈希表 key 中，指定的字段是否存在。</td>
</tr>
<tr>
<td>HGET key field </td>
<td> 获取存储在哈希表中指定字段的值</td>
</tr>
<tr>
<td>HGETALL key </td>
<td> 获取在哈希表中指定 key 的所有字段和值</td>
</tr>
<tr>
<td>HINCRBY key field increment </td>
<td> 为哈希表 key 中的指定字段的整数值加上增量 increment 。</td>
</tr>
<tr>
<td>HINCRBYFLOAT key field increment </td>
<td> 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。</td>
</tr>
<tr>
<td>HKEYS key </td>
<td> 获取所有哈希表中的字段</td>
</tr>
<tr>
<td>HLEN key </td>
<td> 获取哈希表中字段的数量</td>
</tr>
<tr>
<td><code>HMGET key field1 [field2]</code> </td>
<td> 获取所有给定字段的值</td>
</tr>
<tr>
<td><code>HMSET key field1 value1 [field2 value2 ]</code> </td>
<td> 同时将多个 field-value (域-值)对设置到哈希表 key 中。</td>
</tr>
<tr>
<td><code>HSET key field value</code> </td>
<td> 将哈希表 key 中的字段 field 的值设为 value 。</td>
</tr>
<tr>
<td><code>HSETNX key field value</code> </td>
<td> 只有在字段 field 不存在时，设置哈希表字段的值。</td>
</tr>
<tr>
<td>HVALS key </td>
<td> 获取哈希表中所有值</td>
</tr>
<tr>
<td><code>HSCAN key cursor [MATCH pattern] [COUNT count]</code> </td>
<td> 迭代哈希表中的键值对。</td>
</tr>
</tbody>
</table>


<h3>3.3 列表类型</h3>

<p>列表类型（list）可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，或者获得列表的某一个片段。 列表类型内部是使用双向链表（double linked list）实现的，所以向列表两端添加元素的时间复杂度为0(1)，获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的（和从只有20个元素的列表中获取头部或尾部的10条记录的速度是一样的）。不过使用链表的代价是通过索引访问元素比较慢。</p>

<p>列表类型能非常快速地完成关系数据库难以应付的场景：如社交网站的新鲜事，我们关心的只是最新的内容，使用列表类型存储，即使新鲜事的总数达到几千万个，获取其中最新的100条数据也是极快的。同样因为在两端插入记录的时间复杂度是0(1)，列表类型也适合用来记录日志，可以保证加入新日志的速度不会受到已有日志数量的影响。借助列表类型，Redis还可以作为队列使用。与散列类型键最多能容纳的字段数量相同，一个列表类型键最多能容纳2<sup>32</sup>-1个元素。</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>redis 127.0.0.1:6379&gt; LPUSH w3ckey redis
(integer) 1
redis 127.0.0.1:6379&gt; LPUSH w3ckey mongodb
(integer) 2
redis 127.0.0.1:6379&gt; LPUSH w3ckey mysql
(integer) 3
redis 127.0.0.1:6379&gt; LRANGE w3ckey 0 10
1) "mysql"
2) "mongodb"
3) "redis"</code></pre>


<table>
<thead>
<tr>
<th>命令 </th>
<th> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>BLPOP key1 [key2 ] timeout </td>
<td> 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>BRPOP key1 [key2 ] timeout </td>
<td> 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>BRPOPLPUSH source destination timeout </td>
<td> 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>LINDEX key index </td>
<td> 通过索引获取列表中的元素</td>
</tr>
<tr>
<td>LINSERT key BEFORE or AFTER pivot value </td>
<td> 在列表的元素前或者后插入元素</td>
</tr>
<tr>
<td>LLEN key </td>
<td> 获取列表长度</td>
</tr>
<tr>
<td>LPOP key </td>
<td> 移出并获取列表的第一个元素</td>
</tr>
<tr>
<td>LPUSH key value1 [value2] </td>
<td> 将一个或多个值插入到列表头部</td>
</tr>
<tr>
<td>LPUSHX key value </td>
<td> 将一个或多个值插入到已存在的列表头部</td>
</tr>
<tr>
<td>LRANGE key start stop </td>
<td> 获取列表指定范围内的元素</td>
</tr>
<tr>
<td>LREM key count value </td>
<td> 移除列表元素</td>
</tr>
<tr>
<td>LSET key index value </td>
<td> 通过索引设置列表元素的值</td>
</tr>
<tr>
<td>LTRIM key start stop </td>
<td> 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td>
</tr>
<tr>
<td>RPOP key </td>
<td> 移除并获取列表最后一个元素</td>
</tr>
<tr>
<td>RPOPLPUSH source destination </td>
<td> 移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td>
</tr>
<tr>
<td>RPUSH key value1 [value2] </td>
<td> 在列表中添加一个或多个值</td>
</tr>
<tr>
<td>RPUSHX key value </td>
<td> 为已存在的列表添加值</td>
</tr>
</tbody>
</table>


<h3>3.4 集合</h3>

<p>集合的概念高中的数学课就学习过。在集合中的每个元素都是不同的，且没有顺序。例如博客的标签就很适合使用集合，一个标签（如Java）包括多篇文章，这些文章就组成一个集合。一个集合类型（set）键可以存储至多2<sup>32</sup>-1个字符串。Redis中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>redis 127.0.0.1:6379&gt; SADD w3ckey redis
(integer) 1
redis 127.0.0.1:6379&gt; SADD w3ckey mongodb
(integer) 1
redis 127.0.0.1:6379&gt; SADD w3ckey mysql
(integer) 1
redis 127.0.0.1:6379&gt; SADD w3ckey mysql
(integer) 0
redis 127.0.0.1:6379&gt; SMEMBERS w3ckey
1) "mysql"
2) "mongodb"
3) "redis"</code></pre>


<table>
<thead>
<tr>
<th>命令 </th>
<th> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SADD key member1 [member2] </td>
<td> 向集合添加一个或多个成员</td>
</tr>
<tr>
<td>SCARD key </td>
<td> 获取集合的成员数</td>
</tr>
<tr>
<td>SDIFF key1 [key2] </td>
<td> 返回给定所有集合的差集</td>
</tr>
<tr>
<td>SDIFFSTORE destination key1 [key2] </td>
<td> 返回给定所有集合的差集并存储在 destination 中</td>
</tr>
<tr>
<td>SINTER key1 [key2] </td>
<td> 返回给定所有集合的交集</td>
</tr>
<tr>
<td>SINTERSTORE destination key1 [key2] </td>
<td> 返回给定所有集合的交集并存储在 destination 中</td>
</tr>
<tr>
<td>SISMEMBER key member </td>
<td> 判断 member 元素是否是集合 key 的成员</td>
</tr>
<tr>
<td>SMEMBERS key </td>
<td> 返回集合中的所有成员</td>
</tr>
<tr>
<td>SMOVE source destination member </td>
<td> 将 member 元素从 source 集合移动到 destination 集合</td>
</tr>
<tr>
<td>SPOP key </td>
<td> 移除并返回集合中的一个随机元素</td>
</tr>
<tr>
<td>SRANDMEMBER key [count] </td>
<td> 返回集合中一个或多个随机数</td>
</tr>
<tr>
<td>SREM key member1 [member2] </td>
<td> 移除集合中一个或多个成员</td>
</tr>
<tr>
<td>SUNION key1 [key2] </td>
<td> 返回所有给定集合的并集</td>
</tr>
<tr>
<td>SUNIONSTORE destination key1 [key2] </td>
<td> 所有给定集合的并集存储在 destination 集合中</td>
</tr>
<tr>
<td>SSCAN key cursor [MATCH pattern] [COUNT count] </td>
<td> 迭代集合中的元素</td>
</tr>
</tbody>
</table>


<h3>3.5 有序集合</h3>

<p>有序集合类型（sorted set）的特点从它的名字中就可以猜到，它与上一节介绍的集合类型的区别就是“有序”二字。 在集合类型的基础上有序集合类型为集合中的每个元素都关联了一个分数，这使得我们不仅可以完成插入、删除和判断元素是否存在等集合类型支持的操作，还能够获得分数最高（或最低）的前N个元素、获得指定分数范围内的元素等与分数有关的操作。虽然集合中每个元素都是不同的，但是它们的分数却可以相同。 集合中最大的成员数为 2<sup>32</sup> &ndash; 1。</p>

<p>有序集合类型是使用散列表和跳跃表（Skip list）实现的，所以即使读取位于中间部分的数据速度也很快（时间复杂度是O(log(N))</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>redis 127.0.0.1:6379&gt; ZADD w3ckey 1 redis
(integer) 1
redis 127.0.0.1:6379&gt; ZADD w3ckey 2 mongodb
(integer) 1
redis 127.0.0.1:6379&gt; ZADD w3ckey 3 mysql
(integer) 1
redis 127.0.0.1:6379&gt; ZADD w3ckey 3 mysql
(integer) 0
redis 127.0.0.1:6379&gt; ZADD w3ckey 4 mysql
(integer) 0
redis 127.0.0.1:6379&gt; ZRANGE w3ckey 0 10 WITHSCORES
1) "redis"
2) "1"
3) "mongodb"
4) "2"
5) "mysql"
6) "4"</code></pre>


<table>
<thead>
<tr>
<th>命令 </th>
<th> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZADD key score1 member1 [score2 member2] </td>
<td> 向有序集合添加一个或多个成员，或者更新已存在成员的分数</td>
</tr>
<tr>
<td>ZCARD key </td>
<td> 获取有序集合的成员数</td>
</tr>
<tr>
<td>ZCOUNT key min max </td>
<td> 计算在有序集合中指定区间分数的成员数</td>
</tr>
<tr>
<td>ZINCRBY key increment member </td>
<td> 有序集合中对指定成员的分数加上增量 increment</td>
</tr>
<tr>
<td>ZINTERSTORE destination numkeys key [key &hellip;] </td>
<td> 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td>
</tr>
<tr>
<td>ZLEXCOUNT key min max </td>
<td> 在有序集合中计算指定字典区间内成员数量</td>
</tr>
<tr>
<td>ZRANGE key start stop [WITHSCORES] </td>
<td> 通过索引区间返回有序集合成指定区间内的成员。WITHSCORES 表示结果包含分数。</td>
</tr>
<tr>
<td>ZRANGEBYLEX key min max [LIMIT offset count] </td>
<td> 通过字典区间返回有序集合的成员</td>
</tr>
<tr>
<td>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] </td>
<td> 通过分数返回有序集合指定区间内的成员。min, max支持无穷大，-inf和+inf分别表示负无穷和正无穷。&#8221;(&ldquo;还可以表示开区间。例如<code>ZRANGEBYSCORE keyname 80 (100</code>, <code>ZRANGEBYSCORE keyname (80 +inf</code></td>
</tr>
<tr>
<td>ZRANK key member </td>
<td> 返回有序集合中指定成员的索引</td>
</tr>
<tr>
<td>ZREM key member [member &hellip;] </td>
<td> 移除有序集合中的一个或多个成员</td>
</tr>
<tr>
<td>ZREMRANGEBYLEX key min max </td>
<td> 移除有序集合中给定的字典区间的所有成员</td>
</tr>
<tr>
<td>ZREMRANGEBYRANK key start stop </td>
<td> 移除有序集合中给定的排名区间的所有成员</td>
</tr>
<tr>
<td>ZREMRANGEBYSCORE key min max </td>
<td> 移除有序集合中给定的分数区间的所有成员</td>
</tr>
<tr>
<td>ZREVRANGE key start stop [WITHSCORES] </td>
<td> 返回有序集中指定区间内的成员，通过索引，分数从高到底</td>
</tr>
<tr>
<td>ZREVRANGEBYSCORE key max min [WITHSCORES] </td>
<td> 返回有序集中指定分数区间内的成员，分数从高到低排序</td>
</tr>
<tr>
<td>ZREVRANK key member </td>
<td> 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td>
</tr>
<tr>
<td>ZSCORE key member </td>
<td> 返回有序集中，成员的分数值</td>
</tr>
<tr>
<td>ZUNIONSTORE destination numkeys key [key &hellip;] </td>
<td> 计算给定的一个或多个有序集的并集，并存储在新的 key 中</td>
</tr>
<tr>
<td>ZSCAN key cursor [MATCH pattern] [COUNT count] </td>
<td> 迭代有序集合中的元素（包括元素成员和元素分值）</td>
</tr>
</tbody>
</table>


<h2>4. 进阶</h2>

<h3>4.1 事务</h3>

<p>Redis的事务没有关系数据库事务提供的回滚功能。为此开发者必须在事务执行出错后自己收拾剩下的摊子（将数据库复原回事务执行前的状态等）。</p>

<p>Redis的事务是一组命令的集合。事务同命令一样都是最小执行单位，一个事务中的命令要么都执行，要么都不执行。同一事务的命令会依次执行，不会被其它客户端的命令打断。</p>

<p>如果事务中的命令有语法错误，则所有命令都不会执行。而某个命令的运行错误，如操作类型错误，则<strong>其它命令仍然会执行</strong>。</p>

<p>以 MULTI 开始一个事务， 然后将多个命令入队到事务中， 最后由 EXEC 命令触发事务， 一并执行事务中的所有命令。</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>redis 127.0.0.1:6379&gt; MULTI
OK

redis 127.0.0.1:6379&gt; SET book-name "Mastering C++ in 21 days"
QUEUED

redis 127.0.0.1:6379&gt; GET book-name
QUEUED

redis 127.0.0.1:6379&gt; SADD tag "C++" "Programming" "Mastering Series"
QUEUED

redis 127.0.0.1:6379&gt; SMEMBERS tag
QUEUED

redis 127.0.0.1:6379&gt; EXEC
1) OK
2) "Mastering C++ in 21 days"
3) (integer) 3
4) 1) "Mastering Series"
   2) "C++"
   3) "Programming"</code></pre>


<table>
<thead>
<tr>
<th>命令 </th>
<th> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>DISCARD  </td>
<td> 取消事务，放弃执行事务块内的所有命令。</td>
</tr>
<tr>
<td>EXEC  </td>
<td> 执行所有事务块内的命令。</td>
</tr>
<tr>
<td>MULTI  </td>
<td> 标记一个事务块的开始。</td>
</tr>
<tr>
<td>UNWATCH  </td>
<td> 取消 WATCH 命令对所有 key 的监视。</td>
</tr>
<tr>
<td>WATCH key [key &hellip;]  </td>
<td> 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。   </td>
</tr>
</tbody>
</table>


<h3>4.2 生存时间</h3>

<h4>4.2.1 实现访问频率限制</h4>

<p>在实际开发中，经常会遇到一些有时效的数据，如限时优惠活动、缓存或验证码等，过了一定的时间就需要删除这些数据。在Redis中可以使用EXPIRE命令设置一个键的生存时间，到时间后Redis会自动删除它。命令格式：<code>EXPIRE KEY SECONDS</code>，TTL命令（TTL KEY）可以查询键的剩余时间，PERSIST命令（PERSIST KEY）可以取消键的生存时间设置（即恢复成永久）。</p>

<p>假设每分钟限制每个用户最多只能访问100个页面，可以通过Redis对每个用户使用名为“rate.limiting:用户IP”的字符串类型键，每次用户访问时使用INCR命令递增该键。如果递增后是1（第一次访问），则设置生存时间为1分钟。如果超过100则表示访问频率超过限制，提示用户稍后访问。</p>

<h4>4.2.1 实现缓存</h4>

<p>可以利用Redis实现缓存，通过设置键的生存时间，每次访问时查询缓存是否存在，如果存在直接使用缓存值，否则重新计算并生成缓存。</p>

<p>如果缓存键很多且生存时间长，可能导致Redis占满内容。可以设置最大可用内存大小（maxmemory参数），当内存超出限制时，Redis会根据maxmemory-policy参数指定的策略来删除不需要的键。对于常用的LRU(最近最少使用)算法，会将最近最少使用的键删除。（实际上只是随机选3个键，删除其中最久未被使用的键）</p>

<h3>4.3 排序</h3>

<p>集合类型如果需要排序，则需要用到有序集合类型。相关的命令见前表。</p>

<h4>4.3.1 SORT命令</h4>

<p>SORT命令（SORT KEY）可以对列表类型、集合类型和有序集合类型键进行排序。加上ALPHA参数可以按字典顺序排序, DESC倒序：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>127.0.0.1:6379&gt; lpush mylist a c e d B C A
(integer) 7
127.0.0.1:6379&gt; sort mylist
(error) ERR One or more scores can't be converted into double
127.0.0.1:6379&gt; sort mylist ALPHA
1) "A"
2) "B"
3) "C"
4) "a"
5) "c"
6) "d"
7) "e"
127.0.0.1:6379&gt; sort mylist ALPHA DESC
1) "e"
2) "d"
3) "c"
4) "a"
5) "C"
6) "B"
7) "A"</code></pre>


<p>利用BY参数可以对某个属性进行排序。STORE参数可将结果保存。SORT是Redis中最强大最复杂的命令之一，如果使用不好很容易成为性能瓶颈。</p>

<h3>4.4 消息通知</h3>

<h4>4.4.1 任务队列</h4>

<p>任务队列有两种实体：生产者、消费者。使用Redis的列表类型可以实现队列，让生产者将任务LPUSH到某个键中，另一边消费者不断地使用RPOP命令从该键中取出任务即可。BRPOP与RPOP的区别是，如果列表中没有元素时前者会一直阻塞，直到有新元素加入（可设置超时参数）。</p>

<p>BRPOP命令可以同时接收多个键，如果所有键都没有元素则阻塞；如果其中有一个键有元素则会从该键弹出元素；如果多个键都有元素则按照从左到右的顺序取键中的元素。利用这个特性可以实现优先级任务队列。即BRPOP命令中，将优先级高的键放前面，优先级低的键放后面。</p>

<h4>4.4.2 发布订阅模式</h4>

<p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>

<p>订阅者可以订阅任意数量的频道，发布者可以向指定频道发送消息，所有订阅此频道的订阅者都会收到此消息。</p>

<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_%202015-03-08_pubsub1.png" alt="image" /></p>

<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_%202015-03-08_pubsub2.png" alt="image" /></p>

<p>以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 redisChat:</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>redis 127.0.0.1:6379&gt; SUBSCRIBE redisChat
Reading messages... (press Ctrl-C to quit)
1) "subscribe"
2) "redisChat"
3) (integer) 1</code></pre>


<p>现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>redis 127.0.0.1:6379&gt; PUBLISH redisChat "Redis is a great caching technique"
(integer) 1
redis 127.0.0.1:6379&gt; PUBLISH redisChat "Learn redis by w3cschool.cc"
(integer) 1

# 订阅者的客户端会显示如下消息
1) "message"
2) "redisChat"
3) "Redis is a great caching technique"
1) "message"
2) "redisChat"
3) "Learn redis by w3cschool.cc"</code></pre>


<table>
<thead>
<tr>
<th>命令 </th>
<th> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PSUBSCRIBE pattern [pattern &hellip;] </td>
<td> 订阅一个或多个符合给定模式的频道。</td>
</tr>
<tr>
<td>PUBSUB subcommand [argument [argument &hellip;]] </td>
<td> 查看订阅与发布系统状态。</td>
</tr>
<tr>
<td>PUBLISH channel message </td>
<td> 将信息发送到指定的频道。</td>
</tr>
<tr>
<td>PUNSUBSCRIBE [pattern [pattern &hellip;]] </td>
<td> 退订所有给定模式的频道。</td>
</tr>
<tr>
<td>SUBSCRIBE channel [channel &hellip;] </td>
<td> 订阅给定的一个或多个频道的信息。</td>
</tr>
<tr>
<td>UNSUBSCRIBE [channel [channel &hellip;]] </td>
<td> 指退订给定的频道。</td>
</tr>
</tbody>
</table>


<p>使用PSUBSCRIBE可以重复订阅一个频道，此时会重复收到多条消息。PUNSUBSCRIBE只能退订PSUBSCRIBE订阅的规则，不会影响SUBSCRIBE订阅的频道。</p>

<h3>4.5 管道</h3>

<p>在连续执行多个命令时，每条命令都需要等待上一条命令执行完才能执行，即使命令不需要上一条命令的执行结果。每个命令都要经过网络往返，产生了往返时延。Redis底层通信协议对管道提供了支持，通过管道可以一次性发送金条命令并在执行完成后一次性将结果返回。当一组命令中的每条命令都不依赖于之前命令的执行结果时就可以将这组命令一起通过管道发生。这样客户端与服务器只需要一个来回，降低了往返时延。</p>

<h2>5. 管理</h2>

<h3>5.1 持久化</h3>

<p>Redis的强劲性能很大程度上是由于其将所有数据都存储在了内存中，为了使Redis在重启之后仍能保证数据不丢失，需要将数据从内存中以某种形式同步到硬盘中，这一过程就是持久化。Redis支持两种方式的持久化，一种是RDB方式，一种是AOF方式。可以单独使用其中一种或将二者结合使用。</p>

<h4>5.1.1 RDB方式</h4>

<p>RDB方式的持久化是通过快照（snapshotting）完成的，当符合一定条件时Redis会自动将内存中的所有数据进行快照并存储在硬盘上。进行快照的条件可以由用户在配置文件中自定义，由两个参数构成：时间和改动的键的个数。当在指定的时间内被更改的键的个数大于指定的数值时就会进行快照。</p>

<p>RDB是Redis默认采用的持久化方式，在配置文件中已经预置了3个条件：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>save 900 1 
save 300 10 
save 60 10000 </code></pre>


<p>save参数指定了快照条件，可以存在多个条件，条件之间是“或”的关系。如上所说，save 900 1的意思是在15分钟（900秒钟）内有至少一个键被更改则进行快照。</p>

<p>如果想要禁用自动快照，只需要将所有的save参数删除即可。Redis默认会将快照文件存储在当前目录的dump.rdb文件中，可以通过配置dir和dbfilename两个参数分别指定快照文件的存储路径和文件名。</p>

<p>理清Redis实现快照的过程对我们了解快照文件的特性有很大的帮助。快照的过程如下。</p>

<p>（1）Redis使用fork函数复制一份当前进程（父进程）的副本（子进程）；
（2）父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件；
（3）当子进程写入完所有数据后会用该临时文件替换旧的RDB文件，至此一次快照操作完成。</p>

<p>在执行fork的时候操作系统（类Unix操作系统）会使用写时复制（copy-on-write）策略，即fork函数发生的一刻父子进程共享同一内存数据，当父进程要更改其中某片数据时（如执行一个写命令），操作系统会将该片数据复制一份以保证子进程的数据不受影响，所以新的RDB文件存储的是执行fork一刻的内存数据。</p>

<p>通过上述过程可以发现Redis在进行快照的过程中不会修改RDB文件，只有快照结束后才会将旧的文件替换成新的，也就是说任何时候RDB文件都是完整的。这使得我们可以通过定时备份RDB文件来实现Redis数据库备份。RDB文件是经过压缩（可以配置rdbcompression参数以禁用压缩节省CPU占用）的二进制格式，所以占用的空间会小于内存中的数据大小，更加利于传输。</p>

<p>除了自动快照，还可以手动发送SAVE或BGSAVE命令让Redis执行快照，两个命令的区别在于，前者是由主进程进行快照操作，会阻塞住其他请求，后者会通过fork子进程进行快照操作。</p>

<p>Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将一个记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟。</p>

<p>通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化。</p>

<h4>5.1.2 AOF方式</h4>

<p>默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启： <code>appendonly yes</code>。开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。</p>

<p>AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof，可以通过appendfilename参数修改： <code>appendfilename appendonly.aof</code></p>

<p>下面讲解AOF持久化的具体实现，假设在开启AOF持久化的情况下执行了如下4个命令：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>SET foo 1 
SET foo 2 
SET foo 3 
GET foo Redis</code></pre>


<p>Redis会将前3条命令写入AOF文件中，AOF文件是纯文本文件，其内容正是Redis客户端向Redis发送的原始通信协议的内容。然而这时有一个问题是前2条命令其实都是冗余的，因为这两条的执行结果会被第三条命令覆盖。随着执行的命令越来越多，AOF文件的大小也会越来越大，即使内存中实际的数据可能并没有多少。</p>

<p>很自然地，我们希望Redis可以自动优化AOF文件，就上例而言，就是将前两条无用的记录删除，只保留第三条。实际上Redis也正是这样做的，每当达到一定条件时Redis就会自动重写AOF文件，这个条件可以在配置文件中设置：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>auto-aof-rewrite-percentage 100 
auto-aof-rewrite-min-size 64mb</code></pre>


<p>auto-aof-rewrite-percentage参数的意义是当目前的AOF文件大小超过上一次重写时的AOF文件大小的百分之多少时会再次进行重写，如果之前没有重写过，则以启动时的AOF文件大小为依据。auto-aof-rewrite-min-size参数限制了允许重写的最小AOF文件大小，通常在AOF文件很小的情况下即使其中有很多冗余的命令我们也并不太关心。</p>

<p>除了让Redis自动执行重写外，我们还可以主动使用BGREWRITEAOF命令手动执行AOF重写。 重写的过程只和内存中的数据有关，和之前的AOF文件无关，这与RDB很相似，只不过二者的文件格式完全不同。</p>

<p>在启动时Redis会逐个执行AOF文件中的命令来将硬盘中的数据载入到内存中，载入的速度相较RDB会慢一些。 需要注意的是虽然每次执行更改数据库内容的操作时，AOF都会将命令记录在AOF文件中，但是事实上，由于操作系统的缓存机制，数据并没有真正地写入硬盘，而是进入了系统的硬盘缓存。在默认情况下系统每30秒会执行一次同步操作，以便将硬盘缓存中的内容真正地写入硬盘，在这30秒的过程中如果系统异常退出则会导致硬盘缓存中的数据丢失。一般来讲启用AOF持久化的应用都无法容忍这样的损失，这就需要Redis在写入AOF文件后主动要求系统将缓存内容同步到硬盘中。在Redis中我们可以通过appendfsync参数设置同步的时机：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'># appendfsync always 
appendfsync everysec 
# appendfsync no </code></pre>


<p>默认情况下Redis采用everysec 规则，即每秒执行一次同步操作。always表示每次执行写入都会执行同步，这是最安全也是最慢的方式。no表示不主动进行同步操作，而是完全交由操作系统来做（即每30秒一次），这是最快但最不安全的方式。一般情况下使用默认值everysec就足够了，既兼顾了性能又保证了安全。 Redis允许同时开启AOF和RDB，既保证了数据安全又使得进行备份等操作十分容易。此时重新启动Redis后Redis会使用AOF文件来恢复数据，因为AOF方式的持久化可能丢失的数据更少。</p>

<h3>5.2 复制</h3>

<p>通过持久化功能，Redis保证了即使在服务器重启的情况下也不会损失（或少量损失）数据。但是由于数据是存储在一台服务器上的，如果这台服务器的硬盘出现故障，也会导致数据丢失。为了避免单点故障，我们希望将数据库复制多个副本以部署在不同的服务器上，即使有一台服务器出现故障其他服务器依然可以继续提供服务。这就要求当一台服务器上的数据库更新后，可以自动将更新的数据同步到其他服务器上，Redis提供了复制（replication）功能可以自动实现同步的过程。</p>

<h4>5.2.1 配置</h4>

<p>同步后的数据库分为两类，一类是主数据库（master），一类是从数据库（slave）。主数据库可以进行读写操作，当发生写操作时自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。一个主数据库可以拥有多个从数据库 在Redis中使用复制功能非常容易，只需要在从数据库的配置文件中加入“slaveof主数据库IP主数据库端口”即可，主数据库无需进行任何配置。</p>

<h4>5.2.2 原理</h4>

<p>了解Redis复制的原理对日后运维有很大的帮助。 当一个从数据库启动后，会向主数据库发送SYNC命令，主数据库接收到SYNC命令后会开始在后台保存快照（即RDB持久化的过程），并将保存期间接收到的命令缓存起来。当快照完成后，Redis会将快照文件和所有缓存的命令发送给从数据库。从数据库收到后，会载入快照文件并执行收到的缓存的命令。当主从数据库断开重连后会重新执行上述操作，不支持断点续传。</p>

<h4>5.2.4 读写分离</h4>

<p>通过复制可以实现读写分离以提高服务器的负载能力。在常见的场景中，读的频率大于写，当单机的Redis无法应付大量的读请求时（尤其是较耗资源的请求，比如SORT命令等）可以通过复制功能建立多个从数据库，主数据库只进行写操作，而从数据库负责读操作。</p>

<h4>5.2.5 从数据库持久化</h4>

<p>另一个相对耗时的操作是持久化，为了提高性能，可以通过复制功能建立一个（或若干个）从数据库，并在从数据库中启用持久化，同时在主数据库禁用持久化。当从数据库崩溃时重启后主数据库会自动将数据同步过来，所以无需担心数据丢失。而当主数据库崩溃时，需要在从数据库中使用SLAVEOF NO ONE命令将从数据库提升成主数据库继续服务，并在原来的主数据库启动后使用SLAVEOF命令将其设置成新的主数据库的从数据库，即可将数据同步回来。</p>

<h3>5.3 安全</h3>

<p>Redis的作者Salvatore Sanfilippo曾经发表过Redis宣言，其中提到Redis以简洁为美。同样在安全层面Redis也没有做太多的工作。</p>

<p>Redis的安全设计是在“Redis运行在可信环境”这个前提下做出的。</p>

<h3>5.4 通信协议</h3>

<p>Redis支持两种通信协议，一种是二进制安全的统一请求协议（unified request protocol），一种是比较直观的便于在telnet程序中输入的简单协议。这两种协议只是命令的格式有区别，命令返回值的格式是一样的。</p>

<h3>5.5 管理工具</h3>

<p>当一条命令执行时间超过限制时，Redis会将命令的执行时间等信息加入耗时命令日志（slow log）中。使用<code>SLOWLOG　GET</code>命令获得当前的耗时命令日志。</p>

<p>使用MONITOR命令可监控Redis执行的所有命令。（非常影响Redis性能）</p>

<p>其它管理工具还包括<a href="https://github.com/ErikDubbelboer/phpRedisAdmin">phpRedisAdmin</a>和<a href="https://github.com/sripathikrishnan/redis-rdb-tools">Rdbtools</a>（Redis快照文件解析器）。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux基础]]></title>
    <link href="http://blog.ubone.com/blog/2015/02/24/linuxji-chu/"/>
    <updated>2015-02-24T11:37:23+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/02/24/linuxji-chu</id>
    <content type="html"><![CDATA[<p>学习Linux的一些基本知识，包括用户身份、文件、目录、程序执行和磁盘管理等。</p>

<!--more-->


<h2>1. 用户身份</h2>

<p>Linux的用户只有两个等级：root和非root。Linux支持最多2<sup>32</sup> -1个用户。Linux还有一些用户是用来完成特定任务的，如nobody, admin, ftp等。但不管这些用户多牛逼，都是普通用户。用户组相当于职业，从更高层面来抽象用户能够访问的文件。有些用户的主要任务就是运行某些程序以确保安全性，如nobody用户就可以用于Nginx的工作进程。这类用户一般不分配密码和shell，甚至home目录也没有。</p>

<h3>1.1 用户</h3>

<p>通过<code>/etc/passwd</code>文件可以查看用户。每一行表示一个用户，其结构为：<code>用户名：密码：UID(User ID):GID(Group ID):用户命名：home目录：shell</code>。当然，密码并没有真正包含在内：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false
root:*:0:0:System Administrator:/var/root:/bin/sh
daemon:*:1:1:System Services:/var/root:/usr/bin/false</code></pre>


<p>UID的0一般分配给root，1～499分配给系统用户，普通用户从500开始。</p>

<h3>1.2 组</h3>

<p>通过<code>/etc/group</code>查看组，每一行代表一个用户组，其结构为：<code>组名：组密码：GID：用户组内的用户名</code>：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>nobody:*:-2:
nogroup:*:-1:
wheel:*:0:root
daemon:*:1:root</code></pre>


<p>同样，密码并没有存放在这。“用户组内的用户名”并不完整，通常只显示兼职的用户，专职的用户已经在<code>/etc/passwd</code>中定义过了。</p>

<h3>1.2 管理用户和组</h3>

<p>通过adduser或useradd命令可以增加用户，这些命令会修改<code>/etc/passwd</code>和<code>/etc/group</code>这两个文件，并通过文件<code>/etc/shadow</code>来管理密码。不同的Linux发行版本中adduser可能有区别，而useradd则是一样的。</p>

<pre  class='line-numbers language-bash'><code class='language-bash'># useradd jason
# passwd                //修改当前用户密码
# passwd jason
# userdel jason         //删除用户
# userdel -r jason  //删除用户，并连同home目录一同删除。
# usermod           //修改用户的群组、账户名、目录、shell等等。</code></pre>


<p>用户组的管理命令包括：groupadd、groupmod、groupdel和gpasswd。组密码很少用到。</p>

<h3>1.3 sudo</h3>

<p>通过sudo可以临时以root身份执行一条命令。但不是所有普通用户都有sudo权限。该权限由<code>/etc/sudoers</code>管理。</p>

<pre  class='line-numbers language-bash'><code class='language-bash'># User privilege specification
root    ALL=(ALL:ALL) ALL

# Members of the admin group may gain root privileges
%admin ALL=(ALL) ALL

# Allow members of group sudo to execute any command
%sudo   ALL=(ALL:ALL) ALL</code></pre>


<p>如果觉得sudo给予的root权限过大，可以限制可执行的命令，例如：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>%users ALL=/sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom

#还可以使用!表示禁止
$users ALL=(ALL) ALL, !/usr/sbin/adduser, !/usr/sbin/useradd</code></pre>


<h3>1.4 我是谁？</h3>

<p>用户登录的身份为实际用户，通过su命令转换身份后为有效用户。有些脚本可能需要识别“我是谁？”。可以通过以下几个命令：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>//以普通用户mxs登录
mxs@Jasondroplet:~$ whoami
mxs
mxs@Jasondroplet:~$ who am i
mxs      pts/1        2015-02-23 23:20 (10.0.0.100)
mxs@Jasondroplet:~$ who
mxs      pts/1        2015-02-23 23:20 (10.0.0.100)

//su后
mxs@Jasondroplet:~$ su
root@Jasondroplet:/usr/mxs# whoami
root
root@Jasondroplet:/usr/mxs# who am i
mxs      pts/1        2015-02-23 23:20 (10.0.0.100)
root@Jasondroplet:/usr/mxs# who
mxs      pts/1        2015-02-23 23:20 (10.0.0.100)</code></pre>


<h2>2. 文件与目录</h2>

<p>Linux下用ls命令显示文件和目录时，会采用颜色区分类型。常见的如蓝色表示目录，其他颜色表示文件，绿色表示可执行文件、青色表示符号连接等等。通过<code>ls -l</code>命令可查看详细的属性：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>-rw-rw-r--  1 mxs  mxs       692 Oct 24 08:31 log4j.properties
drwxrwxr-x  2 mxs  mxs      4096 Jan 20 10:26 pki</code></pre>


<p>第一个字符用于描述文件类型，可取的值包括：</p>

<ul>
<li>-：普通文件</li>
<li>d：目录</li>
<li>l：软连接，硬连接没有特殊标记</li>
<li>b：设备文件，块设备，如磁盘等</li>
<li>c：设备文件，字符设备，如鼠标键盘等</li>
<li>s：套接字（Socket）文件</li>
<li>p：命名管道文件</li>
</ul>


<p>后面紧跟着的三套“rwx”分别表示所有者、所属用户组和其他用户的读、写和执行权限。对于目录，x权限表示是否能够打开它，r权限表示能否查看这个目录中的文件列表，在该目录创建文件则需要w权限。</p>

<p>文件名前带点号“.”的表示隐藏文件。</p>

<p>之后的数字表示“连接数”。Linux使用的文件系统是一种基于inode的文件系统。每一个新创建的文件都会分配一个inode，且每个文件都有唯一的inode编号。可以将inode理解成一个指针，指向的是文件所在磁盘中的物理位置。上面的文件属性也保存在inode中。为了提高效率，访问过的文件的inode会缓存在内存中。使用ln命令可以建立文件连接。命令<code>ln -s /bin/bash sh</code>建立了一个新的软连接sh指向<code>/bin/bash</code>，软连接也占用一个inode，不影响inode的引用计数。如果去除参数<code>-s</code>则创建的是硬连接。硬连接的属性跟目标文件的属性完全相同，因为引用的是相同的inode，仅仅将inode的引用计数进行了加1操作。由于有<code>.</code>目录的存在，所以每个目录的连接数都为2，而<code>..</code>目录的存在，则导致每增加一个子目录，其连接数都加1.</p>

<h3>2.1 文件属性与权限</h3>

<p>chown可用于修改文件的拥有者，<code>chown [-R] username filename</code> 或者 <code>chown [-R] username:group filename</code>, 后者连同文件所属用户组也一同修改了。参数<code>-R</code>表示目录。</p>

<p>chmod用于修改文件权限，可以使用数字法或文字法。数字法就是用数字代替r(4)、w(2)和x(1)，例如w-x(5), rw-(6)和rwx(7)。例如：<code>chmod 755 .bashrc</code>。文字法则使用四个字母：u(拥有者)、g(所属组)、o(其他)和a(全部)，和三个字符：+(增加)、-(减去)和=（设定）来设置权限。例如：<code>chmod a-x .bashrc</code>, <code>chmod ugo-x .bashrc</code>, <code>chmod ugo=rwx .bashrc</code>。</p>

<p>除了rwx外，Linux还有两个特殊的权限s和t。s可以出现在拥有者的x位置（SUID），也可以出现在所属组的x位置（SGID）。SUID的典型示例是<code>/bin/su</code>命令，其属性为<code>-rwsr-xr-x</code>，表示执行者将具有该程序拥有者（root）的权限，并且仅在执行该程序过程中有效。SGID不常见。<code>t</code>权限用于其他用户的<code>x</code>权限位（SBIT），仅对目录有效。典型例子是<code>/tmp</code>目录，这个目录允许任何用户在里面创建文件，但为了避免文件被其他人误删除，则设置SBIT权限，使得自己创建的文件只能通过自己或者root删除。</p>

<h3>2.2 搜索文件</h3>

<p>Linux有5个搜索文件的命令。</p>

<table>
<thead>
<tr>
<th>命令 </th>
<th> 说明 </th>
<th> 示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>whereis </td>
<td> 搜索可执行文件、联机帮助和源代码文件。基于每天更新一次的数据库（/var/lib/mlocate/），查询快速。</td>
<td> whereis ls</td>
</tr>
<tr>
<td>locate </td>
<td> 与whereis使用相同的数据库，支持复杂的匹配语法。</td>
<td> locate ls 会找到很多结果。</td>
</tr>
<tr>
<td>which </td>
<td> 只在$PATH环境变量中搜索可执行文件。可用于确认系统是否安装了指定软件。</td>
<td> which gcc</td>
</tr>
<tr>
<td>find </td>
<td> 强大的查找工具。<code>find / -mtime -1 -exec ls -l {} \;</code>表示列出一天以内变化的文件的详细信息。<code>-exec</code>表示对找到的文件执行的动作，{}表示占位符，find命令执行过程中会不断地被替换为当前找到的文件，这样ls命令就完整了。分号&#8221;;&ldquo;是因为<code>-exec</code>的结束标记是分号，在bash中有特殊含义，所以需要转义符<code>\</code>。另一个示例： 在php文件中查找41：  find . -name &lsquo;*.php&rsquo; -type f -exec grep -q 41 {} \; -print</td>
<td> </td>
</tr>
</tbody>
</table>


<h3>2.3 文件打包压缩</h3>

<pre  class='line-numbers language-bash'><code class='language-bash'>#解压缩
tar -vxf filename
#压缩
tar -zcvf filename.tar.gz FILES</code></pre>


<h2>3. 程序执行</h2>

<p>在命令行下执行命令，Linux只会在$PATH环境变量所指定的那些路径中搜索对应的程序，如果找不到就失败。因此即使是当前路径也需要指定相对路径（./abc.sh）或绝对路径。</p>

<p>管道是Linux系统提供的多任务协调机制，应用十分广泛。通过管道，数据从一端写入，另一端读取（FIFO）。管道分为匿名和命名两种，用竖线“|”表示匿名管道，mkfifo命令可建立命名管道（会在指定路径创建类型为“p”的文件）。I/O重定向（“>”）是Linux提供的一种多任务协调机制。下面的例子演示了管道和重定向：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>$ find /boot | cpio -ocB &gt; /tmp/boot.img</code></pre>


<p>find命令查找/boot下的所有文件，并通过匿名管道传给cpio命令，cpio将输出内容重定向到boot.img文件。</p>

<p>Linux命令行下也支持前台和后台任务。前台任务转后台：Ctrl+Z，然后执行bg命令。如果想直接创建一个后台任务，在命令末尾添加“&amp;”符号即可。通过jobs命令查看所有后台任务，要将后台任务切换成前台任务，运行命令<code>fg 任务号</code>即可。</p>

<p>kill命令用于结束一个任务或进程。</p>

<p>计划任务可分为单次和循环，前者使用at命令，后者使用crontab命令。</p>

<p>Linux的守护进程分为stand alone和xinetd。前者可以自行启动，启动后会一直占用内存和系统资源，响应快，例如apache, mysql。后者由一个统一的stand alone守护进程(super daemon)负责唤起，当没有客户端要求时，xinetd类型的守护进程都是未启动的，一旦有客户端要求服务，super daemon就会唤醒具体的xinetd守护进程。</p>

<p>大多数Linux会将stand alone守护进程的启动脚本放在/etc/init.d/目录下，而xinetd守护进程的文件放在/etc/xinetd.d/。</p>

<p>查看当前运行的程序信息，可以使用ps、top和pstree三个命令。ps命令显示某一时刻的程序信息，常见三种用法：<code>ps aux</code>查看系统中所有程序的数据；<code>ps ux</code>查看当前用户所有程序的数据；<code>ps -l</code>查看与当前终端关联的程序数据。top命令可以每隔5秒刷新一次数据，相当于Windows任务管理器。而pstree可以查看进程的父子祖先关系。</p>

<h2>4. 磁盘管理</h2>

<p>Linux的文件系统格式被称为ExtN(N=2,3,4)。ExtN文件系统中包含inode数据结构来代表一个文件，并且存储了这个文件的各种属性和权限。文件的实际数据保存在data block块区中。data block与inode一样，每一个都有一个唯一编号，inode只需要记录这些编号，就能够定位整个文件的任意一段数据。因此ExtN通过inode能够一次性获得文件数据所存放的位置，尽量保证在磁盘只旋转一圈的情况下将所有内容读出来。而FAT32则只有将对应的data block读入之后才知道下一个data block在什么地方，因此效率比较低，这也是Windows系统使用较长时间后，碎片较多，系统变慢的原因。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Web中文编码]]></title>
    <link href="http://blog.ubone.com/blog/2015/02/23/java-webzhong-wen-bian-ma/"/>
    <updated>2015-02-23T15:57:18+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/02/23/java-webzhong-wen-bian-ma</id>
    <content type="html"><![CDATA[<p>介绍常见的编码格式，以及Java Web和JavaScript相关的字符集编码。</p>

<!--more-->


<h2>1. 常见的编码格式</h2>

<table>
<thead>
<tr>
<th>编码 </th>
<th> 说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ASCII </td>
<td> 共128个，用1个字节表示。0～31为控制字符，如换行、回车等。32～126为打印字符。</td>
</tr>
<tr>
<td>ISO-8859-1 </td>
<td> 扩展ASCII编码，仍然是单字节，共256个字符。</td>
</tr>
<tr>
<td>GB2312 </td>
<td> 双字节编码，A1~A9是符号区，共682个符号；B0~F7是汉字区，共6763个汉字</td>
</tr>
<tr>
<td>GBK </td>
<td> 为Win95所制定的汉字内码规范，扩展GB2312，与GB2312兼容，能表示21003个汉字。</td>
</tr>
<tr>
<td>GB18030 </td>
<td> 可能是单字节、双字节或者四字节编码，与GB2312兼容。虽然是国家标准，但未广泛使用。</td>
</tr>
<tr>
<td>UTF-16 </td>
<td> 定义了Unicode字符在计算机中的存取方法。Unicode是ISO试图创建一个全新的超语言字典，世界上所有语言都可以通过这个字典相互翻译。Unicode是Java和XML的基础。UTF-16用两个字节来表示Unicode的转化格式，采用定长的表示方法。</td>
</tr>
<tr>
<td>UTF-8 </td>
<td> 避免UTF-16的空间浪费，采用变长技术，每个编码区域有不同的字码长度。不同类型的字符可以由1～6个字节组成。</td>
</tr>
</tbody>
</table>


<p>UTF-8的编码规则：</p>

<ul>
<li>如果是1个字节，最高位（第8位）为0，表示1个ASCII字符。</li>
<li>如果是1个字节，以11开着，则连续的1的个数表示这个字符的字节数。例如110xxxxx表示它是双字节UTF-8字符的首字节。</li>
<li>如果1个字节，以10开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节。</li>
</ul>


<h2>2. Java中的编码场景</h2>

<h3>2.1 在I/O中编码</h3>

<p>在磁盘和网络I/O中，都涉及字节与字符的转换。Reader类是Java的I/O中读字符的父类，而InputStream类是读字节的父类。两者之间的转换由StreamDecoder和StreamEncoder完成。在编、解码过程中必须指定Charset，否则使用本地环境默认字符集，如中文环境使用GBK。</p>

<p>在实际开发过程中，只要保持编码的一致就不会造成乱码：</p>

<pre class='line-numbers language-java'><code class='language-java'>String charset = "UTF-8";
String file = "c:/stream.txt";

FileOutputStream fos = new FieOutputStream(file);
OutputStreamWriter writer = new OutputStreamWriter(fos, charset);

...
InputStreamReader reader = new InputStreamReader(inputStream, charset);</code></pre>


<h3>2.2 在内存中编码</h3>

<p>String类提供了字符和字节的转换方法：</p>

<pre class='line-numbers language-java'><code class='language-java'>String s= "这是一段中文";
byte[] b = s.getBytes("UTF-8");
String n = new String(b, "UTF-8");</code></pre>


<p></p>

<p>另一种方法是使用Charset类：</p>

<pre class='line-numbers language-java'><code class='language-java'>Charset charset = Charset.forName("UTF-8");
ByteBuffer byteBuffer = charset.encode("abcd");
CharBuffer charBuffer = charset.decode(byteBuffer);</code></pre>


<p></p>

<h2>3. Java Web中的编解码</h2>

<p>用户从浏览器发起一个HTTP请求，需要编码的地方包括URL、Cookie和Parameter。</p>

<h3>3.1 URL的编解码</h3>

<p>URL <code>http://localhost:8080/examples/servlets/servlet/books?author=jason</code> 可分解为：</p>

<ul>
<li>URI: <code>/examples/servlets/servlet/books</code></li>
<li>schema: http</li>
<li>domain: localhost</li>
<li>port: 8080</li>
<li>contextPath: examples</li>
<li>servletPath: servlets/servlet</li>
<li>PathInfo: books</li>
<li>QueryString: author=jason</li>
</ul>


<p>对于Tomcat，对URL的URI部分进行解码的字符集是在Connector中定义的。如果没有定义，那么默认为ISO-8859-1。QueryString的解码字符集要么是Header中ContentType定义的Charset，要么是默认的ISO-8859-1。要使用ContentType定义的编码，需要设置Connector。因此Tomcat一般会设置：</p>

<p><code>&lt;Connector URIEncoding="UTF-8" useBodyEncodingForURI="true" /&gt;</code></p>

<h3>3.2 HTTP Header的编解码</h3>

<p>除了URL外，还可能在Header中传递其它参数，如Cookie、redirectPath等。不要在Header中传递非ASCII字符，如果一定要传递，可以先用URLEncoder编码，再添加到Header中。</p>

<h3>3.3 其它编解码</h3>

<p>POST表单也是通过ContentType的Charset编码。用JDBC来存取数据时要和数据的内置编码保持一致，可以通过设置JDBC URL来指定，如MySQL: url=&ldquo;jdbc:mysql://localhost:3306/DB?useUnicode=true&amp;characterEncoding=GBK&#8221;。</p>

<h2>4. Javascript中的编码问题</h2>

<p>如果Javascript文件的编码格式与当前页面不一致，需要指定字符集，否则可能出现乱码：<code>&lt;script src="abc.js" charset="gbk"/&gt;</code>。在Javascript中处理URL可以使用<code>encodeURI()</code>和<code>encodeURIComponent()</code>。后者编码得更彻底，除了<code>!</code>、<code>'</code>、<code>(</code>、<code>)</code>、<code>*</code>、<code>-</code>、<code>.</code>、<code>_</code>、<code>~</code>、<code>0-9</code>、<code>a-z</code>和<code>A-Z</code>之外，对其他所有字符都编码，因此通常用于将一个URL当作一个参数放在另一个URL中。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java内存模型与线程]]></title>
    <link href="http://blog.ubone.com/blog/2015/01/31/javanei-cun-mo-xing-yu-xian-cheng/"/>
    <updated>2015-01-31T19:45:39+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/01/31/javanei-cun-mo-xing-yu-xian-cheng</id>
    <content type="html"><![CDATA[<p>学习并发编程，需要了解Java内存模型与线程。</p>

<!--more-->


<h2>1. 硬件的基础</h2>

<p>为了提高效率，现在的CPU都有一层读写速度接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存中。</p>

<p>对于多处理器系统，每个处理器都有自己的高速缓存，而它们又共享同一个主内存。因此就存在缓存一致性的问题。当多个处理器的运算任务都涉及同一块主内存区域时，就可能导致各自的缓存数据不一致。为了解决一致性问题，需要遵循一些协议（如MSI, MESI, MOSI等）。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_-2015-01-31-19.55.58.png" alt="image" /></p>

<p>乱序执行（Out-Of-Order Execution）优化。为了使处理器内部的运算单元能尽量充分利用，处理器可能会对代码进行乱序执行优化，在计算之后将结果重组，保证该结果与顺序执行的结果一致。也就是处理器并不保证各条语句执行的先后顺序与输入顺序一致。JIT也有类似的指令重排序（Instruction Recorder）优化。</p>

<h2>2. Java内存模型</h2>

<h3>2.1 主内存与工作内存</h3>

<p>JVM规范定义了Java内存模型来屏蔽各种硬件和OS的内存访问差异。该模型规定所有变量都存储在主内存（仅是虚拟机内存的一部分）中，每条线程还有自己的工作内存，线程的工作内存保存了该线程使用到的变量（不是对象，而是对象的引用）的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_-2015-01-31-20.27.06.png" alt="image" /></p>

<h3>2.2 内存间交互操作</h3>

<p>关于主内存与工作内存之间的交互，Java内存模型定义了8种操作来完成，每种操作都是原子操作。</p>

<ul>
<li>lock: 作用于主内存变量，把一个变量标识为一条线程独占状态</li>
<li>unlock: 作用于主内存变量，释放一个锁定的变量，可以被其他线程锁定</li>
<li>read: 作用于主内存变量，把一个变量的值从主内存传输到线程的工作内存中，以便load动作使用。</li>
<li>load: 作用于工作内存变量，把read操作从主内存中得到的变量值放入工作内存变量副本中。</li>
<li>use: 作用于工作内存变量，把工作内存中的变量的值传递给执行引擎。每当虚拟机遇到一个需要使用变量的值的字节码指令时会执行这个操作。</li>
<li>assign: 作用于工作内存变量，把从执行引擎接收到的值赋给工作内存变量。每当虚拟机遇到一个给变量赋值的字节码指令时执行此操作。</li>
<li>store: 作用于工作内存变量，把工作内存中一个变量的值传送到主内存中，以便write操作使用。</li>
<li>write: 作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>


<h3>2.3 volatile变量</h3>

<h4>2.3.1 可见性</h4>

<p>对于volatile变量，具备两个特性：一是保证此变量对所有线程的可见性，即当一个线程修改了这个变量的值，新值对于其他线程来说可以立即得知。实际上volatile变量在各线程的工作内存中也可以存在不一致的情况，但是由于使用之前都要先刷新，因此可以认为不存在一致性问题。但由于Java中的运算不是原子操作，因此volatile在并发下也不一定是安全的。例如下面的代码：</p>

<pre class='line-numbers language-java'><code class='language-java'>public static volatile int race = 0;

public static void increase() {
    race++;
}

//测试代码：
for(int i = 0; i &lt; 20; i++) {
    ...//用20个线程调用increase()方法
    public void run() {
        for(int j = 0; j &lt; 10000; j++) {
            increase();
        }
    }
}

//当20个线程结束后，race的值通常会少于20万。</code></pre>


<p>volatile变量与普通变量的区别在于，前者保证新值能立即同步到主内存，并且每次使用前都立即从主内存刷新。对于volatile变量，如果不符合以下两条规则，则仍然要通过加锁来实现同步：</p>

<ol>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ol>


<h4>2.3.2 禁止指令重排序优化</h4>

<p>volatile变量也用于禁止指令重排序。直接看伪代码：</p>

<pre class='line-numbers language-java'><code class='language-java'>volatile boolean initialized = false;

//线程A
initConfig() //做一些初始化的工作
initialized = true;

//线程B
while(! initialized) { sleep();}
//使用线程A中初始化好的配置信息
doSomethingWithConfig();</code></pre>


<p>如果变量initialized不声明为volatile，则指令重排序后，有可能线程A中的<code>initialized = true</code>比<code>initConfig()</code>提前执行。导致线程B无法正确获取配置信息。</p>

<h2>3. Java与线程</h2>

<p>主流操作系统都提供了线程实现，Java语言则提供了在不同硬件和操作系统平台下对线程操作的统一处理。线程实现主要有3种方式：</p>

<h3>3.1 使用内核线程实现</h3>

<p>内核线程是由操作系统内核（Kernel）支持的线程。程序并不直接使用内核线程，而是使用轻量级进程（Light Weight Process, LWP）。LWP就是我们通常意义上所讲的线程。每个LWP与内核线程是1：1关系。</p>

<p>内核线程的缺点是调用代价高，需要在用户态和内核态来回切换。同时LWP要消耗一定的内核资源。因此一个系统支持LWP的数量是有限的。</p>

<h3>3.2 使用用户线程实现</h3>

<p>用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核帮助。因此可以支持更大的线程数量，不需要切换到内核，快速且消耗低。进程与用户线程的关系为1：N关系。</p>

<p>由于没有系统内核支援，所有线程操作都需要用户程序自己处理，因此程序比较复杂。Java曾经使用过用户线程，但最终放弃使用它。</p>

<h3>3.3 使用用户线程加LWP混合实现</h3>

<p>这种混合实现方式即存在用户线程，也存在LWP。用户线程还是完全建立在用户空间中，因此创建、切换等操作依然廉价，并且可以支持大规模用户线程并发。而操作系统提供支持的LWP则作为用户线程与内核线程之间的桥梁，可以使用内核提供的线程调度功能及处理器映射，用户线程的系统调用通过LWP完成，大大降低了整个进程被完全阻塞的风险。用户线程与LWP的数量比不定，即N:M的关系。</p>

<h3>3.4 Java线程的实现</h3>

<p>JDK1.2之前使用用户线程实现。从1.2开始，线程模型基于操作系统原生线程模型来实现。对于SunJDK，Windows和Linux版都是使用1：1的线程模型，即一条Java线程映射到一条LWP。而Solaris，HP-UX等则由于操作系统的线程特性，可以同时支持1：1及N:M模型。</p>

<h2>4. 线程安全</h2>

<p>Brian Goetz对线程安全的定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。</p>

<h3>4.1 Java语言中的线程安全</h3>

<h4>4.1.1 不可变</h4>

<p>Java中不可变的对象一定是线程安全的。如果共享的数据是一个基本数据类型，只要在定义时使用了final关键字就可以保证它是不可变的。如果共享数据是一个对象，则需要保证对象的行为不会对其状态产生任何影响。</p>

<h4>4.1.2 绝对线程安全</h4>

<p>Java API中标注为线程安全的类，大多数都不是绝对的线程安全。例如java.util.Vector是线程安全的容器，其get(), remove()和size()方法都是同步的。但如果不在方法调用端做额外的同步措施，代码仍然是不安全的：</p>

<pre class='line-numbers language-java'><code class='language-java'>//如果一个线程在操作Vector时，另一个线程删除了了个元素，导致i元素不可再用，就会抛出异常。
private static Vector&lt;Integer&gt; vector = new Vector&lt;Integer&gt;();

public static void main(String[] args) {
    while(true) {
        for(int i = 0; i &lt; 10; i++) {vector.add(i);}
        
        Thread removeThread = new Thread(new Runnable(){
            public void run() {
                for(int i = 0; i &lt; vector.size(); i++) {
                    vector.remove(i);
                }
            }
        });
        
        Thread printThread = new Thread(new Runnable(){
            public void run() {
                for(int i = 0; i &lt; vector.size(); i++) {
                    System.out.println((vector.get(i)));
                }
            }
        });
        
        removeThread.start();
        printThread.start();
        
        while(Thread.activeCount() &gt; 20);
    }
}</code></pre>


<h4>4.1.3 相对线程安全</h4>

<p>这就是我们平时说的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用时不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p>

<h4>4.1.4 线程兼容</h4>

<p>对象本身并不是线程安全的，但是可以在调用端正确使用同步手段来保证对象在并发环境下可以安全使用。</p>

<h4>4.1.5 线程对立</h4>

<p>无论调用端是否采取了同步措施，都无法在多线程环境中并发使用。Java中这种代码很少，但Thread的suspend()和resume()方法就是个例子。如果并发情况下，一个尝试中断，另一个尝试恢复线程，无论调用时是否进行了同步，目标线程都存在死锁风险。这两个方法已经声明为Deprecated.</p>

<h3>4.2 线程安全的实现方法</h3>

<h4>4.2.1 互斥同步</h4>

<p>Java中最基本的互斥同步手段是synchronized关键字。这是一个相对重量级的操作，因为需要进行用户态和核心态的转换。</p>

<p>ReentranLock是另一个同步实现方法。它与synchronized相比，有以下高级功能：</p>

<ul>
<li>等待可中断：如果持有锁的线程长期不释放锁，正在等待锁的线程可以选择放弃。</li>
<li>公平锁：多个线程在等待同一个锁时，必须按照申请的顺序依次获得锁。（synchronized是非公平的。 ReentranLock默认也是非公平的，但通过参数可以要求用公平锁）</li>
<li>锁绑定多个条件：一个ReentranLock对象可以同时绑定多个Condition对象。</li>
</ul>


<p>JDK6之后，虚拟机对synchronized性能进行了优化，已经与ReentranLock持平了，未来优化还会偏向于synchronized。因此如果性能满足需要时，可以优先考虑使用synchronized来同步。</p>

<h4>4.2.2 非阻塞同步</h4>

<p>互斥同步是一种悲观的并发策略，因为不论是否真的存在竞争，它都会加锁。随着硬件指令集的发展，有了另一种选择。基于冲突检测的乐观并发策略，就是先进行操作，如果没有其他线程急用共享数据，那操作就成功。如果产生了冲突，再采取其他的补偿措施。这种乐观的并发策略不需要把线程挂起，因此称为非阻塞同步。</p>

<p>非阻塞同步需要了解CAS指令。它有3个操作数，分别是内存位置（V）、旧的预期值(A)和新值（B）。CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则它就不执行更新。但是无论是否更新了V的值，都会返回V的旧值，这是一个原子操作。</p>

<p>CAS指令看起来很美，但可能产生“ABA”问题。如果V初次读取时是A，并且在准备赋值时检查到它仍然是A，并不能说明它没有被其他线程修改过。因此在此过程中，它可能被改为B，然后再改为A。这时候CAS操作就误以为它从来没有被改变过。当然大部分情况下ABA问题不会影响程序的正确性。</p>

<h3>4.3 JDK的锁优化</h3>

<h4>4.3.1 自旋锁与自适应自旋</h4>

<p>互斥同步对性能最大的影响是阻塞的实现，因为线程挂起和恢复操作都要转入内核态中完成。很多应用中共享数据的锁定状态只会持续很短的时间，为了这个时间去挂起和恢复线程并不值得。因此不妨让后面的请求线程“稍等一下”，执行一个忙循环（自旋），这就是自旋锁。</p>

<p>自旋锁如果占用时间长了，就失去了自旋的意义，因此JDK6之前的自旋锁超过10次仍然没有成功获得锁，就会改用传统的方式去挂起线程。</p>

<p>JDK6引入了自适应的自旋锁，也就是自旋的时间不固定了，会根据前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。例如前几次成功了，就认为后面也会成功。如果自旋很少成功，以后就可能直接省略自旋，避免浪费资源。</p>

<h4>4.3.2 锁消除</h4>

<p>通常基于逃逸分析，如果堆上的数据不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁就无须进行。</p>

<h4>4.3.3 锁粗化</h4>

<p>大部分情况下，我们都要将同步代码块限制得尽量小。但是如果一系列的连续操作导致对同一个对象反复加锁、解锁，虚拟机会把加锁同步的范围扩大，只需要加一次锁就行了。</p>

<h4>4.3.4 轻量级锁</h4>

<p>轻量级锁的依据是：对于绝大部分锁，在整个同步周期内都是不存在竞争的。因此可以在没有多线程竞争的前提下，减少传统重量级锁使用操作系统互斥量产生的性能消耗。实现原理是在对象头（Object Header）的内存中加入锁标志位，利用CAS操作来实现。</p>

<h4>4.3.5 偏向锁</h4>

<p>如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM字节码执行引擎]]></title>
    <link href="http://blog.ubone.com/blog/2015/01/20/jvmzi-jie-ma-zhi-xing-yin-qing/"/>
    <updated>2015-01-20T06:40:46+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/01/20/jvmzi-jie-ma-zhi-xing-yin-qing</id>
    <content type="html"><![CDATA[<p>JVM执行引擎输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。本文从概念模型的角度学习栈帧结构、方法调用和字节码执行。</p>

<!--more-->


<h2>1. 运行时栈帧结构</h2>

<p>栈帧（Stack Frame）是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素，是支持虚拟机进行方法调用和方法执行的数据结构。每个方法从调用开始到执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p>

<p>每个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和额外的附加信息。在编译生成字节码时，栈帧中需要多大的局部变量表、多深的操作数栈就已经完全确定并保存在方法表的Code属性中。</p>

<p>一个线程中的方法调用链可能很长，很多方法同时处于执行状态。但对执行引擎来说，活动线程中，只有栈顶的栈帧才是有效的，称为当前栈帧。与当前栈帧相关联的方法称为当前方法。执行引擎运行的所有字节码指令都只针对当前栈帧操作。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_-2015-01-20_06.59.02.jpg" alt="image" /></p>

<h3>1.1 局部变量表</h3>

<p>局部变量表用于存放方法参数和方法内局部变量，其容量以Variable Slot为最小单位。每个Slot可以存放32位以内的数据类型，包括boolean、byte、char、short、int、float、reference和returnAddress，对于64位的数据类型long和double，会分配2个连续的Slot。由于虚拟机栈是线程的私有数据，因此操作2个Slot不会引起数据安全问题。</p>

<p>虚拟机通过索引定位的方式使用局部变量表，索引值从0到最大Slot数量。在方法执行时，局部变量表完成参数值到数量变量列表的传递过程。如果执行的是实例方法（非static），关键字&#8221;this&#8221;是隐含参数，位于第0个索引，其余参数按照参数表顺序排列。</p>

<p>为了节省栈帧空间，Slot是可以重用的，因为方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用。但这也会有一些副作用，示例如下：</p>

<pre class='line-numbers language-java'><code class='language-java'>public static void main(String[] args) {
    {
        byte[] placeholder = new byte[64*1024*1024];//64MB
    }
    
    int a = 0; //!
    System.gc();
}</code></pre>


<p>上面的代码，如果没有<code>int a</code>那一行，从逻辑上讲应该能够回收placeholder的内存，但实际上并非如此。原因就是代码虽然已经离开了placeholder的作用域，但在此之后，没有任何对局部变量表的读写操作，placeholder占用的Slot还没有被其他变量复用，所以GC Roots一部分的局部变量表仍然保持对它的关联。因此加上<code>int a</code>那一行就能够正常回收了。</p>

<p>因此，如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用大量内存，实际上已经不再会使用的变量，手动将其设置为null以帮助内存回收也是有意义的。需要注意的是，在日常编程时，没必要过度依赖将变量设置为null，因为编译器优化和JIT编译都可能使赋null语句被优化掉。</p>

<p>此外，局部变量并没有类变量和实例变量那样存在“准备阶段”，因此不会自动赋予系统初始值。</p>

<h3>1.2 操作数栈</h3>

<p>操作数栈（Operand Stack）也常称为操作栈，它是后入先出（LIFO）栈。当一个方法开始执行时，它的操作数栈是空的。在方法执行过程中，会有各种字节码指令往操作数栈写入和提取内容。</p>

<p>在概念模型中，两个栈帧是完全独立的。但大多虚拟机实现都会做优化，让两个栈帧出现一部分重叠。让下面的栈帧的部分操作数栈与上面的栈帧的部分局部变量表重叠在一起，无须进行额外的参数复制。</p>

<h3>1.3 动态连接</h3>

<p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。</p>

<h3>1.4 方法返回地址</h3>

<p>当方法开始执行后，有两种方式退出。一是遇到方法返回的字节码指令；二是遇到异常并且这个异常没有在方法体内得到处理。无论哪种退出方式，方法退出之后都要返回到方法被调用的位置。一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是通过异常处理器表来确定的，栈帧中一般不会保存此信息。</p>

<p>方法退出的过程就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，修改PC计数器的值以指向后一条指令等。</p>

<h3>1.5 附加信息</h3>

<p>各虚拟实现时会增加一些规范中没有描述的信息放到栈帧中，例如与调试相关的信息。</p>

<h2>2. 方法调用</h2>

<p>方法调用并不是方法执行，此阶段的唯一任务是确定被调用方法的版本，即调用哪一个方法。</p>

<h3>2.1 解析（Resolution）</h3>

<p>所有方法调用中的目标方法在Class文件里都是一个常量池中的符号引用。在解析阶段，会将其中一部分符号引用转化为直接引用：如果方法在真正运行之前就有一个可确定的调用版本，并且这个调用版本在运行期是不可改变的，那么就会被转化为直接引用。</p>

<p>符合这个条件的有静态方法、私有方法、实例构造器和父类方法4类。这4类方法和final方法都称为非虚方法。非虚方法在编译期间就完成了解析调用，将符号引用转变为可确定的直接引用。</p>

<h3>2.2 分派（Dispatch）</h3>

<p>分派与解析相反，要在运行时确定调用哪个版本的方法。这是多态特性的体现。分派可能是静态或动态的，根据分派的依据又分为单分派和多分派。</p>

<h4>2.2.1 静态分派</h4>

<p>首先明确什么是静态类型和实际类型，看下面的代码：</p>

<pre class='line-numbers language-java'><code class='language-java'>public class Human{...}
public class Man extends Human{...}
public class Woman extends Human{...}

public void sayHello(Human h) {print("human");}
public void sayHello(Man h) {print("man");}
public void sayHello(Woman h) {print("woman");}

public static void main(String[] args) {
    Human man = new Man();
    syaHello(man); //会打印什么呢？
}</code></pre>


<p>在main方法中，Human称为变量的Static类型或Apparent类型，而Man则为变量的实际类型。</p>

<p>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是方法重载(Overload)。虚拟机在重载时通过参数的静态类型而不是实际类型作为判定依据。并且静态类型是编译期可知的，因此在编译阶段，编译器会根据参数的静态类型决定使用哪个方法的重载版本。所以main方法中会打印human.</p>

<h4>2.2.2 动态分派</h4>

<p>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。典型应用是方法重写(Override)。</p>

<h4>2.2.3 单分派与多分派</h4>

<p>方法的接收者和方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以分为单分派和多分派。单分派根据一个宗量对目标方法进行选择，而多分派则根据多于一个宗量对目标方法进行选择。</p>

<p>根据上面的知识，可以得知：Java是一门静态多分派，动态单分派的语言。</p>

<h4>2.2.4 虚拟机动态分派的实现</h4>

<p>由于动态分派是非常频繁的动作，需要在运行时中确定，因此虚拟机的实现基于性能考虑，并不会进行频繁的搜索，而是采用虚方法表来提高性能。</p>

<p>虚方法表中存放了各个方法的实际入口。如果某个方法在子类中没有被重写，那么子类的虚方法表里面的地址入口与父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类重写了这个方法，则子类方法表中的地址将会替换为指向子类实现版本的入口地址。</p>

<p>方法表一般在类加载的连接阶段进行初始化，类的变量初始值后，会把该类的方法表也初始化。</p>

<h2>3. 基于栈的字节码解释执行引擎</h2>

<p>虚拟机执行Java代码时有解释执行和编译执行。先学习一下解释执行。</p>

<p>Java编译器输出的指令流，基本是一种基于栈的指令集架构（Instruction Set Architecture, ISA），指令流中的指令大部分是零地址指令，它们依赖操作数栈工作。相对应的，x86使用的是基于寄存器的指令集。</p>

<p>基于栈的指令集主要优点是可移植，但缺点是执行速度会稍慢一些，因为出栈入栈操作本身就产生了相当多的指令数量，而且栈实现是在内存中，比寄存器的速度慢了很多。</p>

<p>通过一段代码来学习基于栈的解释器执行过程。</p>

<pre class='line-numbers language-java'><code class='language-java'>public int calc() {
    int a = 100;
    int b = 200;
    int c = 300;
    return (a+b) *c;
}</code></pre>


<p>对应的字节码：</p>

<pre class='line-numbers language-java'><code class='language-java'>public int calc();
Code:
stack=2, Locals=4, Args_size=1
0: bipush 100       //将单字节的整数常量值(-128~`17)推入操作数栈
2: istore_1     //将操作数栈顶的整形值出栈并存放到第1个局部变量Slot中
3: sipush 200       //与0类似
6: istore_2
7: sipush 300       
10:istore_3
11:iload_1      //将局部变量表第1个Slot的整型值复制到操作数栈顶
12:iload_2      //将局部变量表第2个Slot的整型值复制到操作数栈顶
13:iadd     //将操作数栈中的头两个栈顶出栈，相加，再将结果入栈
14:iload_3      //把第3个Slot的300压入操作数栈
15:imul     //将操作数栈中头两个栈顶出栈，相乘，将结果入栈
16:ireturn      //结束方法执行，将操作数栈顶的整数返回</code></pre>


<p>上面的示例可以看出中间变量都以操作数栈的入栈和出栈为信息交换途径。以上执行过程只是概念模型，实际执行时虚拟机会做优化。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Titanium UI及最佳实践]]></title>
    <link href="http://blog.ubone.com/blog/2015/01/13/titanium-uiji-zui-jia-shi-jian/"/>
    <updated>2015-01-13T21:05:37+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/01/13/titanium-uiji-zui-jia-shi-jian</id>
    <content type="html"><![CDATA[<p>学习Titanium的UI，以及Titanium相关的最佳实践。</p>

<!--more-->


<h2>1. User Interface</h2>

<h3>1.1 基础</h3>

<p>布局属性：</p>

<ul>
<li>width</li>
<li>height</li>
<li>left</li>
<li>right</li>
<li>top</li>
<li>bottom</li>
<li>center: 其属性x和y，表示view中心相对父容器的left, top</li>
<li>layout: &ldquo;vertical&rdquo;, &ldquo;horizontal&rdquo; or &ldquo;composite&#8221;，默认为composite，值absolute也是composite</li>
<li>size: 只读，当自己与下级渲染完后才有值。</li>
<li>rect: 只读</li>
<li>zIndex: 整数，值大的位于上层</li>
</ul>


<p>Titanium.UI.FILL and Titanium.UI.SIZE</p>

<table>
<thead>
<tr>
<th>Name </th>
<th> Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>width </td>
<td> If width is defined, it takes precedence and the positioning pins are not used to determine the view&rsquo;s width. If width is not defined, and at least two horizontal positioning pins are defined, the width is calculated implicitly from the pins. For example, left and right or left and center.x. If all three horizontal pins are defined, the width is determined by the left and center.x pins. If width cannot be implicitly calculated it follows the view&rsquo;s default sizing behavior.</td>
</tr>
<tr>
<td>left </td>
<td> If left is defined, it always takes precedence for positioning the view horizontally.</td>
</tr>
<tr>
<td>center.x </td>
<td> Used to position the view horizontally if left is not set. If left is set, this property is not used to position the view, although it may be used to determine its width.</td>
</tr>
<tr>
<td>right </td>
<td> Used to position the view horizontally when neither left or center.x is set. If either left or center.x is set, this property is not used to position the view, although it may be used to determine its width.</td>
</tr>
<tr>
<td>height </td>
<td> If height is defined, it takes precedence and the positioning pins are not used to determine the view&rsquo;s height. If height is not defined, and at least two vertical positioning pins are defined, the height is determined implicitly from the pins. If all three vertical pins are defined, the height is determined by the top and center.y pins. If height cannot be implicitly calculated it follows the view&rsquo;s default sizing behavior.</td>
</tr>
<tr>
<td>top </td>
<td> If specified, always takes precedence for positioning the view horizontally.</td>
</tr>
<tr>
<td>center.y </td>
<td> Used to position the view vertically if top is not set. If top is defined, this property is not used to position the view, although it may be used to determine its height.</td>
</tr>
<tr>
<td>bottom </td>
<td> Used to position the view vertically if neither top or center.y is set. If either top or center.y is set, this property is ignored. this property is not used to position the view, although it may be used to determine its height.</td>
</tr>
</tbody>
</table>


<p>为了防止重新布局影响性能，可以使用批量操作：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>myView.applyProperties({
  top: 50,
  left: 50,
  width: 200
});</code></pre>


<p>使用rect属性可以获取控件的位置、大小。由于布局是异步发生，因此可能需要在postlayout事件之后去获取rect。示例如下：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var postLayoutCallback  = function(e){
  Ti.API.info(String.format("Layout done, left: %f, width: %f", myView.rect.x, myView.rect.width));
  myView.removeEventListener('postlayout', postLayoutCallback);
}
myView.addEventListener('postlayout', postLayoutCallback);
myView.updateLayout({
  left: '25%',
  width: '25%'
});</code></pre>


<p>注意！如果在postlayout事件中修改view的大小，会导致死循环！此外，为了性能，只监听特定view的postlayout事件，而不是整个窗口。一些非布局的参数变化也可能导致触发此事件，例如设置label的text。</p>

<p><strong>尺寸单位</strong></p>

<table>
<thead>
<tr>
<th>Unit </th>
<th> Abbreviation </th>
<th> Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>pixels </td>
<td> px </td>
<td></td>
</tr>
<tr>
<td>density-independent pixels </td>
<td> dip or dp </td>
<td> Equivalent to Apple &ldquo;points.&rdquo;</td>
</tr>
<tr>
<td>inches  </td>
<td> in </td>
<td></td>
</tr>
<tr>
<td>millimeters </td>
<td> mm</td>
<td> Android, iOS only</td>
</tr>
<tr>
<td>centimeters </td>
<td> cm </td>
<td> Android, iOS only</td>
</tr>
<tr>
<td>points </td>
<td> pt</td>
<td> 1/72 of an inch. Android only. Not to be confused with Apple &ldquo;points.&rdquo;</td>
</tr>
</tbody>
</table>


<p>On Android, a density-independent pixel (DIP) corresponds to one pixel on a 160DPI display.</p>

<p>On iOS, a DIP corresponds to one pixel on a non-Retina display, which is 163DPI for iPhone/iPod touch and 132DPI for the iPad. A DIP corresponds to 2 pixels of width or height on a Retina display.</p>

<p>如果未指定，系统默认为：Android(pixels), iOS(DIP), WEB(DIP)</p>

<p><strong>Horizontal and Vertical Layouts</strong></p>

<p>对于垂直布局，child.width = FILL时，充满父容器的width; child.height = FILL时，充满父容器剩余的高度，后续加入的child将超出父容器高度，因此不可见。</p>

<p>对于水平布局，child一个一个往右排。如果horizontalWrap=true, 排不下时会换行，否则只会排成一行。</p>

<p>这两种情况，left和right都用于水平padding, top和bottom用于垂直位置。</p>

<p><strong>冲突时的解决办法：</strong></p>

<ul>
<li>当控件使用SIZE，而计算出来的尺寸超过父容器，则以父容器边界为准。</li>
<li>当控件使用FILL，父容器使用SIZE，则父容器按控件FILL走，不停扩大，直到遇到边界限制（例如祖父有限制）。</li>
<li>当控件使用百分比，而父容器使用SIZE，结果不确定。</li>
</ul>


<p>查看<a href="http://docs.appcelerator.com/titanium/latest/#!/guide/Transitioning_to_the_New_UI_Layout_System-section-30088148_TransitioningtotheNewUILayoutSystem-BehaviorChangesinRelease2.0">布局示例</a>。</p>

<h3>1.2 事件处理</h3>

<p>常用事件：click、swipe、scroll、dblclick、doubletap、touchstart, touchmove, touchend等等。一些模块还有自己的事件。</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>element.addEventListener('event_type', function(e) {
 // code here is run when the event is fired
 // properties of the event object 'e' describe the event and object that received it
    Ti.API.info('The '+e.type+' event happened');
});</code></pre>


<p>回调方法的e通常包含以下信息：</p>

<ul>
<li>x和y，事件（如touch）发生时，在view内的坐标。</li>
<li>globalPoint: （仅iOS）事件发生时，在屏幕中的坐标。</li>
<li>type: 事件类型名</li>
<li>source: 事件主体</li>
</ul>


<p>事件可以从当前View往parent View bubbling。Titanium.Event有两个参数控制bubbling: bubbles(boolean)表示事件是否能buggle，只读；cancelBubble(boolean)，如果设置为true则停止bubble。此外，所有View类组件还有一个属性bubbleParent，是可改的。用于表示事件是否bubble给上级。需要注意的是，当手指拿起时，可能触发了touchup, click, tap事件，在touchup事件中设置cancelBubble=true并不会阻止tap或click事件触发和bubble. 在代码中也可以触发事件：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>someButton.fireEvent('click');
//或者传参
someButton.fireEvent('click', {kitchen: 'sink'});
//注意获取kitchen的代码
someButton.addEventListener('click', function(e){
    Ti.APP.info('The value of kitchen is '+e.kitchen);
});</code></pre>


<p><strong>自定义事件</strong>：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>deleteButton.addEventListener('click', function(e){
 // when something happens in your app
    database.doDelete(e.whichRecord);
 // fire an event so components can react
    theTable.fireEvent('db_updated');
});
// ... elsewhere in your code
theTable.addEventListener('db_updated', function(e){
    theTable.setData(database.getCurrentRecords());
});</code></pre>


<p><strong>全局事件</strong>，使用Ti.APP。<strong>注意尽量避免使用全局事件</strong>，因为很容易导致内存无法正确释放。</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>deleteButton.addEventListener('click', function(e){
 // when something happens in your app
    database.doDelete(e.whichRecord);
 // fire a global event so components can react
    Ti.App.fireEvent('db_updated');
});
// ... elsewhere in your code
Ti.App.addEventListener('db_updated', function(e){
    theTable.setData(database.getCurrentRecords());
    someOtherComponent.doSomethingElse();
});</code></pre>


<p><strong>移除事件监听：</strong></p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>function doSomething(e) {
 // do something
}
deleteButton.addEventListener('click', doSomething);
// ... elsewhere in your code ...
deleteButton.removeEventListener('click', doSomething);
});</code></pre>


<p><strong>特殊事件：</strong></p>

<table>
<thead>
<tr>
<th>Event </th>
<th> Fired when &hellip;</th>
</tr>
</thead>
<tbody>
<tr>
<td>androidback </td>
<td> The back button is released</td>
</tr>
<tr>
<td>androidhome </td>
<td> The home button is released</td>
</tr>
<tr>
<td>androidsearch </td>
<td> The search button is released</td>
</tr>
<tr>
<td>androidcamera </td>
<td> The camera button is released</td>
</tr>
<tr>
<td>androidfocus </td>
<td> Fired when the camera button is pressed halfway and then released.</td>
</tr>
<tr>
<td>androidvolup </td>
<td> The volume-up rocker button is released</td>
</tr>
<tr>
<td>androidvoldown </td>
<td> The volume-down rocker button is released</td>
</tr>
</tbody>
</table>


<p>所有涉及Ti.的事件都需要在JavaScript与Native之间进行转换，因此尽量使用Underscore的事件处理。另外，将事件监听尽可能地延后，有助于提高系统响应速度。所有全局事件监听一直是活着的，因此监听中引用的局域变量也一直活着，这将可能导致内存泄露。</p>

<h2>2. Titanium最佳实践</h2>

<h3>2.1 JavaScript建议</h3>

<p>避免使用全局变量，Objects are placed in the global scope when:</p>

<ul>
<li>You declare a variable outside of a function or CommonJS module. Using a modular pattern will alleviate this problem.</li>
<li>You omit the var keyword when declaring a variable (within or outside of a function). So always use var when declaring variables.</li>
</ul>


<p>避免在全局事件监听中引用局部对象，下面的代码是个坏例子：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var someFunction = function() {
    var table = Ti.UI.createTableView(),
        label = Ti.UI.createLabel(),
        view = Ti.UI.createView();
    Ti.App.addEventListener('bad:move', function(e) {
        table.setData(e.data);
    });
    view.add(table);
    view.add(label);
 return view;
};</code></pre>


<p>所有Ti命名空间都与Native相关，因此应避免通过prototype扩展，同时使用缓存来避免多次调用Native方法。如下例：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var isAndroid = (Ti.Platform.osname=='android') ? true : false;
if(isAndroid) {
 // do Android specific stuff
} else {
 // do iOS stuff
}</code></pre>


<p>多个Controller以及CommonJS Module之间，可以使用trigger， on等方法实现事件触发和监听。不要使用Ti相关fireEvent，因为只要涉及Ti都会产生Native与Javascript之间的接口。</p>

<p>变量、属性和方法等不要使双下划线，这是Alloy内部使用的。不要使用JavaScript保留关键字。</p>

<p>Wrap self-calling functions in parenthesis， 这种模式有利于包装局部变量。</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var myValue = function() {
 //do stuff
 return someValue;
}();

//这样写更容易明白返回的是值，而不是一个方法。
var myValue = (function() {
 //do stuff
 return someValue;
})();</code></pre>


<p><strong>提高遍历的效率</strong>，通过保存数组的length:</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var names = ['Jeff','Nolan','Marshall','Don'];
for(var i=0;i&lt;names.length;i++){
    process(names[i]);
}

// I can check the array length only once
var names = ['Jeff','Nolan','Marshall','Don'];
for(var i=0,j=names.length;i&lt;j;i++){
    process(names[i]);
}</code></pre>


<h3>2.2 CommonJS Module</h3>

<p>主要有两种方式来创建CommonJS Module。方式一采用exports方法：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>exports.sayHello = function(name) {
    Ti.API.info('Hello '+name+'!');
};
exports.version = 1.4;
exports.author = 'Don Thorp';</code></pre>


<p>另一种方式公开的方法主要以对象构造器的方式：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>function Person(firstName,lastName) {
 this.firstName = firstName;
 this.lastName = lastName;
}
Person.prototype.fullName = function() {
 return this.firstName+' '+this.lastName;
};
//注意是module.exports
module.exports = Person;</code></pre>


<p>前者使用<code>exports.xxx</code>，后者使用<code>module.exports</code>，这两种方式不要在同一个module中混合使用！</p>

<p>每个module都有自己的scope，只有export的方法才是公开的。注意如果exports属性，该值可能不会改变：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>//statefulModule.js
var _stepVal = 5; // default
exports.setPointStep = function(value) {
  _stepVal = value;
};
exports.getPointStep = function() {
 return _stepVal;
};
exports.stepVal = _stepVal;

//app.js
var stateful = require('statefulModule');
stateful.setPointStep(10);
stateful.getPointStep(); //10
stateful.stepVal //值永远是初始值5.</code></pre>


<h3>2.3 数据库</h3>

<p><strong>每次操作都打开并关闭数据库和resultset</strong></p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>cityWeatherRS.close(); // close the resultset when you're done reading from it
db.close(); // and close the database connection</code></pre>


<p><strong>批量操作时，使用事务</strong></p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var db = Ti.Database.open('myDatabase');
db.execute('BEGIN'); // begin the transaction
for(var i=0, var j=playlist.length; i &lt; j; i++) {
    var item = playlist[i];
    db.execute('INSERT INTO albums (disc, artist, rating) VALUES (?, ?, ?)', item.disc, item.artist, item.comment);
}
db.execute('COMMIT');
db.close();</code></pre>


<h3>2.4 图片</h3>

<blockquote><ul>
<li>PNG – PNG images are in a lossless-compressed format that can support high-color images. This format is best suited to line-art, text, and icons. It is a better choice than GIF in almost all cases.</li>
<li>JPG – JPG (or JPEG) is lossy-compressed file format best suited for photographs. It is not well-suited for text, line drawings, or icons because of visual artifacts created during the compression process that will reduce quality and readability.</li>
<li>因此：</li>
<li>Photos? Use JPG</li>
<li>Text, line drawings, icons, button graphics? Use PNG</li>
<li>Flip-book style animations (for which animated GIFs would be the traditional choice)? Use the ImageView&rsquo;s images property and pass to it an array of PNG or optimized JPG files.</li>
</ul>
</blockquote>

<p>注意：显示JPG图片时，会在内存中解压缩，因此不要一次创建太多的JPG ImageView，否则将耗尽内存。将imageView从view中移除并不会回收内存，还要将imageView设置为null.</p>

<p>为了减少ipa/apk的大小，需要对图片进行优化。见<a href="http://docs.appcelerator.com/titanium/latest/#!/guide/Image_Best_Practices">Titanium文档</a>。</p>

<p>ImageView已经能够显示本地和远程的图片。显示远程图片时，可以先设置defaultImage，下载成功后会自动显示远程图片。这些图片会缓存，对于Android会缓存到应用退出。要自己控制缓存到本地目录，参考<a href="http://docs.appcelerator.com/titanium/latest/#!/guide/Image_Best_Practices">文档</a>。</p>

<h3>2.5 管理内存</h3>

<p>除了把View移除外，还需要将它设置为null.</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var button = Ti.UI.createButton({
 // parameters go here...
});
var view = Ti.UI.createView({
 // some parameters here...
});
view.add(button);
// ... later
win.remove(view);  // view & button still exist
view = null; // deletes the view and its proxy, but not the button!
// compare that to:
var view = Ti.UI.createView({
 // some parameters here...
});
view.add(Ti.UI.createButton({
 // parameters go here...
}));
// ... later
win.remove(view);
view = null; // deletes the view, button, and their proxies</code></pre>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Titanium Alloy MVC]]></title>
    <link href="http://blog.ubone.com/blog/2015/01/11/titanium-alloy-mvc/"/>
    <updated>2015-01-11T19:25:14+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/01/11/titanium-alloy-mvc</id>
    <content type="html"><![CDATA[<p>这是一篇学习笔记，主要内容是Alloy的Controller, Model, Collection, View以及Widget.</p>

<!--more-->


<h2>1. Alloy Controllers</h2>

<p>创建Controller和获得View: Alloy.createController and Controller.getView.</p>

<p>可以继承：exports.baseController = &lsquo;baseControllerName&#8217;，子类继承父类export的方法，并可以重写。</p>

<p>可以在Controller中判断当前平台：OS_ANDROID, OS_BLACKBERRY, OS_IOS, OS_MOBILEWEB, ENV_DEV, ENV_TEST, ENV_PRODUCTION, DIST_ADHOC, DIST_STORE:</p>

<p><code>if (OS_IOS) {...}</code></p>

<p>传参：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>//index.js
var arg = {
        title: source[i].postTitle,
        url: source[i].postLink
    };
    data.push(Alloy.createController('row', arg).getView());

//row.js
var args = arguments[0] || {};
$.rowView.title = args.title || '';
$.rowView.url = args.url || '';
</code></pre>


<p>使用Alloy.Globals命名空间可以保存全局变量：<code>Alloy.Globals.xxx = ...</code></p>

<p>alloy.js运行于应用的生命周期之前，会在index.js加载之前调用，也就是任何UI加载之前。</p>

<p>lib文件夹用于类库，也可以建立平台子文件夹（如ios）。但require时，不需要指定平台名。</p>

<p>当前，Controller已经默认加载了Alloy, Underscore.js和Backbone.js，但以后可能需要自己加载：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var Alloy = require('alloy'), _ = require("alloy/underscore")._, Backbone = require("alloy/backbone");</code></pre>


<h2>2. Alloy Models</h2>

<h3>2.1 Alloy Collection and Model Objexts</h3>

<h4>2.1.1 Models</h4>

<p>In Alloy, models inherit from the <a href="http://docs.appcelerator.com/backbone/0.9.2/#Model">Backbone.Model</a> class.</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>exports.definition = {
    config : {
 // table schema and adapter information
    },
    extendModel: function(Model) {      
        _.extend(Model.prototype, {
 // Extend, override or implement Backbone.Model 
        });
 
 return Model;
    },
    extendCollection: function(Collection) {        
        _.extend(Collection.prototype, {
 // Extend, override or implement Backbone.Collection 
        });
 
 return Collection;
    }
}</code></pre>


<p>在Controller中访问Model:</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var book = Alloy.createModel('book', {title:'Green Eggs and Ham', author:'Dr. Seuss'}); 
var title = book.get('title');
var author = book.get('author');
// Label object in the view with id = 'label'
$.label.text = title + ' by ' + author;</code></pre>


<p>全局Model单例：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>// This will create a singleton if it has not been previously created,
// or retrieves the singleton if it already exists.
var book = Alloy.Models.instance('book');</code></pre>


<h5>2.1.1.1 定义表结构</h5>

<p>config对象有三部分：columns, defaults和adapter.</p>

<p>columns定义表结构。对应SQLite，支持以下类型：string, varchar, int, tinyint, smallint, bigint, double, float, decimal, number, date, datetime and boolean，其它未知类型将视为TEXT。</p>

<p>defaults对象用于设置默认值。</p>

<p>adapter对象定义存储接口。</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>exports.definition = {
    config: {
 "columns": {
 "title": "String",
 "author": "String",
 "book_id": "INTEGER PRIMARY KEY AUTOINCREMENT" //自增长
        },
 "defaults": { //默认值
 "title": "-",
 "author": "-"
        },
 "adapter": { 
 "type": "sql", //存储类型SQLite
 "collection_name": "books", //表名
  "idAttribute": "book_id" //主键
        }
    }
}</code></pre>


<h5>2.1.1.2 Extending the Backbone.Model Class</h5>

<p>在extendModel中扩展方法，例如validate方法.</p>

<h4>2.1.2 Collections</h4>

<p>在Controller中创建Collection，作用域为本Controller:</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var library = Alloy.createCollection('book'); 
library.fetch(); // Grab data from persistent storage </code></pre>


<p>创建全局单例Collection:</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>// This will create a singleton if it has not been previously created,
// or retrieves the singleton if it already exists.
var library = Alloy.Collections.instance('book');</code></pre>


<p>在extendCollection中定义扩展Backbone的方法，例如：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>// Implement the comparator method.
comparator : function(book) {
    return book.get('title');
}</code></pre>


<p></p>

<p>Backbone.Collection继承了underscore的一些集合操作方法，例如迭代：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var data = [];
library.map(function(book) {
 // The book argument is an individual model object in the collection
    var title = book.get('title');
    var row = Ti.UI.createTableViewRow({"title":title});
    data.push(row);
});
// TableView object in the view with id = 'table'
$.table.setData(data);</code></pre>


<p>事件处理：use the Backbone.Events on, off and trigger methods</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var library = Alloy.createCollection('book');
function event_callback (context) {
    var output = context || 'change is bad.';
    Ti.API.info(output);
};
// Bind the callback to the change event of the collection.
library.on('change', event_callback);
// Trigger the change event and pass context to the handler.
library.trigger('change', 'change is good.');
// Passing no parameters to the off method unbinds all event callbacks to the object.
library.off();
// This trigger does not have a response.
library.trigger('change');</code></pre>


<p>注意：如果事件名称不要使用空格。因为Backbone使用了空格来处理多事件。</p>

<h3>2.2 Alloy Data Binding</h3>

<p>当Collection或Model变化时，View也跟随变化，这就是绑定.</p>

<p><strong>注意：如果使用绑定，必须在controller关闭时，调用<code>$.destroy()</code>方法，以避免内存泄露:</strong></p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>$.win.addEventListener("close", function(){
    $.destroy();
} </code></pre>


<h4>2.2.1 Collection-View Binding</h4>

<p>以下View对象支持Collection绑定：</p>

<table>
<thead>
<tr>
<th>View Object </th>
<th> Add data binding attributes to&hellip; </th>
<th> Repeater Object</th>
</tr>
</thead>
<tbody>
<tr>
<td>ButtonBar </td>
<td> <code>&lt;Labels&gt;</code> </td>
<td> <code>&lt;Label/&gt;</code></td>
</tr>
<tr>
<td>CoverFlowView </td>
<td> <code>&lt;Images&gt;</code> </td>
<td> <code>&lt;Image/&gt;</code></td>
</tr>
<tr>
<td>ListView </td>
<td> <code>&lt;ListSection&gt;</code> </td>
<td> <code>&lt;ListItem/&gt;</code></td>
</tr>
<tr>
<td>Map Module </td>
<td> <code>&lt;Module module="ti.map" method="createView"&gt;</code>  </td>
<td> <code>&lt;Annotation/&gt;</code></td>
</tr>
<tr>
<td>Picker </td>
<td> <code>&lt;PickerColumn&gt;</code> or <code>&lt;Column&gt;</code> </td>
<td> <code>&lt;PickerRow/&gt;</code> or <code>&lt;Row/&gt;</code></td>
</tr>
<tr>
<td>ScrollableView </td>
<td> <code>&lt;ScrollableView&gt;</code> </td>
<td> <code>&lt;View/&gt;</code></td>
</tr>
<tr>
<td>TableView </td>
<td> <code>&lt;TableView&gt;</code> </td>
<td> <code>&lt;TableViewRow/&gt;</code></td>
</tr>
<tr>
<td>TabbedBar </td>
<td> <code>&lt;Labels&gt;</code> </td>
<td> <code>&lt;Label/&gt;</code></td>
</tr>
<tr>
<td>Toolbar </td>
<td> <code>&lt;Items&gt;</code> </td>
<td> <code>&lt;Item/&gt;</code></td>
</tr>
<tr>
<td>View </td>
<td> <code>&lt;View&gt;</code> </td>
<td> 除了Window和TabGroup之外的View对象</td>
</tr>
</tbody>
</table>


<p>在XML中定义以下元素，其中只有dataCollection是必须的：</p>

<ul>
<li>dataCollection: 指定一个Collection</li>
<li>dataTransform: 回调方法，传入model，返回修改的JSON对象</li>
<li>dataFilter: 过滤collection, 传入collection, 返回model数组</li>
<li>dataFunction: 指定一个方法名，controller使用这个方法来更新view。这个方法不是controller中声明的方法。该属性创建一个别名访问内在的绑定方法。（<a href="http://docs.appcelerator.com/titanium/latest/#!/guide/Alloy_Data_Binding-section-36739592_AlloyDataBinding-BackboneBinding">没搞懂</a>）</li>
</ul>


<p>对于Collection中的model，xml中可以使用<code>{}</code>来获取model的值，例如：<code>&lt;Label text="{title} by {author}" /&gt;</code>。</p>

<p>在repeater对象的controller中，可以使用<code>$model</code>来引用当前model。如<code>$model.title</code></p>

<p>Collection绑定示例：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>app/views/index.xml
&lt;Alloy&gt;
    &lt;Collection src="book"/&gt;
    &lt;Window backgroundColor="white" onClose="cleanup"&gt;
        &lt;ScrollableView dataCollection="book"&gt;
            &lt;View layout="vertical"&gt;
                &lt;ImageView image="{cover}" /&gt;
                &lt;Label text="{title} by {artist}" /&gt;
            &lt;/View&gt;
        &lt;/ScrollableView&gt; 
    &lt;/Window&gt;
&lt;/Alloy&gt;

app/controllers/index.js
$.index.open();
Alloy.Collections.album.fetch();
 
function cleanup() {
    $.destroy();
}
</code></pre>


<h4>2.2.2 Model-View Binding</h4>

<pre class='line-numbers language-javascript'><code class='language-javascript'>&lt;Alloy&gt;
    &lt;Model src="settings"/&gt;
    &lt;Window backgroundColor="white" onClose="cleanup"&gt;
        &lt;View layout="vertical"&gt;
            &lt;Label text="Text Size" /&gt;
            &lt;Slider value="{settings.textsize}" max="5" min="1"/&gt;
            &lt;Label text="Bold"/&gt;
            &lt;Switch value="{settings.bold}" /&gt;
            &lt;Label text="Italics"/&gt;
            &lt;Switch value="{settings.italics}" /&gt;
        &lt;/View&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt;</code></pre>


<p>上例中，获取值使用的格式为：<code>{modelName.attrName}</code></p>

<h4>2.2.3 Collection方法示例</h4>

<pre class='line-numbers language-javascript'><code class='language-javascript'>app/views/index.xml
&lt;Alloy&gt;
    &lt;Collection src="book" /&gt;
    &lt;Window class="container"&gt;
        &lt;TableView dataCollection="book"
                   dataTransform="transformFunction"
                   dataFilter="filterFunction"
                   dataFunction="updateUI"
                   onDragEnd="refreshTable"&gt;
            &lt;!-- Also can use Require --&gt;
            &lt;TableViewRow title="{title}" /&gt;
        &lt;/TableView&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt;

app/controllers/index.js
$.index.open();
 
// Encase the title attribute in square brackets
function transformFunction(model) {
 // Need to convert the model to a JSON object
    var transform = model.toJSON();
    transform.title = '[' + transform.title + ']';
 // Example of creating a custom attribute, reference in the view using {custom}
    transform.custom = transform.title + " by " + transform.author;
 return transform;
}
// Show only book models by Mark Twain
function filterFunction(collection) {
 return collection.where({author:'Mark Twain'});
}
 
function refreshTable(){
 // Trigger the binding function identified by the dataFunction attribute
    updateUI();
}
// Trigger the synchronization
var library = Alloy.Collections.book;
library.fetch();
 
// Free model-view data binding resources when this view-controller closes
$.index.addEventListener('close', function() {
    $.destroy();
});</code></pre>


<p>当数据变化时，上面的例子中的界面会跟着变化。如果想避免发生变化，可以在调用Backbone方法修改model数据时指定参数：<code>{silent:true}</code>.</p>

<h3>2.3 Alloy数据持久化与升级</h3>

<p>Model数据可以同步到本地或远程服务器。这项功能使用的是Backbone sync方法。</p>

<h4>2.3.1 Backbone同步方式</h4>

<p>Backbone sync时，默认会执行RESTful JSON请求到Model.urlRoot或者Collection.url。读操作使用GET方法，写操作使用POST方法。不论Model是否定义了自己的主键，Backbone都会创建Client ID(cid)。在未保存前，可以使用Model.cid或者Collection.getByCid方法来存取数据。Backbone同步示例：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>// Since the urlRoot attribute is defined, all HTTP commands are to /library
var Book = Backbone.Model.extend({urlRoot:'/library'})
var book = new Book();
 
// Performs a POST on /library with the arguments as a payload and the server returns the id as 1
book.save({title:'Bossypants',author:'Tina Fey',checkout:false}) 
 
// Performs a GET on /library/1
book.fetch({id:1}); 
 
// Performs a PUT on /library/1 with the entire modified object as a payload.
book.save({checkout:true});
 
// Performs a DELETE on /library/1
book.destroy();</code></pre>


<h4>2.3.2Alloy的同步方式</h4>

<p>Alloy支持SQLite或者properties来保存数据。Alloy查询SQLite时，可以使用简单查询或者prepared statement:</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var library = Alloy.createCollection('book');
// The table name is the same as the collection_name value from the 'config.adapter' object. This may be different from the model name.
var table = library.config.adapter.collection_name;
// use a simple query
library.fetch({query:'SELECT * from ' + table + ' where author="' + searchAuthor + '"'});
// or a prepared statement
library.fetch({query: { statement: 'SELECT * from ' + table + ' where author = ?', params: [searchAuthor] }});

//查询1条记录：
myModel.fetch({id: 123});
// is equivalent to
myModel.fetch({query: 'select * from ... where id = ' + 123 });</code></pre>


<h4>2.3.3 数据库迁移（升级或降级）</h4>

<p>Alloy采用migration对象来迁移数据库。首先，要将相应的JavaScript文件放在app/migrations文件夹下。文件名采用以下格式：<code>YYYYMMDDHHmmss_MODELNAME.js</code>，例如20150120160155_book.js。Alloy将升序执行js文件以完成数据库迁移。</p>

<p>JavaScript文件中要实现两个方法：migration.up(migrator) 和 migration.down(migrator)。migrator对象的值如下：</p>

<table>
<thead>
<tr>
<th>Key </th>
<th> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>db </td>
<td> Ti.Database实例，可以调用db.execute方法执行SQL。<strong>注意不要关闭或打开另一个实例。</strong></td>
</tr>
<tr>
<td>dbname </td>
<td> 数据库名</td>
</tr>
<tr>
<td>table </td>
<td> table名，也就是Model的config.adapter.collection_name值</td>
</tr>
<tr>
<td>idAttribute </td>
<td> 主键字段名</td>
</tr>
<tr>
<td>createTable </td>
<td> 创建表的方法，参数为Model config.columns</td>
</tr>
<tr>
<td>dropTable </td>
<td> 删除表</td>
</tr>
<tr>
<td>insertRow </td>
<td> 插入行, 参数为待插入的数据对象</td>
</tr>
<tr>
<td>deleteRow </td>
<td> 删除行，参数为待删除的数据对象</td>
</tr>
</tbody>
</table>


<p>下面的示例先创建表将初始数据，之后进行了升级:</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>app/migrations/20120610049877_book.js
var preload_data = [
    {title: 'To Kill a Mockingbird', author:'Harper Lee'}
];
 
migration.up = function(migrator)
{
    migrator.createTable({
 "columns":
        {
 "book": "TEXT",
 "author": "TEXT"
        }
    });
 for (var i = 0; i &lt; preload_data.length; i++) { 
        migrator.insertRow(preload_data[i]);
    }
};
 
migration.down = function(migrator)
{
    migrator.dropTable();
};

//升级app/migrations/20130118069778_book.js
migration.up = function(migrator) {
    migrator.db.execute('ALTER TABLE ' + migrator.table + ' ADD COLUMN isbn INT;');
};
migration.down = function(migrator) {
    var db = migrator.db;
    var table = migrator.table;
    db.execute('CREATE TEMPORARY TABLE book_backup(title,author,alloy_id);')
    db.execute('INSERT INTO book_backup SELECT title,author,alloy_id FROM ' + table + ';');
    migrator.dropTable();
    migrator.createTable({
        columns: {
            title:"TEXT",
            author:"TEXT",
        },
    });
    db.execute('INSERT INTO ' + table + ' SELECT title,author,alloy_id FROM book_backup;');
    db.execute('DROP TABLE book_backup;');
};</code></pre>


<h2>3. Alloy Widgets</h2>

<p>在Alloy XML Markup中已经介绍了如何使用Widgets，这里主要介绍如何创建Widgets。</p>

<p>Widgets应放在app/Widgets文件夹下，与app文件夹一相，每个Widget也有自己的views, controllers, models, styles and assets等。在Widget中不能访问除了i18n之外的文件。其它主要区别如下：</p>

<ul>
<li>使用WPATH()来自动处理assets和libs的路径总是。例如要在Widget中require <code>app/widgets/foo/lib/helper.js</code>，可以<code>require(WPATH('helper'))</code>。对于<code>app/widgets/foo/assets/images/foo.png</code>使用<code>WPATH('images/foo.png')</code>。</li>
<li>Widgets使用自己的配置文件widget.json</li>
<li>Widgets的主controller是widget.js，而不是index.js。创建widget内的另一个controller需要使用Widget.createController方法。</li>
<li>所有Widget控制器中的方法均为私有方法，除非使用$，例如<code>$.init=function(){...}</code>，然后就可以在项目中调用：<code>$.fooWidget.init()</code>.</li>
<li>Widget中也可以创建Model和Collection, 但要使用Widget.createModel和Widget.createCollection方法。</li>
<li>样式文件为widget.tss</li>
<li>Widget同样可以有Theme, 相关样式和资源要放到：<code>app/themes/&lt;THEME_NAME&gt;/&lt;WIDGET_NAME&gt;</code>。</li>
<li>Widget的主View是widget.xml而不是index.xml。当Widget中的某个view指定了id(eg. buttonId)时，在项目中可以这样引用：<code>$.fooWidget.buttonId.xxx</code></li>
<li>Widget可以包含其它Widget。需要在widget.json中定义依赖。在controller中可以调用：<code>Widget.createWidget(widget_name, [controller_name])</code></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Titanium Alloy基础]]></title>
    <link href="http://blog.ubone.com/blog/2015/01/10/titaniumxue-xi-bi-ji/"/>
    <updated>2015-01-10T20:32:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/01/10/titaniumxue-xi-bi-ji</id>
    <content type="html"><![CDATA[<p>这是一篇学习笔记，主要内容是Alloy的基础概念。</p>

<!--more-->


<h2>1. Alloy框架</h2>

<h3>1.1 Alloy相关概念</h3>

<p><strong>Alloy models</strong> are built on top of <a href="http://backbonejs.org/">Backbone.js</a>, taking advantage of Backbone&rsquo;s rich Model and Collection APIs.</p>

<p><strong>Alloy views</strong> are built from Titanium UI components.</p>

<p><strong>Alloy controllers</strong> generally have a one-to-one relationship with Alloy views.</p>

<p>Additionally, Alloy provides built-in support for <a href="http://underscorejs.org/">Underscore.js</a>, which provides a set of utility functions, such as array and iterative helpers.</p>

<p>资源文件放于app/assets/android or app/assets/iphone folder.</p>

<p>Titanium代码与Alloy XML:</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var button = Titanium.UI.createButton({
    text: "Foobar",
    top: 0,
    width: Ti.UI.SIZE
});

button.addEventListener('click', doClick);</code></pre>


<p>等价于：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>&lt;Button title="Foobar" top="0" width="Ti.UI.SIZE"  onClick="doClick"/&gt;</code></pre>


<p>Alloy项目文件夹：</p>

<table>
<thead>
<tr>
<th>文件夹</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>app </td>
<td> Contains the models, views, controllers and assets of the application. All work should be done here. See folder descriptions below.</td>
</tr>
<tr>
<td><code>app/alloy.jmk</code> </td>
<td> Build configuration file.</td>
</tr>
<tr>
<td><code>app/alloy.js</code> </td>
<td> Initializer file used to preconfigure components or override Alloy methods before the main controller is executed. </td>
</tr>
<tr>
<td><code>app/config.json</code> </td>
<td> Project configuration file.</td>
</tr>
<tr>
<td><code>app/assets</code> </td>
<td> Contains image assets and other files that need to be copied into the Resources directory. Reference these files in the code without the &lsquo;app/assets&rsquo; path and without the platform-specific if it is inside one.</td>
</tr>
<tr>
<td><code>app/controllers</code> </td>
<td> Contains controllers in the format filename.js to a corresponding view file <code>app/views/filename.xml</code>.</td>
</tr>
<tr>
<td><code>app/lib</code> </td>
<td> Contains application-specific library code, typically in the CommonJS format.</td>
</tr>
<tr>
<td>app/migrations </td>
<td> Contains database migration files in the format <code>&lt;DATETIME&gt;_filename.js</code>.</td>
</tr>
<tr>
<td><code>app/models</code> </td>
<td> Contains model files in the format filename.js.</td>
</tr>
<tr>
<td><code>app/styles</code> </td>
<td> Contains view styling in the format filename.tss, which is applied to a corresponding view file <code>app/views/filename.xml</code>.</td>
</tr>
<tr>
<td><code>app/themes</code> </td>
<td> Contains themes to customize the assets and styles of the entire GUI.</td>
</tr>
<tr>
<td><code>app/views</code> </td>
<td> Contains views in the format filename.xml with the optional corresponding files <code>app/controllers/filename.js</code> and <code>app/styles/filename.tss</code>.</td>
</tr>
<tr>
<td><code>app/widgets</code> </td>
<td> Contains widget files. Each widget will have its own app-like directory structure.</td>
</tr>
<tr>
<td>i18n </td>
<td> Contains internationalization and localization files. Same usage as with a Titanium application.</td>
</tr>
<tr>
<td>Resources </td>
<td> Contains the Titanium files generated by the Alloy interface from the app directory. All files will be overwritten each time the application is built. Since Alloy 1.3.0, Alloy creates a separate Titanium project for each platform you build for in the <code>Resources/&lt;platform&gt;</code> folder.</td>
</tr>
</tbody>
</table>


<p><strong>Widgets</strong> are self-contained components that can be easily dropped into Alloy-powered Titanium projects.</p>

<p>Alloy comes with additional utilities used to simplify certain functions, such as animations, string manipulation, and display unit conversion. These utilities are referred to as &lsquo;<strong>builtins</strong>.&rsquo;</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var animation = require('alloy/animation');
$.shake.addEventListener('click', function(e) {
    animation.shake($.view);
});</code></pre>


<h3>1.2 Alloy Views</h3>

<h4>1.2.1 XML Markup</h4>

<pre class='line-numbers language-javascript'><code class='language-javascript'>//app/views/index.xml
&lt;Alloy&gt;
    &lt;Window class="container"&gt;
        &lt;Label id="labelId" onClick="doClick"&gt;Hello, World&lt;/Label&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt;</code></pre>


<p>可以使用<code>$.labelId</code>引用上面的label，对于根视图可以使用<code>$.index</code>（文件名）。</p>

<p>XML中可以使用的属性：</p>

<table>
<thead>
<tr>
<th>属性名 </th>
<th> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>id </td>
<td> Identifies UI elements in the controller (prefixed with &lsquo;$.&rsquo;) and style sheet (prefixed with &lsquo;#&rsquo;).</td>
</tr>
<tr>
<td>class </td>
<td> Applies additional styles (prefixed with &lsquo;.&rsquo; in the TSS file)</td>
</tr>
<tr>
<td>autoStyle </td>
<td> 是否动态样式，当class动态变化时，控件样式动态变化。对性能有影响</td>
</tr>
<tr>
<td>formFactor </td>
<td> handheld or tablet</td>
</tr>
<tr>
<td>if </td>
<td> 使用条件表达式。See <a href="http://docs.appcelerator.com/titanium/latest/#!/guide/Alloy_XML_Markup-section-35621528_AlloyXMLMarkup-ConditionalCode">Conditional Code</a> and <a href="http://docs.appcelerator.com/titanium/latest/#!/guide/Alloy_Styles_and_Themes-section-35621526_AlloyStylesandThemes-CustomQueryStyles">Alloy Styles and Themes: Custom Query Styles</a> for more details.</td>
</tr>
<tr>
<td>module </td>
<td> Requires in a CommonJS module </td>
</tr>
<tr>
<td>ns </td>
<td> Overrides the default Titanium.UI namespace. See Namespace for more details.</td>
</tr>
<tr>
<td>platform </td>
<td> android, blackberry, ios, or mobileweb。如果多个可以使用逗号分隔。</td>
</tr>
</tbody>
</table>


<p>除了上述属性，各组件还可以包括自己特有的属性和事件。另外还有一些特殊的元素：</p>

<table>
<thead>
<tr>
<th>Element </th>
<th> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alloy </td>
<td>Root element for all view XML files. Required in all views.</td>
</tr>
<tr>
<td>Collection </td>
<td> Creates a singleton or instance of the specified collection. </td>
</tr>
<tr>
<td>Model </td>
<td> Creates a singleton or instance of the specified model. </td>
</tr>
<tr>
<td>Module </td>
<td> Imports a module view inside this view (since Alloy 1.2.0). </td>
</tr>
<tr>
<td>Require </td>
<td> Imports a widget or includes another view inside this view. </td>
</tr>
<tr>
<td>Widget </td>
<td> Imports a widget inside this view. Same as the Require Element with the type specified to &lsquo;widget&rsquo;. </td>
</tr>
</tbody>
</table>


<p>index.xml是一个特殊情况，只接受以下根节点：</p>

<ul>
<li>Ti.UI.Window or <code>&lt;Window&gt;</code></li>
<li>Ti.UI.TabGroup or <code>&lt;TabGroup&gt;</code></li>
<li>Ti.UI.iOS.NavigationWindow or <code>&lt;NavigationWindow&gt;</code></li>
<li>Ti.UI.iPad.SplitWindow or <code>&lt;SplitWindow&gt;</code></li>
</ul>


<p><strong>XML中的Collection节点</strong></p>

<p>The Collection XML element creates a singleton or instance of a collection.</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>&lt;Alloy&gt;
    &lt;Collection src="book" /&gt;
    &lt;Window&gt;
        &lt;TableView id="table" /&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt;</code></pre>


<p>上面的代码创建了一个单例集合，对应的model为book.js。在controller中可以这样访问：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var library = Alloy.Collections.book;
library.fetch();</code></pre>


<p>上面的例子 Alloy.Collections.book是全局的，但也可以创建只用于一个Controller的Collection：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>&lt;Alloy&gt;
    &lt;Collection id="localLibrary" src="book" instance="true"/&gt;
    &lt;Window&gt;
        &lt;TableView id="table" /&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt;</code></pre>


<p>注意上面的src和instance。在代码中通过id来引用：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var library = $.localLibrary;
library.fetch();</code></pre>


<p><strong>Model Element</strong>
与Collection类似，XML中也可以创建Model单例，或者用于某个Controller的一个实例。</p>

<p>单例：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>&lt;Alloy&gt;
    &lt;Model src="book" /&gt;
    &lt;Window&gt;
        &lt;TableView id="table" /&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt;

var drama = Alloy.Models.book;
drama.set('title', 'Hamlet');
drama.set('author', 'William Shakespeare');</code></pre>


<p>某个Controller的实例：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>&lt;Alloy&gt;
    &lt;Model id="myBook" src="book" instance="true"/&gt;
    &lt;Window&gt;
        &lt;TableView id="table" /&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt;

var drama = $.myBook;
drama.set('title', 'Hamlet');
drama.set('author', 'William Shakespeare');</code></pre>


<p>注意前述的Collection和Model都要放在Alloy节点下。</p>

<p><strong>Module Attribute</strong>
XML中可以引入CommonJS module。首先，module要放入<code>app/lib</code>，并且有一个public方法createXXX，返回一个UI对象。然后，将XXX用于xml节点元素，并设置module路径(基于<code>app/lib</code>)，元素的其它属性将作为参数传入createXXX方法。示例如下：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>//app/lib/foo.js
// XML attributes are passed to the function
exports.createFoo = function (args) {
    var viewArgs = {
        backgroundColor: args.color || 'white',
        width: '100dp',
        height: '100dp'
    };
    var view = Ti.UI.createView(viewArgs);
    var labelArgs = {
        color: args.textColor || 'black',
        text: args.text || 'Foobar' 
    };
    var label = Ti.UI.createLabel(labelArgs);
    view.add(label);
 // Return a UI object that can be added to a view
 return view;
}; 

//app/views/index.xml
&lt;Alloy&gt;
    &lt;Window backgroundColor="white"&gt;
        &lt;!-- Requires in the lib/foo.js module and calls the createFoo method --&gt;
        &lt;Foo module="foo" color="blue" textColor="orange" text="Hello, World!"/&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt;</code></pre>


<p>对于Native开发的Module，也可以引入XML中，分为5步：</p>

<ol>
<li>将module引入项目</li>
<li>在XML中的View或Window的下级加入Module</li>
<li>设置属性module为module名称</li>
<li>设置属性method为创建方法名称，如果没设置则默认为createView</li>
<li>如果方法参数只需要一个简单的Javascript对象，则可以将值inline写入或者使用TSS文件。</li>
</ol>


<p>Paint Module的示例如下：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>&lt;Alloy&gt;
    &lt;Window&gt;
        &lt;Module id="paint" module="ti.paint" method="createPaintView"
            eraseMode="false" strokeWidth="1.0" strokeColor="red" strokeAlpha="100" /&gt;
        &lt;Button onClick="eraseMe" bottom="0"&gt;Erase&lt;/Button&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt;

function eraseMe(){
    $.paint.clear();
}</code></pre>


<p><strong>Require Element</strong>
require元素主要有两个用途：including external views and importing widgets into the current view.</p>

<p>including external views示例：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>//index.xml
&lt;Alloy&gt;
    &lt;TabGroup&gt;
        &lt;Tab id="leftTab"&gt;
            &lt;Require type="view" src="rss" id="rssTab"/&gt;
        &lt;/Tab&gt;
    &lt;/TabGroup&gt;
&lt;/Alloy&gt;

//rss.xml
&lt;Alloy&gt;
    &lt;Window id='rssWindow'&gt;
        &lt;WebView id='rssView' /&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt; 

var rssView = $.rssTab.getView('rssView'); 
rssView.url = 'http://www.google.com'; </code></pre>


<p><strong>Importing Widgets，</strong>引入Widgets只需要三步：</p>

<ol>
<li>将Widget放入app/widgets文件夹</li>
<li>在config.json中添加依赖</li>
<li>在XML中加入<code>&lt;Widget&gt;</code>，可以设置id和name属性。id属性用于引用并调用方法，name属性用于指定view对应的Controller，而不是使用默认的widget.js。</li>
</ol>


<pre class='line-numbers language-javascript'><code class='language-javascript'>app/views/index.xml
&lt;Alloy&gt;
    &lt;Window&gt;
        &lt;Widget src="mywidget" id="foo" name="foo" /&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt;

$.foo.myMethod();</code></pre>


<p>config.json中的依赖：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'> "dependencies": {
    "mywidget":"1.0"
  }</code></pre>


<p></p>

<p>可以直接在XML中设置属性，用于传参。与代码具有等同效果：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>&lt;Require id="foobar" src="foo" customTitle="Hello" customImage="hello.png"/&gt; 

var foobar = Alloy.createController('foo', { 
    id: "foobar", 
    customTitle: "Hello", 
    customImage: "hello.png" 
});</code></pre>


<p>对于required view，可以<strong>绑定事件</strong>。下面的例子中，parent视图引入了button视图，并绑定了回调方法：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>//Parent View:
&lt;Require id="fooButton" src="button" onClick="doClick" /&gt; 

function doClick(e) {...}

//Button View:
&lt;Alloy&gt;
    &lt;Button id="button"&gt;Click Me!&lt;/Button&gt;
&lt;/Alloy&gt;

//在子视图中trigger click事件
$.button.addEventListener('click', function(e) { 
    $.trigger('click', e); 
}); </code></pre>


<p><strong>Adding Children Views。</strong>用于将parent view中的数据传给required view。下面的例子实现了这样一个场景：index.xml require info.xml，index.xml可以将子元素传给info.xml展示，info.js可以通过<code>arguments[0].children</code>访问这些子元素。</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>//app/views/info.xml
&lt;Alloy&gt;
    &lt;View backgroundColor="yellow" borderWidth="0.5" borderColor="brown"/&gt;
&lt;/Alloy&gt;

//controllers/info.js
var args = arguments[0] || {};
// add children if there are any
_.each(args.children || [], function(child) {
    $.info.add(child);
});
$.info.height = Ti.UI.SIZE; 

//app/views/index.xml
&lt;Alloy&gt;
    &lt;Window class="container"&gt;
        &lt;Require src="info"&gt;
            &lt;Label&gt;I am an info box.&lt;/Label&gt;
        &lt;/Require&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt;</code></pre>


<p><strong>Namespace</strong></p>

<p>XML中的控件默认为Titanium.UI，如果组件不是这个命名空间，可以设置ns属性：</p>

<p><code>&lt;View ns="Ti.Map" id="map"/&gt;</code></p>

<h4>1.2.2 Alloy Styles and Themes</h4>

<h5>Titanium Style Sheets (TSS)</h5>

<p>Titanium Style Sheets (TSS) file uses a JSON-like syntax. the class name prefixed with a period (.), or the id name prefixed with a hash tag (#) 。也可以使用条件表达式。值可以是以下类型：</p>

<ul>
<li>JSON values, that is, Strings, Numbers, Objects, Array, Booleans and null</li>
<li>undefined to unset a property (do not place undefined in quotes) (since Alloy 1.4.0)</li>
<li>Titanium SDK constants, for example, Ti.UI.SIZE</li>
<li>Localization functions, either Ti.Locale.getString() and its shorthand L()</li>
<li>Variables from the Alloy.CFG or Alloy.Globals namespaces</li>
<li>Bitwise operators, which includes bit shifting (&lsquo;>>&rsquo;, &lsquo;&lt;&lt;&rsquo;, and &lsquo;>>>&rsquo;), bitwise AND (&lsquo;&amp;&rsquo;), bitwise OR (&lsquo;|&rsquo;) and bitwise XOR (&lsquo;^&rsquo;) (since Alloy 1.3.0)</li>
</ul>


<p>注释方法： //comment and multiline comments <code>/* comment */</code></p>

<p>Alloy不支持：Alloy does not support the CSS concept of child or descendent selectors</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>// 如果不使用.和#，这表示适用于所有Lable
"Label": {
    width: Ti.UI.SIZE,
    height: Ti.UI.SIZE,
    color: "#000", // black
    transform: Alloy.Globals.rotateLeft // value is defined in the alloy.js file      
},</code></pre>


<p>注意上面的transform使用了全局方法：<code>Alloy.Globals.rotateLeft = Ti.UI.create2DMatrix().rotate(-90);</code></p>

<p>app.tss中定义的是全局样式。样式的优先权：XML中输入的 <code>&gt;</code> 当前View对应的TSS <code>&gt;</code> 全局样式。</p>

<p>样式可以加平台条件，用中括号，注意中括号和平台代码间<strong>不要用空格！</strong>:</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>// iPad and iPad mini
"Label[platform=ios formFactor=tablet]": { 
    backgroundColor: "#0f0",
    text: 'iPad'
},

还可以： 
[platform=ios,android] //android, blackberry, ios, or mobileweb
[platform=!ios]
</code></pre>


<p><strong>Custom Query Styles</strong>
Custom query styles override all styles, that is, class, id, and markup element styles, except the ones defined as attributes in the XML file.</p>

<ol>
<li>使用Alloy.Globals定义一个返回boolean的方法，或者通过Alloy.createController中传入boolean属性，然后在xml或tss文件中使用。</li>
<li>在xml和tss中使用if属性。</li>
</ol>


<pre class='line-numbers language-javascript'><code class='language-javascript'>apps/controllers/index.js
function openBar (e) {
    Alloy.createController('win2', {'fooBar': true}).getView().open();
};

app/styles/win2.tss
"#label[if=$.args.fooBar]" : {
 'text' : 'Foobar',
 'color' : 'blue'
}

app/views/win2.xml
&lt;Alloy&gt;
    &lt;Window&gt;
        &lt;Label if="$.args.fooBar" color="blue"&gt;Foobar&lt;/Label&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt;</code></pre>


<p>另一个例子：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>Alloy.Globals.isIos7Plus = (OS_IOS && parseInt(Ti.Platform.version.split(".")[0]) &gt;= 7);

//index.tss
// Query styles
"#info[if=Alloy.Globals.isIos7Plus]" : {
    font : { textStyle : Ti.UI.TEXT_STYLE_FOOTNOTE }
},</code></pre>


<h5>Themes</h5>

<p>使用Theme的方法。首先在app下建立themes文件夹，并在其下级以各主题名建立子文件夹，如:app-themes-mytheme, 在mytheme下分别建立assets(放图片资源)和styles(放tss文件，还可以再包含平台子文件夹)。在config.json设置当前主题：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>{
 "global": {
 "theme":"mytheme"
    }, 
 "env:development": {}, 
 "env:test": {}, 
 "env:production": {}, 
 "os:ios": {
 "theme":"green"
    }, 
 "os:android": {
 "theme":"blue"
    }, 
 "dependencies": {}
}</code></pre>


<p>打包时，主题下的assets资源和样式将覆盖app下的资源与样式。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM监控与故障处理工具]]></title>
    <link href="http://blog.ubone.com/blog/2015/01/04/jvmjian-kong-yu-gu-zhang-chu-li-gong-ju/"/>
    <updated>2015-01-04T21:42:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/01/04/jvmjian-kong-yu-gu-zhang-chu-li-gong-ju</id>
    <content type="html"><![CDATA[<p>本文介绍常用的Java虚拟机性能监控与故障处理工具。</p>

<!--more-->


<h2>1. JDK命令行工具</h2>

<h3>1.1 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jps.html">jps</a></h3>

<p>与Unix下的ps命令相似，可以列出正在运行的虚拟机进程并显示主类（main()函数所在类）类名以及LVMID(Local Virtual Machine Identifier)。LVMID与PID是一致的。命令格式：</p>

<p><code>jps [options] [hostid]</code></p>

<table>
<thead>
<tr>
<th>选项 </th>
<th> 用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>-q </td>
<td> 只输出LVMID</td>
</tr>
<tr>
<td>-m </td>
<td> 输出JVM启动时传递给主类main()函数的参数</td>
</tr>
<tr>
<td>-l </td>
<td> 输出主类全名</td>
</tr>
<tr>
<td>-v </td>
<td> 输出JVM启动时的JVM参数</td>
</tr>
</tbody>
</table>


<h3>1.2 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html">jstat</a>，虚拟机统计信息监视工具</h3>

<p>在<a href="http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>中已经有描述。</p>

<h3>1.3 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jinfo.html">jinfo</a>, Java配置信息工具</h3>

<p>用于实时查看和调整虚拟机各项参数。</p>

<h3>1.4 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jmap.html">jmap</a>, Java内存映像工具</h3>

<p>在<a href="http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>中已经有描述。</p>

<h3>1.5 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jhat.html">jhat</a>， 堆转储快照分析工具</h3>

<p>用于分析堆转储快照，内置一个微型HTTP服务器，分析结果后可在浏览器中查看。但这个工具并不常用。</p>

<h3>1.6 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstack.html">jstack</a>, Java堆栈跟踪工具</h3>

<p>用于生成虚拟机当前时刻的线程快照（threaddump），即当前每一条线程正在执行的方法堆栈集合。主要目的是定位线程出现长时间停顿的原因，如死锁、死循环、请求外部资源等。</p>

<p>当线程出现停顿时，通过jstack查看各线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么。</p>

<table>
<thead>
<tr>
<th>选项 </th>
<th> 用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>-F </td>
<td> 当正常输出的请求不被响应时，强制输出线程堆栈</td>
</tr>
<tr>
<td>-l </td>
<td> 除堆栈外，显示关于锁的附加信息</td>
</tr>
<tr>
<td>-m </td>
<td> 如果调用本地方法的话，显示C/C++堆栈</td>
</tr>
</tbody>
</table>


<h2>2. JDK的可视化工具</h2>

<h3>2.1 JConsole</h3>

<p>基于JMX的可视化监视、管理工具。直接通过集令后运行jconsol。</p>

<h3>2.2 <a href="http://visualvm.java.net/">VisualVM</a>，多合一故障处理工具</h3>

<p>VisualVM Is Designed For You:</p>

<ul>
<li><strong>Application Developer</strong>: Monitor, profile, take thread dumps, browse heap dumps</li>
<li><strong>System Administrator</strong>: Monitor and control Java applications across the entire network</li>
<li><strong>Java Application User</strong>: Create bug reports containing all the necessary information</li>
</ul>


<p>在命令行执行<code>jvisualvm</code>即可</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java垃圾收集与内存分配]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/26/la-ji-shou-ji-qi-yu-nei-cun-fen-pei-ce-lue/"/>
    <updated>2014-12-26T20:20:12+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/26/la-ji-shou-ji-qi-yu-nei-cun-fen-pei-ce-lue</id>
    <content type="html"><![CDATA[<p>在<a href="http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>中，了解了Java的内存管理和垃圾收集。本文再深入学习垃圾收集算法和HotSpot中垃圾收集的实现。</p>

<!--more-->


<h2>1. 什么是垃圾</h2>

<p>Java并没有使用引用计数法来识别对象是否为垃圾，而是采用可达性分析（Reachability Analysis）判断对象是否存活。其基本思路就是通过GC Roots对象为起点，搜索其引用链，只要是通过它们可达的对象就是活对象。GC Roots对象包括以下几种：</p>

<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI(即Native方法)引用的对象</li>
</ul>


<p>而Java的引用又分为多种类型，对象是否存活也与引用类型有关：</p>

<ul>
<li>强引用：普通引用都是强引用，只要强引用还存在，对象就不会被回收。</li>
<li>软引用：SoftReference关联的对象是还有用，但不是必须的对象。在系统将要发生内存溢出异常之前，会把这些对象列入回收范围进行第二次回收。</li>
<li>弱引用：WeakReference与SoftReference更弱，它关联的对象只能生成到下一次垃圾收集发生之前（无论内存是否足够，都会被回收）。</li>
<li>虚引用：PhantomReference是最弱的一种引用，对生存时间完全没有影响，也无法通过虚引用来取得一个对象实例。其唯一目的就是在回收时收到一个系统通知。</li>
</ul>


<p>真正宣告一个对象的死亡，要经历至少两次标记过程。当扫描发现对象与GC Roots没有引用链，将进行第一次标记，并判断对象是否有必要执行finalize()方法（如果对象没有覆盖该方法，或者方法已经被调用过，视为没有必要执行）。如果有必要执行finalize()方法，虚拟机将该对象放入F-Queue队列，稍后自动由低优先级的Finalizer线程执行该方法。之后GC还会对F-Queue中的对象进行第二次标记，如果对象在finalize()方法中重新建立了一个有效引用，就会被移除出“即将回收”的集合，逃脱回收。</p>

<p>但注意finalize()方法是没有保障的，JVM只会触发它执行，并不保证它会运行结束。试想如果finalize()方法中有死循环，会造成整个内存回收系统崩溃。所以正如<a href="http://blog.ubone.com/blog/2014/06/27/effective-java-chuang-jian-he-xiao-hui-dui-xiang/">Effective Java-创建和销毁对象</a>中提到的，你就当Java没有finalize()方法吧!</p>

<p>方法区（通常所指的永久代）也是<strong>可以（非必须）</strong>垃圾收集的。主要回收废弃常量和无用的类。对于常量，例如“abc”已经进入常量池，但当前没有任何一个String对象是“abc”，那么这个常量可能会被清理出去。如何判断无用的类则要苛刻许多，需要同时满足以下条件：</p>

<ul>
<li>该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例。</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>


<p>方法区的对象仅仅是可以回收，并不是必然会回收。在大量使用反射、动态代理、CGLib等字节码框架、动态JSP和OSGi这类频繁自定义ClassLoader场景下，虚拟机需要具备类卸载的功能。</p>

<p>HotSpot提供了参数<code>-Xnoclassgc</code>参数控制方法区回收。在Product版JVM中还可以使用<code>-verbose:class</code>和<code>-XX:+TraceClassLoading</code>查看类加载信息。FastDebug版的JVM还支持<code>-XX:+TraceClassUnLoading</code>查看卸载信息。</p>

<h2>2. 垃圾收集算法</h2>

<p>各平台的虚拟机操作内存的方法各不相同，常见的垃圾收集算法说明如下：</p>

<h3>2.1 常见的垃圾收集算法</h3>

<h4>标记-清除算法(Mark-Sweep)</h4>

<p>这是最基础的收集算法，分为标记和清除两个阶段。首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。它有两个主要问题：一是效率不高，另一个是空间问题，会产生大量不连续的内存碎片。</p>

<h4>复制算法(Copying)</h4>

<p>复制算法的思路是将内存分为大小相等的两块，每次只使用其中一块，永远有一块是空的。当一块用完了，就将存活对象复制到另一块上，把前者内存空间一次清理掉。</p>

<p>复制算法特别适合那些短命的对象，现代虚拟机都采用这个算法来回收新生代。将内存分为较大的Eden区和两个较小的Survivor，每次使用Eden和其中一个Survivor。回收时，将Eden和Survivor存活的对象复制到另一个Survivor，最后清理掉Eden和前一个Survivor空间。HotSpot默认的Eden和Survivor比例是8：1. 如果另一个Survivor空间不足以放下存活对象，那些经历多少GC仍存活的对象会被放入老年代。</p>

<h4>标记-整理算法（Mark-Compact）</h4>

<p>对于长命的对象，复制算法的效率就变得太低。标记-整理算法就适合老年代。其思路是标记后，将活对象向一端移动，然后清理掉边界以外的内存。</p>

<h4>分代收集算法(Generational Collection)</h4>

<p>这个算法没有特殊之处，就是将堆分为新生代和老年代，然后根据各年代的特点选择最适当的算法。在新生代使用复制算法，在老年代使用“标记-清理”或者“标记-整理”算法。</p>

<h3>2.2 HotSpot的算法实现</h3>

<p>结合前面的垃圾收集算法，看看HotSpot是如何实现的。</p>

<h4>2.2.1 枚举GC Roots</h4>

<p>前面说到GC Roots主要是在全局性的引用和执行上下文（如栈帧中的本地变量表）中，但HotSpot并不需要逐个检查这里面的引用，因为这样的效率太低了。</p>

<p>HotSpot使用一组称为OopMap的数据结构，在类加载完成时，就把对象内各偏移量上是什么类型的数据计算出来了，因此GC扫描时，可以直接得到这些信息，并准确判断堆上的数据是否还可能被使用。</p>

<h4>2.2.2 安全点</h4>

<p>当GC时，线程会停在安全点，常见的安全点包括方法调用、循环跳转、异常跳转等。如何让线程停在安全点，有两种方案：抢先式中断和主动式中断。抢先式指中断所有线程，如果发现某个线程不在安全点，则恢复线程让它跑到安全点。但几乎所有虚拟机都没有采用这个方法。</p>

<p>主动式中断的思路是GC需要中断线程时，设置一个标志，各线程执行时会在安全点和创建对象需要分配内存的地方轮询这个标志，如果为真就把自己挂起。</p>

<p>对于那些处于Sleep或Blocked状态的线程，无法跑到安全点，则需要安全区域来解决。安全区域中任何地方GC都是安全的。当线程执行到安全区域中的代码时，先标识自己已经进入安全区，这时GC就不管这些线程了。当线程要离开安全区时，它要检查系统是否已经完成了根节点枚举或GC过程，如果完成则继续执行，否则继续等待直到收到可安全离开的信号。</p>

<h4>2.2.3 垃圾收集器</h4>

<p><a href="https://blogs.oracle.com/jonthecollector/entry/our_collectors">下图</a>展示了HotSpot用于不同年代的7种收集器，如果两个收集器间有连线，说明它们可以搭配使用。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-26-Collectors.jpg" alt="image" /></p>

<h5>Serial收集器</h5>

<p>这是一个单线程的收集器，工作于年轻代，使用复制算法。当它工作时，会把所有用户线程全部停下来。它现在仍然是Client模式下的默认收集器。它比其他收集器简单但高效，没有了线程交互的开销。桌面应用由于分配的内存相对较少，收集时停顿时间可控制在几十到一百多毫秒，对桌面应用是可以接受的。</p>

<h5>ParNew收集器</h5>

<p>它其实就是Serial收集器的多线程版本，对于单核CPU的环境下，绝对不会比Serial更好。但它适合于在服务端模式时与CMS配合(CMS用于老年代，ParNew用于年轻代)。</p>

<h5>Parallel Scavenge收集器</h5>

<p>这是一个年轻代的收集器，使用复制算法，是并行的多线程收集器。</p>

<ul>
<li>并行(Parallel):指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li>并发(Concurrent): 指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行）。</li>
</ul>


<p>Parallel Scavenge收集器与其它收集器不同，它的目标是达到一个可控制的吞吐量，即CPU用于运行用户代码的时间与CPU总消耗时间的比值。因此适合于不需要太多交互，主要是后台运算的场景。</p>

<h5>Serial Old收集器</h5>

<p>这是Serial收集器的老年代版本，同样是单线程收集器，使用“标记-整理”算法。其主要意义也是Client模式的虚拟机中使用。如果在Server模式下，主要是在JDK1.5及之前的版本中与Parallel Scavenge搭配使用，以及作为CMS的后备预案。</p>

<h5>Parallel Old收集器</h5>

<p>这是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。从JDK1.6开始提供，主要用于与Parallel Scavenge搭配使用，作为“吞吐量优先”的组合。</p>

<h5>CMS收集器(Concurrent Mark Sweep)</h5>

<p>这是一种以获取最短回收停顿时间为目标的收集器。也是基于“标记-清除”算法实现，整个过程分为4步：</p>

<ol>
<li>初始标记：标记GC Roots能直接关联到的对象，时间很快。</li>
<li>并发标记：进行GC Roots Tracing，时间很长。</li>
<li>重新标记：修正并发标记期间因用户程序继续运行而导致标记发生变化的那一部分对象的标记记录，比第一步稍长。</li>
<li>并发清除</li>
</ol>


<p>第1、3步需要Stop the World，而耗时最长的第2、4步可以与用户线程一起工作。</p>

<p>CMS是非常优秀的垃圾收集器，是Java 5推荐的高性能收集器，在Java 6仍保持了旺盛的生命力。但它的主要缺点是：</p>

<ol>
<li>对CPU资源非常敏感。在并发标记阶段，虽然用户程序不用停顿，但CMS占用了一部分CPU资源而导致应用变慢，总吞吐量降低。</li>
<li>无法处理浮动垃圾，可能出现“Concurrent Mode Failure”，导致另一次Full GC。浮动垃圾就是在并发清除阶段，用户线程还在运行并产生新的垃圾。CMS需要预留一部分内存空间给用户线程使用。如果预留的空间无法满足程序需要，就会出现“Concurrent Mode Failure”，导致JVM临时启用Serial Old收集器来重新进行老年代收集，停顿时间就很长了。</li>
<li>由于使用“标记-清除”算法，因此会有碎片产生，有时不得不提前触发一次Full GC。</li>
</ol>


<h5>G1收集器</h5>

<p>这是面向服务端应用的垃圾收集器，可用于替换CMS。具备如下特点：</p>

<ol>
<li>并行与并发：充分利用多CPU、多核优势，缩短Stop the world时间。</li>
<li>分代收集：仍保留分代概念，可以独立管理整个GC堆。</li>
<li>空间整合：G1整体上是基于“标记-清除”，但从局部看是基于“复制”算法，不会产生内存碎片。</li>
<li>可预测的停顿：G1能建立可预测的停顿时间模型，可指定一个长度为M毫秒的时间片段，G1分将停顿时间尽量控制在该时间范围内。</li>
</ol>


<p>G1将整个堆划分为多个大小相等的独立区域（Region），虽然保留分代概念，但新生代和老年代不是物理隔离的，它们是一部分Region的集合（不需要连续）。</p>

<p>它的实现方式是跟踪每个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及所需时间的经验值），维护一个优先列表，每次根据停顿目标值，回收价值最大的Region。保证在有限的时间内获得尽可能高的收集效率。</p>

<p>每个Region都有一个对应的Remembered Set，用于记录跨Region的引用。因此进行内存回收时，只需要在GC Roots枚举范围内加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SecureRandom导致Tomcat启动过慢]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/20/%5B%3F%5D-ci-jie-jue-tomcatqi-dong-guo-man-de-jing-li/"/>
    <updated>2014-12-20T12:08:33+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/20/[?]-ci-jie-jue-tomcatqi-dong-guo-man-de-jing-li</id>
    <content type="html"><![CDATA[<p>昨天晚上在Tomcat上部署一个小应用时，Tomcat启动非常慢，有时甚至需要10分钟。查看日志，发现一直停在Deploying阶段：</p>

<!--more-->




<pre  class='line-numbers language-bash'><code class='language-bash'>INFO: Starting service Catalina
Dec 19, 2014 9:56:33 AM org.apache.catalina.core.StandardEngine startInternal
INFO: Starting Servlet Engine: Apache Tomcat/7.0.52 (Ubuntu)
Dec 19, 2014 9:56:33 AM org.apache.catalina.startup.HostConfig deployWAR
INFO: Deploying web application archive /usr/mxs/kindleinstance/webapps/kindlegen.war</code></pre>


<p>难道是war文件有问题？检查了md5校验码，尝试了解压缩，完全没问题啊！到底是什么原因呢？等了十分钟后，发现Tomcat已经启动完成，可以使用了。再次查看日志：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>INFO: Deploying web application archive /usr/mxs/kindleinstance/webapps/kindlegen.war
Dec 19, 2014 10:11:25 AM org.apache.catalina.util.SessionIdGenerator createSecureRandom
INFO: Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [888,934] milliseconds.
Dec 19, 2014 10:11:25 AM org.apache.coyote.AbstractProtocol start
INFO: Starting ProtocolHandler ["http-bio-9090"]
Dec 19, 2014 10:11:25 AM org.apache.catalina.startup.Catalina start
INFO: Server startup in 892334 ms</code></pre>


<p>原来是“Creation of SecureRandom instance for session ID”消耗了888秒，这个SecureRandom实例是什么呢？在<a href="http://wiki.apache.org/tomcat/HowTo/FasterStartUp">How do I make Tomcat startup faster?</a>中，有这样的描述：</p>

<blockquote><p>Tomcat 7+ heavily relies on SecureRandom class to provide random values for its session ids and in other places. Depending on your JRE it can cause delays during startup if entropy source that is used to initialize SecureRandom is short of entropy.</p></blockquote>

<p>也就是说，Tomcat 7之后严重依赖SecureRandom类来提供随机数用于Session ID。当Tomcat启动时，取决于你使用的JRE，如果用来初始化SecureRandom的熵值（Entropy）资源是一个短熵时，将可能导致延时。</p>

<p>再看看JDK中关于<a href="http://docs.oracle.com/javase/7/docs/api/java/security/SecureRandom.html">SecureRandom类</a>:</p>

<blockquote><p>This class provides a cryptographically strong random number generator (RNG). A cryptographically strong random number minimally complies with the statistical random number generator tests specified in FIPS 140-2, Security Requirements for Cryptographic Modules, section 4.9.1. Additionally, SecureRandom must produce non-deterministic output. Therefore any seed material passed to a SecureRandom object must be unpredictable, and all SecureRandom output sequences must be cryptographically strong, as described in RFC 1750: Randomness Recommendations for Security.</p></blockquote>

<p>该类提供保密性强的随机数生成器（RNG）。一个保密性强的随机数应最低限度遵循FIPS 140-2指定的统计随机数发生器测试和4.9.1节的加密模块安全要求。并且SecureRandom必须产出非确定性的输出。因此，正如RFC 1750中描述的，传递给SecureRandom对象的任何材料必须是不可预测的，并且所有SecureRandom输出序列必须是保密性强的的。</p>

<p>在<a href="http://www.cigital.com/justice-league-blog/2014/01/06/issues-when-using-java-securerandom/">ISSUES TO BE AWARE OF WHEN USING JAVA’S SECURERANDOM</a>中，提到了使用SecureRandom可能存在的问题，主要包括三个方面：调用顺序、阻塞和内部Seeding机制。其中说明了阻塞是如何产生的：</p>

<blockquote><p>Some SecureRandom implementations in the Oracle JRE for *nix use /dev/random to get entropy at certain times. Since /dev/random can block if sufficient entropy is not available, your code will stop executing if you call certain SecureRandom methods at times when /dev/random does not have sufficient entropy available.</p></blockquote>

<p>这样看来，我的Ubuntu 14中的OpenJDK(OpenJDK Runtime Environment (IcedTea 2.5.3) (7u71-2.5.3-0ubuntu0.14.04.1))正是使用了操作系统的<code>/dev/random</code>作为信息源，而它又没有提供足够的熵，所以导致阻塞。</p>

<p>按照前文<a href="http://wiki.apache.org/tomcat/HowTo/FasterStartUp">How do I make Tomcat startup faster?</a>中给出的次安全的解决办法，改为使用<code>-Djava.security.egd=file:/dev/./urandom</code>，即在setenv.sh中加入一行：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>#!/bin/sh
export CATALINA_OPTS="-Djava.security.egd=file:/dev/./urandom"</code></pre>


<p>然后再重启Tomcat，这次非常快了，整个启动只用了3秒多：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>INFO: Starting service Catalina
Dec 19, 2014 10:51:55 PM org.apache.catalina.core.StandardEngine startInternal
INFO: Starting Servlet Engine: Apache Tomcat/7.0.52 (Ubuntu)
Dec 19, 2014 10:51:55 PM org.apache.catalina.startup.HostConfig deployWAR
INFO: Deploying web application archive /usr/mxs/kindleinstance/webapps/kindlegen.war
Dec 19, 2014 10:51:58 PM org.apache.coyote.AbstractProtocol start
INFO: Starting ProtocolHandler ["http-bio-9090"]
Dec 19, 2014 10:51:58 PM org.apache.catalina.startup.Catalina start
INFO: Server startup in 3418 ms</code></pre>


<p>修改后的<code>/dev/urandom</code>没有默认的<code>dev/random</code>安全吗？似乎也不一定，博文<a href="http://www.2uo.de/myths-about-urandom/">Myths about /dev/urandom</a>对两者进行了全面的分析，值得一看。最后作者认为用<code>/dev/urandom</code>就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java运行时数据区与内存溢出异常]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/15/javayun-xing-shi-shu-ju-qu-yu-nei-cun-yi-chu-yi-chang/"/>
    <updated>2014-12-15T21:55:31+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/15/javayun-xing-shi-shu-ju-qu-yu-nei-cun-yi-chu-yi-chang</id>
    <content type="html"><![CDATA[<p>JVM定义了各种运行时数据区用于程序执行。有些数据区随着JVM启动而创建，当JVM退出时销毁。另一些数据区则是随着线程而存亡。每个数据区都是内存，因此就存在内存溢出的异常。本文学习JVM有哪些数据区以及常见的内存溢出异常。</p>

<!--more-->


<h2>1. 运行时数据区（Run-Time Data Areas）</h2>

<p>根据<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5">JVM规范</a>，运行时数据区主要分为以下部分。</p>

<h3>1.1 程序计数器（Program Counter Register）</h3>

<p>每个JVM线程拥有自己的程序计数器，各线程之间计数器互不影响，这部分区域可以称为线程私有的内存。在任何时间点，一个CPU核心都只会执行一个线程中某个方法的指令，这就是当前方法：</p>

<ul>
<li>如果当前方法不是Native方法，程序计数器包含正在执行的虚拟机字节码指令的地址。</li>
<li>如果是Native方法计数器值为Undefined。</li>
</ul>


<p>程序计数器所占内存非常小，也是唯一没有规定任何内存溢出异常的区域。</p>

<h3>1.2 虚拟机栈（JVM Stacks）</h3>

<p>每个线程同时也有一个私有的虚拟机栈，因此虚拟机栈的生命周期与线程相同。每个栈包括帧（frames），帧与方法调用相关，每当方法被调用，就会创建一个新的帧。当方法结束，帧也就被销毁。帧包括局域变量、自己的操作栈和当前方法的运行时常量池引用。</p>

<p>虚拟机栈与C语言中的栈相似，它包括局域变量和部分结果，并在方法调用和返回中扮演角色。除了push和pop帧，虚拟机栈并不提供其它直接操作。帧可能是在堆中分配内存。虚拟机栈的内存并不需要是连续的。</p>

<p>通常人们把Java内存分为堆和栈，其中栈就是虚拟机栈。虚拟机栈的内存可以是固定大小或者根据计算动态扩展。虚拟机栈涉及两个异常：</p>

<ul>
<li>StackOverflowError: 如果线程请求的栈深度大于允许的深度。</li>
<li>OutOfMemoryError：如果栈是动态扩展的，扩展时无法申请足够的内存。</li>
</ul>


<p>本地方法栈（Native Method Stack）与虚拟机栈发挥着相似的作用，但它是为Native方法服务。JVM规范并没有对其强制规定。HotSpot直接把本地方法栈和虚拟栈合二为一，相同对待。</p>

<p>栈虽然有两个异常，但实验时，如果是单线程操作，无论是栈帧太大还是虚拟机栈容量太小，基本只会出现StackOverflowError，示例如下：</p>

<pre class='line-numbers language-java'><code class='language-java'>/**
* -Xss128k
*/
public class JavaVMStackSOF {
    private int stackLength = 1;
    public void stackLeak() {
        stackLength++;
        stackLeak();
    }
    
    public static void main(String[] args) {
        JavaVMStackSOF oom = new JavaVMStackSOF();
        try {
            oom.stackLeak();
        } catch(Throwable e) {
            ...
        }
    }
}</code></pre>


<p>实验中，只有多线程时，才会出现OutOfMemoryError。通过不停地创建线程，并且每个线程不停止，当线程足够多时就可以重现此异常。</p>

<h3>1.3 堆（Heap）</h3>

<p>堆是在JVM所管理的内存中最大的一块，它是所有线程共享的区域。当JVM启动时会创建此区域。所有对象实例和数组都在堆上分配（现在也有例外，参见<a href="http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">逸出分析</a>）。</p>

<p>堆中存储的对象由垃圾收集器负责回收。堆的大小可以是固定或者动态扩展。堆不需要连续内存空间，只要逻辑上连续即可。根据垃圾收集器的不同，堆内存有不同的管理方式。例如CMS采用分代收集算法，将堆分为年轻代和老年代；而G1则将堆分成大小相同的区域。详见<a href="http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>。</p>

<p>堆涉及的内存异常为OutOfMemoryError，如果堆中没有内存用于实例分配并且无法再扩展时，就会抛出此异常。堆内存溢出很容易模拟，示例如下：</p>

<pre class='line-numbers language-java'><code class='language-java'>/**
* -Xms20m -Xmx20m
*/
public static void main(String[] args) {
    List&lt;SomeObject&gt; list = new ArrayList&lt;&gt;();
    while(true) {
        list.add(new SomeObject());
    }
}</code></pre>


<h3>1.4 方法区（Method Area）</h3>

<p>方法区也是所有线程共享的内存区域。它存储了每个类的信息，例如运行时常量池、属性和方法数据、方法和构造方法代码，包括类和实例初始化和接口初始化的特殊方法。</p>

<p>方法区随着虚拟机启动而创建。逻辑上它是堆的一部分，但JVM实现可以选择不对它进行垃圾收集或者压缩。JVM规范并没有强制规定它的位置和管理已编译代码的策略。它可以是固定大小或者动态扩展，也不需要是连续的。</p>

<p>对于HotSpot虚拟机来说，开发者更愿意把方法区称为永久代（Permanent Generation），但本质上两者并不等价。这仅仅是因为HotSpot设计团队使用永久代来实现方法区而已。但其它虚拟机（如Bea JRocket, IBM J9）并没有永久代的概念。</p>

<p>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。如果一些框架使用CGLib这类字节码技术，增强的类过多，或者JVM上的动态语言（如Groovy）持续创建类来实现语言动态特性，可能出现此异常。</p>

<h3>1.5 运行时常量池</h3>

<p>在<a href="http://blog.ubone.com/blog/2014/12/04/lei-wen-jian-yu-zi-jie-ma/">类文件与字节码</a>中介绍了类文件的常量池，运行时常量池就是这个常量池的运行时表示。运行时常量池相对于类文件常量池主要有两个区别：</p>

<ul>
<li>除了类文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</li>
<li>运行时常量池可以在运行期间将新的常量加入池中。</li>
</ul>


<p>运行时常量池的内存是从方法区分配出来的。当JVM创建类或接口时，会为它创建运行时常量池。因此它的内存受方法区内存限制，也可能抛出OutOfMemoryError异常。</p>

<h3>1.6 直接内存</h3>

<p>直接内存（Direct Memory）并不是JVM运行时数据区的一部分，也不是JVM规范定义的内存区域。但它也被频繁使用，可能导致OutOfMemoryError异常。</p>

<p>JDK 1.4中加入NIO类，引入了基于Channel与Buffer的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过DirectByteBuffer对象作为这块内存的引用进行操作。由于避免了Java堆与Native堆之间复制数据，在一些场景能显著提高性能。</p>

<p>这部分内存虽然不受Java堆大小限制，但肯定会受本机总内存和寻址空间限制。因此动态扩展时可能出现OutOfMemoryError异常。</p>

<h2>2. 内存Dump分析</h2>

<p>在<a href="http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>中介绍了jmap, jstat等工具可以查看内存映射和垃圾收集活动。这里介绍另一个工具Eclipse Memory Analyzer可以对堆内存溢出问题进行分析。首先需要生成堆转储文件。通过启用参数：</p>

<p><code>-XX:+HeapDumpOnOutOfMemoryError</code></p>

<p>JVM 就会在发生内存泄露时抓拍下当时的内存状态，也就是我们想要的堆转储文件。也可以在未溢出时用jmap创建转储文件。</p>

<p>有了转储文件，利用Eclipse Memory Analyzer tool打开该文件，就可以进行分析了。分析通常分为三步：</p>

<ul>
<li>对内存状态获取一个整体印象。</li>
<li>找到最有可能导致内存泄露的元凶，通常也就是消耗内存最多的对象。</li>
<li>进一步查看这个内存消耗大户的具体情况，看看是否有什么异常行为。</li>
</ul>


<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-17-20.30.59.jpg" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解Java性能调优]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you/"/>
    <updated>2014-12-06T21:00:37+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you</id>
    <content type="html"><![CDATA[<p>人们总是猜不对系统变慢的原因在哪里，你必须量体裁衣。没有评测就没有合适的调优。本文重点学习性能相关的内存管理、垃圾收集、相关工具并简单了解HotSpot。</p>

<!--more-->


<h2>1. 性能指标</h2>

<h3>评价性能的常用指标</h3>

<ul>
<li>等待时间(Latency)：在给定工作量的情况下，处理一个任务单元所消耗的时长。通常用响应时间随负载增长的变化曲线来反映。</li>
<li>吞吐量(Throughput)：在某一参考平台（硬件配置、OS和软件环境）上的每秒事务处理数。</li>
<li>利用率(Utilization)：在可用资源中处理工作单元的资源百分比。例如CPU的利用率。</li>
<li>效率(Efficiency)：吞吐量除以所用资源。</li>
<li>容量(Capacity)：任一时刻能通过系统的工作单元数量。</li>
<li>扩展性(Scalability)：当系统得到更多资源时，吞吐量或等待时间的变化。如果方案A可用的服务器数量翻倍，它的吞吐量也能翻倍，那么它就实现了完美的线性扩展。</li>
<li>退化(Degradation)：分为正面退化和负面退化。当工作单元增加时，性能通常会降低，即负面退化。但也存在正面退化，例如负载超过阈值，使系统切换到高性能模式，处理时间可能缩短。JVM是动态非常强的运行时系统，有几部分可以达成这种效果。</li>
</ul>


<p>性能分析时要了解一些概念：</p>

<blockquote><p>中位数（又称中值，Median），统计学中的专有名词，代表一个样本、种群或概率分布中的一个数值，其可将数值集合划分为相等的上下两部分。对于有限的数集，可以通过把所有观察值高低排序后找出正中间的一个作为中位数。如果观察值有偶数个，通常取最中间的两个数值的平均数作为中位数。</p>

<p>方差是各个数据分别与其和的平均数之差的平方的和的平均数，用字母D表示。在概率论和数理统计中，方差（Variance）用来度量随机变量和其数学期望（即均值）之间的偏离程度。在许多实际问题中，研究随机变量和均值之间的偏离程度有着重要意义。</p>

<p>百分位数是统计学术语，如果将一组数据从小到大排序，并计算相应的累计百分位，则某一百分位所对应数据的值就称为这一百分位的百分位数。可表示为：一组n个观测值按数值大小排列。如，处于p%位置的值称第p百分位数。</p>

<p>标准差（Standard Deviation） ，中文环境中又常称均方差，但不同于均方误差（mean squared error，均方误差是各数据偏离真实值的距离平方的平均数，也即误差平方和的平均数，计算公式形式上接近方差，它的开方叫均方根误差，均方根误差才和标准差形式上接近），标准差是离均差平方和平均后的方根，用σ表示。标准差是方差的算术平方根。标准差能反映一个数据集的离散程度。平均数相同的，标准差未必相同。</p></blockquote>

<h2>2. 务实的性能分析法</h2>

<p>做性能分析最重要的是知道哪个可测环节最重要。应该把测量结果、目标和结论跟一个或多个可测环节结合起来。以下是常见的可测项，都是性能调优的好对象：</p>

<ul>
<li>方法handelRequest()运行所需的平均时间。</li>
<li>并发10客户端时，系统等待时间的第90个百分位数。</li>
<li>并发用户从1增长到1000时，响应时间的退化。</li>
</ul>


<p>要精确确定一个方法或代码片段运行需要多长时间，只有两种方法：</p>

<ul>
<li>直接测量，在源码中插入测量代码。最容易理解，但是侵入式的。如果测量结果不断增多，代码很容易就被数据淹没。</li>
<li>在类加载时把类转换成受测类。使用特殊的类加载器，在方法开始和结束的地方加上记录时间的字节码。典型的有OpTier CoreFirst等性能监测工具，但似乎还没有开源工具。</li>
</ul>


<h2>3. 时间问题</h2>

<p>为了进行性能调优，需要对时间有深刻认识。</p>

<h4>硬件时钟</h4>

<p>基于x64的机器有四种不同的硬件时间源：</p>

<ul>
<li>RTC: 实时时钟（RTC）基本和电子表里的元件一样，在系统断电时由主板上的电池供电。系统启动时从它那得到时间。很多系统会在OS启动后通过网络时间协议（Network Time Protocol, NTP）与时间服务器同步。</li>
<li>8254：是可编程计时芯片，现在基本不需要了。</li>
<li>TSC：时间戳计时器，这是应用最广泛的现代计时器。可认为是一个跟踪CPU运行了多少周期的CPU计数器。由于与CPU相关，因此运行时可能受节能或其它因素影响。不同的CPU会互相偏离，不能跟钟表时间保持一致。</li>
<li>HPET，高精度事件计时器，最近几年才出现。精度非常高，但不是所有硬件都可用，也不是所有操作系统都支持。</li>
</ul>


<h4>Java获取时间的方法</h4>

<p>Java提供了两个获取时间的方法：</p>

<ul>
<li>System.currentTimeMillis()，解析度为毫秒级，几乎所有情况下都跟钟表时间相符。</li>
<li>System.nanoTime()，用于测量比毫秒更精确的时间，时间源来自TSC，可能偏离钟表时间。</li>
</ul>


<p>对于较长的间隔时间，nanoTime()基本是不可信的，应该使用currentTimeMillis()，nanoTime()它只能测量较短的时间间隔。</p>

<h2>4. 垃圾收集</h2>

<h3>4.1 内存管理</h3>

<p>内存自动管理是Java平台最重要的组成部分之一。Java内存分为栈和堆。</p>

<p>栈内存，即虚拟机栈。每个方法被执行的时候都会同时创建一个栈帧，用来存储局部变量，操作栈，动态链接，方法出口等信息。<strong>局部变量包括各种基本类型的变量和对象的引用变量都是在方法的栈内存中分配。</strong>其中，64位长度的long和double类型的数据占用2个局部变量的空间，其他数据类型只占用1个。局部变量所需要的内存空间是在编译期间完成的，当进入一个方法时候，这个方法所需的局部变量空间已经确定，在方法运行期间不会改变。当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。当线程请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常。当虚拟机栈无法扩展时候则抛出OutOfMemoryError异常。</p>

<p>堆内存，在虚拟机启动时创建。堆内存的唯一目的就是创建对象实例，所有的对象实例和数组都要在堆上分配。对象的域即使是原始类型，也仍然分配在堆内存中。堆内存的回收由垃圾回收负责。</p>

<h4>标记和清除</h4>

<p>标记和清除是最简单、也是出现最早的垃圾收集算法。Perl和PHP等语言则采用引用计数法。</p>

<p>最简单的标记和清除算法会暂停所有正在运行的线程，并从一组“活”对象（任何用户线程的任何堆栈帧中存在引用的对象）开始遍历其引用树，标记出路径上的所有活对象。遍历完成后，所有没被标记的被当作垃圾，可以回收。被清除的内存不是还给OS，而是JVM。</p>

<p>Java平台对基本的标记清除算法进行了改进，采用“分代式垃圾收集”。内存分成了几个不同的区域：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-07-Java-Memory-Model-450x186.png" alt="image" /></p>

<ul>
<li>Eden(伊甸园)：对象最初降生的堆区域。</li>
<li>Survivor(幸存者乐园)：分为两个空间（S0, S1）,除非正在执行垃圾收集，否则总有一个空间是空的。</li>
<li>Old Generation：老年代。是那些“足够老”的幸存对象的归宿。</li>
<li>PermGen：为内部结构分配的内存，例如类定义。它不是严格的堆内存，并且普通的对象最后不会在这里结束。</li>
</ul>


<p>上面这些内存区域的垃圾收集方式不尽相同。</p>

<h4>年轻代收集（Minor GC）</h4>

<p>年轻代收集只会清理“年轻的”空间（伊甸园和幸存者乐园），其过程如下：</p>

<ul>
<li>在标记阶段发现的所有仍然存活的年轻对象都会被挪走：那些足够老的对象（从次数足够多的GC中幸存下来的）进入老年代；所有Eden中存活的对象被移到幸存者乐园的其中一个空间，幸存者乐园中的存活对象也会被移到该空间。（S0, S1总有一个是空的）</li>
<li>伊甸园和最近腾空的幸存者乐园可以重用了，因为它们里面已经全是垃圾了。</li>
</ul>


<h4>完全收集（Major GC）</h4>

<p>当年轻代收集不能把对象放进老年代时（空间不够了），就会触发一次完全收集，这通常要更长的时间。根据老年代所用的收集器，可能会牵涉到老年代对象的内部迁移。以确保必要时能从老年代对象所占的内存中给大的对象腾出足够的空间。这被称为压缩。</p>

<p>由于Major GC会消耗更长时间，消耗的时间取决于垃圾收集策略，这期间应用将无响应。因此在高响应应用中，有必要监视和优化垃圾回收以避免超时。</p>

<h4>安全点</h4>

<p>因为垃圾收集时，要暂停所有应用线程，因此线程给执行GC留出了特定的位置——安全点。常见的安全点是方法被调用的地方（调用点），不过也有其它安全点。当执行垃圾收集时，所有应用线程都必须停在安全点。</p>

<h3>4.2 工具</h3>

<p>借助一些工具可以帮你了解运行中的进程和垃圾收集。</p>

<h4>jmap</h4>

<p>jmap是Oracle JVM自带的一个工具，用来显示Java进程的内存映射，也能分析Java核心文件（Java core file，主要保存各应用线程在某一时刻的执行栈以及stack trace的显示）。</p>

<p><strong>默认视图</strong></p>

<p>jmap最简单的用法是查看连接到进程里的本地类库。用处不大，用得最多的是后面两种视图。</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>$ jmap 25154
Attaching to process ID 25154, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 24.65-b04</code></pre>


<p><strong>堆视图</strong></p>

<p>使用-heap选项，jmap会抓取进程当前的堆快照。以下是输出结果示例：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>$ jmap -heap 25164
Attaching to process ID 25164, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 24.65-b04

using thread-local object allocation.
Parallel GC with 4 thread(s)

Heap Configuration:
   MinHeapFreeRatio = 0
   MaxHeapFreeRatio = 100
   MaxHeapSize      = 2147483648 (2048.0MB)
   NewSize          = 1310720 (1.25MB)
   MaxNewSize       = 17592186044415 MB
   OldSize          = 5439488 (5.1875MB)
   NewRatio         = 2
   SurvivorRatio    = 8      //Eden = (From+To)*幸存比例
   PermSize         = 21757952 (20.75MB)
   MaxPermSize      = 85983232 (82.0MB)
   G1HeapRegionSize = 0 (0.0MB)

Heap Usage:
PS Young Generation
Eden Space:
   capacity = 69206016 (66.0MB)
   used     = 22857000 (21.798133850097656MB)
   free     = 46349016 (44.201866149902344MB)
   33.02747553045099% used
From Space:
   capacity = 5242880 (5.0MB)
   used     = 5223552 (4.9815673828125MB)
   free     = 19328 (0.0184326171875MB)
   99.63134765625% used
To Space:
   capacity = 5242880 (5.0MB)
   used     = 0 (0.0MB)
   free     = 5242880 (5.0MB)
   0.0% used
PS Old Generation
   capacity = 89128960 (85.0MB)
   used     = 14067336 (13.415657043457031MB)
   free     = 75061624 (71.58434295654297MB)
   15.78312593347886% used
PS Perm Generation
   capacity = 22020096 (21.0MB)
   used     = 15539944 (14.820045471191406MB)
   free     = 6480152 (6.179954528808594MB)
   70.57164510091145% used

10750 interned Strings occupying 1540688 bytes.</code></pre>


<p>可以看到，堆的大小是年轻代、老年代加上PermGen的总和。年轻代分为Eden和幸存者乐园（From + To）。要知道堆里面有什么，需要柱状视图。</p>

<p><strong>柱状视图</strong></p>

<p>柱状视图显示了系统中每个类型的实例占用的内存量，并按占用内存倒序排序，非常直观：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>$ jmap -histo 25164 | head -30

 num     #instances         #bytes  class name
----------------------------------------------
   1:         46155       20826544  [B
   2:         78977       13845352  [C
   3:          1777       10259592  [I
   4:         28606        3977416  &lt;constMethodKlass&gt;
   5:         28606        3670320  &lt;methodKlass&gt;
   6:          2464        2990888  &lt;constantPoolKlass&gt;
   7:          2193        1756960  &lt;constantPoolCacheKlass&gt;
   8:          2464        1728800  &lt;instanceKlassKlass&gt;
   9:         53032        1272768  java.lang.String
  10:         12669         405408  java.util.HashMap$Entry
  11:          2740         333816  java.lang.Class
  12:          4131         330480  java.lang.reflect.Method
  13:          4488         297968  [S
  14:          4204         287432  [Ljava.lang.Object;
  15:           524         271024  &lt;methodDataKlass&gt;
  16:          4277         228680  [[I
  17:          2107         185416  org.apache.naming.resources.FileDirContext$FileResourceAttributes
  18:          3047         170632  java.util.zip.ZipFile$ZipFileInputStream
  19:           987         167256  [Ljava.util.HashMap$Entry;
  20:          2929         164024  java.util.zip.ZipFile$ZipFileInflaterInputStream
  21:           259         140896  &lt;objArrayKlassKlass&gt;
  22:          4282         137024  java.io.File
  23:          2194         131888  [Ljava.lang.String;
  24:          5483         131592  java.lang.StringBuilder
  25:          2656         127488  java.util.HashMap
  26:          2520         100800  java.lang.ref.Finalizer
  27:          2341          93640  java.util.LinkedHashMap$Entry</code></pre>


<p>结果使用的是类型内部名称，例如byte数组会写成[B，char数组会写成[C（字符数组数据经常出现在String对象里）。参考<a href="http://blog.ubone.com/blog/2014/12/04/lei-wen-jian-yu-zi-jie-ma/">类文件与字节码</a>。以char数组为例，共有78977个实例，占用约13.8MB。</p>

<p>使用-histo:live选项，jmap将只处理活对象，而不是整个堆：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>$ jmap -histo:live 25164 | head -7

 num     #instances         #bytes  class name
----------------------------------------------
   1:         28573        5905704  [C
   2:         28606        3977416  &lt;constMethodKlass&gt;
   3:         28606        3670320  &lt;methodKlass&gt;
   4:          2464        2990888  &lt;constantPoolKlass&gt;</code></pre>


<p>活的字符串只有28573个实例，占用约5.9MB，证明有（13.8-5.9）MB在等待回收。需要注意的是，如果jmap正在执行时，JVM做了垃圾回收，有可能看到奇怪或太好的结果，所以应该多运行几次。</p>

<p><strong>产生离线导出文件</strong></p>

<p>jmap能创建导出文件：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>$ jmap -dump:live,format=b,file=heap.hprof 25164
Dumping heap to /Users/mxs/Documents/blog/heap.hprof ...
Heap dump file created</code></pre>


<p>导出结果可以用来做离线分析，留给jmap以后使用，或者留给Oracle的jhat（Java堆分析工具）做高级分析。</p>

<h4>jstat</h4>

<p>Oracle JVM自带的jstat可以查看内存和垃圾收集的活动，并能循环显示。下例以每秒一次的频率显示内存状况：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>meixuesongdeMacBook-Pro:blog mxs$ jstat -gc 25164 1000
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC     PU    YGC     YGCT    FGC    FGCT     GCT   
14336.0 13312.0  0.0    0.0   133632.0 85887.5   52224.0    10313.5   33280.0 15221.9      7    0.064   3      0.171    0.236
14336.0 13312.0  0.0    0.0   133632.0 85887.5   52224.0    10313.5   33280.0 15221.9      7    0.064   3      0.171    0.236</code></pre>


<ul>
<li>S0C和S1C: Survivor0和Survivor1的大小（KB）</li>
<li>S0U和S1U: Survivor0和Survivor1的已使用大小（KB）</li>
<li>EC and EU：Eden空间的大小和已经使用大小（KB）</li>
<li>OC and OU: 老年代空间的大小和已经使用大小（KB）</li>
<li>PC and PU: Perm空间的大小和已经使用大小（KB）</li>
<li>YGC and YGCT：YGC为年轻代GC的次数。YGCT显示年轻代GC的累计时间。</li>
<li>FGC and FGCT：Full GC的次数和累计时间</li>
<li>GCT：GC总时间，包括年轻代和Full GC。</li>
</ul>


<h4>Java VisualVM</h4>

<p>另一个可视化的工具是Java VisualVM，在命令行执行<code>jvisualvm</code>即可。</p>

<h3>4.3 与GC相关的JVM参数</h3>

<p>JVM的参数非常多。以<code>-X</code>开头的选项不是标准选项，在其它JVM上可能不可用。而<code>-XX</code>开头的是扩展选项，不要随便使用。很多与性能相关的选项都是扩展选项。</p>

<p>基本的垃圾收集选项可以见本文前面的内存分布图片。主要包括：</p>

<ul>
<li><code>-Xms</code>: 堆的初始大小</li>
<li><code>-Xmx</code>: 堆的最大大小</li>
<li><code>-Xmn</code>: 堆中年轻大的大小</li>
<li><code>-XX:-DisableExplicitGC</code>: 让System.gc()调用不产生任何作用。</li>
</ul>


<h3>4.4 逸出分析</h3>

<p>这是JVM最近的一项修改，开发者不能直接控制或影响这项修改。从Java 6u23之后，逸出分析是默认打开的。</p>

<p>它的基本思路是分析方法并确认其中哪个局部变量只用在方法内部，以及哪些变量不会传入其他方法或从当前方法中返回。JVM可以在当前方法的栈内部创建这个对象，不再使用堆内存。在当前方法返回时，被局部变量占用的内存就自动释放了，因此将减少程序年轻代收集的次数，提高性能。</p>

<h3>4.5 并发标记清除（CMS）</h3>

<p>CMS是Java 5推荐的高性能收集器，在Java 6仍保持了旺盛的生命力。通过以下选项激活：</p>

<table>
<thead>
<tr>
<th>选项 </th>
<th> 效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-XX:+UseConcMarkSweepGC</code> </td>
<td> 打开CMS收集</td>
</tr>
<tr>
<td><code>-XX:+CMSIncrementalMode</code> </td>
<td> 增量模式（一般都需要）</td>
</tr>
<tr>
<td><code>-XX:+CMSIncrementalPacing</code> </td>
<td> 配合增量模式，根据应用的行为自动调整每次执行垃圾回收任务的幅度（一般都需要）</td>
</tr>
<tr>
<td><code>-XX:+UseParNewGC</code> </td>
<td> 并发收集年轻代</td>
</tr>
<tr>
<td><code>-XX:ParallelGCThreads=&lt;N&gt;</code> </td>
<td> GC使用的线程数</td>
</tr>
</tbody>
</table>


<p>并发方式是如何工作的，以下是重要事实：</p>

<ul>
<li>某种世界停转（SWT）的暂停是不可避免的；</li>
<li>GC子系统绝对不能漏掉存活对象，这样做会导致JVM垮掉（或更糟）</li>
<li>只有所有应用线程都为整体收集暂停下来，才能保证收集所有的垃圾。</li>
</ul>


<p>CMS利用最后一点，制造两个非常短暂的STW暂停，并且在GC周期的剩余时间和应用程序的线程一起运行。CMS要在运行时做复杂的记账工作，记录哪些是垃圾，哪些不是。CMS在更多CPU核心的机器上表现会更好，并且会制造更频繁的短暂暂停。</p>

<h3>4.6 新的收集器：G1</h3>

<p>G1是Java平台最新的收集器，预发布于Java 6，到Java 7时已是成品。G1有望成为高性能应用的默认选择。</p>

<p>G1与原来的收集器完全不同，开发人员有更多控制权。其核心思想是暂停目标（Pause gaol），也就是程序能为GC暂停多长时间（如每5分钟20ms）。G1会努力达成该目标。</p>

<p>尽管G1仍然使用标记清除法，但它不是真正的分代式垃圾收集器。它把堆分成大小相同的区域（如每个1MB），不区分年轻、老年代。暂停时，对象被撤到其他区域（就像Eden挪到Survivor），清空的区域被放回到空白区自由列表上。</p>

<p>这个新的收集策略让Java平台统计收集单个区域所需平均时长。然后你就可以指定一个合理的暂停目标。G1只会在有限的时间内收集尽可能多的区域。与G1相关的选项如下表：</p>

<table>
<thead>
<tr>
<th>选项 </th>
<th> 效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-XX:+UseG1GC</code> </td>
<td> 打开G1收集</td>
</tr>
<tr>
<td><code>-XX:MaxGCPauseMillis=50</code> </td>
<td> 收集一次暂停的时间应尽量保持在50ms以内</td>
</tr>
<tr>
<td><code>-XX:GCPauseIntervalMillis=200</code> </td>
<td> 两次收集的时间间隔尽量保持在200ms以上。</td>
</tr>
</tbody>
</table>


<h2>5. HotSpot的JIT编译</h2>

<p>Java是一种“动态编译”语言。方法一开始都是以字节码形态存在，JVM对其解释并执行，同时会记录被调用的次数。当调用次数超过某个阈值（默认1万次）时，后台就会把字节码编译成机器码。如果编译成功，以后就会调用该方法的编译结果。编译后的机器码运行速度可能会快1000倍。</p>

<p>那为什么要动态编译，先编译好岂不是性能更好？原因之一是与平台无关的东西作为基本部署单位要更轻松。原因之二是动态编译能提供给编译器更多信息，例如某个指令是否可用，代码运行情况的统计数据等。因此Java这样的动态编译语言实际上可能会比提前编译的语言运行得更快。</p>

<p>HotSpot有两种运行模式：客户端模式和服务器模式，分别对应JVM启动选项：<code>-client</code>和<code>-server</code>。前者编译时会确保操作的一致性，较为保守。后者编译时会大胆假设，做一次运行时检查，以确保假设有效。编译结果性能好很多。</p>

<p><strong>实时Java</strong>是近年出现的，它并不一定是最快的。它关注的是让执行操作的时间尽量保持一致。为了达成这个目的，它可能会牺牲一些平均等待时间，整体性能可以受到轻微影响。</p>

<p><strong>内联</strong>是HotSpot的最大卖点之一。内联的方法不再是被调用，而是直接放到调用者内部。HotSpot会根据运行时的统计数据（方法调用频率）和其他因素来决定如何处理内联。这比提前编译更智能。它完全是自动的，通常不需要修改选项（用处不大）。</p>

<p><strong>独占调用</strong></p>

<p>独占调用是大胆优化的例子之一，只有服务端编译器才会做这种大胆优化，实时和客户端编译器都不会这样做。它是基于大量观察做出的优化，以下面的代码为例：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>MyActualClassNotInterface obj = getInstance();
obj.callMyMethod();</code></pre>


<p>如果上面的代码只会在一种类型的对象上调用（基于统计），也就是obj.callMyMethod()几乎不会同时碰到一个类和它的子类。这时就可以把Java方法查找替换为callMyMethod()编译结果的直接调用。为了防止getInstance()可能返回的是其他类，运行时会检查，确保对象的类型是由编译器按预期插入的。如果这个预期被违背，运行时会取消优化。程序不会注意到这些动作也不会犯任何错误。</p>

<p>通过启动选项<code>-XX:+PrintCompilation</code>可以告诉JIT编译线程输出标准日志。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类文件与字节码]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/04/lei-wen-jian-yu-zi-jie-ma/"/>
    <updated>2014-12-04T20:40:02+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/04/lei-wen-jian-yu-zi-jie-ma</id>
    <content type="html"><![CDATA[<p>本篇学习类加载过程、类文件的分析工具和字节码。</p>

<!--more-->


<h2>1. 类加载和类对象</h2>

<p>一个.class文件定义了JVM的一种类型。类加入到JVM当前运行态中，首先要加载并连接，进行大量验证，然后提供一个代表该类型的Class对象给正在运行的系统，用于创建新的实例。</p>

<h4>加载</h4>

<p>加载的过程首先要读取类文件的字节数据流，创建一个字节数组，然后产生对应的Class对象。这个过程会进行一些基本检查。加载结束时，Class对象还不成熟，类也不可用。</p>

<h4>连接</h4>

<p>加载完成后，类必须连接起来。这分为三个步骤：验证、准备和解析。验证类文件符合预期，不会引起系统运行时错误。准备阶段会分配内存，准备好初始化类中的静态变量（但不会现在初始化变量）。解析阶段会检查类中引用的类型是否有未知类型，如果有会加载进来。</p>

<h4>初始化</h4>

<p>一旦需要加载的其他类型全部定位并完成解析，VM就可以初始化这个类。这时所有静态变量都可以被初始化，所有静态初始化代码块都会运行。类的加载全部完成，已经可以使用了。</p>

<h4>Class对象</h4>

<p>加载和连接过程的最终结果是一个Class对象，可以使用这个新类型创建实例了。Class对象可以和反射API一起实现对方法、域和构造方法等类成员的间接访问，通过getSuperClass()返回其父类。</p>

<h4>类加载器</h4>

<p>比较两个类是否“相等”，只有这两个类是由同一个类加载器加载的前提下才有意义。同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类必定不等。这里所指的“相等”，包括Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果以及instanceof关键字。</p>

<p>Java平台有几个经典的类加载器：</p>

<ul>
<li>根（或引导）类加载器：通常在VM启动后不久实例化，一般用本地代码实现。可视为VM的一部分。负责加载系统的基础JAR(主要是rt.jar),而且不做验证工作。</li>
<li>扩展类加载器：用来加载安装时自带的标准扩展。一般包括安全性扩展。</li>
<li>应用（或系统）类加载器：应用最广泛的类加载器，负责加载应用类。</li>
<li>定制类加载器：在更复杂的环境，如EE或比较复杂的SE框架，通常会有些附加（即定制）的类加载器。</li>
</ul>


<p>在实现类加载器时，Java推荐使用双亲委派模型。即定制类加载器继承自应用类加载器，应用类加载器继承自扩展类加载器，扩展类加载器继承自根类加载器。其工作过程是，如果一个类加载器收到了类加载的请求，它首先把这个请求委派给父类加载器去完成，每个层次的类加载器都是如此，因此所有的加载请求都最终应该传送到顶层的根类加载器。只有当父类加载器反馈自己无法完成加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。双亲委派模型的代码实现示例如下：</p>

<pre class='line-numbers language-java'><code class='language-java'>protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {
    //先检查类是否已经加载过了
    Class c = findLoadedClass(name);
    if (c == null) {
        try {
            if (parent != null) {
                c = parent.loadClass(name, false);
            } else {
                c = findBootstrapClassOrNull(name);
            }
        } catch(ClassNotFoundException e) {
            //如果父类抛出异常，说明父类加载器无法完成加载请求
        }
        
        if (c == null) {
            //父类无法加载时，调用本身的findClass方法进行类加载
            c = findClass(name);
        }
    }
    
    if (resolve) {
        resolveClass(c);
    }
    
    return c;
}</code></pre>


<p>从JDK1.2之后，不再提倡用户覆盖loadClass()方法，而应当把自己的类加载逻辑放到findClass()方法中。随着用户对程序动态性的要求，双亲委派模型不一定成立。例如在OSGi中，类加载器变成了复杂的网状结构。</p>

<p>OSGi的Bundle类加载器之间只有规则，没有固定的委派关系。例如，某个Bundle声明了一个它依赖的Package，如果有其他Bundle声明发布了这个Package，那么所有对这个Package的类加载动作都会委派给发布它的Bundle类加载器去完成。一个Bundle类加载器为其他Bundle提供服务时，会根据Export-Package列表严格控制访问范围。如果一个类存在于Bundle的类库中但没有被Export，那么这个Bundle的类加载器能找到这个类，但不会提供给其他Bundle使用，而且OSGi平台也不会把其他Bundle的类加载请求分配给这个Bundle来处理。</p>

<p>假设有三个Bundle：A, B和C。A依赖了<code>java.*</code>包；B依赖于A、C和<code>java.*</code>包；C依赖于A。那么这三个Bundle的类加载器如下图所示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2015-01-21.jpg" alt="image" /></p>

<p>如上图所示，OSGi中类加载器的关系不再是双亲委派模型的树形结构，而是已经发展成网状结构。但带来灵活性的同时，也引入了额外的复杂度，带来了线程死锁和内存泄露的风险。</p>

<h2>2. 方法句柄</h2>

<p>反射代码有很多套路，要捕获各种讨厌的异常，代码看起来也不直观。Java 7为间接调用方法引入了java.lang.invoke包，即方法句柄，可以提高安全性和代码的可读性。</p>

<h4>MethodHandle</h4>

<p>它是对可直接执行的方法（或域、构造方法等）的类型化引用，是一个有能力安全调用方法的对象。</p>

<pre class='line-numbers language-java'><code class='language-java'>MethodHandle mh = getTwoArgMH();
MyType ret;
try {
    //调用obj对象的句柄，传入参数arg0, arg1
    ret = mh.invokeExact(obj, arg0, arg1);
} catch(Throwable e) {
    //...
}</code></pre>


<h4>MethodType</h4>

<p>它表示方法签名类型的不可变对象。每个方法句柄都有一个MethodType实例，用来指明方法的返回类型和参数类型。但它没有方法的名称和接收者类型。通过工厂方法可以得到MethodType实例：</p>

<pre class='line-numbers language-java'><code class='language-java'>//第一个参数为返回类型，随后是方法参数的类型。
//toString()
MethodType mtToString = MethodType.methodType(String.class);
//setter方法
MethodType mtSetter = MethodType.methodType(void.class, Object.class);
//Comparator&lt;String&gt;定义的compareTo()方法
MethodType mtStringComparator = MethodType.methodType(int.class, String.Class, String.class);</code></pre>


<h4>查找方法句柄</h4>

<p>通过lookup对象，你给出持有所需方法的类、方法名称以及你所需方法签名相匹配的MethodType，就可以得到方法句柄：</p>

<pre class='line-numbers language-java'><code class='language-java'>public MethodHandle getToStringMH() {
    MethodHandle mh;
    MethodType mt = MethodType.methodType(String.class);
    MethodHandles.Lookup lk = MethodHandles.lookup();
    
    try {
        mh = lk.findVirtual(getClass(), "toString", mt);
    } catch(NoSuchMethodException | IllegalAccessException mhx) {
        //...
    }
    
    return mh;
}</code></pre>


<blockquote><p>如果不是从当前类中查找，则只能看到或取得public方法的句柄。方法句柄总是在安全管理之下安全使用。没有反射中setAccessible()那种破解方法。</p></blockquote>

<p>有了方法句柄，就可以执行它了。执行方法有两个：invokeExact()和invoke()。前者要求参数类型完全匹配，后者可以在不太匹配时做些修改后执行（如装箱或拆箱）。</p>

<h4>示例：反射、代理和方法句柄的使用对比</h4>

<p>现在通过一个实例来对比这三种方法。下面的代码演示了如何通过这三种方法来访问私有方法cancel()：</p>

<pre class='line-numbers language-java'><code class='language-java'>public class ThreadPoolManager {
    //...
    private void cancel(final ScheduledFuture&lt;?&gt; hndl) {
        //...
    }
    
    /* 反射方法
    * 使用方法简单示例：
    * Method meth = manager.makeReflective();
    * meth.invoke(hndl);
    */
    public Method makeReflective() {
        Method method = null;
        try {
            Class&lt;?&gt; argTypes = new Class[] {ScheduledFuture.class};
            method = ThreadPoolManager.class.getDeclaredMethod("cancel", argTypes);
            method.setAccessible(true);
        } catch(IllegalArgumentException | NoSuchMethodException | SecurityException e) {
            //...
        }
        
        return method;
    }
    
    /* 代理方法
    *  使用方法简单示例：
    *  CancelProxy proxy = manager.makeProxy();
    *  proxy.invoke(manager, hndl);
    */
    public static class CancelProxy {
        private CancelProxy() {}
        public void invoke(ThreadPoolManager mae, ScheduledFuture&lt;?&gt; hndl) {
            mae.cancel(hndl);
        }
    }
    
    public CancelProxy makeProxy() {
        return new CancelProxy();
    }
    
    /* 方法句柄
    * 使用方法简单示例：
    * MethodHandle mh = manager.makeMh();
    * mh.invokeExact(manager, hndl);
    */
    public MethodHandle makeMh() {
        MethodHandle mh;
        MethodType desc = MethodType.methodType(void.class, ScheduledFuture.class);
        try {
            mh = MethodHandles.lookup().findVirtual(ThreadPoolManager.class, "cancel", desc);
        } catch(NoSuchMethodException | IllegalAccessException e) {
            //...
        }
        
        return mh;
    }
}</code></pre>


<p>三种方法的比较：</p>

<table>
<thead>
<tr>
<th>方法 </th>
<th> 访问控制 </th>
<th> 类型纪律 </th>
<th> 性能  </th>
</tr>
</thead>
<tbody>
<tr>
<td>反射 </td>
<td> 必须使用setAccesible。会被安全管理器禁止 </td>
<td> 不匹配就抛异常 </td>
<td> 较慢</td>
</tr>
<tr>
<td>代理 </td>
<td> 内部类可以访问受限方法 </td>
<td> 静态，为了代理全部代理类，可能需要更多PermGen </td>
<td> 跟其他方法一样快</td>
</tr>
<tr>
<td>方法句柄 </td>
<td> 取决于上下文，与安全管理器没有冲突 </td>
<td> 运行时是类型安全的，不占用PermGen </td>
<td> 力求跟其他方法调用一样快</td>
</tr>
</tbody>
</table>


<p>方法句柄还有一个特性，可以在静态上下文中确定当前类。例如下面的代码改写了logger的创建方式，可以不用将类名写死：</p>

<pre class='line-numbers language-java'><code class='language-java'>Logger logger = LoggerFactory.getLogger(MyClass.class);
//可改为：
Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());</code></pre>


<h2>3. 了解类文件</h2>

<h3>3.1 类文件的结构</h3>

<p>Class文件是一组以8位字节为基础单位的二进制流，各数据项目严格按照顺序紧凑排列，中间没有添加任何分隔符。当遇到需要占用8位字节以上的数据项时，会按照高位在前（Big-Endian，最高位字节在地址最低位，最低位字节在地址最高位。SPARC, POWERPC是这种方式，而x86则相反）的方式分割成若干个8位字节进行存储。</p>

<p>Class文件格式采用类似C语言结构体的伪结构来存储数据，这种伪结构只有两种数据类型：无符号数和表。无符号数属于基本数据类型，u1, u2,u4,u8分别代表1，2，4，8个字节的无符号数。无符号数用来描述数字、索引引用、数量值或者按照UTF8编码构成字符串值。表是由多个无符号数或者其他表作为数据项构成的复合数据类型。所有表都习惯以“_info”结尾。整个Class文件本质上就是一张表。</p>

<p>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会用一个前置的计数器（表示数量）加若干连续的数据项（某一类型的集合）形式来表示。</p>

<p>每个Class文件的头4个字节称为<strong>魔数</strong>（Magic Number），值为<code>0xCAFEBABE</code>，其作用是确定这个文件是否为虚拟机所接受。紧接魔数之后的是4个字节的<strong>Class文件版本号</strong>。第5，6字节是次版本号，第7，8字节是主版本号。（JDK1.0的版本号是45.0，JDK1.7.0可生成的Class文件主版本号最大值为51）</p>

<p>版本号之后是<strong>常量池</strong>入口。常量池中的常量数量是不固定的，所以先有一项u2类型的数据表示常量池容量数值（constant_pool_count）。它从1开始计数，0被空出来，用于某些指向常量池的索引值的数据在特定情况下表达“不引用任何一个常量池项目”的含义。</p>

<p>常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。字面量比较接近于常量概念，如字符串、声明为final的常量值等。而符号引用则包括类和接口的全限定名（Full Qualifed Name）、字段的名称和描述符以及方法的名称和描述符。当虚拟机运行时，需要从常量池获得对应的符号引用，瑞在类创建时或运行时解析、翻译到具体的内存地址中。</p>

<p>常量池中每一项常量都是一个表，JDK1.7之前共有11种不同的表结构数据，1.7又增加了三种以支持动态语言调用。这14种表的第1位是u1类型的标志位，代表当前这个常量属于哪种常量类型。每种常量类型均有自己的结构。</p>

<p><strong>访问标志</strong>紧跟常量池，用两个字节表示。主要用于识别Class是类还是接口，是否public，是否abstract类型，是否final等。</p>

<p><strong>类索引、父类索引和接口索引集合</strong>按顺序排列在访问标志之后。类索引用于确定这个类的全限定名，父类索引用于确定父类的全限定名，他们都用两个u2类型的索引值表示。接口索引集合用于描述这个类实现了哪些接口，由于这是可变的，因为入口有一个计数器表示索引表的容量。</p>

<p><strong>字段表集合</strong>（Field_info）用于描述接口或类中声明的亦是。包括类变量和实例变量，但不包括方法的局域变量。信息包括作用域（public/private/protected）、实例还是类变量(static)、可变性（final）、并发可见性(volatile)、可否序列化（transient）、数据类型、字段名等。字段表集合不会列出父类或实现接口中继承的字段，但可能列出原本Java代码中不存在的字段（如向内部类添加指向外部类实例的字段）。</p>

<p><strong>方法表集合</strong>与字段表集合相似。但方法里的Java代码编译成字节码指令后存放在方法属性表集合中一个名为“Code”的属性里面。Code属性表包含方法的很多信息。只说几个重要的：</p>

<ul>
<li>max_stack:方法的操作数栈（Operand Stacks）深度最大值</li>
<li>max_locals:局部变量所需的存储空间。单位为Slot，局部变量分配内存的最小单位。byte,int等长度不超过32位的数据类型，每个局部变量占用1个Slot，doublue和long需要2个Slot。并不是方法中用到多少个局部变量，所占Slot之和就是所需存储空间，Slot是可以重用的，当代码执行超过一个局部变量的作用域时，这个局部变量的Slot就可以被其他局部变量使用。</li>
<li>code_length:字节码长度</li>
<li>code: 存储字节码指令的一系列字节流。</li>
<li>exception_table:异常表，编译器使用异常表而不是简单的跳转命令来实现Java异常及finally处理机制。</li>
</ul>


<p>方法表除了Code属性，还有还有多种其他属性。例如Exceptions属性（即方法声明中的throws列表的异常）、LineNumberTable属性（javac用<code>-g:none</code>或<code>-g:lines</code>参数。如果不生成LineNumberTable属性，则异常中不会显示出错的行号）、LocalVariableTable属性（javac用<code>-g:none</code>或<code>-g:vars</code>参数，如果不生成这项信息，IDE只会显示arg0, arg1等，丢失了原有的参数名）。</p>

<p><strong>属性表集合</strong>，Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。</p>

<p>由于类文件是二进制文件，和它打交道并不容易。Oracle JVM的javap这个工具可以用来探视类文件内部和反编译。</p>

<p>我们以一个简单的Java类作为示例：</p>

<pre class='line-numbers language-java'><code class='language-java'>public class Sample {
    private byte b;
    private char c;
    private double d;
    private float f;
    private int i;
    private Integer Int;
    private long l;
    private String s;
    private boolean bl;
    private int[] array;
    
    //getter, setter</code></pre>


<h3>3.2 查看类文件的方法和属性</h3>

<pre class='line-numbers language-java'><code class='language-java'>$ javap  Sample.class 
Compiled from "Sample.java"
public class com.ubone.tdd.chapter1.javaio.Sample {
  public com.ubone.tdd.chapter1.javaio.Sample();
  public byte getB();
  public void setB(byte);
  public char getC();
  //其它getter, setter方法...
}</code></pre>


<p>javap默认显示public, protected和包级protected级别的方法和属性。加上-p选项后可以显示private方法和属性。</p>

<h3>3.3 方法签名的内部形式</h3>

<p>JVM内部用的方法签名使用紧凑形式，例如int用I表示。这称为类型描述符：</p>

<ul>
<li>B: byte</li>
<li>C: char(16位Unicode字符)</li>
<li>D: double</li>
<li>F: float</li>
<li>I: int</li>
<li>J: long</li>
<li>L&lt;类型名称>: 引用类型，如：Ljava/lang/String</li>
<li>S: short</li>
<li>Z: boolean</li>
<li>[: array-of</li>
</ul>


<p>使用javap -s可以输出签名的类型描述符：</p>

<pre class='line-numbers language-java'><code class='language-java'>$ javap -s Sample.class 
Compiled from "Sample.java"
public class com.ubone.tdd.chapter1.javaio.Sample {
  public com.ubone.tdd.chapter1.javaio.Sample();
    Signature: ()V

  public byte getB();
    Signature: ()B

  public void setB(byte);
    Signature: (B)V

  public char getC();
    Signature: ()C

  public void setC(char);
    Signature: (C)V

  public double getD();
    Signature: ()D

  public void setD(double);
    Signature: (D)V

  public float getF();
    Signature: ()F

  public void setF(float);
    Signature: (F)V

  public int getI();
    Signature: ()I

  public void setI(int);
    Signature: (I)V

  public java.lang.Integer getInt();
    Signature: ()Ljava/lang/Integer;

  public void setInt(java.lang.Integer);
    Signature: (Ljava/lang/Integer;)V

  public long getL();
    Signature: ()J

  public void setL(long);
    Signature: (J)V

  public java.lang.String getS();
    Signature: ()Ljava/lang/String;

  public void setS(java.lang.String);
    Signature: (Ljava/lang/String;)V

  public boolean isBl();
    Signature: ()Z

  public void setBl(boolean);
    Signature: (Z)V

  public int[] getArray();
    Signature: ()[I

  public void setArray(int[]);
    Signature: ([I)V
}</code></pre>


<h3>3.4 常量池</h3>

<p>常量池是为类文件中的其他（常量）元素提供快捷访问方式的区域。通过javap -v可以查看常量池的信息：</p>

<pre class='line-numbers language-java'><code class='language-java'>Constant pool:
   #1 = Class              #2             //  com/ubone/tdd/chapter1/javaio/Sample
   #2 = Utf8               com/ubone/tdd/chapter1/javaio/Sample
   #3 = Class              #4             //  java/lang/Object
   #4 = Utf8               java/lang/Object
   #5 = Utf8               b
   #6 = Utf8               B
   #7 = Utf8               c
   #8 = Utf8               C
   #9 = Utf8               d
  #10 = Utf8               D
  #11 = Utf8               f
  #12 = Utf8               F
  #13 = Utf8               i
  #14 = Utf8               I
  #15 = Utf8               Int
  #16 = Utf8               Ljava/lang/Integer;
  #17 = Utf8               l
  #18 = Utf8               J  
  ...
  #70 = Utf8               getL
  #71 = Utf8               ()J
  #72 = Fieldref           #1.#73         //  com/ubone/tdd/chapter1/javaio/Sample.l:J
  #73 = NameAndType        #17:#18        //  l:J
  #74 = Utf8               setL
  #75 = Utf8               (J)V
  ...</code></pre>


<p>如上所示，常量池的条目是带有类型的，它们还会相互引用。例如类型为Class的条目会引用类型为Utf8的条目。后者是个字符串，因此第1行为类的名称。</p>

<p>72行的Fieldref定义了一个域，解析这个域需要名称、类型和它所在的类。<code>#1.#73</code>表示来自类<code>#1</code>,域为<code>#73</code>。<code>#73</code>的NameAndType描述名称和类型，分别来自17和18，即类型J(Long)，名称为<code>l</code>。</p>

<h2>4. 字节码</h2>

<p>字节码的基本特性：</p>

<ul>
<li>字节码是程序的中间表示形式，介于人类可读的源码和机器码之间。</li>
<li>字节码由javac产生。</li>
<li>某些高级语言特性在编译时已经从字节码去掉。例如for语句在字节码中被转换成分支指令。</li>
<li>每个操作码都由一个字节表示（因此叫做字节码）。</li>
<li>字节码可以进一步编译成机器码，也就是“即时编译”。</li>
</ul>


<h3>反编译类</h3>

<p>javap可以用于反编译类：</p>

<pre class='line-numbers language-java'><code class='language-java'>$ javap -c -p Sample.class 
Compiled from "Sample.java"
public class com.ubone.tdd.chapter1.javaio.Sample {
  private byte b;

  private char c;
  ...
  
    public com.ubone.tdd.chapter1.javaio.Sample();
    Code:
       0: aload_0       
       1: invokespecial #28                 // Method java/lang/Object."&lt;init&gt;":()V
       4: return        
  ...
  
  public long getL();
    Code:
       0: aload_0       
       1: getfield      #72                 // Field l:J
       4: lreturn       

  public void setL(long);
    Code:
       0: aload_0       
       1: lload_1       
       2: putfield      #72                 // Field l:J
       5: return        

</code></pre>


<p>代码前的数字表示从方法开始算起的字节码偏移量。先看构造方法，由于void构造方法总会隐式调用父类的构造方法。因此有invokespecial指令。对于方法getL()和setL()也可以看到相应的操作码和参数。</p>

<p>javac产生的字节码没有经过特别优化，是非常简单的表示形式。大部分优化工作由JIT编译器来完成。</p>

<h3>运行时环境</h3>

<p>JVM没有处理器寄存器，而是使用堆栈机完成所有的计算和操作，所以理解堆栈机的操作对理解字节码至关重要。方法在运行时需要一块内存区域作为计算堆栈来计算新值。另外，每个运行的线程都需要一个调用堆栈来记录当前正在执行的方法。来看下面的代码是如何完成计算的：</p>

<p><code>return 3 + petRecords.getNumberOfPets("Ben");</code></p>

<p>系统首先会把3压入操作数栈，然后把接收对象（petRecords）压入计算堆栈，传入的参数尾随其后。然后invoke操作符会调用方法getNumberOfPets，把控制权移交给被调用的方法。进入新方法后，需要启用不同的操作数栈，所以已经在调用者操作数栈中的值不可能影响被调用方法的计算结果。</p>

<p>当getNumberOfPets完成时，返回结果会被放到调用者的操作数栈中，进程中与getNumberOfPets相关的部分也会从调用堆栈中移走。然后相加运算得到结果。</p>

<h3>操作码</h3>

<p>JVM字节码由操作码（opcode）序列构成，每个指令后可能会跟一些参数（Operands，操作数）。每个操作码由一个单字节值表示，所以最多有255个操作码。目前用了200个左右。大致可以分为以下几类，摘要说明如下：</p>

<blockquote><ul>
<li>参数：操作码参数。如果参数出现在括号中，表示可选。以i打头的参数用来作为常量池或局部变量中的查询索引的几个字节。如果有多个此类参数，会合并在一直。例如i1,i2表示从这两个字节生成一个16位的索引。</li>
<li>堆栈布局：展示栈在操作码执行前后的状态。</li>
<li>表中操作码并不全，只用于示例。</li>
</ul>
</blockquote>

<p>加载和储存操作码，这个族系负责将值加载到栈或者检索值。有很多不同形式的变体。如dload操作码把双精度数从局部变量加载到栈上。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-05-5-4.jpg" alt="image" /></p>

<p>数学运算操作码用来执行数学运算。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-05-5-5.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-05-5-6.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-05-5-7.jpg" alt="image" /></p>

<p><strong>平台操作操作码</strong></p>

<p>在字节码这一级，构造方法被转换成带有特殊名称<init>的方法。不能由用户代码调用，但可以由字节码调用。这便形成了一个与对象创建直接相关的不同的字节码模式：new之后跟着一个dup，然后是一个调用<init>方法的invokespecial.</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-05-5-8.jpg" alt="image" /></p>

<blockquote><p>为了节省字节，很多字节码都有快捷方式。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java并发编程(四)]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/01/javabing-fa-bian-cheng-si/"/>
    <updated>2014-12-01T22:43:50+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/01/javabing-fa-bian-cheng-si</id>
    <content type="html"><![CDATA[<p>在学习了《Java编程思想》中关于<a href="http://blog.ubone.com/blog/2014/09/02/javabing-fa-bian-cheng-san/">并发编程</a>的内容后，继续学习Java并发编程。</p>

<!--more-->


<h2>1. 常用的并发构件</h2>

<h3>为什么是synchronized?</h3>

<p>这个单词的意思是同步，那么Java中synchronized表示什么意思呢？其实就是同步被锁定对象的主内存块。</p>

<ul>
<li>当进入一个synchronized代码块时，持有锁的线程和被锁定对象主内存中的视图会进行同步。</li>
<li>当synchronized代码块执行完之后，被锁定对象所做的任何修改会在线程锁释放之前刷回到主内存中。</li>
</ul>


<p>而volatile变量，在使用之前总是会从主内存中再读出来。线程所写的值总会在指令完成之前被刷回到主内存中。volatile变量不会引入线程锁，是真正线程安全的。<strong>但只有写入时不依赖当前状态（读取的状态）的变量才应该声明为volatile变量。对于要关注当前状态的变量，只能借助线程锁保证绝对安全性。</strong></p>

<h3>Lock有什么好处？</h3>

<ul>
<li>添加不同类型的锁，比如读取锁和写入锁。</li>
<li>对锁的阻塞没有限制，即允许在一个方法中上锁，在另一个方法中解锁。</li>
<li>如果线程得不到锁，比如锁由另外一个线程持有，就允许该线程后退或继续执行，或者做点别的事情——运用tryLock()方法。</li>
<li>允许线程尝试取锁，并可以在超过等待时间后放弃。</li>
</ul>


<p>Lock接口的两个实现类：</p>

<ul>
<li>ReentranLock: 本质上与同步块一样，但更灵活些。</li>
<li>ReentranReadWriteLock: 在读多写入的时候，性能更好。</li>
</ul>


<h3>ConcurrentHashMap</h3>

<p>ConcurrentHashMap是HashMap的并发版本，改进了Collections.synchronizedMap()功能。它是concurrent包中最有用的类之一，不仅提供了多线程的安全性，而且性能更优。它提供了原子操作的新方法：</p>

<ul>
<li>putIfAbsent(): 如果没有对应键，则将键值对添加到HashMap中。</li>
<li>remove(): 如果键存在，且值与当前状态相等，则用原子方式移除键值对。</li>
<li>replace(): 当键存在时，进行原子替换。</li>
</ul>


<h3>CopyOnWriteArrayList</h3>

<p>它是标准ArrayList的替代品，通过copy-on-write来实现线程安全性，对修改列表的任何操作都会创建一个新复本。当快速、一致的数据快照（不同的读取器读到的数据偶尔可能会不一样）比完美的同步以及性能上的突破更重要时，这种共享数据的方法非常理想，经常出现在非关键任务中。</p>

<h3>Queue</h3>

<p>Java有些多线程编程模型在很大程度上依赖于Queue实现线程安全性。BlockingQueue是最简单的实现。向队列put()时，如果队列满则放入线程会等待。从队列take()时，如果队列空，则取出线程阻塞。</p>

<p>Queue接口全是泛型<code>Queue&lt;E&gt;</code>，利用这一点把工作项封装到一个人工容器中会更方便。例如工作单元MyAwesomeClass，与其用<code>BlockingQueue&lt;MyAwesomeClass&gt;</code>不如使用<code>BlockingQueue&lt;WorkUnit&lt;MyAwesomeClass&gt;&gt;</code>：</p>

<pre class='line-numbers language-java'><code class='language-java'>public class WorkUnit&lt;T&gt; {
    private final T workUnit;
    public T getWork() {return workUnit;}
    public WorkUnit(T workUnit) {
        this.workUnit = workUnit;
    }
}</code></pre>


<p>有了这层间接引用，可以添加额外的元数据而不用牺牲MyAwesomeClass的完整性。例如在WorkUnit中添加用于测试、性能指标和运行时系统信息等。</p>

<p>除了基本的put()和take()方法，BlockingQueue还提供了还超时的放入和取出方法：offer(E e, long timeout, TimeUnit unit)和poll(long timeout, TimeUnit unit)。</p>

<p>Java 7还引入了TransferQueue，本质上是多了transfer()操作的BlockingQueue。在BlockingQueue中，当上游线程池比下游快时，可能会引发一些问题，导致LinkedBlockingQueue溢出。反之，如果下游比上游快，则可能队列经常空着。TransferQueue可以优化这种情况，调控上/下游的速度。当消费线程在等待时，transfer()操作会马上把工作项传给它，否则就会阻塞直到取走工作项的线程出现。可以把这看做“挂号信”选项，即正在处理工作项的线程在交付当前工作项之前不会开始其他工作项的工作。</p>

<p>用TransferQueue取代BlockingQueue的代码性能可能会更好，因为前者的实现考虑了现代编译器和处理器的特性，执行效率更高。</p>

<h2>2. 控制执行</h2>

<p>如果每个工作单元都启动一个新线程执行，效率会太低。因此可以利用线程池来执行工作单元/任务。</p>

<h3>任务建模</h3>

<p>任务建模可以采用三种办法：Callable, Future接口和FutureTask类。</p>

<h4>Callable接口</h4>

<p>Callable接口代表一段可以调用并返回结果的代码，典型用法是匿名实现类：</p>

<pre class='line-numbers language-java'><code class='language-java'>final MyObject obj = new MyObject();

Callable&lt;String&gt; cb = new Callable&lt;String&gt;() {
    public String call() throws Exception {
        return obj.someMethod();
    }
};

String s = cb.call();</code></pre>


<h4>Future接口</h4>

<p>Future接口用来表示异步任务。主要有三个方法：</p>

<ul>
<li>get()，获取结果，如果没执行完会阻塞，直到能取得结果。</li>
<li>cancel()，在结束前取消。</li>
<li>isDonw()，判断是否结束。</li>
</ul>


<pre class='line-numbers language-java'><code class='language-java'>interface ArchiveSearcher { String search(String target); }
 class App {
   ExecutorService executor = ...
   ArchiveSearcher searcher = ...
   void showSearch(final String target)
       throws InterruptedException {
     Future&lt;String&gt; future
       = executor.submit(new Callable&lt;String&gt;() {
         public String call() {
             return searcher.search(target);
         }});
     displayOtherThings(); // do other things while searching
     try {
       displayText(future.get()); // use future
     } catch (ExecutionException ex) { cleanup(); return; }
   }
 }</code></pre>


<h4>FutureTask类</h4>

<p>FutureTask类是Future接口的常用实现类，实现了Runnable接口，因此可以由执行者调度。它提供的方法基本是Future和Runnable接口的组合：get(), cancel(), isDone(), isCancelled()和run()。它还提供了两个很方便的构造器：一个以Callable为参数，另一个以Runnable为参数。</p>

<pre class='line-numbers language-java'><code class='language-java'>FutureTask&lt;String&gt; future =
       new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() {
         public String call() {
           return searcher.search(target);
       }});
executor.execute(future);</code></pre>


<h3>ScheduledThreadPoolExecutor(STPE)</h3>

<p>STPE是Executors类工厂方法的众多执行者之一。它有以下特点：</p>

<ul>
<li>可以预定线程池大小，也可自适应</li>
<li>所安排的任务可以定期执行，也可只运行一次。</li>
</ul>


<pre class='line-numbers language-java'><code class='language-java'>ScheduledExecutorService stpe = Executors.newScheduledThreadPool(2);

final Runnable msgReader = new Runnable() {
    public void run() {
        //...
    }
};

//每10毫秒唤醒一个线程。该线程可以尝试poll一个队列...
ScheduledFuture&lt;?&gt; hndl = stpe.scheduleAtFixedRate(msgReader, 10, 10, TimeUnit.MILLISECONDS);</code></pre>


<h2>3.分支/合并框架</h2>

<p>这是Java 7重点突出的框架之一，用于轻量级并发，实现线程池中任务的自动调度。</p>

<p>先来看看之前的并发算法可能存在的问题。如果某个线程的运行队列都是小任务，而另一个全是大任务。那么小任务的线程可能会空闲很多。而基于Work-Stealing（工作窃取）算法的ForkJoin则可以很好地解决此问题。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-02-fork-join.GIF" alt="image" /></p>

<ul>
<li>分支/合并框架引入一种新的执行者服务，称为ForkJoinPool</li>
<li>ForkJoinPool处理比线程更小的并发单元ForkJoinTask</li>
<li>ForkJoinTask是一种由ForkJoinPool以更轻量化的方式所调度的抽象</li>
<li>通常使用两种任务（尽管都表示为ForkJoinTask实例）：“小型”任务是无需耗费太多时间就可以直接执行的任务；“大型”任务是需要分解（可能多次分解）后再执行的任务。</li>
</ul>


<p>这个框架的关键特性之一就是这些轻量的任务都能生成新的ForkJoinTask实例，而这些实例将仍由执行它们父任务的线程池来安排调度。这就是分而治之。例如在归并算法中，就可以将左侧、右侧的排序任务视为一个ForkJoinTask，在递归过程中，不断产生小型任务执行。下面的示例是一个对微博按时间归并排序的例子：</p>

<pre class='line-numbers language-java'><code class='language-java'>//RecursiveAction继承自ForkJoinTask&lt;Void&gt;
public class MicroBlogUpdateSorter extends RecursiveAction {
  private static final int SMALL_ENOUGH = 32;
  private final Update[] updates;
  private final int start, end;
  private final Update[] result;

  public MicroBlogUpdateSorter(Update[] updates_) {
    this(updates_, 0, updates_.length);
  }

  public MicroBlogUpdateSorter(Update[] upds_, int startPos_, int endPos_) {
    start = startPos_;
    end = endPos_;
    updates = upds_;
    result = new Update[updates.length];
  }

  private void merge(MicroBlogUpdateSorter left_, MicroBlogUpdateSorter right_) {
    int i = 0;
    int lCt = 0;
    int rCt = 0;
    while (lCt &lt; left_.size() && rCt &lt; right_.size()) {
      result[i++] = (left_.result[lCt].compareTo(right_.result[rCt]) &lt; 0) ? left_.result[lCt++]
          : right_.result[rCt++];
    }
    while (lCt &lt; left_.size())
      result[i++] = left_.result[lCt++];
    while (rCt &lt; right_.size())
      result[i++] = right_.result[rCt++];
  }

  public int size() {
    return end - start;
  }

  public Update[] getResult() {
    return result;
  }

  @Override
  protected void compute() {
      //如果数组太小，就用系统排序
    if (size() &lt; SMALL_ENOUGH) {
      System.arraycopy(updates, start, result, 0, size());
      Arrays.sort(result, 0, size());
    } else {
      int mid = size() / 2;
      MicroBlogUpdateSorter left = new MicroBlogUpdateSorter(updates, start,
          start + mid);
      MicroBlogUpdateSorter right = new MicroBlogUpdateSorter(updates, start
          + mid, end);
      invokeAll(left, right);
      merge(left, right);
    }
  }
  
    public static void main() {
    List&lt;Update&gt; lu = new ArrayList&lt;Update&gt;();
    String text = "";
    final Update.Builder ub = new Update.Builder();
    final Author a = new Author("Tallulah");

    for (int i = 0; i &lt; 256; i++) {
      text = text + "X";
      long now = System.currentTimeMillis();
      lu.add(ub.author(a).updateText(text).createTime(now).build());
      try {
        Thread.sleep(1);
      } catch (InterruptedException e) {
      }
    }
    Collections.shuffle(lu);
    Update[] updates = lu.toArray(new Update[0]); // Avoid allocation by passing
                                                  // zero-sized array
    MicroBlogUpdateSorter sorter = new MicroBlogUpdateSorter(updates);
    ForkJoinPool pool = new ForkJoinPool(4);
    pool.invoke(sorter);

    for (Update u : sorter.getResult()) {
      System.out.println(u);
    }
  }
}</code></pre>


<p>如果下面这些问题答案是肯定的，那么就适合于使用分支/合并框架：</p>

<ul>
<li>问题的子任务是否无需与其他子任务有显式的协作或同步也可以工作？</li>
<li>子任务是不是不会对数据进行修改，只是经过计算得出结果？</li>
<li>对于子任务来说，分而治之是不是很自然的事？子任务是不是会创建更多的子任务，而且它们要比派生出它们的任务粒度更细？</li>
</ul>

]]></content>
  </entry>
  
</feed>
