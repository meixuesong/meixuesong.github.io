<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[码出人生]]></title>
  <link href="http://blog.ubone.com/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2014-08-19T23:22:31+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式:访问者模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/19/she-ji-mo-shi-fang-wen-zhe-mo-shi/"/>
    <updated>2014-08-19T22:17:28+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/19/she-ji-mo-shi-fang-wen-zhe-mo-shi</id>
    <content type="html"><![CDATA[<p>访问者(Visitor)模式的目的是封装一些施加于某种数据结构元素之上的操作，一旦这些操作需要修改的话，接受这个操作的数据结构则可以保持不变。假如要对一个不同类型的聚集进行遍历，为了判断不同的类型对象，需要写很多的if else，而访问者模式可以解决此问题。示意类图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140819_232009.jpg" alt="image" /></p>

<!--more-->


<ol>
<li>Visitor角色：声明一个或多个访问操作。</li>
<li>ConcreteVisitor角色：实现接口方法。</li>
<li>Node角色：声明一个接受操作，接受一个访问者对象作为一个参数。</li>
<li>Concrete Node角色：实现接受操作。</li>
<li>ObjectStructure角色：遍历结构中的所有元素，如果需要，提供高层次的接口让访问者对象可以访问每一个元素；如果需要，可以设计成一个复合对象或者一个聚集，如List或Set。</li>
</ol>


<h3>单分派和多分派</h3>

<p>方法的接收者（即方法所属的对象）和方法的参量统称为方法的宗量。单分派语言根据一个宗量的类型进行方法的选择，多分派语言根据多于一个的宗量的类型对方法进行选择。</p>

<p>Java语言支持静态的多分派和动态的单分派。对于Java方法重载（Overload），在编译期会根据方法的接收者类型和方法的所有参量类型进行分派，因此是静态多分派。而方法覆盖（Override），是在运行时仅仅根据方法的接收者类型进行分派。</p>

<p>在访问者模式中，数据结构的每一个节点都可以接受一个访问者的调用，此节点向访问者对象传入节点对象，而访问者对象则反过来执行节点对象的操作。这样的过程就叫做“双重分派”。</p>

<h3>示例代码</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">//class ConcreteVisitor</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">visitA</span><span class="o">(</span><span class="n">NodeA</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">operationA</span><span class="o">());</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//class NodeA</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="n">Visitor</span> <span class="n">visitor</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">visitor</span><span class="o">.</span><span class="na">visitA</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//class ObjectStructure</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">action</span><span class="o">(</span><span class="n">Visitor</span> <span class="n">visitor</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">for</span><span class="o">(</span><span class="n">Enumeration</span> <span class="n">e</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="na">elements</span><span class="o">();</span> <span class="n">e</span><span class="o">.</span><span class="na">hasMoreElements</span><span class="o">();)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">node</span> <span class="o">=</span> <span class="o">(</span><span class="n">Node</span><span class="o">)</span><span class="n">e</span><span class="o">.</span><span class="na">nextElement</span><span class="o">();</span>
</span><span class='line'>      <span class="n">node</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">visitor</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//class Client</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">ObjectStructure</span> <span class="n">aObjects</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectStructure</span><span class="o">();</span>
</span><span class='line'>  <span class="n">aObjects</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">NodeA</span><span class="o">());</span>
</span><span class='line'>  <span class="n">aObjects</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">NodeB</span><span class="o">());</span>
</span><span class='line'>  <span class="n">Visitor</span> <span class="n">visitor</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcreteVisitor</span><span class="o">();</span>
</span><span class='line'>  <span class="n">aObjects</span><span class="o">.</span><span class="na">action</span><span class="o">(</span><span class="n">visitor</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>访问者模式的优缺点</h3>

<p>访问者模式仅应当用在被访问的类结构非常稳定的情况。如果出现需要加入新的Node的情况，则必须在每一个访问对象中加入一个对应于这个新节点的访问操作，这将是一个大规模修改，违背“开-闭”原则。</p>

<p>如果系统有比较稳定的数据结构，又有易于变化的算法，使用访问者模式就比较合适。</p>

<p>访问者模式的优点包括：</p>

<ol>
<li>增加新的操作变得非常容易，只需要增加一个新的访问者。</li>
<li>此模式将行为集中到一个访问者对象中，而不是分散到节点类中。因此可以在访问的过程中将执行操作的状态积累在自己内部（例如计算合计值）。</li>
</ol>


<p>访问者模式的缺点：增加新的节点类变得很困难。每增加一个新的节点都要在抽象访问者角色中增加一个新的抽象操作，并在每个具体访问者类中增加相应的具体操作。</p>

<p>访问者模式是一个存争议的设计模式。</p>

<p>——《Java与模式》读书笔记</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:状态模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/18/she-ji-mo-shi-zhuang-tai-mo-shi/"/>
    <updated>2014-08-18T20:22:06+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/18/she-ji-mo-shi-zhuang-tai-mo-shi</id>
    <content type="html"><![CDATA[<p>状态模式把对象的行为包装在不同的状态对象里，所有状态对象都属于抽象状态类的子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。类图示意如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140818_224041.jpg" alt="image" /></p>

<!--more-->


<ol>
<li>State角色：定义接口，用于封装Context对象的一个特定的状态所对应的行为。</li>
<li>ConcreteState角色：每个具体状态类实现Context的一个状态所对应的行为。</li>
<li>Context角色：定义客户端所感兴趣的接口，并且保留一个具体状态类的实例，即当前的状态。上图中Context.someOperation的行为是委派给具体State类来执行的。当Context.state变化时，动态地将具体类指向另一个具体状态类，从而改变改变其行为。</li>
</ol>


<h3>什么情况下使用状态模式</h3>

<ol>
<li>对象的行为依赖于它所处的状态，对象的行为必须随着其状态的改变而改变。</li>
<li>对象在某个方法里依赖于一重或多重的条件转移语句，其中有大量的代码。状态模式可以把条件转移语句的每一个分支包装到一个状态类中。</li>
</ol>


<p>TcpConnection就是一个状态模式的经典例子，TCP连接的三个状态（Established, Listening, Closed）分别对应三个状态类（TcpEstablished, TcpListen, TcpClosed）。</p>

<p>在绘图软件中，状态模式广泛用于建立编辑器框架。使客户端能够轻易地挂接新工具。</p>

<h3>模式实现</h3>

<p>状态的变化由谁来定义？状态模式并没有对此进行规定。可以由外部事件、Context控制或者具体State自行决定。</p>

<p>状态对象的创建和销毁，可以按需创建或者预先创建。</p>

<h3>与其它模式的关系</h3>

<p>状态模式与策略模式很相似，类图也很相似。但是策略模式的特点是，一旦环境类选择了一个具体策略，那么在其生命周期内就不会改变这个具体策略类。而状态模式在环境类的生命周期中会有多个不同的状态对象被使用。</p>

<p>——《Java与模式》读书笔记</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:备忘录模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/13/she-ji-mo-shi-bei-wang-lu-mo-shi/"/>
    <updated>2014-08-13T23:00:58+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/13/she-ji-mo-shi-bei-wang-lu-mo-shi</id>
    <content type="html"><![CDATA[<p>备忘录(Memento)模式又叫做快照模式。备忘录对象是一个用来存储另外一个对象内部状态快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态存储在外部，从而在合适的时候把这个对象还原到原来的状态。通常系统不止存储一个状态，而是存储多个状态（快照）。每一个快照所处的位置就是Check Point。其结构如下图：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140813_231854.jpg" alt="image" /></p>

<!--more-->


<ol>
<li>备忘录(Memento)角色：一是将发起人(Originator)对象的内部状态存储起来；二是保护其内容不被发起人以外的任何对象所读取，即图中宽接口和窄接口的作用。</li>
<li>发起人(Originator)角色：创建备忘录对象，并使用该对象存储其内部状态。</li>
<li>负责人(Caretaker)角色：负责保存备忘录对象，不管备忘录对象的内容。</li>
</ol>


<h3>白箱实现</h3>

<p>在Java中实现宽、窄两个接口并不容易，白箱实现就是只提供宽接口。类图示意如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140813_235928.jpg" alt="image" /></p>

<p>上面的发起人只有一个状态“state”，发起人创建备忘录对象，并传入state，而负责人可以保存和获得备忘录对象。上图中备忘录对负责人也是宽接口，因此负责人可以访问到state值。<strong>所以，白箱实现的缺点是破坏了对发起人状态的封闭。</strong>下面的Client的示意代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Originator</span> <span class="n">o</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Originator</span><span class="o">();</span>
</span><span class='line'><span class="n">Caretaker</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Caretaker</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="na">setState</span><span class="o">(</span><span class="s">&quot;On&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">Memento</span> <span class="n">m</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="na">createMemento</span><span class="o">();</span>
</span><span class='line'><span class="n">c</span><span class="o">.</span><span class="na">saveMemento</span><span class="o">(</span><span class="n">m</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="na">setState</span><span class="o">(</span><span class="s">&quot;Off&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="na">restoreMemento</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="na">retrieveMemento</span><span class="o">());</span>
</span><span class='line'><span class="c1">//此时o.state = &quot;On&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>双重接口实现（黑盒实现）</h3>

<p>如何用Java实现宽、窄两个接口呢？也就是对发起人是宽接口，对其它任何对象都是窄接口。可以将备忘录对象作为发起人的内部类，因此发起人可以访问备忘录的所有属性和方法。而窄接口，是备忘录对象实现一个标识接口(MementoIF，没有任何方法的接口)，同时备忘录对象的方法为私有方法，所有其它对象都通过标识接口获得备忘录对象的引用，却无法访问备忘录对象的状态和方法。这就是双重接口的实现。如下图所示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140814_220438.jpg" alt="image" /></p>

<p>客户端的代码与白盒实现完全相同，但是Caretaker再也无法访问备忘录对象的状态了。</p>

<p>上面的两种实现，都由客户端持有发起人和负责人的引用。实际上也可以由负责人完成备忘录对象的创建和必要时恢复发起人状态。</p>

<h3>多重检查点</h3>

<p>前面的例子都只存储一个状态，在实际业务中，常需要存储多个状态，也就是多个检查点。实现方式可以在备忘录对象中建立<code>List&lt;String&gt; states</code>存储多个检查点。</p>

<h3>“自述历史”模式</h3>

<p>自述历史模式其实是指发起人角色兼任负责人角色时的备忘录模式。类图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140815_221228.jpg" alt="image" /></p>

<p>Memento类是发起人的内部类。</p>

<h3>“假如”协议模式</h3>

<p>备忘录的操作过程是，先创建备忘录对象保存发起人状态，然后修改发起人状态，如果需要的话，可以撤消这一步。也就是通过备忘录对象恢复发起人的状态。简单地说，就是先保存状态，然后执行修改，如果需要则恢复原状态。</p>

<p>而“假如”协议则是将发起人对象做一个拷贝，然后再拷贝上执行备忘录操作，如果成功并且状态有效，则在原对象上执行这个操作。如果失败或者状态无效，则扔掉拷贝并触发异常处理。</p>

<p>“假如”协议的优点是安全，相当于先试验没总是后才在原始对象上执行。缺点是同一个操作要执行两遍。因此“假如”协议适合于成功率较低的场景。</p>

<h3>备忘录模式的优点</h3>

<ol>
<li>有时一些发起人对象的内部信息必须保存在发起人对象以外的地方，但是必须要由发起人对象自己读取，这时，使用备忘录模式可以把复杂的发起人内部信息对其他的对象屏蔽起来，从而可以恰当地保持封装的边界。</li>
<li>本模式简化了发起人。发起人不再需要管理和保存其内部状态的一个个版本，客户端可以自行管理他们所需要的这些状态的版本。</li>
<li>当发起人角色的状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原。</li>
</ol>


<h3>备忘录模式的缺点：</h3>

<ol>
<li>如果发起人角色的状态需要完整地存储到备忘录对象中，那么在资源消耗上面备忘录对象会很昂贵。</li>
<li>当负责人角色将一个备忘录存储起来的时候，负责人可能并不知道这个状态会占用多大的存储空间，从而无法提醒用户一个操作是否很昂贵。</li>
<li>当发起人角色的状态改变的时候，有可能这个协议无效。如果状态改变的成功率不高的话，不如采取“假如”协议模式。</li>
</ol>


<p>——《Java与模式》读书笔记。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:命令模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/11/she-ji-mo-shi-ming-ling-mo-shi/"/>
    <updated>2014-08-11T22:58:11+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/11/she-ji-mo-shi-ming-ling-mo-shi</id>
    <content type="html"><![CDATA[<p>命令模式将发出命令和执行命令的责任分割开，委派给不同的对象。类图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140811_233515.jpg" alt="image" /></p>

<!--more-->


<ol>
<li>Client角色：创建具体命令对象，并确定接收者。</li>
<li>Command角色：声明抽象接口，通常是接口或抽象类。</li>
<li>ConcreteCommand角色：定义一个接收者和行为之间的弱耦合；负责调用接收者的相应操作。</li>
<li>Invoker角色：负责调用命令对象执行请求。</li>
<li>Reciever角色：负责具体实施和执行一个请求。任何一个类都可以成为接收者。</li>
</ol>


<p>Client的示例代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">Receiver</span> <span class="n">receiver</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Receiver</span><span class="o">();</span>
</span><span class='line'>  <span class="n">Command</span> <span class="n">command</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcreteCommand</span><span class="o">(</span><span class="n">receiver</span><span class="o">);</span>
</span><span class='line'>  <span class="n">Invoker</span> <span class="n">invoker</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Invoker</span><span class="o">(</span><span class="n">command</span><span class="o">);</span>
</span><span class='line'>  <span class="n">invoker</span><span class="o">.</span><span class="na">action</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码中，invoker.action调用command.execute，execute方法调用receiver.action，receiver.action是真正实施命令的方法。</p>

<p>模式实现时，可以考虑命令是“重”还是“轻”。如果轻，则命令只是提供请求者与接收者之间的耦合。如果是重，则命令执行也可放在命令中，接收者可以省略。更常见的是中间情况，由命令类动态决定调用哪一个接收者类。如果要支持undo, redo，则命令类要存储状态信息。</p>

<p>可以把命令对象集合在一起，实现宏命令。命令模式的缺点是命令可能会非常多。命令模式可用于：</p>

<ol>
<li>需要在不同的时间指定请求，将请求排队。命令对象可以在序列化之后发送到另一台机器上。</li>
<li>支持undo, redo操作。</li>
<li>从日志中读回所有命令，重新执行execute方法，恢复系统数据。</li>
<li>需要支持交易的系统，一个交易结构封装了一组数据更新命令。命令模式可以使系统增加新的交易类型。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:责任链模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-ze-ren-lian-mo-shi/"/>
    <updated>2014-08-10T23:24:28+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-ze-ren-lian-mo-shi</id>
    <content type="html"><![CDATA[<p>多个对象和下家的引用连接起来形成一条链。请求在这个链上传递，直到链上的某个对象处理此请求。类图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140810_235454.jpg" alt="image" /></p>

<!--more-->


<p>一个纯的责任链模式要求具体的处理者对象只能在两个行为中选择一个：一是处理请求；二是把责任传给下家。不允许出现一个对象即处理请求，又把责任往下传。纯的责任链很难找到，一般看到的例子都是不纯的。</p>

<p>Java 1.0版的AWT事件处理机制就是责任链模式。事件触发后，可以一直浮升，直到有容器处理事件。容器可以选择继续传下去或者处理事件。</p>

<p>针对DHTML的事件处理，Netscape与IE是不一样的。Netscape是从Window->Document往下，最后到达事件产生的对象。而IE则相反，事件产生的对象是链的第一个。</p>

<p>责任链模式并不负责创建责任链，责任链的创建必须由系统的其它部分完成。一个链可以是一条线、树甚至环。责任链模式并不指定链的拓扑结构，但要求在同一时间里，命令只可以被传给一个下家（或者处理请求），不可以同时传给多个下家。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:迭代子模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-die-dai-zi-mo-shi/"/>
    <updated>2014-08-10T12:18:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-die-dai-zi-mo-shi</id>
    <content type="html"><![CDATA[<p>迭代子模式是最常见的几个设计模式之一，Java Collection广泛使用迭代子来遍历其元素。之所以需要迭代子模式，是因为它将迭代逻辑与聚集对象分离，两者可以自由演变。其结构示意图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140810_163841.jpg" alt="image" /></p>

<!--more-->


<ol>
<li>Iterator：定义遍历元素所需的接口。</li>
<li>ConcreteIterator：实现Iterator接口，维护迭代过程中的游标位置。</li>
<li>Aggregate：给出创建迭代子对象的接口。</li>
<li>ConcreteAggregate：实现创建迭代子对象的接口，返回一个合适的具体迭代子实例。</li>
<li>Client：拥有对聚集和迭代子对象的引用，调用迭代子对象的迭代接口。</li>
</ol>


<h3>宽接口与窄接口</h3>

<p>宽接口是指聚集提供了可以用来修改聚集元素的方法；否则就是窄接口。宽接口的典型示例是公开了类的一个List，因此破坏了聚集对象的封装。</p>

<p>聚集对象可以提供两个接口，对迭代子公开宽接口，而对外提供窄接口。因此，可以将迭代子类设计成聚集类的内部成员类。</p>

<h3>Java Iterator和ListIterator</h3>

<p>Java Collection接口方法iterator()返回Iterator，而Java的List接口的listIterator()返回ListIterator类型。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140810_163856.jpg" alt="image" /></p>

<p>ListIterator提供了安全的修改方法add, remove和set。它们能够在迭代的过程中安全地修改List的内容。</p>

<ul>
<li>add()方法，在List当前位置插入一个对象。所谓当前位置就是：add方法增加对象后，调用previous()方法将返回这个对象。</li>
<li>remove()方法，将当前元素删除。所谓当前元素就是：如果刚调用了next()或previous()方法，当前元素就是它们返回的元素。<strong>注：每调用一次remove()，都需要先调用一次next()或者previous()，如果刚调用了add()，也必须先调用一次next()或者previous()。</strong></li>
<li>set()方法，更新当前元素。当前元素的定义与remove()方法相同。每次set()之前，也必须调用next()或previous()。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:观察者模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-guan-cha-zhe-mo-shi/"/>
    <updated>2014-08-10T11:36:40+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-guan-cha-zhe-mo-shi</id>
    <content type="html"><![CDATA[<p>观察者模式也称为发布-订阅模式，它定义了一种一对多的依赖关系，让多个观察者同时监听一个主题对象。当主题对象的状态发生变化时，会通知观察者对象，使它们能够自动更新自己。它的类图如下所示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140810_115301.jpg" alt="image" /></p>

<p>在实际应用中，如果有多个ConcreteSubject，也可以将Subject变成抽象类，将observers和notifyObservers方法上移到抽象Subject。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:模板方法模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-mo-ban-fang-fa-mo-shi/"/>
    <updated>2014-08-10T09:52:25+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-mo-ban-fang-fa-mo-shi</id>
    <content type="html"><![CDATA[<p>模板方法（Template Method）模式是最常见的模式，几乎每个人都用过。它将部分逻辑以具体方法以及具体构造子的形式实现。抽象类定义顶级逻辑，具体类实现具体方法。类图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140810_095857.jpg" alt="image" /></p>

<ol>
<li>抽象模板角色：定义一个或多个抽象操作，以便让子类实现。定义并实现一个模板方法，给出顶级逻辑的骨架。</li>
<li>具体模板角色：实现父类的抽象方法。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:策略模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/09/she-ji-mo-shi-ce-lue-mo-shi/"/>
    <updated>2014-08-09T22:55:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/09/she-ji-mo-shi-ce-lue-mo-shi</id>
    <content type="html"><![CDATA[<p>策略模式把行为和环境分割开。环境类负责维持和查询行为类，各种算法则在具体策略类中提供。由于算法和环境独立开来，算法的增减、修改都不会影响环境和客户端。准备一组算法，并将每一个算法封装起来，使得它们可以互换。策略模式的类图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140809_230502.jpg" alt="image" /></p>

<!--more-->


<p>各角色如下：</p>

<ol>
<li>环境角色：持有一个Strategy类的引用。</li>
<li>抽象策略角色：抽象角色，通常是接口或者抽象类，给出接口。</li>
<li>具体策略角色：包装相关的算法或行为。通常具体策略角色会有多个。</li>
</ol>


<p>从策略模式中是看不出具体策略适用于哪一种情况的，应当由客户端自己决定在什么情况下使用什么具体策略角色。策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中退出。</p>

<p>策略模式适合于在多个算法中选择一种的情形，不适用于需要多个算法或者嵌套多于一个算法的情形。</p>

<p>什么情况下使用策略模式？</p>

<ol>
<li>如果系统有很多类，它们之间的区别仅在于它们的行为，策略模式可动态地让一个对象在许多行为中选择一种行为。</li>
<li>系统需要动态地在几种算法中选择一种。</li>
</ol>


<p>策略模式的缺点：客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:不变模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/09/she-ji-mo-shi-bu-bian-mo-shi/"/>
    <updated>2014-08-09T18:08:28+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/09/she-ji-mo-shi-bu-bian-mo-shi</id>
    <content type="html"><![CDATA[<p>从这个模式开始学习行为模式。行为模式是对在不同的对象之间划分责任和算法的抽象化。行为模式不仅仅是关于类和对象的，而且是关于它们之间的相互作用的。行为模式分为类的行为模式（使用继承在几个类之间分配行为）和对象的行为模式（使用对象的聚合来分配行为）。</p>

<p>不变（Immutable）模式是指一个对象创建之后，它的状态将不再变化。不变模式不需要类图描述，它分为弱不变模式和强不变模式。</p>

<p>不变与只读的区别：只读表示值不能直接修改，但可能随其它变量改变而发生改变。例如出生日期是不变的，但年龄是只读的，因为它会随着时间而改变。</p>

<!--more-->


<h3>弱不变模式</h3>

<p>类的实例状态是不可变化的，但其子类的实例可能会变化，这就是弱不变模式。要实现弱不变模式，必须满足以下条件：</p>

<ol>
<li>类没有任何方法会修改对象的状态；</li>
<li>所有属性都应当是私有的；</li>
<li>如果引用了其它可变对象，必须设法限制外界对可变对象的访问。应当尽量避免在客户端初始化可变对象，否则应该复制一份，而不要直接使用客户端传入的引用。</li>
</ol>


<h3>强不变模式</h3>

<p>类的实例状态是不可变化的，同时它的子类也是不可变化的状态，这就是强不变模式。一个类在满足弱不变模式的前提下，需要满足以下条件之一才是强不变模式：</p>

<ol>
<li>类的所有方法都应当是final，因此子类不能置换掉此类的方法。</li>
<li>这个类本身就是final的，因此不可能会有子类。</li>
</ol>


<h3>不变模式的优缺点</h3>

<p>一个不变的对象比可变的对象更加容易维护。不变对象天生就是线程安全的，可以省掉同步化的开销。不变模式唯一的缺点是如果需要频繁地修改不变对象，会创建出大量的对象，这是一种资源的浪费。</p>

<p>在设计任何一个类时，除非有变化的必要，不然就应该将它设计成不变类。</p>

<p>与享元模式的区别：不变模式可以用于实现享元模式，但享元对象并不一定非得是不变对象，只要它的内部状态与环境无关就不会影响享元对象的共享。</p>

<p>几个问题：</p>

<ol>
<li>构造方法需不需要同步化？（不需要，对象创建只可能发生在一个纯种中）</li>
<li>子类是否可以置换掉父类的同步方法，它是同步还是不同步？（可以置换，但父类的同步特性没有改变，如果明显地调用父类的同步方法，那么这个方法将是同步调用的）</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[哈尔滨印象]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/07/ha-er-bin-yin-xiang/"/>
    <updated>2014-08-07T20:16:24+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/07/ha-er-bin-yin-xiang</id>
    <content type="html"><![CDATA[<p>8月初，恰逢有机会去哈尔滨出差，来到这个古老、精致的城市，印象还不错。街道很干净，建筑很有特色。</p>

<p>街边一景</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1304.jpg" alt="image" /></p>

<!--more-->


<p>圣索菲亚教堂</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1266.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1268.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1269.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1275.jpg" alt="image" /></p>

<p>随处可见的音乐一角，都是俄罗斯风格的音乐。</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1276.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1277.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1278.jpg" alt="image" /></p>

<p>松花江畔</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1279.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1281.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1282.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1283.jpg" alt="image" /></p>

<p>防洪纪念塔，本以为是98年建的，其实不是，以前就有了，但可以看到水位高度。</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1285.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1288.jpg" alt="image" /></p>

<p>中央大街一景</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1289.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1291.jpg" alt="image" /></p>

<p>这么多人排队</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1295.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1298.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1300.jpg" alt="image" /></p>

<p>从黑龙江移动大楼上看松花江</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1306.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1307.jpg" alt="image" /></p>

<p>哈尔滨火车站</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1316.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1317.jpg" alt="image" /></p>

<p>哈工大</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1319.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1320.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1321.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1322.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1323.jpg" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:桥梁模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-qiao-liang-mo-shi/"/>
    <updated>2014-08-03T22:09:23+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-qiao-liang-mo-shi</id>
    <content type="html"><![CDATA[<p>桥梁模式的用意是“将抽象化与实现化解耦，使二者可以独立变化。”这里的解耦就是将它们之间的强关联改变成弱关联。所谓强关联就是继承关系，在编译期就已经确定。而弱关联就是动态确定并且可以在运行期动态改变的关联。因此对于Java，继承是强关联，而聚合关系是弱关联。因此桥梁模式中的解耦，就是指将抽象化与实现化之间的继承关系换成组合/聚合关系，使两者可以独立变化。桥梁模式的结构图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140803_233716.jpg" alt="image" /></p>

<!--more-->


<ol>
<li>抽象化角色（Abstraction）：抽象化给出的定义，并保存一个对实现化对象的引用。</li>
<li>修正抽象化角色（Refined Abstraction）：扩展抽象化角色，改变和修正父类的定义。</li>
<li>实现化角色（Implementor）：给出实现化角色的接口，但不给出具体实现。这个接口不一定与抽象化角色接口相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。</li>
<li>具体实现化角色（Concrete Implementor）：给出实现化角色接口的具体实现。当具体实现化类只有一个ConcreteImplementor的情况下，实现化角色就可以省略了。</li>
</ol>


<p>抽象化等级结构中的方法通过向对应的实现化对象的委派实现自己的功能。一般来说，实现化角色中的每一个方法都应当有一个抽象化角色中的某一个方法与之对应，但反过来则不一定。即抽象化角色的接口比实现化角色的接口宽，抽象化角色还可能提供其它的商业方法。而实现化角色则仅仅为实现抽象化角色的相关行为而存在。</p>

<p>桥梁模式是为了分享抽象化与实现，使两者的接口可以不同。而适配器模式是为了改变已有接口，使它们相容。因此这两种模式是不一样的。</p>

<p>什么情况下应当使用桥梁模式？</p>

<ul>
<li>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的联系。</li>
<li>设计要求实现化角色的任何改变不应当影响客户端。</li>
<li>一个构件有多个抽象化角色和实现化角色，系统需要它们之间进行动态耦合。</li>
<li>虽然在系统中使用继承没有问题，但由于抽象化角色和具体角色需要独立变化，设计要求需要独立管理这两者。</li>
</ul>


<p>桥梁模式的一个例子是Java AWT的Peer架构。Java应用在不同的操作系统上有不同的Look and Feel。Java为AWT中的每一个GUI构件都提供了一个Peer构件。Java程序员只需要关心Button对象提供的接口，当运行时，Button对象动态地与一个本地环境的底层Peer对象联系起来，这个Peer对象会按照指令执行正确的操作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:门面模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-men-mian-mo-shi/"/>
    <updated>2014-08-03T21:59:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-men-mian-mo-shi</id>
    <content type="html"><![CDATA[<p>门面(Facade)模式的作用是屏蔽众多子系统的复杂性，为客户端提供一个统一的门面(Facade)对象，方便客户端调用。门面模式没有统一的结构。一般是一个子系统提供一个门面。要注意的是门面只负责协调子系统去服务客户端的请求，不能在门面类中增加功能和职责。</p>

<p>什么情况下使用门面模式？如果子系统演化得越来越复杂，客户端的调用变得很复杂，产生很大的依赖性，则可以引入门面模式将一个子系统与它的客户端以及其他子系统分离。</p>

<p>这与迪米特法则也是相符的，该法则要求不要与陌生人说话，只与你直接朋友通信。采用门面模式，客户端只要与门面打交道，不需要去协调多个子系统。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:享元模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-xiang-yuan-mo-shi/"/>
    <updated>2014-08-03T19:10:40+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-xiang-yuan-mo-shi</id>
    <content type="html"><![CDATA[<p>享元模式以共享的方式支持大量的细粒度对象。Java的String类型其实就使用了享元模式。享元对象具有内部状态(Internal State)和外部状态(External State)。内部状态是享元对象内部的，一旦创建就不会再改变，因此具有内部状态的享元对象可以进行共享。外部状态是随环境改变而改变的，是不可以共享的状态。享元对象的外部状态必须由客户端保存，通常以方法参数的方式传给享元对象，以改变方法的行为，但不会改变内在状态。享元模式可以分为单纯享元模式和复合享元模式。结构图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140803_193842.jpg" alt="image" /></p>

<!--more-->


<p>左边为单纯享元模式，右边为复合享元模式。复合享元模式只多了一个ConcreteCompositeFlyweight，它们的角色如下：</p>

<ul>
<li>抽象享元角色(Flyweight)：定义公共接口。</li>
<li>具体享元角色(ConcreteFlyweight)：实现抽象享元角色接口，维护内部状态。内部状态必须与外部环境元关，一旦创建就不能修改。</li>
<li>享元工厂角色(FlyweightFactory)：负责创建和管理享元角色，保证享元对象可以被系统共享。当客户端调用工厂方法时，通常会判断是否有符合要求的享元对象，如果有就返回，如果没有则创建。此角色一般只有一个，可以使用单例模式。</li>
<li>客户端角色(Client)：调用享元工厂创建享元对象，维护享元对象的外部状态。</li>
<li>复合享元角色(ConcreteCompositeFlyweight)：由单纯的享元对象复合而成，因此提供了add这样的方法。由于聚焦元素是在复合享元对象创建之后加入的，因此复合享元对象的状态是可以改变的，所以此角色<strong>不可以共享</strong>。</li>
</ul>


<p><strong>一些例子</strong></p>

<p>一个咖啡摊所售的咖啡只有固定的几种口味，一坏咖啡一旦生产出来它的口味就不会改变，其内部状态就是口味。因此系统不用为每一杯咖啡创建一个对象，可以使用享元模式为每种口味创建一个对象，然后进行共享。</p>

<p>又例如一个文字编辑器，输入的内部是固定的A..Z，但字母所处的位置、字体是变化的。如果用享元模式，内部状态就是字母，外部状态是位置和字体。</p>

<p><strong>什么情况下使用享元模式</strong></p>

<p>当以下条件都满足时，可以考虑使用享元模式：</p>

<ol>
<li>系统有大量的对象。</li>
<li>这些对象耗费大量的内存。</li>
<li>这些对象的大部分状态都可以外部化。</li>
<li>这些对象可以按照内部状态分成很多组，剔除外部状态后，每一组都可以仅用一个对象代替。</li>
<li>系统不依赖于这些对象的身份，即这些对象可以是不可分辨的。</li>
<li>系统需要记录所有已有的享元对象，这需要消耗资源，因此应当在只有足够多的享元实例可供共享时才值得使用享元模式。</li>
</ol>


<p>享元模式的优点是大幅降低内存中对象的数量，但享元模式可能使系统更复杂，需要将一些状态外部化，这可能使逻辑变得复杂。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:代理模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-dai-li-mo-shi/"/>
    <updated>2014-08-03T11:56:48+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-dai-li-mo-shi</id>
    <content type="html"><![CDATA[<p>代理模式是对象的结构模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。代理模式的结构如下图：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140803_120304.jpg" alt="image" /></p>

<!--more-->


<p>各角色说明如下：</p>

<ul>
<li>抽象主题角色：是真实主题和代理主题的共同接口，任何可以使用真实主题的地方都可以使用代理主题。</li>
<li>代理主题角色：内部含有对真实主题的引用，可以在任何时候操作真实主题对象。</li>
<li>真实主题角色：真实的对象。</li>
</ul>


<p><strong>常见的代理种类：</strong></p>

<ul>
<li>远程(Remote)代理：位于不同地址空间的代理对象。</li>
<li>虚拟(Virtual)代理：当创建真实对象需要消耗较大资源时，通过虚拟代理实现只有真正需要时才创建资源。例如加载图像。</li>
<li>Copy-on-Write代理：虚拟代理的一种，把复制拖延到只有客户端需要时才执行。</li>
<li>保护(Protect or Access)代理：控制对一个对象的访问，可以为不同的客户端提供不同级别的权限。</li>
<li>Cache代理：为真实对象操作的结果提供临时的存储空间，以便多个客户端可共享该结果。</li>
<li>防火墙(Firewall)代理：保护目标，不让恶意用户接近。</li>
<li>同步化(Synchronization)代理：使多个用户能够同时使用一个对象而没有冲突。</li>
<li>智能(Smart Reference)引用：当一个对象被引用时，提供一些额外的操作，例如记录调用次数。</li>
</ul>


<p>反射与代理常常一起使用，<a href="http://blog.ubone.com/blog/2014/06/28/li-yong-fan-zhang-hao/">这篇博文</a>就是代理模式的一个例子。</p>

<p>代理模式与适配器模式的区别是，后者的用意是改变接口，而前者不能改变接口。代理模式与装饰模式都保持接口不变，但它们区别是，后者应当提供增加的功能/性能，而前者是对原对象施加控制，并不提供增强功能。</p>

<h3>虚拟代理的例子</h3>

<p>为了更好的用户体验，在应用中显示网络图片时，先显示“加载中”或者占位符，等待图片下载完成后再替换成图片。这就是虚拟代理的真实例子。对于客户端仍然是创建图片并显示，但实际创建的是图片代理，图片代理先显示“加载中”，然后启动另一线程去下载图片，当下载完成后，才真正显示图片。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:装饰模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/01/she-ji-mo-shi-zhuang-shi-mo-shi/"/>
    <updated>2014-08-01T20:00:16+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/01/she-ji-mo-shi-zhuang-shi-mo-shi</id>
    <content type="html"><![CDATA[<p>装饰模式以对客户端透明的方式扩展对象的功能。客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。其类图所下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-08-01_20.13.33.jpg" alt="image" /></p>

<!--more-->


<p>图中4个角色说明如下：</p>

<ol>
<li>Component角色，一个抽象接口，被装饰对象和装饰对象都遵循的接口。在实际中可以是接口、抽象或具体类。</li>
<li>Concrete Component角色，被装饰的具体对象。</li>
<li>Decorator角色，持有Component对象的实例，可以是抽象类。</li>
<li>ConcreteDecorator角色，负责给构件对象贴上附加的责任。</li>
</ol>


<h3>什么情况下使用装饰模式？</h3>

<ol>
<li>需要扩展一个类的功能，或给一个类增加附加责任。</li>
<li>需要动态给一个对象增加功能，这些功能可以再动态地撤销。</li>
<li>需要增加由一些基本功能的排列组合而产生的非常大量的功能，而继承关系就变得不现实。</li>
</ol>


<h3>装饰模式的优缺点</h3>

<p>装饰模式的优点包括：</p>

<ol>
<li>可以动态地贴上一个需要的装饰，或者除掉一个不需要的装饰。</li>
<li>通过使用不同的具体装饰类，以及这些装饰类的排列组合，可以创造出很多不同行为的组合。</li>
</ol>


<p>装饰模式的缺点是比继承要使用更多的对象，更多的对象会使得查错变得困难。</p>

<h3>装饰模式的简化</h3>

<p>不论如何简化，必须保证：</p>

<ol>
<li>ConcreteDecorator类必须继承自一个共同的父类Component。</li>
<li>尽量保持Component作为一个“轻”类。</li>
</ol>


<p>常见的简化包括：</p>

<ol>
<li>没有Component，只有ConcreteComponent，此时，Decorator可以是ConcreteComponent的子类，ConcreteComponent扮演双重角色。</li>
<li>没有Decorator，只有ConcreteDecorator，但如果有两个以上的。</li>
</ol>


<h3>其它</h3>

<p>纯粹的装饰模式对客户端的要求是不要声明ConcreteDecorator类型的变量，而应当声明Component类型的变量。这也就是针对抽象编程。因此，ConcreteDecorator不能有Component接口之外的方法。但现实中的装饰模式允许改变接口，增加新方法，即客户端可以声明ConcreteDecorator类型的变量。这就有点像是适配器模式。</p>

<p>装饰模式与适配器模式其实是不一样的。适配器模式的目的是改变接口，常常改写或者增加新的方法来适配接口。而装饰模式是保持接口不变，增强或增加功能。它们的类图是不一样的。</p>

<p>以Java的IO库为例，Reader类型的对象读入字符(Character)流，而InputStreamReader是一种Reader类型，把InputStream类型对象包装起来，从而把byte的API转换成字符流的API。这就是适配器模式的例子。即InputStreamReader把InputStream的API适配成Reader的API。</p>

<p>而BufferredReader则是一个装饰类，因为它实现Reader，并且包装一个Reader，接口未变，但提供更优的性能。但它不是一个100％的装饰类，因为它提供了一个readLine()的新方法。</p>

<p>以InputStream相关类为例，如下所示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140803_002859.jpg" alt="image" /></p>

<p>图中，红色类为适配器模式，将其它类型（如Byte数组）接口转换成InputStream接口。而绿色及其子类为适配器模式，各角色：</p>

<ol>
<li>Component角色：InputStream</li>
<li>Concrete Component角色：红色的类</li>
<li>Decorator角色：绿色的类</li>
<li>ConcreteDecorator角色：最下面的四个类。</li>
</ol>


<p>附各类的主要用途：</p>

<ol>
<li>ByteArrayInputStream: 为多线程的通信提供缓冲区操作功能，接收Byte数组作为流的源。</li>
<li>FileInputStream：接收一个File对象作为流的源。</li>
<li>PipedInputStream：与PipedOutputStream配合使用，用于读入一个数据管道的数据，接收PipedOutputStream作为源。</li>
<li>StringBufferInputStream：接收一个String对象作为流的源。</li>
<li>FilterInputStream：过滤输入流，将另一个输入流作为流的源。</li>
<li>BufferInputStream：内部提供内存缓冲区，从此缓冲区提供数据。</li>
<li>DataInputStream：提供多字节的读取方法，读取原始数据类型的数据。</li>
<li>LineNumberInputStream: 提供带有行计数功能和按行号读取数据的过滤输入流。不常用，主要用于编译器。</li>
<li>PushbackInputStream：提供特殊功能，将已经读取的字节“推回”到输入流中。不常用，主要用于编译器。</li>
<li>ObjectInputStream：读取使用ObjectOutputStream序列化的流，将其反序列化。</li>
<li>SequenceInputStream：将两个已有的输入流连接起来，形成一个输入流。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:组合（Composite）模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/31/she-ji-mo-shi-zu-he-mo-shi/"/>
    <updated>2014-07-31T21:08:30+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/31/she-ji-mo-shi-zu-he-mo-shi</id>
    <content type="html"><![CDATA[<p>组合模式将对象以树状结构组织起来，达成“部分－整体”的层次结构，使得客户端对单个对象和组合对象的使用具有一致性。结构示意图：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-31_21.14.15.jpg" alt="image" /></p>

<!--more-->


<p>此模式涉及三个角色：</p>

<ol>
<li>Component角色：定义共有的接口及其默认行为。</li>
<li>Leaf角色：叶节点，不能有下级子对象。</li>
<li>Composite角色：树枝节点，可以有下级子对象的节点。</li>
</ol>


<p>组合模式根据实现方式的不同，分为安全方式和透明方式。区别主要在于接口的定义。Composite角色拥有add、remove、getChild等方法，这些方法对于Leaf角色完全没有用处。因此Component角色是否定义这些方法，就形成了两种实现方式。</p>

<h3>透明方式</h3>

<p>这种方式在Component中定义所有的方法，不管这些方法对于Leaf角色是否有用。这样做的好处是所有角色都有相同的接口，客户端可以统一的方式对待所有对象。缺点是不够安全，因为Leaf角色的add方法没有意义，可能在运行期出错。透明方式的组合模式结构图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-31_21.29.20.jpg" alt="image" /></p>

<p>可以看出，这种方式的Leaf和Composite没有什么区别，都实现了Component的所有接口方法。但Leaf角色的add, remove等方法都是平庸实现。</p>

<h3>安全方式</h3>

<p>这种方式的Component只定义公共的接口，不包括Composite角色的add, remove等方法。结构如下图：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-31_22.11.35.jpg" alt="image" /></p>

<p>不论采用哪种方式，其中composite属性都是指向父节点的引用。这样就可以很容易地遍历所有的父对象。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:缺省适配模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/31/she-ji-mo-shi-que-sheng-gua-pei-mo-shi/"/>
    <updated>2014-07-31T20:31:57+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/31/she-ji-mo-shi-que-sheng-gua-pei-mo-shi</id>
    <content type="html"><![CDATA[<p>缺省适配模式其实很简单，就是一个接口有很多方法，通过一个抽象类为这些方法提供默认实现，而具体的类继承这个抽象类，实现自己关心的方法即可。其结构如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-31_20.37.12.jpg" alt="image" /></p>

<p>什么情况下用缺省适配模式？如果不准备实现一个接口的所有方法时，可以通过一个抽象类，给出所有方法的实现。有用的方法要有实现，没用的方法也要有空的、平庸的实现。这样子类就不必实现所有方法了。对应适配器模式的三个角色：</p>

<ul>
<li>Adapter：子类</li>
<li>Adaptee：抽象类</li>
<li>Target：接口</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:适配器模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/30/she-ji-mo-shi-gua-pei-qi-mo-shi/"/>
    <updated>2014-07-30T22:31:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/30/she-ji-mo-shi-gua-pei-qi-mo-shi</id>
    <content type="html"><![CDATA[<p>适配器模式分为类的适配器和对象的适配器。它们都是把被适配类的API转换成目标类的API。但前者使用继承关系，而后者使用委派关系。它们的结构如下图：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-30_22.38.26.jpg" alt="image" /> <img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-30_22.40.21.jpg" alt="image" /></p>

<!--more-->


<p>上图中的三个角色：</p>

<ol>
<li>Target接口，这是目标接口，表示要适配成这个接口。</li>
<li>Adaptee，这是被适配的对象，表示要将它适配成Target。</li>
<li>Adapter，适配器，将Adaptee适配成Target。</li>
</ol>


<p>第一张图对应的是类的适配器，第二张图是对象的适配器。从图上看，区别主要是Adapter到Adaptee的连线不一样，一个是继承，一个是依赖。</p>

<h2>类的适配器</h2>

<p>先看类的适配器，即第一张图。Adapter继承自Adaptee，因此继承了方法operation1，再加上它自己实现的方法operation2，从而实现了Target接口，完成适配。由于是继承关系，因此Adaptee必须是一个类，不能是接口。</p>

<h2>对象的适配器</h2>

<p>对第二张图，Adaptee是被适配的接口，可以是接口或者类。Adapter包含一个对Adaptee的引用。Adapter的operation1方法，只需调用Adaptee.operation1，同时增加operation2，从而实现Target接口，完成适配。</p>

<p>因为没有了继承关系，因此一个适配器可以把多种不同的源适配到同一个目标。</p>

<h2>什么情况下使用适配器模式</h2>

<ol>
<li>系统需要使用现有类，而此类的接口不符合系统需要。</li>
<li>建立一个可重复使用的类，用于与一些彼此没有太大关联的一些类一起工作。</li>
<li>对象的适配器可用于改变多个已有的子类的接口。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式: 原型（Prototype）模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/30/she-ji-mo-shi-prototypemo-shi/"/>
    <updated>2014-07-30T20:58:15+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/30/she-ji-mo-shi-prototypemo-shi</id>
    <content type="html"><![CDATA[<p>原型（Prototype）模式的用处是：对于给定的原型对象，用复制的方法创建出更多的同类型对象。之前学习的工厂方法模式常常需要有一个与产品等级相同的等级结构，而原型模式则不需要这样。Java语言天生就支持原型模式。原型模式的结构图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-30_21.10.50.jpg" alt="image" /></p>

<!--more-->


<h2><code>clone()</code>方法</h2>

<p>Java的Object类提供了<code>protected Object clone()</code>方法，用于复制对象。而<code>Cloneable</code>接口用于在运行期告诉JVM可以安全地使用<code>clone()</code>方法，否则JVM将会抛出<code>CloneNotSupportedException</code>异常。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">//复制一个pandaA</span>
</span><span class='line'><span class="n">pandaB</span> <span class="o">=</span> <span class="n">pandaA</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>一般而言，clone方法满足以下描述：</p>

<ol>
<li><code>x.clone() != x</code>，也就是说复制出来后，不是同一个对象。</li>
<li>复制对象与被复制对象是同一种类型。</li>
<li>在Java的API中，<code>x.clone().equals(x)</code>是成立的，因此建议要遵守这一条。</li>
</ol>


<h2>深复制和浅复制</h2>

<ul>
<li>浅复制：对象所有的变量与原来的对象值相同，所有对其它对象的引用仍然指向原来的对象。</li>
<li>深复制：对象所有的变量与原来的对象值相同，所有对其它对象的引用也指向被复制的新对象。</li>
</ul>


<p><code>clone()</code>方法是浅复制，而深复制可以通过序列化实现。例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DeepCloneDemo</span> <span class="kd">implements</span> <span class="n">Serializable</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="n">DeepCloneDemo</span> <span class="nf">deepClone</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">ByteArrayOutputStream</span> <span class="n">bo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ByteArrayOutputStream</span><span class="o">();</span>
</span><span class='line'>      <span class="n">ObjectOutputStream</span> <span class="n">oo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectOutputStream</span><span class="o">(</span><span class="n">bo</span><span class="o">);</span>
</span><span class='line'>      <span class="n">oo</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'>      
</span><span class='line'>      <span class="n">ByteArrayInputStream</span> <span class="n">bi</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ByteArrayInputStream</span><span class="o">(</span><span class="n">bo</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">());</span>
</span><span class='line'>      <span class="n">ObjectInputStream</span> <span class="n">oi</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectInputStream</span><span class="o">(</span><span class="n">bi</span><span class="o">);</span>
</span><span class='line'>      
</span><span class='line'>      <span class="k">return</span> <span class="o">(</span><span class="n">DeepCloneDemo</span><span class="o">)</span> <span class="n">oi</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">//...</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">//...</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1">//测试代码</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DeepCloneDemoTest</span> <span class="kd">extends</span> <span class="n">TestCase</span><span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testDeepClone</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">DeepCloneDemo</span> <span class="n">demo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DeepCloneDemo</span><span class="o">();</span>
</span><span class='line'>      <span class="n">demo</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;Demo&quot;</span><span class="o">);</span>
</span><span class='line'>      
</span><span class='line'>      <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">DeepCloneDemo</span> <span class="n">demo2</span> <span class="o">=</span> <span class="n">demo</span><span class="o">.</span><span class="na">deepClone</span><span class="o">();</span>
</span><span class='line'>          <span class="n">Assert</span><span class="o">.</span><span class="na">assertFalse</span><span class="o">(</span><span class="n">demo2</span> <span class="o">==</span> <span class="n">demo</span><span class="o">);</span>
</span><span class='line'>          <span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">demo</span><span class="o">,</span> <span class="n">demo2</span><span class="o">);</span>
</span><span class='line'>          
</span><span class='line'>      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClassNotFoundException</span> <span class="o">|</span> <span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>          <span class="n">Assert</span><span class="o">.</span><span class="na">assertFalse</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意要实现Serializable接口。如果不希望某个属性被序列化，可以使用<code>transient</code>关键字，例如：<code>private transient int age;</code>。</p>

<h2>什么时候用原型模式</h2>

<p>如果类是动态加载的，给每个类配备clone方法，就可以在运行时创建。</p>

<p>原型模式的优点是：允许动态地增加或减少产品类；提供简化的创建结构，不需要工厂方法那样的等级结构；为软件提供动态加载新功能的能力；</p>

<p>原型模式的缺点是：每个类都必须有clone方法，这对新类来说很容易，但已有的类就不一定，例如引用了不支持序列化的间接对象时，或者含有循环结构的时候。</p>
]]></content>
  </entry>
  
</feed>
