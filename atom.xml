<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[码出人生]]></title>
  <link href="http://blog.ubone.com/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2014-12-21T13:58:53+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SecureRandom导致Tomcat启动过慢]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/20/%5B%3F%5D-ci-jie-jue-tomcatqi-dong-guo-man-de-jing-li/"/>
    <updated>2014-12-20T12:08:33+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/20/[?]-ci-jie-jue-tomcatqi-dong-guo-man-de-jing-li</id>
    <content type="html"><![CDATA[<p>昨天晚上在Tomcat上部署一个小应用时，Tomcat启动非常慢，有时甚至需要10分钟。查看日志，发现一直停在Deploying阶段：</p>

<!--more-->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>INFO: Starting service Catalina
</span><span class='line'>Dec 19, 2014 9:56:33 AM org.apache.catalina.core.StandardEngine startInternal
</span><span class='line'>INFO: Starting Servlet Engine: Apache Tomcat/7.0.52 (Ubuntu)
</span><span class='line'>Dec 19, 2014 9:56:33 AM org.apache.catalina.startup.HostConfig deployWAR
</span><span class='line'>INFO: Deploying web application archive /usr/mxs/kindleinstance/webapps/kindlegen.war</span></code></pre></td></tr></table></div></figure>


<p>难道是war文件有问题？检查了md5校验码，尝试了解压缩，完全没问题啊！到底是什么原因呢？等了十分钟后，发现Tomcat已经启动完成，可以使用了。再次查看日志：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>INFO: Deploying web application archive /usr/mxs/kindleinstance/webapps/kindlegen.war
</span><span class='line'>Dec 19, 2014 10:11:25 AM org.apache.catalina.util.SessionIdGenerator createSecureRandom
</span><span class='line'>INFO: Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [888,934] milliseconds.
</span><span class='line'>Dec 19, 2014 10:11:25 AM org.apache.coyote.AbstractProtocol start
</span><span class='line'>INFO: Starting ProtocolHandler ["http-bio-9090"]
</span><span class='line'>Dec 19, 2014 10:11:25 AM org.apache.catalina.startup.Catalina start
</span><span class='line'>INFO: Server startup in 892334 ms</span></code></pre></td></tr></table></div></figure>


<p>原来是“Creation of SecureRandom instance for session ID”消耗了888秒，这个SecureRandom实例是什么呢？在<a href="http://wiki.apache.org/tomcat/HowTo/FasterStartUp">How do I make Tomcat startup faster?</a>中，有这样的描述：</p>

<blockquote><p>Tomcat 7+ heavily relies on SecureRandom class to provide random values for its session ids and in other places. Depending on your JRE it can cause delays during startup if entropy source that is used to initialize SecureRandom is short of entropy.</p></blockquote>

<p>也就是说，Tomcat 7之后严重依赖SecureRandom类来提供随机数用于Session ID。当Tomcat启动时，取决于你使用的JRE，如果用来初始化SecureRandom的熵值（Entropy）资源是一个短熵时，将可能导致延时。</p>

<p>再看看JDK中关于<a href="http://docs.oracle.com/javase/7/docs/api/java/security/SecureRandom.html">SecureRandom类</a>:</p>

<blockquote><p>This class provides a cryptographically strong random number generator (RNG). A cryptographically strong random number minimally complies with the statistical random number generator tests specified in FIPS 140-2, Security Requirements for Cryptographic Modules, section 4.9.1. Additionally, SecureRandom must produce non-deterministic output. Therefore any seed material passed to a SecureRandom object must be unpredictable, and all SecureRandom output sequences must be cryptographically strong, as described in RFC 1750: Randomness Recommendations for Security.</p></blockquote>

<p>该类提供保密性强的随机数生成器（RNG）。一个保密性强的随机数应最低限度遵循FIPS 140-2指定的统计随机数发生器测试和4.9.1节的加密模块安全要求。并且SecureRandom必须产出非确定性的输出。因此，正如RFC 1750中描述的，传递给SecureRandom对象的任何材料必须是不可预测的，并且所有SecureRandom输出序列必须是保密性强的的。</p>

<p>在<a href="http://www.cigital.com/justice-league-blog/2014/01/06/issues-when-using-java-securerandom/">ISSUES TO BE AWARE OF WHEN USING JAVA’S SECURERANDOM</a>中，提到了使用SecureRandom可能存在的问题，主要包括三个方面：调用顺序、阻塞和内部Seeding机制。其中说明了阻塞是如何产生的：</p>

<blockquote><p>Some SecureRandom implementations in the Oracle JRE for *nix use /dev/random to get entropy at certain times. Since /dev/random can block if sufficient entropy is not available, your code will stop executing if you call certain SecureRandom methods at times when /dev/random does not have sufficient entropy available.</p></blockquote>

<p>这样看来，我的Ubuntu 14中的OpenJDK(OpenJDK Runtime Environment (IcedTea 2.5.3) (7u71-2.5.3-0ubuntu0.14.04.1))正是使用了操作系统的<code>/dev/random</code>作为信息源，而它又没有提供足够的熵，所以导致阻塞。</p>

<p>按照前文<a href="http://wiki.apache.org/tomcat/HowTo/FasterStartUp">How do I make Tomcat startup faster?</a>中给出的次安全的解决办法，改为使用<code>-Djava.security.egd=file:/dev/./urandom</code>，即在setenv.sh中加入一行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/sh
</span><span class='line'>export CATALINA_OPTS="-Djava.security.egd=file:/dev/./urandom"</span></code></pre></td></tr></table></div></figure>


<p>然后再重启Tomcat，这次非常快了，整个启动只用了3秒多：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>INFO: Starting service Catalina
</span><span class='line'>Dec 19, 2014 10:51:55 PM org.apache.catalina.core.StandardEngine startInternal
</span><span class='line'>INFO: Starting Servlet Engine: Apache Tomcat/7.0.52 (Ubuntu)
</span><span class='line'>Dec 19, 2014 10:51:55 PM org.apache.catalina.startup.HostConfig deployWAR
</span><span class='line'>INFO: Deploying web application archive /usr/mxs/kindleinstance/webapps/kindlegen.war
</span><span class='line'>Dec 19, 2014 10:51:58 PM org.apache.coyote.AbstractProtocol start
</span><span class='line'>INFO: Starting ProtocolHandler ["http-bio-9090"]
</span><span class='line'>Dec 19, 2014 10:51:58 PM org.apache.catalina.startup.Catalina start
</span><span class='line'>INFO: Server startup in 3418 ms</span></code></pre></td></tr></table></div></figure>


<p>修改后的<code>/dev/urandom</code>没有默认的<code>dev/random</code>安全吗？似乎也不一定，博文<a href="http://www.2uo.de/myths-about-urandom/">Myths about /dev/urandom</a>对两者进行了全面的分析，值得一看。最后作者认为用<code>/dev/urandom</code>就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java运行时数据区与内存溢出异常]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/15/javayun-xing-shi-shu-ju-qu-yu-nei-cun-yi-chu-yi-chang/"/>
    <updated>2014-12-15T21:55:31+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/15/javayun-xing-shi-shu-ju-qu-yu-nei-cun-yi-chu-yi-chang</id>
    <content type="html"><![CDATA[<p>JVM定义了各种运行时数据区用于程序执行。有些数据区随着JVM启动而创建，当JVM退出时销毁。另一些数据区则是随着线程而存亡。每个数据区都是内存，因此就存在内存溢出的异常。本文学习JVM有哪些数据区以及常见的内存溢出异常。</p>

<!--more-->


<h2>1. 运行时数据区（Run-Time Data Areas）</h2>

<p>根据<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5">JVM规范</a>，运行时数据区主要分为以下部分。</p>

<h3>1.1 程序计数器（Program Counter Register）</h3>

<p>每个JVM线程拥有自己的程序计数器，各线程之间计数器互不影响，这部分区域可以称为线程私有的内存。在任何时间点，一个CPU核心都只会执行一个线程中某个方法的指令，这就是当前方法：</p>

<ul>
<li>如果当前方法不是Native方法，程序计数器包含正在执行的虚拟机字节码指令的地址。</li>
<li>如果是Native方法计数器值为Undefined。</li>
</ul>


<p>程序计数器所占内存非常小，也是唯一没有规定任何内存溢出异常的区域。</p>

<h3>1.2 虚拟机栈（JVM Stacks）</h3>

<p>每个线程同时也有一个私有的虚拟机栈，因此虚拟机栈的生命周期与线程相同。每个栈包括帧（frames），帧与方法调用相关，每当方法被调用，就会创建一个新的帧。当方法结束，帧也就被销毁。帧包括局域变量、自己的操作栈和当前方法的运行时常量池引用。</p>

<p>虚拟机栈与C语言中的栈相似，它包括局域变量和部分结果，并在方法调用和返回中扮演角色。除了push和pop帧，虚拟机栈并不提供其它直接操作。帧可能是在堆中分配内存。虚拟机栈的内存并不需要是连续的。</p>

<p>通常人们把Java内存分为堆和栈，其中栈就是虚拟机栈。虚拟机栈的内存可以是固定大小或者根据计算动态扩展。虚拟机栈涉及两个异常：</p>

<ul>
<li>StackOverflowError: 如果线程请求的栈深度大于允许的深度。</li>
<li>OutOfMemoryError：如果栈是动态扩展的，扩展时无法申请足够的内存。</li>
</ul>


<p>本地方法栈（Native Method Stack）与虚拟机栈发挥着相似的作用，但它是为Native方法服务。JVM规范并没有对其强制规定。HotSpot直接把本地方法栈和虚拟栈合二为一，相同对待。</p>

<p>栈虽然有两个异常，但实验时，如果是单线程操作，无论是栈帧太大还是虚拟机栈容量太小，基本只会出现StackOverflowError，示例如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm">* -Xss128k</span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JavaVMStackSOF</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">int</span> <span class="n">stackLength</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stackLeak</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">stackLength</span><span class="o">++;</span>
</span><span class='line'>      <span class="n">stackLeak</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">JavaVMStackSOF</span> <span class="n">oom</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JavaVMStackSOF</span><span class="o">();</span>
</span><span class='line'>      <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">oom</span><span class="o">.</span><span class="na">stackLeak</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="o">...</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>实验中，只有多线程时，才会出现OutOfMemoryError。通过不停地创建线程，并且每个线程不停止，当线程足够多时就可以重现此异常。</p>

<h3>1.3 堆（Heap）</h3>

<p>堆是在JVM所管理的内存中最大的一块，它是所有线程共享的区域。当JVM启动时会创建此区域。所有对象实例和数组都在堆上分配（现在也有例外，参见<a href="http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">逸出分析</a>）。</p>

<p>堆中存储的对象由垃圾收集器负责回收。堆的大小可以是固定或者动态扩展。堆不需要连续内存空间，只要逻辑上连续即可。根据垃圾收集器的不同，堆内存有不同的管理方式。例如CMS采用分代收集算法，将堆分为年轻代和老年代；而G1则将堆分成大小相同的区域。详见<a href="http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>。</p>

<p>堆涉及的内存异常为OutOfMemoryError，如果堆中没有内存用于实例分配并且无法再扩展时，就会抛出此异常。堆内存溢出很容易模拟，示例如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm">* -Xms20m -Xmx20m</span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">List</span><span class="o">&lt;</span><span class="n">SomeObject</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span><span class='line'>  <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">SomeObject</span><span class="o">());</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>1.4 方法区（Method Area）</h3>

<p>方法区也是所有线程共享的内存区域。它存储了每个类的信息，例如运行时常量池、属性和方法数据、方法和构造方法代码，包括类和实例初始化和接口初始化的特殊方法。</p>

<p>方法区随着虚拟机启动而创建。逻辑上它是堆的一部分，但JVM实现可以选择不对它进行垃圾收集或者压缩。JVM规范并没有强制规定它的位置和管理已编译代码的策略。它可以是固定大小或者动态扩展，也不需要是连续的。</p>

<p>对于HotSpot虚拟机来说，开发者更愿意把方法区称为永久代（Permanent Generation），但本质上两者并不等价。这仅仅是因为HotSpot设计团队使用永久代来实现方法区而已。但其它虚拟机（如Bea JRocket, IBM J9）并没有永久代的概念。</p>

<p>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。如果一些框架使用CGLib这类字节码技术，增强的类过多，或者JVM上的动态语言（如Groovy）持续创建类来实现语言动态特性，可能出现此异常。</p>

<h3>1.5 运行时常量池</h3>

<p>在<a href="http://blog.ubone.com/blog/2014/12/04/lei-wen-jian-yu-zi-jie-ma/">类文件与字节码</a>中介绍了类文件的常量池，运行时常量池就是这个常量池的运行时表示。运行时常量池相对于类文件常量池主要有两个区别：</p>

<ul>
<li>除了类文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</li>
<li>运行时常量池可以在运行期间将新的常量加入池中。</li>
</ul>


<p>运行时常量池的内存是从方法区分配出来的。当JVM创建类或接口时，会为它创建运行时常量池。因此它的内存受方法区内存限制，也可能抛出OutOfMemoryError异常。</p>

<h3>1.6 直接内存</h3>

<p>直接内存（Direct Memory）并不是JVM运行时数据区的一部分，也不是JVM规范定义的内存区域。但它也被频繁使用，可能导致OutOfMemoryError异常。</p>

<p>JDK 1.4中加入NIO类，引入了基于Channel与Buffer的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过DirectByteBuffer对象作为这块内存的引用进行操作。由于避免了Java堆与Native堆之间复制数据，在一些场景能显著提高性能。</p>

<p>这部分内存虽然不受Java堆大小限制，但肯定会受本机总内存和寻址空间限制。因此动态扩展时可能出现OutOfMemoryError异常。</p>

<h2>2. 内存Dump分析</h2>

<p>在<a href="http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>中介绍了jmap, jstat等工具可以查看内存映射和垃圾收集活动。这里介绍另一个工具Eclipse Memory Analyzer可以对堆内存溢出问题进行分析。首先需要生成堆转储文件。通过启用参数：</p>

<p><code>-XX:+HeapDumpOnOutOfMemoryError</code></p>

<p>JVM 就会在发生内存泄露时抓拍下当时的内存状态，也就是我们想要的堆转储文件。也可以在未溢出时用jmap创建转储文件。</p>

<p>有了转储文件，利用Eclipse Memory Analyzer tool打开该文件，就可以进行分析了。分析通常分为三步：</p>

<ul>
<li>对内存状态获取一个整体印象。</li>
<li>找到最有可能导致内存泄露的元凶，通常也就是消耗内存最多的对象。</li>
<li>进一步查看这个内存消耗大户的具体情况，看看是否有什么异常行为。</li>
</ul>


<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-17-20.30.59.jpg" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解Java性能调优]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you/"/>
    <updated>2014-12-06T21:00:37+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you</id>
    <content type="html"><![CDATA[<p>人们总是猜不对系统变慢的原因在哪里，你必须量体裁衣。没有评测就没有合适的调优。本文重点学习性能相关的内存管理、垃圾收集、相关工具并简单了解HotSpot。</p>

<!--more-->


<h2>1. 性能指标</h2>

<h3>评价性能的常用指标</h3>

<ul>
<li>等待时间(Latency)：在给定工作量的情况下，处理一个任务单元所消耗的时长。通常用响应时间随负载增长的变化曲线来反映。</li>
<li>吞吐量(Throughput)：在某一参考平台（硬件配置、OS和软件环境）上的每秒事务处理数。</li>
<li>利用率(Utilization)：在可用资源中处理工作单元的资源百分比。例如CPU的利用率。</li>
<li>效率(Efficiency)：吞吐量除以所用资源。</li>
<li>容量(Capacity)：任一时刻能通过系统的工作单元数量。</li>
<li>扩展性(Scalability)：当系统得到更多资源时，吞吐量或等待时间的变化。如果方案A可用的服务器数量翻倍，它的吞吐量也能翻倍，那么它就实现了完美的线性扩展。</li>
<li>退化(Degradation)：分为正面退化和负面退化。当工作单元增加时，性能通常会降低，即负面退化。但也存在正面退化，例如负载超过阈值，使系统切换到高性能模式，处理时间可能缩短。JVM是动态非常强的运行时系统，有几部分可以达成这种效果。</li>
</ul>


<p>性能分析时要了解一些概念：</p>

<blockquote><p>中位数（又称中值，Median），统计学中的专有名词，代表一个样本、种群或概率分布中的一个数值，其可将数值集合划分为相等的上下两部分。对于有限的数集，可以通过把所有观察值高低排序后找出正中间的一个作为中位数。如果观察值有偶数个，通常取最中间的两个数值的平均数作为中位数。</p>

<p>方差是各个数据分别与其和的平均数之差的平方的和的平均数，用字母D表示。在概率论和数理统计中，方差（Variance）用来度量随机变量和其数学期望（即均值）之间的偏离程度。在许多实际问题中，研究随机变量和均值之间的偏离程度有着重要意义。</p>

<p>百分位数是统计学术语，如果将一组数据从小到大排序，并计算相应的累计百分位，则某一百分位所对应数据的值就称为这一百分位的百分位数。可表示为：一组n个观测值按数值大小排列。如，处于p%位置的值称第p百分位数。</p>

<p>标准差（Standard Deviation） ，中文环境中又常称均方差，但不同于均方误差（mean squared error，均方误差是各数据偏离真实值的距离平方的平均数，也即误差平方和的平均数，计算公式形式上接近方差，它的开方叫均方根误差，均方根误差才和标准差形式上接近），标准差是离均差平方和平均后的方根，用σ表示。标准差是方差的算术平方根。标准差能反映一个数据集的离散程度。平均数相同的，标准差未必相同。</p></blockquote>

<h2>2. 务实的性能分析法</h2>

<p>做性能分析最重要的是知道哪个可测环节最重要。应该把测量结果、目标和结论跟一个或多个可测环节结合起来。以下是常见的可测项，都是性能调优的好对象：</p>

<ul>
<li>方法handelRequest()运行所需的平均时间。</li>
<li>并发10客户端时，系统等待时间的第90个百分位数。</li>
<li>并发用户从1增长到1000时，响应时间的退化。</li>
</ul>


<p>要精确确定一个方法或代码片段运行需要多长时间，只有两种方法：</p>

<ul>
<li>直接测量，在源码中插入测量代码。最容易理解，但是侵入式的。如果测量结果不断增多，代码很容易就被数据淹没。</li>
<li>在类加载时把类转换成受测类。使用特殊的类加载器，在方法开始和结束的地方加上记录时间的字节码。典型的有OpTier CoreFirst等性能监测工具，但似乎还没有开源工具。</li>
</ul>


<h2>3. 时间问题</h2>

<p>为了进行性能调优，需要对时间有深刻认识。</p>

<h4>硬件时钟</h4>

<p>基于x64的机器有四种不同的硬件时间源：</p>

<ul>
<li>RTC: 实时时钟（RTC）基本和电子表里的元件一样，在系统断电时由主板上的电池供电。系统启动时从它那得到时间。很多系统会在OS启动后通过网络时间协议（Network Time Protocol, NTP）与时间服务器同步。</li>
<li>8254：是可编程计时芯片，现在基本不需要了。</li>
<li>TSC：时间戳计时器，这是应用最广泛的现代计时器。可认为是一个跟踪CPU运行了多少周期的CPU计数器。由于与CPU相关，因此运行时可能受节能或其它因素影响。不同的CPU会互相偏离，不能跟钟表时间保持一致。</li>
<li>HPET，高精度事件计时器，最近几年才出现。精度非常高，但不是所有硬件都可用，也不是所有操作系统都支持。</li>
</ul>


<h4>Java获取时间的方法</h4>

<p>Java提供了两个获取时间的方法：</p>

<ul>
<li>System.currentTimeMillis()，解析度为毫秒级，几乎所有情况下都跟钟表时间相符。</li>
<li>System.nanoTime()，用于测量比毫秒更精确的时间，时间源来自TSC，可能偏离钟表时间。</li>
</ul>


<p>对于较长的间隔时间，nanoTime()基本是不可信的，应该使用currentTimeMillis()，nanoTime()它只能测量较短的时间间隔。</p>

<h2>4. 垃圾收集</h2>

<h3>4.1 内存管理</h3>

<p>内存自动管理是Java平台最重要的组成部分之一。Java内存分为栈和堆。</p>

<p>栈内存，即虚拟机栈。每个方法被执行的时候都会同时创建一个栈帧，用来存储局部变量，操作栈，动态链接，方法出口等信息。<strong>局部变量包括各种基本类型的变量和对象的引用变量都是在方法的栈内存中分配。</strong>其中，64位长度的long和double类型的数据占用2个局部变量的空间，其他数据类型只占用1个。局部变量所需要的内存空间是在编译期间完成的，当进入一个方法时候，这个方法所需的局部变量空间已经确定，在方法运行期间不会改变。当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。当线程请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常。当虚拟机栈无法扩展时候则抛出OutOfMemoryError异常。</p>

<p>堆内存，在虚拟机启动时创建。堆内存的唯一目的就是创建对象实例，所有的对象实例和数组都要在堆上分配。对象的域即使是原始类型，也仍然分配在堆内存中。堆内存的回收由垃圾回收负责。</p>

<h4>标记和清除</h4>

<p>标记和清除是最简单、也是出现最早的垃圾收集算法。Perl和PHP等语言则采用引用计数法。</p>

<p>最简单的标记和清除算法会暂停所有正在运行的线程，并从一组“活”对象（任何用户线程的任何堆栈帧中存在引用的对象）开始遍历其引用树，标记出路径上的所有活对象。遍历完成后，所有没被标记的被当作垃圾，可以回收。被清除的内存不是还给OS，而是JVM。</p>

<p>Java平台对基本的标记清除算法进行了改进，采用“分代式垃圾收集”。内存分成了几个不同的区域：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-07-Java-Memory-Model-450x186.png" alt="image" /></p>

<ul>
<li>Eden(伊甸园)：对象最初降生的堆区域。</li>
<li>Survivor(幸存者乐园)：分为两个空间（S0, S1）,除非正在执行垃圾收集，否则总有一个空间是空的。</li>
<li>Old Generation：老年代。是那些“足够老”的幸存对象的归宿。</li>
<li>PermGen：为内部结构分配的内存，例如类定义。它不是严格的堆内存，并且普通的对象最后不会在这里结束。</li>
</ul>


<p>上面这些内存区域的垃圾收集方式不尽相同。</p>

<h4>年轻代收集（Minor GC）</h4>

<p>年轻代收集只会清理“年轻的”空间（伊甸园和幸存者乐园），其过程如下：</p>

<ul>
<li>在标记阶段发现的所有仍然存活的年轻对象都会被挪走：那些足够老的对象（从次数足够多的GC中幸存下来的）进入老年代；所有Eden中存活的对象被移到幸存者乐园的其中一个空间，幸存者乐园中的存活对象也会被移到该空间。（S0, S1总有一个是空的）</li>
<li>伊甸园和最近腾空的幸存者乐园可以重用了，因为它们里面已经全是垃圾了。</li>
</ul>


<h4>完全收集（Major GC）</h4>

<p>当年轻代收集不能把对象放进老年代时（空间不够了），就会触发一次完全收集，这通常要更长的时间。根据老年代所用的收集器，可能会牵涉到老年代对象的内部迁移。以确保必要时能从老年代对象所占的内存中给大的对象腾出足够的空间。这被称为压缩。</p>

<p>由于Major GC会消耗更长时间，消耗的时间取决于垃圾收集策略，这期间应用将无响应。因此在高响应应用中，有必要监视和优化垃圾回收以避免超时。</p>

<h4>安全点</h4>

<p>因为垃圾收集时，要暂停所有应用线程，因此线程给执行GC留出了特定的位置——安全点。常见的安全点是方法被调用的地方（调用点），不过也有其它安全点。当执行垃圾收集时，所有应用线程都必须停在安全点。</p>

<h3>4.2 工具</h3>

<p>借助一些工具可以帮你了解运行中的进程和垃圾收集。</p>

<h4>jmap</h4>

<p>jmap是Oracle JVM自带的一个工具，用来显示Java进程的内存映射，也能分析Java核心文件（Java core file，主要保存各应用线程在某一时刻的执行栈以及stack trace的显示）。</p>

<p><strong>默认视图</strong></p>

<p>jmap最简单的用法是查看连接到进程里的本地类库。用处不大，用得最多的是后面两种视图。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ jmap 25154
</span><span class='line'>Attaching to process ID 25154, please wait...
</span><span class='line'>Debugger attached successfully.
</span><span class='line'>Server compiler detected.
</span><span class='line'>JVM version is 24.65-b04</span></code></pre></td></tr></table></div></figure>


<p><strong>堆视图</strong></p>

<p>使用-heap选项，jmap会抓取进程当前的堆快照。以下是输出结果示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ jmap -heap 25164
</span><span class='line'>Attaching to process ID 25164, please wait...
</span><span class='line'>Debugger attached successfully.
</span><span class='line'>Server compiler detected.
</span><span class='line'>JVM version is 24.65-b04
</span><span class='line'>
</span><span class='line'>using thread-local object allocation.
</span><span class='line'>Parallel GC with 4 thread(s)
</span><span class='line'>
</span><span class='line'>Heap Configuration:
</span><span class='line'>   MinHeapFreeRatio = 0
</span><span class='line'>   MaxHeapFreeRatio = 100
</span><span class='line'>   MaxHeapSize      = 2147483648 (2048.0MB)
</span><span class='line'>   NewSize          = 1310720 (1.25MB)
</span><span class='line'>   MaxNewSize       = 17592186044415 MB
</span><span class='line'>   OldSize          = 5439488 (5.1875MB)
</span><span class='line'>   NewRatio         = 2
</span><span class='line'>   SurvivorRatio    = 8      //Eden = (From+To)*幸存比例
</span><span class='line'>   PermSize         = 21757952 (20.75MB)
</span><span class='line'>   MaxPermSize      = 85983232 (82.0MB)
</span><span class='line'>   G1HeapRegionSize = 0 (0.0MB)
</span><span class='line'>
</span><span class='line'>Heap Usage:
</span><span class='line'>PS Young Generation
</span><span class='line'>Eden Space:
</span><span class='line'>   capacity = 69206016 (66.0MB)
</span><span class='line'>   used     = 22857000 (21.798133850097656MB)
</span><span class='line'>   free     = 46349016 (44.201866149902344MB)
</span><span class='line'>   33.02747553045099% used
</span><span class='line'>From Space:
</span><span class='line'>   capacity = 5242880 (5.0MB)
</span><span class='line'>   used     = 5223552 (4.9815673828125MB)
</span><span class='line'>   free     = 19328 (0.0184326171875MB)
</span><span class='line'>   99.63134765625% used
</span><span class='line'>To Space:
</span><span class='line'>   capacity = 5242880 (5.0MB)
</span><span class='line'>   used     = 0 (0.0MB)
</span><span class='line'>   free     = 5242880 (5.0MB)
</span><span class='line'>   0.0% used
</span><span class='line'>PS Old Generation
</span><span class='line'>   capacity = 89128960 (85.0MB)
</span><span class='line'>   used     = 14067336 (13.415657043457031MB)
</span><span class='line'>   free     = 75061624 (71.58434295654297MB)
</span><span class='line'>   15.78312593347886% used
</span><span class='line'>PS Perm Generation
</span><span class='line'>   capacity = 22020096 (21.0MB)
</span><span class='line'>   used     = 15539944 (14.820045471191406MB)
</span><span class='line'>   free     = 6480152 (6.179954528808594MB)
</span><span class='line'>   70.57164510091145% used
</span><span class='line'>
</span><span class='line'>10750 interned Strings occupying 1540688 bytes.</span></code></pre></td></tr></table></div></figure>


<p>可以看到，堆的大小是年轻代、老年代加上PermGen的总和。年轻代分为Eden和幸存者乐园（From + To）。要知道堆里面有什么，需要柱状视图。</p>

<p><strong>柱状视图</strong></p>

<p>柱状视图显示了系统中每个类型的实例占用的内存量，并按占用内存倒序排序，非常直观：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ jmap -histo 25164 | head -30
</span><span class='line'>
</span><span class='line'> num     #instances         #bytes  class name
</span><span class='line'>----------------------------------------------
</span><span class='line'>   1:         46155       20826544  [B
</span><span class='line'>   2:         78977       13845352  [C
</span><span class='line'>   3:          1777       10259592  [I
</span><span class='line'>   4:         28606        3977416  &lt;constMethodKlass&gt;
</span><span class='line'>   5:         28606        3670320  &lt;methodKlass&gt;
</span><span class='line'>   6:          2464        2990888  &lt;constantPoolKlass&gt;
</span><span class='line'>   7:          2193        1756960  &lt;constantPoolCacheKlass&gt;
</span><span class='line'>   8:          2464        1728800  &lt;instanceKlassKlass&gt;
</span><span class='line'>   9:         53032        1272768  java.lang.String
</span><span class='line'>  10:         12669         405408  java.util.HashMap$Entry
</span><span class='line'>  11:          2740         333816  java.lang.Class
</span><span class='line'>  12:          4131         330480  java.lang.reflect.Method
</span><span class='line'>  13:          4488         297968  [S
</span><span class='line'>  14:          4204         287432  [Ljava.lang.Object;
</span><span class='line'>  15:           524         271024  &lt;methodDataKlass&gt;
</span><span class='line'>  16:          4277         228680  [[I
</span><span class='line'>  17:          2107         185416  org.apache.naming.resources.FileDirContext$FileResourceAttributes
</span><span class='line'>  18:          3047         170632  java.util.zip.ZipFile$ZipFileInputStream
</span><span class='line'>  19:           987         167256  [Ljava.util.HashMap$Entry;
</span><span class='line'>  20:          2929         164024  java.util.zip.ZipFile$ZipFileInflaterInputStream
</span><span class='line'>  21:           259         140896  &lt;objArrayKlassKlass&gt;
</span><span class='line'>  22:          4282         137024  java.io.File
</span><span class='line'>  23:          2194         131888  [Ljava.lang.String;
</span><span class='line'>  24:          5483         131592  java.lang.StringBuilder
</span><span class='line'>  25:          2656         127488  java.util.HashMap
</span><span class='line'>  26:          2520         100800  java.lang.ref.Finalizer
</span><span class='line'>  27:          2341          93640  java.util.LinkedHashMap$Entry</span></code></pre></td></tr></table></div></figure>


<p>结果使用的是类型内部名称，例如byte数组会写成[B，char数组会写成[C（字符数组数据经常出现在String对象里）。参考<a href="http://blog.ubone.com/blog/2014/12/04/lei-wen-jian-yu-zi-jie-ma/">类文件与字节码</a>。以char数组为例，共有78977个实例，占用约13.8MB。</p>

<p>使用-histo:live选项，jmap将只处理活对象，而不是整个堆：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ jmap -histo:live 25164 | head -7
</span><span class='line'>
</span><span class='line'> num     #instances         #bytes  class name
</span><span class='line'>----------------------------------------------
</span><span class='line'>   1:         28573        5905704  [C
</span><span class='line'>   2:         28606        3977416  &lt;constMethodKlass&gt;
</span><span class='line'>   3:         28606        3670320  &lt;methodKlass&gt;
</span><span class='line'>   4:          2464        2990888  &lt;constantPoolKlass&gt;</span></code></pre></td></tr></table></div></figure>


<p>活的字符串只有28573个实例，占用约5.9MB，证明有（13.8-5.9）MB在等待回收。需要注意的是，如果jmap正在执行时，JVM做了垃圾回收，有可能看到奇怪或太好的结果，所以应该多运行几次。</p>

<p><strong>产生离线导出文件</strong></p>

<p>jmap能创建导出文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ jmap -dump:live,format=b,file=heap.hprof 25164
</span><span class='line'>Dumping heap to /Users/mxs/Documents/blog/heap.hprof ...
</span><span class='line'>Heap dump file created</span></code></pre></td></tr></table></div></figure>


<p>导出结果可以用来做离线分析，留给jmap以后使用，或者留给Oracle的jhat（Java堆分析工具）做高级分析。</p>

<h4>jstat</h4>

<p>Oracle JVM自带的jstat可以查看内存和垃圾收集的活动，并能循环显示。下例以每秒一次的频率显示内存状况：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>meixuesongdeMacBook-Pro:blog mxs$ jstat -gc 25164 1000
</span><span class='line'> S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC     PU    YGC     YGCT    FGC    FGCT     GCT   
</span><span class='line'>14336.0 13312.0  0.0    0.0   133632.0 85887.5   52224.0    10313.5   33280.0 15221.9      7    0.064   3      0.171    0.236
</span><span class='line'>14336.0 13312.0  0.0    0.0   133632.0 85887.5   52224.0    10313.5   33280.0 15221.9      7    0.064   3      0.171    0.236</span></code></pre></td></tr></table></div></figure>


<ul>
<li>S0C和S1C: Survivor0和Survivor1的大小（KB）</li>
<li>S0U和S1U: Survivor0和Survivor1的已使用大小（KB）</li>
<li>EC and EU：Eden空间的大小和已经使用大小（KB）</li>
<li>OC and OU: 老年代空间的大小和已经使用大小（KB）</li>
<li>PC and PU: Perm空间的大小和已经使用大小（KB）</li>
<li>YGC and YGCT：YGC为年轻代GC的次数。YGCT显示年轻代GC的累计时间。</li>
<li>FGC and FGCT：Full GC的次数和累计时间</li>
<li>GCT：GC总时间，包括年轻代和Full GC。</li>
</ul>


<h4>Java VisualVM</h4>

<p>另一个可视化的工具是Java VisualVM，在命令行执行<code>jvisualvm</code>即可。</p>

<h3>4.3 与GC相关的JVM参数</h3>

<p>JVM的参数非常多。以<code>-X</code>开头的选项不是标准选项，在其它JVM上可能不可用。而<code>-XX</code>开头的是扩展选项，不要随便使用。很多与性能相关的选项都是扩展选项。</p>

<p>基本的垃圾收集选项可以见本文前面的内存分布图片。主要包括：</p>

<ul>
<li><code>-Xms</code>: 堆的初始大小</li>
<li><code>-Xmx</code>: 堆的最大大小</li>
<li><code>-Xmn</code>: 堆中年轻大的大小</li>
<li><code>-XX:-DisableExplicitGC</code>: 让System.gc()调用不产生任何作用。</li>
</ul>


<h3>4.4 逸出分析</h3>

<p>这是JVM最近的一项修改，开发者不能直接控制或影响这项修改。从Java 6u23之后，逸出分析是默认打开的。</p>

<p>它的基本思路是分析方法并确认其中哪个局部变量只用在方法内部，以及哪些变量不会传入其他方法或从当前方法中返回。JVM可以在当前方法的栈内部创建这个对象，不再使用堆内存。在当前方法返回时，被局部变量占用的内存就自动释放了，因此将减少程序年轻代收集的次数，提高性能。</p>

<h3>4.5 并发标记清除（CMS）</h3>

<p>CMS是Java 5推荐的高性能收集器，在Java 6仍保持了旺盛的生命力。通过以下选项激活：</p>

<table>
<thead>
<tr>
<th>选项 </th>
<th> 效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-XX:+UseConcMarkSweepGC</code> </td>
<td> 打开CMS收集</td>
</tr>
<tr>
<td><code>-XX:+CMSIncrementalMode</code> </td>
<td> 增量模式（一般都需要）</td>
</tr>
<tr>
<td><code>-XX:+CMSIncrementalPacing</code> </td>
<td> 配合增量模式，根据应用的行为自动调整每次执行垃圾回收任务的幅度（一般都需要）</td>
</tr>
<tr>
<td><code>-XX:+UseParNewGC</code> </td>
<td> 并发收集年轻代</td>
</tr>
<tr>
<td><code>-XX:ParallelGCThreads=&lt;N&gt;</code> </td>
<td> GC使用的线程数</td>
</tr>
</tbody>
</table>


<p>并发方式是如何工作的，以下是重要事实：</p>

<ul>
<li>某种世界停转（SWT）的暂停是不可避免的；</li>
<li>GC子系统绝对不能漏掉存活对象，这样做会导致JVM垮掉（或更糟）</li>
<li>只有所有应用线程都为整体收集暂停下来，才能保证收集所有的垃圾。</li>
</ul>


<p>CMS利用最后一点，制造两个非常短暂的STW暂停，并且在GC周期的剩余时间和应用程序的线程一起运行。CMS要在运行时做复杂的记账工作，记录哪些是垃圾，哪些不是。CMS在更多CPU核心的机器上表现会更好，并且会制造更频繁的短暂暂停。</p>

<h3>4.6 新的收集器：G1</h3>

<p>G1是Java平台最新的收集器，预发布于Java 6，到Java 7时已是成品。G1有望成为高性能应用的默认选择。</p>

<p>G1与原来的收集器完全不同，开发人员有更多控制权。其核心思想是暂停目标（Pause gaol），也就是程序能为GC暂停多长时间（如每5分钟20ms）。G1会努力达成该目标。</p>

<p>尽管G1仍然使用标记清除法，但它不是真正的分代式垃圾收集器。它把堆分成大小相同的区域（如每个1MB），不区分年轻、老年代。暂停时，对象被撤到其他区域（就像Eden挪到Survivor），清空的区域被放回到空白区自由列表上。</p>

<p>这个新的收集策略让Java平台统计收集单个区域所需平均时长。然后你就可以指定一个合理的暂停目标。G1只会在有限的时间内收集尽可能多的区域。与G1相关的选项如下表：</p>

<table>
<thead>
<tr>
<th>选项 </th>
<th> 效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-XX:+UseG1GC</code> </td>
<td> 打开G1收集</td>
</tr>
<tr>
<td><code>-XX:MaxGCPauseMillis=50</code> </td>
<td> 收集一次暂停的时间应尽量保持在50ms以内</td>
</tr>
<tr>
<td><code>-XX:GCPauseIntervalMillis=200</code> </td>
<td> 两次收集的时间间隔尽量保持在200ms以上。</td>
</tr>
</tbody>
</table>


<h2>5. HotSpot的JIT编译</h2>

<p>Java是一种“动态编译”语言。方法一开始都是以字节码形态存在，JVM对其解释并执行，同时会记录被调用的次数。当调用次数超过某个阈值（默认1万次）时，后台就会把字节码编译成机器码。如果编译成功，以后就会调用该方法的编译结果。编译后的机器码运行速度可能会快1000倍。</p>

<p>那为什么要动态编译，先编译好岂不是性能更好？原因之一是与平台无关的东西作为基本部署单位要更轻松。原因之二是动态编译能提供给编译器更多信息，例如某个指令是否可用，代码运行情况的统计数据等。因此Java这样的动态编译语言实际上可能会比提前编译的语言运行得更快。</p>

<p>HotSpot有两种运行模式：客户端模式和服务器模式，分别对应JVM启动选项：<code>-client</code>和<code>-server</code>。前者编译时会确保操作的一致性，较为保守。后者编译时会大胆假设，做一次运行时检查，以确保假设有效。编译结果性能好很多。</p>

<p><strong>实时Java</strong>是近年出现的，它并不一定是最快的。它关注的是让执行操作的时间尽量保持一致。为了达成这个目的，它可能会牺牲一些平均等待时间，整体性能可以受到轻微影响。</p>

<p><strong>内联</strong>是HotSpot的最大卖点之一。内联的方法不再是被调用，而是直接放到调用者内部。HotSpot会根据运行时的统计数据（方法调用频率）和其他因素来决定如何处理内联。这比提前编译更智能。它完全是自动的，通常不需要修改选项（用处不大）。</p>

<p><strong>独占调用</strong></p>

<p>独占调用是大胆优化的例子之一，只有服务端编译器才会做这种大胆优化，实时和客户端编译器都不会这样做。它是基于大量观察做出的优化，以下面的代码为例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MyActualClassNotInterface obj = getInstance();
</span><span class='line'>obj.callMyMethod();</span></code></pre></td></tr></table></div></figure>


<p>如果上面的代码只会在一种类型的对象上调用（基于统计），也就是obj.callMyMethod()几乎不会同时碰到一个类和它的子类。这时就可以把Java方法查找替换为callMyMethod()编译结果的直接调用。为了防止getInstance()可能返回的是其他类，运行时会检查，确保对象的类型是由编译器按预期插入的。如果这个预期被违背，运行时会取消优化。程序不会注意到这些动作也不会犯任何错误。</p>

<p>通过启动选项<code>-XX:+PrintCompilation</code>可以告诉JIT编译线程输出标准日志。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类文件与字节码]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/04/lei-wen-jian-yu-zi-jie-ma/"/>
    <updated>2014-12-04T20:40:02+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/04/lei-wen-jian-yu-zi-jie-ma</id>
    <content type="html"><![CDATA[<p>本篇学习类加载过程、类文件的分析工具和字节码。</p>

<!--more-->


<h2>1. 类加载和类对象</h2>

<p>一个.class文件定义了JVM的一种类型。类加入到JVM当前运行态中，首先要加载并连接，进行大量验证，然后提供一个代表该类型的Class对象给正在运行的系统，用于创建新的实例。</p>

<h4>加载</h4>

<p>加载的过程首先要读取类文件的字节数据流，创建一个字节数组，然后产生对应的Class对象。这个过程会进行一些基本检查。加载结束时，Class对象还不成熟，类也不可用。</p>

<h4>连接</h4>

<p>加载完成后，类必须连接起来。这分为三个步骤：验证、准备和解析。验证类文件符合预期，不会引起系统运行时错误。准备阶段会分配内存，准备好初始化类中的静态变量（但不会现在初始化变量）。解析阶段会检查类中引用的类型是否有未知类型，如果有会加载进来。一旦需要加载的其他类型全部定位并完成解析，VM就可以初始化这个类。这时所有静态变量都可以被初始化，所有静态初始化代码块都会运行。类的加载全部完成，已经可以使用了。</p>

<h4>Class对象</h4>

<p>加载和连接过程的最终结果是一个Class对象，可以使用这个新类型创建实例了。Class对象可以和反射API一起实现对方法、域和构造方法等类成员的间接访问，通过getSuperClass()返回其父类。</p>

<h4>类加载器</h4>

<p>Java平台有几个经典的类加载器：</p>

<ul>
<li>根（或引导）类加载器：通常在VM启动后不久实例化，一般用本地代码实现。可视为VM的一部分。负责加载系统的基础JAR(主要是rt.jar),而且不做验证工作。</li>
<li>扩展类加载器：用来加载安装时自带的标准扩展。一般包括安全性扩展。</li>
<li>应用（或系统）类加载器：应用最广泛的类加载器，负责加载应用类。</li>
<li>定制类加载器：在更复杂的环境，如EE或比较复杂的SE框架，通常会有些附加（即定制）的类加载器。</li>
</ul>


<h2>2. 方法句柄</h2>

<p>反射代码有很多套路，要捕获各种讨厌的异常，代码看起来也不直观。Java 7为间接调用方法引入了java.lang.invoke包，即方法句柄，可以提高安全性和代码的可读性。</p>

<h4>MethodHandle</h4>

<p>它是对可直接执行的方法（或域、构造方法等）的类型化引用，是一个有能力安全调用方法的对象。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">MethodHandle</span> <span class="n">mh</span> <span class="o">=</span> <span class="n">getTwoArgMH</span><span class="o">();</span>
</span><span class='line'><span class="n">MyType</span> <span class="n">ret</span><span class="o">;</span>
</span><span class='line'><span class="k">try</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">//调用obj对象的句柄，传入参数arg0, arg1</span>
</span><span class='line'>  <span class="n">ret</span> <span class="o">=</span> <span class="n">mh</span><span class="o">.</span><span class="na">invokeExact</span><span class="o">(</span><span class="n">obj</span><span class="o">,</span> <span class="n">arg0</span><span class="o">,</span> <span class="n">arg1</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">//...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>MethodType</h4>

<p>它表示方法签名类型的不可变对象。每个方法句柄都有一个MethodType实例，用来指明方法的返回类型和参数类型。但它没有方法的名称和接收者类型。通过工厂方法可以得到MethodType实例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">//第一个参数为返回类型，随后是方法参数的类型。</span>
</span><span class='line'><span class="c1">//toString()</span>
</span><span class='line'><span class="n">MethodType</span> <span class="n">mtToString</span> <span class="o">=</span> <span class="n">MethodType</span><span class="o">.</span><span class="na">methodType</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'><span class="c1">//setter方法</span>
</span><span class='line'><span class="n">MethodType</span> <span class="n">mtSetter</span> <span class="o">=</span> <span class="n">MethodType</span><span class="o">.</span><span class="na">methodType</span><span class="o">(</span><span class="kt">void</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">Object</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'><span class="c1">//Comparator&lt;String&gt;定义的compareTo()方法</span>
</span><span class='line'><span class="n">MethodType</span> <span class="n">mtStringComparator</span> <span class="o">=</span> <span class="n">MethodType</span><span class="o">.</span><span class="na">methodType</span><span class="o">(</span><span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">String</span><span class="o">.</span><span class="na">Class</span><span class="o">,</span> <span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<h4>查找方法句柄</h4>

<p>通过lookup对象，你给出持有所需方法的类、方法名称以及你所需方法签名相匹配的MethodType，就可以得到方法句柄：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">MethodHandle</span> <span class="nf">getToStringMH</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">MethodHandle</span> <span class="n">mh</span><span class="o">;</span>
</span><span class='line'>  <span class="n">MethodType</span> <span class="n">mt</span> <span class="o">=</span> <span class="n">MethodType</span><span class="o">.</span><span class="na">methodType</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>  <span class="n">MethodHandles</span><span class="o">.</span><span class="na">Lookup</span> <span class="n">lk</span> <span class="o">=</span> <span class="n">MethodHandles</span><span class="o">.</span><span class="na">lookup</span><span class="o">();</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">mh</span> <span class="o">=</span> <span class="n">lk</span><span class="o">.</span><span class="na">findVirtual</span><span class="o">(</span><span class="n">getClass</span><span class="o">(),</span> <span class="s">&quot;toString&quot;</span><span class="o">,</span> <span class="n">mt</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">NoSuchMethodException</span> <span class="o">|</span> <span class="n">IllegalAccessException</span> <span class="n">mhx</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">//...</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">return</span> <span class="n">mh</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>如果不是从当前类中查找，则只能看到或取得public方法的句柄。方法句柄总是在安全管理之下安全使用。没有反射中setAccessible()那种破解方法。</p></blockquote>

<p>有了方法句柄，就可以执行它了。执行方法有两个：invokeExact()和invoke()。前者要求参数类型完全匹配，后者可以在不太匹配时做些修改后执行（如装箱或拆箱）。</p>

<h4>示例：反射、代理和方法句柄的使用对比</h4>

<p>现在通过一个实例来对比这三种方法。下面的代码演示了如何通过这三种方法来访问私有方法cancel()：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadPoolManager</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">//...</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">cancel</span><span class="o">(</span><span class="kd">final</span> <span class="n">ScheduledFuture</span><span class="o">&lt;?&gt;</span> <span class="n">hndl</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">//...</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="cm">/* 反射方法</span>
</span><span class='line'><span class="cm"> * 使用方法简单示例：</span>
</span><span class='line'><span class="cm"> * Method meth = manager.makeReflective();</span>
</span><span class='line'><span class="cm"> * meth.invoke(hndl);</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">Method</span> <span class="nf">makeReflective</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">Method</span> <span class="n">method</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>      <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">argTypes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Class</span><span class="o">[]</span> <span class="o">{</span><span class="n">ScheduledFuture</span><span class="o">.</span><span class="na">class</span><span class="o">};</span>
</span><span class='line'>          <span class="n">method</span> <span class="o">=</span> <span class="n">ThreadPoolManager</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredMethod</span><span class="o">(</span><span class="s">&quot;cancel&quot;</span><span class="o">,</span> <span class="n">argTypes</span><span class="o">);</span>
</span><span class='line'>          <span class="n">method</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">IllegalArgumentException</span> <span class="o">|</span> <span class="n">NoSuchMethodException</span> <span class="o">|</span> <span class="n">SecurityException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="c1">//...</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      
</span><span class='line'>      <span class="k">return</span> <span class="n">method</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="cm">/* 代理方法</span>
</span><span class='line'><span class="cm"> *  使用方法简单示例：</span>
</span><span class='line'><span class="cm"> *  CancelProxy proxy = manager.makeProxy();</span>
</span><span class='line'><span class="cm"> *  proxy.invoke(manager, hndl);</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">CancelProxy</span> <span class="o">{</span>
</span><span class='line'>      <span class="kd">private</span> <span class="nf">CancelProxy</span><span class="o">()</span> <span class="o">{}</span>
</span><span class='line'>      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">ThreadPoolManager</span> <span class="n">mae</span><span class="o">,</span> <span class="n">ScheduledFuture</span><span class="o">&lt;?&gt;</span> <span class="n">hndl</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">mae</span><span class="o">.</span><span class="na">cancel</span><span class="o">(</span><span class="n">hndl</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="n">CancelProxy</span> <span class="nf">makeProxy</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="k">new</span> <span class="nf">CancelProxy</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="cm">/* 方法句柄</span>
</span><span class='line'><span class="cm"> * 使用方法简单示例：</span>
</span><span class='line'><span class="cm"> * MethodHandle mh = manager.makeMh();</span>
</span><span class='line'><span class="cm"> * mh.invokeExact(manager, hndl);</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">MethodHandle</span> <span class="nf">makeMh</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">MethodHandle</span> <span class="n">mh</span><span class="o">;</span>
</span><span class='line'>      <span class="n">MethodType</span> <span class="n">desc</span> <span class="o">=</span> <span class="n">MethodType</span><span class="o">.</span><span class="na">methodType</span><span class="o">(</span><span class="kt">void</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">ScheduledFuture</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>      <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">mh</span> <span class="o">=</span> <span class="n">MethodHandles</span><span class="o">.</span><span class="na">lookup</span><span class="o">().</span><span class="na">findVirtual</span><span class="o">(</span><span class="n">ThreadPoolManager</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">&quot;cancel&quot;</span><span class="o">,</span> <span class="n">desc</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">NoSuchMethodException</span> <span class="o">|</span> <span class="n">IllegalAccessException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="c1">//...</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      
</span><span class='line'>      <span class="k">return</span> <span class="n">mh</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>三种方法的比较：</p>

<table>
<thead>
<tr>
<th>方法 </th>
<th> 访问控制 </th>
<th> 类型纪律 </th>
<th> 性能  </th>
</tr>
</thead>
<tbody>
<tr>
<td>反射 </td>
<td> 必须使用setAccesible。会被安全管理器禁止 </td>
<td> 不匹配就抛异常 </td>
<td> 较慢</td>
</tr>
<tr>
<td>代理 </td>
<td> 内部类可以访问受限方法 </td>
<td> 静态，为了代理全部代理类，可能需要更多PermGen </td>
<td> 跟其他方法一样快</td>
</tr>
<tr>
<td>方法句柄 </td>
<td> 取决于上下文，与安全管理器没有冲突 </td>
<td> 运行时是类型安全的，不占用PermGen </td>
<td> 力求跟其他方法调用一样快</td>
</tr>
</tbody>
</table>


<p>方法句柄还有一个特性，可以在静态上下文中确定当前类。例如下面的代码改写了logger的创建方式，可以不用将类名写死：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="n">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">MyClass</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'><span class="c1">//可改为：</span>
</span><span class='line'><span class="n">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="n">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">MethodHandles</span><span class="o">.</span><span class="na">lookup</span><span class="o">().</span><span class="na">lookupClass</span><span class="o">());</span>
</span></code></pre></td></tr></table></div></figure>


<h2>3. 了解类文件</h2>

<p>有时候有必要查看类文件，但它是二进制文件，和它打交道并不容易。Oracle JVM的javap这个工具可以用来探视类文件内部和反编译。</p>

<p>我们以一个简单的Java类作为示例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Sample</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">byte</span> <span class="n">b</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">char</span> <span class="n">c</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">double</span> <span class="n">d</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">float</span> <span class="n">f</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">int</span> <span class="n">i</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="n">Integer</span> <span class="n">Int</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">long</span> <span class="n">l</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="n">String</span> <span class="n">s</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">bl</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">;</span>
</span><span class='line'>  
</span><span class='line'>  <span class="c1">//getter, setter</span>
</span></code></pre></td></tr></table></div></figure>


<h3>查看类文件的方法和属性</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">$</span> <span class="n">javap</span>  <span class="n">Sample</span><span class="o">.</span><span class="na">class</span>
</span><span class='line'><span class="n">Compiled</span> <span class="n">from</span> <span class="s">&quot;Sample.java&quot;</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">com</span><span class="o">.</span><span class="na">ubone</span><span class="o">.</span><span class="na">tdd</span><span class="o">.</span><span class="na">chapter1</span><span class="o">.</span><span class="na">javaio</span><span class="o">.</span><span class="na">Sample</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">com</span><span class="o">.</span><span class="na">ubone</span><span class="o">.</span><span class="na">tdd</span><span class="o">.</span><span class="na">chapter1</span><span class="o">.</span><span class="na">javaio</span><span class="o">.</span><span class="na">Sample</span><span class="o">();</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">byte</span> <span class="nf">getB</span><span class="o">();</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setB</span><span class="o">(</span><span class="kt">byte</span><span class="o">);</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">char</span> <span class="nf">getC</span><span class="o">();</span>
</span><span class='line'>  <span class="c1">//其它getter, setter方法...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>javap默认显示public, protected和包级protected级别的方法和属性。加上-p选项后可以显示private方法和属性。</p>

<h3>方法签名的内部形式</h3>

<p>JVM内部用的方法签名使用紧凑形式，例如int用I表示。这称为类型描述符：</p>

<ul>
<li>B: byte</li>
<li>C: char(16位Unicode字符)</li>
<li>D: double</li>
<li>F: float</li>
<li>I: int</li>
<li>J: long</li>
<li>L&lt;类型名称>: 引用类型，如：Ljava/lang/String</li>
<li>S: short</li>
<li>Z: boolean</li>
<li>[: array-of</li>
</ul>


<p>使用javap -s可以输出签名的类型描述符：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">$</span> <span class="n">javap</span> <span class="o">-</span><span class="n">s</span> <span class="n">Sample</span><span class="o">.</span><span class="na">class</span>
</span><span class='line'><span class="n">Compiled</span> <span class="n">from</span> <span class="s">&quot;Sample.java&quot;</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">com</span><span class="o">.</span><span class="na">ubone</span><span class="o">.</span><span class="na">tdd</span><span class="o">.</span><span class="na">chapter1</span><span class="o">.</span><span class="na">javaio</span><span class="o">.</span><span class="na">Sample</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">com</span><span class="o">.</span><span class="na">ubone</span><span class="o">.</span><span class="na">tdd</span><span class="o">.</span><span class="na">chapter1</span><span class="o">.</span><span class="na">javaio</span><span class="o">.</span><span class="na">Sample</span><span class="o">();</span>
</span><span class='line'>    <span class="nl">Signature:</span> <span class="o">()</span><span class="n">V</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">byte</span> <span class="nf">getB</span><span class="o">();</span>
</span><span class='line'>    <span class="nl">Signature:</span> <span class="o">()</span><span class="n">B</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setB</span><span class="o">(</span><span class="kt">byte</span><span class="o">);</span>
</span><span class='line'>    <span class="nl">Signature:</span> <span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="n">V</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">char</span> <span class="nf">getC</span><span class="o">();</span>
</span><span class='line'>    <span class="nl">Signature:</span> <span class="o">()</span><span class="n">C</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setC</span><span class="o">(</span><span class="kt">char</span><span class="o">);</span>
</span><span class='line'>    <span class="nl">Signature:</span> <span class="o">(</span><span class="n">C</span><span class="o">)</span><span class="n">V</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getD</span><span class="o">();</span>
</span><span class='line'>    <span class="nl">Signature:</span> <span class="o">()</span><span class="n">D</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setD</span><span class="o">(</span><span class="kt">double</span><span class="o">);</span>
</span><span class='line'>    <span class="nl">Signature:</span> <span class="o">(</span><span class="n">D</span><span class="o">)</span><span class="n">V</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">float</span> <span class="nf">getF</span><span class="o">();</span>
</span><span class='line'>    <span class="nl">Signature:</span> <span class="o">()</span><span class="n">F</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setF</span><span class="o">(</span><span class="kt">float</span><span class="o">);</span>
</span><span class='line'>    <span class="nl">Signature:</span> <span class="o">(</span><span class="n">F</span><span class="o">)</span><span class="n">V</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getI</span><span class="o">();</span>
</span><span class='line'>    <span class="nl">Signature:</span> <span class="o">()</span><span class="n">I</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setI</span><span class="o">(</span><span class="kt">int</span><span class="o">);</span>
</span><span class='line'>    <span class="nl">Signature:</span> <span class="o">(</span><span class="n">I</span><span class="o">)</span><span class="n">V</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Integer</span> <span class="nf">getInt</span><span class="o">();</span>
</span><span class='line'>    <span class="nl">Signature:</span> <span class="o">()</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Integer</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setInt</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Integer</span><span class="o">);</span>
</span><span class='line'>    <span class="nl">Signature:</span> <span class="o">(</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Integer</span><span class="o">;)</span><span class="n">V</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getL</span><span class="o">();</span>
</span><span class='line'>    <span class="nl">Signature:</span> <span class="o">()</span><span class="n">J</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setL</span><span class="o">(</span><span class="kt">long</span><span class="o">);</span>
</span><span class='line'>    <span class="nl">Signature:</span> <span class="o">(</span><span class="n">J</span><span class="o">)</span><span class="n">V</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="nf">getS</span><span class="o">();</span>
</span><span class='line'>    <span class="nl">Signature:</span> <span class="o">()</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">String</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setS</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">);</span>
</span><span class='line'>    <span class="nl">Signature:</span> <span class="o">(</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">String</span><span class="o">;)</span><span class="n">V</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isBl</span><span class="o">();</span>
</span><span class='line'>    <span class="nl">Signature:</span> <span class="o">()</span><span class="n">Z</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setBl</span><span class="o">(</span><span class="kt">boolean</span><span class="o">);</span>
</span><span class='line'>    <span class="nl">Signature:</span> <span class="o">(</span><span class="n">Z</span><span class="o">)</span><span class="n">V</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">getArray</span><span class="o">();</span>
</span><span class='line'>    <span class="nl">Signature:</span> <span class="o">()[</span><span class="n">I</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]);</span>
</span><span class='line'>    <span class="nl">Signature:</span> <span class="o">([</span><span class="n">I</span><span class="o">)</span><span class="n">V</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>常量池</h3>

<p>常量池是为类文件中的其他（常量）元素提供快捷访问方式的区域。通过javap -v可以查看常量池的信息：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Constant</span> <span class="nl">pool:</span>
</span><span class='line'>   <span class="err">#</span><span class="mi">1</span> <span class="o">=</span> <span class="n">Class</span>              <span class="err">#</span><span class="mi">2</span>             <span class="c1">//  com/ubone/tdd/chapter1/javaio/Sample</span>
</span><span class='line'>   <span class="err">#</span><span class="mi">2</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">com</span><span class="o">/</span><span class="n">ubone</span><span class="o">/</span><span class="n">tdd</span><span class="o">/</span><span class="n">chapter1</span><span class="o">/</span><span class="n">javaio</span><span class="o">/</span><span class="n">Sample</span>
</span><span class='line'>   <span class="err">#</span><span class="mi">3</span> <span class="o">=</span> <span class="n">Class</span>              <span class="err">#</span><span class="mi">4</span>             <span class="c1">//  java/lang/Object</span>
</span><span class='line'>   <span class="err">#</span><span class="mi">4</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">java</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Object</span>
</span><span class='line'>   <span class="err">#</span><span class="mi">5</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">b</span>
</span><span class='line'>   <span class="err">#</span><span class="mi">6</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">B</span>
</span><span class='line'>   <span class="err">#</span><span class="mi">7</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">c</span>
</span><span class='line'>   <span class="err">#</span><span class="mi">8</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">C</span>
</span><span class='line'>   <span class="err">#</span><span class="mi">9</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">d</span>
</span><span class='line'>  <span class="err">#</span><span class="mi">10</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">D</span>
</span><span class='line'>  <span class="err">#</span><span class="mi">11</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">f</span>
</span><span class='line'>  <span class="err">#</span><span class="mi">12</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">F</span>
</span><span class='line'>  <span class="err">#</span><span class="mi">13</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">i</span>
</span><span class='line'>  <span class="err">#</span><span class="mi">14</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">I</span>
</span><span class='line'>  <span class="err">#</span><span class="mi">15</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">Int</span>
</span><span class='line'>  <span class="err">#</span><span class="mi">16</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Integer</span><span class="o">;</span>
</span><span class='line'>  <span class="err">#</span><span class="mi">17</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">l</span>
</span><span class='line'>  <span class="err">#</span><span class="mi">18</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">J</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'>  <span class="err">#</span><span class="mi">70</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">getL</span>
</span><span class='line'>  <span class="err">#</span><span class="mi">71</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="o">()</span><span class="n">J</span>
</span><span class='line'>  <span class="err">#</span><span class="mi">72</span> <span class="o">=</span> <span class="n">Fieldref</span>           <span class="err">#</span><span class="mi">1</span><span class="o">.</span><span class="err">#</span><span class="mi">73</span>         <span class="c1">//  com/ubone/tdd/chapter1/javaio/Sample.l:J</span>
</span><span class='line'>  <span class="err">#</span><span class="mi">73</span> <span class="o">=</span> <span class="n">NameAndType</span>        <span class="err">#</span><span class="mi">17</span><span class="o">:</span><span class="err">#</span><span class="mi">18</span>        <span class="c1">//  l:J</span>
</span><span class='line'>  <span class="err">#</span><span class="mi">74</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">setL</span>
</span><span class='line'>  <span class="err">#</span><span class="mi">75</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="o">(</span><span class="n">J</span><span class="o">)</span><span class="n">V</span>
</span><span class='line'>  <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>如上所示，常量池的条目是带有类型的，它们还会相互引用。例如类型为Class的条目会引用类型为Utf8的条目。后者是个字符串，因此第1行为类的名称。</p>

<p>72行的Fieldref定义了一个域，解析这个域需要名称、类型和它所在的类。<code>#1.#73</code>表示来自类<code>#1</code>,域为<code>#73</code>。<code>#73</code>的NameAndType描述名称和类型，分别来自17和18，即类型J(Long)，名称为<code>l</code>。</p>

<h2>4. 字节码</h2>

<p>字节码的基本特性：</p>

<ul>
<li>字节码是程序的中间表示形式，介于人类可读的源码和机器码之间。</li>
<li>字节码由javac产生。</li>
<li>某些高级语言特性在编译时已经从字节码去掉。例如for语句在字节码中被转换成分支指令。</li>
<li>每个操作码都由一个字节表示（因此叫做字节码）。</li>
<li>字节码可以进一步编译成机器码，也就是“即时编译”。</li>
</ul>


<h3>反编译类</h3>

<p>javap可以用于反编译类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">$</span> <span class="n">javap</span> <span class="o">-</span><span class="n">c</span> <span class="o">-</span><span class="n">p</span> <span class="n">Sample</span><span class="o">.</span><span class="na">class</span>
</span><span class='line'><span class="n">Compiled</span> <span class="n">from</span> <span class="s">&quot;Sample.java&quot;</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">com</span><span class="o">.</span><span class="na">ubone</span><span class="o">.</span><span class="na">tdd</span><span class="o">.</span><span class="na">chapter1</span><span class="o">.</span><span class="na">javaio</span><span class="o">.</span><span class="na">Sample</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">byte</span> <span class="n">b</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">char</span> <span class="n">c</span><span class="o">;</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="n">com</span><span class="o">.</span><span class="na">ubone</span><span class="o">.</span><span class="na">tdd</span><span class="o">.</span><span class="na">chapter1</span><span class="o">.</span><span class="na">javaio</span><span class="o">.</span><span class="na">Sample</span><span class="o">();</span>
</span><span class='line'>    <span class="nl">Code:</span>
</span><span class='line'>       <span class="mi">0</span><span class="o">:</span> <span class="n">aload_0</span>
</span><span class='line'>       <span class="mi">1</span><span class="o">:</span> <span class="n">invokespecial</span> <span class="err">#</span><span class="mi">28</span>                 <span class="c1">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>
</span><span class='line'>       <span class="mi">4</span><span class="o">:</span> <span class="k">return</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getL</span><span class="o">();</span>
</span><span class='line'>    <span class="nl">Code:</span>
</span><span class='line'>       <span class="mi">0</span><span class="o">:</span> <span class="n">aload_0</span>
</span><span class='line'>       <span class="mi">1</span><span class="o">:</span> <span class="n">getfield</span>      <span class="err">#</span><span class="mi">72</span>                 <span class="c1">// Field l:J</span>
</span><span class='line'>       <span class="mi">4</span><span class="o">:</span> <span class="n">lreturn</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setL</span><span class="o">(</span><span class="kt">long</span><span class="o">);</span>
</span><span class='line'>    <span class="nl">Code:</span>
</span><span class='line'>       <span class="mi">0</span><span class="o">:</span> <span class="n">aload_0</span>
</span><span class='line'>       <span class="mi">1</span><span class="o">:</span> <span class="n">lload_1</span>
</span><span class='line'>       <span class="mi">2</span><span class="o">:</span> <span class="n">putfield</span>      <span class="err">#</span><span class="mi">72</span>                 <span class="c1">// Field l:J</span>
</span><span class='line'>       <span class="mi">5</span><span class="o">:</span> <span class="k">return</span>
</span></code></pre></td></tr></table></div></figure>


<p>代码前的数字表示从方法开始算起的字节码偏移量。先看构造方法，由于void构造方法总会隐式调用父类的构造方法。因此有invokespecial指令。对于方法getL()和setL()也可以看到相应的操作码和参数。</p>

<p>javac产生的字节码没有经过特别优化，是非常简单的表示形式。大部分优化工作由JIT编译器来完成。</p>

<h3>运行时环境</h3>

<p>JVM没有处理器寄存器，而是使用堆栈机完成所有的计算和操作，所以理解堆栈机的操作对理解字节码至关重要。方法在运行时需要一块内存区域作为计算堆栈来计算新值。另外，每个运行的线程都需要一个调用堆栈来记录当前正在执行的方法。来看下面的代码是如何完成计算的：</p>

<p><code>return 3 + petRecords.getNumberOfPets("Ben");</code></p>

<p>系统首先会把3压入操作数栈，然后把接收对象（petRecords）压入计算堆栈，传入的参数尾随其后。然后invoke操作符会调用方法getNumberOfPets，把控制权移交给被调用的方法。进入新方法后，需要启用不同的操作数栈，所以已经在调用者操作数栈中的值不可能影响被调用方法的计算结果。</p>

<p>当getNumberOfPets完成时，返回结果会被放到调用者的操作数栈中，进程中与getNumberOfPets相关的部分也会从调用堆栈中移走。然后相加运算得到结果。</p>

<h3>操作码</h3>

<p>JVM字节码由操作码（opcode）序列构成，每个指令后可能会跟一些参数。每个操作码由一个单字节值表示，所以最多有255个操作码。目前用了200个左右。大致可以分为以下几类，摘要说明如下：</p>

<blockquote><ul>
<li>参数：操作码参数。如果参数出现在括号中，表示可选。以i打头的参数用来作为常量池或局部变量中的查询索引的几个字节。如果有多个此类参数，会合并在一直。例如i1,i2表示从这两个字节生成一个16位的索引。</li>
<li>堆栈布局：展示栈在操作码执行前后的状态。</li>
<li>表中操作码并不全，只用于示例。</li>
</ul>
</blockquote>

<p>加载和储存操作码，这个族系负责将值加载到栈或者检索值。有很多不同形式的变体。如dload操作码把双精度数从局部变量加载到栈上。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-05-5-4.jpg" alt="image" /></p>

<p>数学运算操作码用来执行数学运算。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-05-5-5.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-05-5-6.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-05-5-7.jpg" alt="image" /></p>

<p><strong>平台操作操作码</strong></p>

<p>在字节码这一级，构造方法被转换成带有特殊名称<init>的方法。不能由用户代码调用，但可以由字节码调用。这便形成了一个与对象创建直接相关的不同的字节码模式：new之后跟着一个dup，然后是一个调用<init>方法的invokespecial.</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-05-5-8.jpg" alt="image" /></p>

<blockquote><p>为了节省字节，很多字节码都有快捷方式。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java并发编程(四)]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/01/javabing-fa-bian-cheng-si/"/>
    <updated>2014-12-01T22:43:50+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/01/javabing-fa-bian-cheng-si</id>
    <content type="html"><![CDATA[<p>在学习了《Java编程思想》中关于<a href="http://blog.ubone.com/blog/2014/09/02/javabing-fa-bian-cheng-san/">并发编程</a>的内容后，继续学习Java并发编程。</p>

<!--more-->


<h2>1. 常用的并发构件</h2>

<h3>为什么是synchronized?</h3>

<p>这个单词的意思是同步，那么Java中synchronized表示什么意思呢？其实就是同步被锁定对象的主内存块。</p>

<ul>
<li>当进入一个synchronized代码块时，持有锁的线程和被锁定对象主内存中的视图会进行同步。</li>
<li>当synchronized代码块执行完之后，被锁定对象所做的任何修改会在线程锁释放之前刷回到主内存中。</li>
</ul>


<p>而volatile变量，在使用之前总是会从主内存中再读出来。线程所写的值总会在指令完成之前被刷回到主内存中。volatile变量不会引入线程锁，是真正线程安全的。<strong>但只有写入时不依赖当前状态（读取的状态）的变量才应该声明为volatile变量。对于要关注当前状态的变量，只能借助线程锁保证绝对安全性。</strong></p>

<h3>Lock有什么好处？</h3>

<ul>
<li>添加不同类型的锁，比如读取锁和写入锁。</li>
<li>对锁的阻塞没有限制，即允许在一个方法中上锁，在另一个方法中解锁。</li>
<li>如果线程得不到锁，比如锁由另外一个线程持有，就允许该线程后退或继续执行，或者做点别的事情——运用tryLock()方法。</li>
<li>允许线程尝试取锁，并可以在超过等待时间后放弃。</li>
</ul>


<p>Lock接口的两个实现类：</p>

<ul>
<li>ReentranLock: 本质上与同步块一样，但更灵活些。</li>
<li>ReentranReadWriteLock: 在读多写入的时候，性能更好。</li>
</ul>


<h3>ConcurrentHashMap</h3>

<p>ConcurrentHashMap是HashMap的并发版本，改进了Collections.synchronizedMap()功能。它是concurrent包中最有用的类之一，不仅提供了多线程的安全性，而且性能更优。它提供了原子操作的新方法：</p>

<ul>
<li>putIfAbsent(): 如果没有对应键，则将键值对添加到HashMap中。</li>
<li>remove(): 如果键存在，且值与当前状态相等，则用原子方式移除键值对。</li>
<li>replace(): 当键存在时，进行原子替换。</li>
</ul>


<h3>CopyOnWriteArrayList</h3>

<p>它是标准ArrayList的替代品，通过copy-on-write来实现线程安全性，对修改列表的任何操作都会创建一个新复本。当快速、一致的数据快照（不同的读取器读到的数据偶尔可能会不一样）比完美的同步以及性能上的突破更重要时，这种共享数据的方法非常理想，经常出现在非关键任务中。</p>

<h3>Queue</h3>

<p>Java有些多线程编程模型在很大程度上依赖于Queue实现线程安全性。BlockingQueue是最简单的实现。向队列put()时，如果队列满则放入线程会等待。从队列take()时，如果队列空，则取出线程阻塞。</p>

<p>Queue接口全是泛型<code>Queue&lt;E&gt;</code>，利用这一点把工作项封装到一个人工容器中会更方便。例如工作单元MyAwesomeClass，与其用<code>BlockingQueue&lt;MyAwesomeClass&gt;</code>不如使用<code>BlockingQueue&lt;WorkUnit&lt;MyAwesomeClass&gt;&gt;</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">WorkUnit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">final</span> <span class="n">T</span> <span class="n">workUnit</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">T</span> <span class="nf">getWork</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">workUnit</span><span class="o">;}</span>
</span><span class='line'>  <span class="kd">public</span> <span class="nf">WorkUnit</span><span class="o">(</span><span class="n">T</span> <span class="n">workUnit</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">workUnit</span> <span class="o">=</span> <span class="n">workUnit</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>有了这层间接引用，可以添加额外的元数据而不用牺牲MyAwesomeClass的完整性。例如在WorkUnit中添加用于测试、性能指标和运行时系统信息等。</p>

<p>除了基本的put()和take()方法，BlockingQueue还提供了还超时的放入和取出方法：offer(E e, long timeout, TimeUnit unit)和poll(long timeout, TimeUnit unit)。</p>

<p>Java 7还引入了TransferQueue，本质上是多了transfer()操作的BlockingQueue。在BlockingQueue中，当上游线程池比下游快时，可能会引发一些问题，导致LinkedBlockingQueue溢出。反之，如果下游比上游快，则可能队列经常空着。TransferQueue可以优化这种情况，调控上/下游的速度。当消费线程在等待时，transfer()操作会马上把工作项传给它，否则就会阻塞直到取走工作项的线程出现。可以把这看做“挂号信”选项，即正在处理工作项的线程在交付当前工作项之前不会开始其他工作项的工作。</p>

<p>用TransferQueue取代BlockingQueue的代码性能可能会更好，因为前者的实现考虑了现代编译器和处理器的特性，执行效率更高。</p>

<h2>2. 控制执行</h2>

<p>如果每个工作单元都启动一个新线程执行，效率会太低。因此可以利用线程池来执行工作单元/任务。</p>

<h3>任务建模</h3>

<p>任务建模可以采用三种办法：Callable, Future接口和FutureTask类。</p>

<h4>Callable接口</h4>

<p>Callable接口代表一段可以调用并返回结果的代码，典型用法是匿名实现类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">final</span> <span class="n">MyObject</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyObject</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'><span class="n">Callable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">cb</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Callable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">String</span> <span class="nf">call</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="na">someMethod</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">cb</span><span class="o">.</span><span class="na">call</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Future接口</h4>

<p>Future接口用来表示异步任务。主要有三个方法：</p>

<ul>
<li>get()，获取结果，如果没执行完会阻塞，直到能取得结果。</li>
<li>cancel()，在结束前取消。</li>
<li>isDonw()，判断是否结束。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">interface</span> <span class="nc">ArchiveSearcher</span> <span class="o">{</span> <span class="n">String</span> <span class="n">search</span><span class="o">(</span><span class="n">String</span> <span class="n">target</span><span class="o">);</span> <span class="o">}</span>
</span><span class='line'> <span class="kd">class</span> <span class="nc">App</span> <span class="o">{</span>
</span><span class='line'>   <span class="n">ExecutorService</span> <span class="n">executor</span> <span class="o">=</span> <span class="o">...</span>
</span><span class='line'>   <span class="n">ArchiveSearcher</span> <span class="n">searcher</span> <span class="o">=</span> <span class="o">...</span>
</span><span class='line'>   <span class="kt">void</span> <span class="nf">showSearch</span><span class="o">(</span><span class="kd">final</span> <span class="n">String</span> <span class="n">target</span><span class="o">)</span>
</span><span class='line'>       <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class='line'>     <span class="n">Future</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">future</span>
</span><span class='line'>       <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="k">new</span> <span class="n">Callable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
</span><span class='line'>         <span class="kd">public</span> <span class="n">String</span> <span class="nf">call</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>             <span class="k">return</span> <span class="n">searcher</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
</span><span class='line'>         <span class="o">}});</span>
</span><span class='line'>     <span class="n">displayOtherThings</span><span class="o">();</span> <span class="c1">// do other things while searching</span>
</span><span class='line'>     <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>       <span class="n">displayText</span><span class="o">(</span><span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">());</span> <span class="c1">// use future</span>
</span><span class='line'>     <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ExecutionException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span> <span class="n">cleanup</span><span class="o">();</span> <span class="k">return</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'>   <span class="o">}</span>
</span><span class='line'> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>FutureTask类</h4>

<p>FutureTask类是Future接口的常用实现类，实现了Runnable接口，因此可以由执行者调度。它提供的方法基本是Future和Runnable接口的组合：get(), cancel(), isDone(), isCancelled()和run()。它还提供了两个很方便的构造器：一个以Callable为参数，另一个以Runnable为参数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">FutureTask</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span>
</span><span class='line'>       <span class="k">new</span> <span class="n">FutureTask</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;(</span><span class="k">new</span> <span class="n">Callable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
</span><span class='line'>         <span class="kd">public</span> <span class="n">String</span> <span class="nf">call</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>           <span class="k">return</span> <span class="n">searcher</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
</span><span class='line'>       <span class="o">}});</span>
</span><span class='line'><span class="n">executor</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">future</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>ScheduledThreadPoolExecutor(STPE)</h3>

<p>STPE是Executors类工厂方法的众多执行者之一。它有以下特点：</p>

<ul>
<li>可以预定线程池大小，也可自适应</li>
<li>所安排的任务可以定期执行，也可只运行一次。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">ScheduledExecutorService</span> <span class="n">stpe</span> <span class="o">=</span> <span class="n">Executors</span><span class="o">.</span><span class="na">newScheduledThreadPool</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="kd">final</span> <span class="n">Runnable</span> <span class="n">msgReader</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">//...</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//每10毫秒唤醒一个线程。该线程可以尝试poll一个队列...</span>
</span><span class='line'><span class="n">ScheduledFuture</span><span class="o">&lt;?&gt;</span> <span class="n">hndl</span> <span class="o">=</span> <span class="n">stpe</span><span class="o">.</span><span class="na">scheduleAtFixedRate</span><span class="o">(</span><span class="n">msgReader</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>3.分支/合并框架</h2>

<p>这是Java 7重点突出的框架之一，用于轻量级并发，实现线程池中任务的自动调度。</p>

<p>先来看看之前的并发算法可能存在的问题。如果某个线程的运行队列都是小任务，而另一个全是大任务。那么小任务的线程可能会空闲很多。而基于Work-Stealing（工作窃取）算法的ForkJoin则可以很好地解决此问题。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-02-fork-join.GIF" alt="image" /></p>

<ul>
<li>分支/合并框架引入一种新的执行者服务，称为ForkJoinPool</li>
<li>ForkJoinPool处理比线程更小的并发单元ForkJoinTask</li>
<li>ForkJoinTask是一种由ForkJoinPool以更轻量化的方式所调度的抽象</li>
<li>通常使用两种任务（尽管都表示为ForkJoinTask实例）：“小型”任务是无需耗费太多时间就可以直接执行的任务；“大型”任务是需要分解（可能多次分解）后再执行的任务。</li>
</ul>


<p>这个框架的关键特性之一就是这些轻量的任务都能生成新的ForkJoinTask实例，而这些实例将仍由执行它们父任务的线程池来安排调度。这就是分而治之。例如在归并算法中，就可以将左侧、右侧的排序任务视为一个ForkJoinTask，在递归过程中，不断产生小型任务执行。下面的示例是一个对微博按时间归并排序的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">//RecursiveAction继承自ForkJoinTask&lt;Void&gt;</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MicroBlogUpdateSorter</span> <span class="kd">extends</span> <span class="n">RecursiveAction</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SMALL_ENOUGH</span> <span class="o">=</span> <span class="mi">32</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Update</span><span class="o">[]</span> <span class="n">updates</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Update</span><span class="o">[]</span> <span class="n">result</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="nf">MicroBlogUpdateSorter</span><span class="o">(</span><span class="n">Update</span><span class="o">[]</span> <span class="n">updates_</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">this</span><span class="o">(</span><span class="n">updates_</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">updates_</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="nf">MicroBlogUpdateSorter</span><span class="o">(</span><span class="n">Update</span><span class="o">[]</span> <span class="n">upds_</span><span class="o">,</span> <span class="kt">int</span> <span class="n">startPos_</span><span class="o">,</span> <span class="kt">int</span> <span class="n">endPos_</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">start</span> <span class="o">=</span> <span class="n">startPos_</span><span class="o">;</span>
</span><span class='line'>    <span class="n">end</span> <span class="o">=</span> <span class="n">endPos_</span><span class="o">;</span>
</span><span class='line'>    <span class="n">updates</span> <span class="o">=</span> <span class="n">upds_</span><span class="o">;</span>
</span><span class='line'>    <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Update</span><span class="o">[</span><span class="n">updates</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="n">MicroBlogUpdateSorter</span> <span class="n">left_</span><span class="o">,</span> <span class="n">MicroBlogUpdateSorter</span> <span class="n">right_</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">lCt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">rCt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="k">while</span> <span class="o">(</span><span class="n">lCt</span> <span class="o">&lt;</span> <span class="n">left_</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">rCt</span> <span class="o">&lt;</span> <span class="n">right_</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">++]</span> <span class="o">=</span> <span class="o">(</span><span class="n">left_</span><span class="o">.</span><span class="na">result</span><span class="o">[</span><span class="n">lCt</span><span class="o">].</span><span class="na">compareTo</span><span class="o">(</span><span class="n">right_</span><span class="o">.</span><span class="na">result</span><span class="o">[</span><span class="n">rCt</span><span class="o">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">left_</span><span class="o">.</span><span class="na">result</span><span class="o">[</span><span class="n">lCt</span><span class="o">++]</span>
</span><span class='line'>          <span class="o">:</span> <span class="n">right_</span><span class="o">.</span><span class="na">result</span><span class="o">[</span><span class="n">rCt</span><span class="o">++];</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">while</span> <span class="o">(</span><span class="n">lCt</span> <span class="o">&lt;</span> <span class="n">left_</span><span class="o">.</span><span class="na">size</span><span class="o">())</span>
</span><span class='line'>      <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">++]</span> <span class="o">=</span> <span class="n">left_</span><span class="o">.</span><span class="na">result</span><span class="o">[</span><span class="n">lCt</span><span class="o">++];</span>
</span><span class='line'>    <span class="k">while</span> <span class="o">(</span><span class="n">rCt</span> <span class="o">&lt;</span> <span class="n">right_</span><span class="o">.</span><span class="na">size</span><span class="o">())</span>
</span><span class='line'>      <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">++]</span> <span class="o">=</span> <span class="n">right_</span><span class="o">.</span><span class="na">result</span><span class="o">[</span><span class="n">rCt</span><span class="o">++];</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="n">Update</span><span class="o">[]</span> <span class="nf">getResult</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">compute</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">//如果数组太小，就用系统排序</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">size</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">SMALL_ENOUGH</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">updates</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">result</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">size</span><span class="o">());</span>
</span><span class='line'>      <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">size</span><span class="o">());</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">size</span><span class="o">()</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
</span><span class='line'>      <span class="n">MicroBlogUpdateSorter</span> <span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MicroBlogUpdateSorter</span><span class="o">(</span><span class="n">updates</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span>
</span><span class='line'>          <span class="n">start</span> <span class="o">+</span> <span class="n">mid</span><span class="o">);</span>
</span><span class='line'>      <span class="n">MicroBlogUpdateSorter</span> <span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MicroBlogUpdateSorter</span><span class="o">(</span><span class="n">updates</span><span class="o">,</span> <span class="n">start</span>
</span><span class='line'>          <span class="o">+</span> <span class="n">mid</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
</span><span class='line'>      <span class="n">invokeAll</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
</span><span class='line'>      <span class="n">merge</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">List</span><span class="o">&lt;</span><span class="n">Update</span><span class="o">&gt;</span> <span class="n">lu</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Update</span><span class="o">&gt;();</span>
</span><span class='line'>    <span class="n">String</span> <span class="n">text</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">final</span> <span class="n">Update</span><span class="o">.</span><span class="na">Builder</span> <span class="n">ub</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Update</span><span class="o">.</span><span class="na">Builder</span><span class="o">();</span>
</span><span class='line'>    <span class="kd">final</span> <span class="n">Author</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Author</span><span class="o">(</span><span class="s">&quot;Tallulah&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">text</span> <span class="o">=</span> <span class="n">text</span> <span class="o">+</span> <span class="s">&quot;X&quot;</span><span class="o">;</span>
</span><span class='line'>      <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
</span><span class='line'>      <span class="n">lu</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">ub</span><span class="o">.</span><span class="na">author</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="na">updateText</span><span class="o">(</span><span class="n">text</span><span class="o">).</span><span class="na">createTime</span><span class="o">(</span><span class="n">now</span><span class="o">).</span><span class="na">build</span><span class="o">());</span>
</span><span class='line'>      <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">Collections</span><span class="o">.</span><span class="na">shuffle</span><span class="o">(</span><span class="n">lu</span><span class="o">);</span>
</span><span class='line'>    <span class="n">Update</span><span class="o">[]</span> <span class="n">updates</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="n">Update</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span> <span class="c1">// Avoid allocation by passing</span>
</span><span class='line'>                                                  <span class="c1">// zero-sized array</span>
</span><span class='line'>    <span class="n">MicroBlogUpdateSorter</span> <span class="n">sorter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MicroBlogUpdateSorter</span><span class="o">(</span><span class="n">updates</span><span class="o">);</span>
</span><span class='line'>    <span class="n">ForkJoinPool</span> <span class="n">pool</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ForkJoinPool</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
</span><span class='line'>    <span class="n">pool</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">sorter</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="n">Update</span> <span class="n">u</span> <span class="o">:</span> <span class="n">sorter</span><span class="o">.</span><span class="na">getResult</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">u</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果下面这些问题答案是肯定的，那么就适合于使用分支/合并框架：</p>

<ul>
<li>问题的子任务是否无需与其他子任务有显式的协作或同步也可以工作？</li>
<li>子任务是不是不会对数据进行修改，只是经过计算得出结果？</li>
<li>对于子任务来说，分而治之是不是很自然的事？子任务是不是会创建更多的子任务，而且它们要比派生出它们的任务粒度更细？</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java NIO.2]]></title>
    <link href="http://blog.ubone.com/blog/2014/11/23/java-nio-dot-2/"/>
    <updated>2014-11-23T10:59:37+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/11/23/java-nio-dot-2</id>
    <content type="html"><![CDATA[<p>Java 7提供了新的NIO(或称为NIO.2, JSR-203)，这是一组新的类和方法，用于取代File类与文件系统的交互，提供新的异步处理类并简化Socket与通道的编码工作。</p>

<!--more-->


<p>在Java 1.4之前，Java缺乏对非阻塞I/O的支持，1.4引入了非阻塞I/O，为I/O操作抽象出缓冲区和通道层；提供字符集的编码和解码能力；能够将文件映射为内存数据；实现正则表达式。Java 7进一步扩展了NIO的能力。</p>

<h2>1. PATH</h2>

<p>Path相关的类包括：</p>

<ul>
<li>Path：获取路径信息</li>
<li>Paths：工具类，提供返回一个路径的辅助方法</li>
<li>FileSystem：与文件系统交互的类</li>
<li>FileSystems：工具类，提供各种方法。</li>
</ul>


<p>Path不仅用于传统的文件系统，也能表示zip或jar这样的文件系统。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">//创建Path</span>
</span><span class='line'><span class="n">Path</span> <span class="n">listing</span> <span class="o">=</span> <span class="n">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;/user/bin/zip&quot;</span><span class="o">)</span><span class="err">；</span>
</span><span class='line'><span class="c1">//相当于</span>
</span><span class='line'><span class="n">Path</span> <span class="n">listing</span> <span class="o">=</span> <span class="n">FileSystems</span><span class="o">.</span><span class="na">getDefault</span><span class="o">().</span><span class="na">getPath</span><span class="o">(</span><span class="s">&quot;/user/bin/zip&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//获取Path信息：</span>
</span><span class='line'><span class="n">listing</span><span class="o">.</span><span class="na">getFileName</span><span class="o">():</span> <span class="n">zip</span>
</span><span class='line'><span class="n">listing</span><span class="o">.</span><span class="na">getNameCount</span><span class="o">():</span> <span class="mi">3</span>
</span><span class='line'><span class="n">listing</span><span class="o">.</span><span class="na">subpath</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">):</span> <span class="o">/</span><span class="n">user</span><span class="o">/</span><span class="n">bin</span>
</span><span class='line'><span class="n">listing</span><span class="o">.</span><span class="na">getParent</span><span class="o">():</span> <span class="o">/</span><span class="n">user</span><span class="o">/</span><span class="n">bin</span>
</span><span class='line'><span class="n">listing</span><span class="o">.</span><span class="na">getRoot</span><span class="o">():</span> <span class="o">/</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果Path是一个文件的路径，有时需要去除冗余信息。例如去除表示当前路径的<code>./</code>，或者该文件只是个符号链接，指向了另一个真正的位置，此时需要得到真实路径。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">//移除冗余</span>
</span><span class='line'><span class="n">Path</span> <span class="n">testPath</span> <span class="o">=</span> <span class="n">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;./test.java&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">Path</span> <span class="n">normalizedPath</span> <span class="o">=</span> <span class="n">testPath</span><span class="o">.</span><span class="na">normalize</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//获取绝对路径</span>
</span><span class='line'><span class="n">Path</span> <span class="n">absolutePath</span> <span class="o">=</span> <span class="n">testPath</span><span class="o">.</span><span class="na">toAbsolutePath</span><span class="o">();</span>
</span><span class='line'><span class="c1">//获取绝对路径并去除冗余信息，或者获取符号连接的真实路径</span>
</span><span class='line'><span class="n">Path</span> <span class="n">realPath</span> <span class="o">=</span> <span class="n">testPath</span><span class="o">.</span><span class="na">toRealPath</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>合并路径与路径比较。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">//合并</span>
</span><span class='line'><span class="n">Path</span> <span class="n">prefix</span> <span class="o">=</span> <span class="n">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;/usr&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">Path</span> <span class="n">completePath</span> <span class="o">=</span> <span class="n">prefix</span><span class="o">.</span><span class="na">resolve</span><span class="o">(</span><span class="s">&quot;mxs&quot;</span><span class="o">);</span>
</span><span class='line'><span class="c1">//completePath: /usr/mxs</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//比较</span>
</span><span class='line'><span class="n">Path</span> <span class="n">path1</span> <span class="o">=</span> <span class="n">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;/Users/mxs/Documents/Blog/&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">Path</span> <span class="n">path2</span> <span class="o">=</span> <span class="n">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;/Users/mxs&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">path1</span><span class="o">.</span><span class="na">relativize</span><span class="o">(</span><span class="n">path2</span><span class="o">):</span> <span class="o">../..</span>
</span><span class='line'><span class="n">path2</span><span class="o">.</span><span class="na">relativize</span><span class="o">(</span><span class="n">path1</span><span class="o">):</span> <span class="n">Documents</span><span class="o">/</span><span class="n">Blog</span>
</span></code></pre></td></tr></table></div></figure>


<p>新的API完全替换了java.io.File类，在处理遗留代码时，可能将其进行互换：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">&quot;../abcd.txt&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">Path</span> <span class="n">listing</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="na">toPath</span><span class="o">();</span>
</span><span class='line'><span class="n">file</span> <span class="o">=</span> <span class="n">listing</span><span class="o">.</span><span class="na">toFile</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<h2>2. 处理目录与目录树</h2>

<p>新的DirectoryStream<T>接口实现了目录相关的操作：</p>

<ul>
<li>循环遍历目录中的子项</li>
<li>用glob表达式（如<code>*Foobar*</code>）进行目录子项的匹配和MIME内容检测（如text/xml文件）</li>
<li>用walkFileTree实现递归移动、复制和删除操作</li>
</ul>


<p><strong>在目录中查找文件：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Path</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;/user/mxs/Documents&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">try</span><span class="o">(</span><span class="n">DirectoryStream</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">Files</span><span class="o">.</span><span class="na">newDirectoryStream</span><span class="o">(</span><span class="n">dir</span><span class="o">,</span> <span class="s">&quot;*.properties&quot;</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">for</span><span class="o">(</span><span class="n">Path</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">stream</span><span class="o">){</span>
</span><span class='line'>      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getFileName</span><span class="o">());</span>   
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">//...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>遍历目录树。</strong>Files.walkFileTree方法是遍历目录树的关键，该方法定义如下：</p>

<p><code>Files.walkFileTree(Path startingDir, FileVisitor&lt;? super Path&gt; visitor);
</code></p>

<p>其中Visitor是一个接口，包括5个方法，但一般使用Java的默认实现SimpleFileVisitor就可以了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">walk</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">Path</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;/code/src&quot;</span><span class="o">);</span>
</span><span class='line'>  <span class="n">Files</span><span class="o">.</span><span class="na">walkFileTree</span><span class="o">(</span><span class="n">dir</span><span class="o">,</span> <span class="k">new</span> <span class="n">FindJavaVisitor</span><span class="o">());</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">FindJavaVisitor</span> <span class="kd">extends</span> <span class="n">SimpleFileVisitor</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">FileVisitresult</span> <span class="nf">visitFile</span><span class="o">(</span><span class="n">Path</span> <span class="n">file</span><span class="o">,</span> <span class="n">BasicFileAttributes</span> <span class="n">attrs</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">endsWith</span><span class="o">(</span><span class="s">&quot;.java&quot;</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>          <span class="c1">//...</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      
</span><span class='line'>      <span class="k">return</span> <span class="n">FileVisitResult</span><span class="o">.</span><span class="na">CONTINUE</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是，walkFileTree方法不会自动跟随符号链接（为了确保递归等操作的安全性）。因此如果你需要跟随符号链接，就需要检查相应属性并执行相应操作。</p>

<h2>3. 文件系统I/O</h2>

<p>在NIO.2中，Files和WatchService是两个重要的基础类。前者用于复制、移动、删除或处理文件，后者用于监视文件或目录，发出定制通知等。</p>

<h3>3.1 创建和删除文件</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Path</span> <span class="n">target</span> <span class="o">=</span> <span class="n">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;/Users/mxs/Document/mystuff.txt&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">Path</span> <span class="n">file</span> <span class="o">=</span> <span class="n">Files</span><span class="o">.</span><span class="na">createFile</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果需要设置文件属性，如读、写和执行的权限，则需要设置FileAttribute，但文件属性与操作系统相关，因此要使用与操作系统相关的文件权限类。以下是POSIX文件系统的示例(其它文件系统参考java.nio.file.attribute.*FilePermission类)：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Set</span><span class="o">&lt;</span><span class="n">PosixFilePermission</span><span class="o">&gt;</span> <span class="n">perms</span> <span class="o">=</span> <span class="n">PosixFilePermissions</span><span class="o">.</span><span class="na">fromString</span><span class="o">(</span><span class="s">&quot;rw-rw-rw-&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">FileAttribute</span><span class="o">&lt;</span><span class="n">Set</span><span class="o">&lt;</span><span class="n">PosixFilePermission</span><span class="o">&gt;&gt;</span> <span class="n">attr</span> <span class="o">=</span> <span class="n">PosixFilePermissions</span><span class="o">.</span><span class="na">asFileAttribute</span><span class="o">(</span><span class="n">perms</span><span class="o">);</span>
</span><span class='line'><span class="n">Files</span><span class="o">.</span><span class="na">createFile</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="n">attr</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>删除文件只需要调用<code>Files.delete(target)</code>方法。</p>

<h3>3.2 文件复制与移动</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Path</span> <span class="n">source</span> <span class="o">=</span> <span class="n">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;c:\\My Documents\\stuff.txt&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">Path</span> <span class="n">target</span> <span class="o">=</span> <span class="n">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;D:\backup\stuff.txt&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">Files</span><span class="o">.</span><span class="na">copy</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">target</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//复制时还可以设置CopyOptions选项（变参，可多个。ATOMIC_MOVE确保两边都成功，否则回滚）</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">static</span> <span class="n">java</span><span class="o">.</span><span class="na">nio</span><span class="o">.</span><span class="na">file</span><span class="o">.</span><span class="na">StandardCopyOption</span><span class="o">.*;</span>
</span><span class='line'><span class="n">Files</span><span class="o">.</span><span class="na">copy</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">target</span><span class="o">,</span> <span class="n">REPLACE_EXISTING</span><span class="o">,</span> <span class="n">COPY_ATTRIBUTES</span><span class="o">,</span> <span class="n">ATOMIC_MOVE</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//移动</span>
</span><span class='line'><span class="n">Files</span><span class="o">.</span><span class="na">move</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">target</span><span class="o">);</span>
</span><span class='line'><span class="n">Files</span><span class="o">.</span><span class="na">move</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">target</span><span class="o">,</span> <span class="n">CopyOptions</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3.3 文件属性</h3>

<p>由于不同的文件系统属性不同，因此Java中的文件属性分为基本文件属性、特定文件属性。前者是各文件系统通用的文件属性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Path</span> <span class="n">zip</span> <span class="o">=</span> <span class="n">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;/usr/bin/zip&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">Files</span><span class="o">.</span><span class="na">getLastModifiedTime</span><span class="o">(</span><span class="n">zip</span><span class="o">);</span>
</span><span class='line'><span class="n">Files</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="n">zip</span><span class="o">);</span>
</span><span class='line'><span class="n">Files</span><span class="o">.</span><span class="na">isSymbolicLink</span><span class="o">(</span><span class="n">zip</span><span class="o">);</span>
</span><span class='line'><span class="n">Files</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">(</span><span class="n">zip</span><span class="o">);</span>
</span><span class='line'><span class="n">Files</span><span class="o">.</span><span class="na">readAttributes</span><span class="o">(</span><span class="n">zip</span><span class="o">,</span> <span class="s">&quot;*&quot;</span><span class="o">);</span> <span class="c1">//批量读取属性</span>
</span></code></pre></td></tr></table></div></figure>


<p>特定文件属性独立于某个操作系统。以POSIX文件系统为例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">//获取文件属性</span>
</span><span class='line'><span class="n">PosixFileAttributes</span> <span class="n">attrs</span> <span class="o">=</span> <span class="n">Files</span><span class="o">.</span><span class="na">readAttributes</span><span class="o">(</span><span class="n">zip</span><span class="o">,</span> <span class="n">PosixFileAttributes</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//修改属性</span>
</span><span class='line'><span class="n">Set</span><span class="o">&lt;</span><span class="n">PosixFilePermission</span><span class="o">&gt;</span> <span class="n">permissions</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="na">permissions</span><span class="o">();</span>
</span><span class='line'><span class="n">permissions</span><span class="o">.</span><span class="na">clear</span><span class="o">;</span>
</span><span class='line'><span class="n">permissions</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">GROUP_READ</span><span class="o">);</span>
</span><span class='line'><span class="c1">//...</span>
</span><span class='line'><span class="n">Files</span><span class="o">.</span><span class="na">setPosixFilePermissions</span><span class="o">(</span><span class="n">zip</span><span class="o">,</span> <span class="n">permissions</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>符号链接的处理：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Path</span> <span class="n">file</span> <span class="o">=</span> <span class="n">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;/opt/platform/java&quot;</span><span class="o">);</span>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">Files</span><span class="o">.</span><span class="na">isSymbolicLink</span><span class="o">(</span><span class="n">file</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">file</span> <span class="o">=</span> <span class="n">Files</span><span class="o">.</span><span class="na">readSymbolicLink</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="c1">//继续处理文件相关操作</span>
</span><span class='line'><span class="n">Files</span><span class="o">.</span><span class="na">readAttributes</span><span class="o">(</span><span class="n">file</span><span class="o">,</span> <span class="n">BasicFileAttributes</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3.4. 快速读写数据</h3>

<p>Files工具类提供了更方便的方法来读写数据：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Path</span> <span class="n">logFile</span> <span class="o">=</span> <span class="n">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;/tmp/app.log&quot;</span><span class="o">);</span>
</span><span class='line'><span class="k">try</span><span class="o">(</span><span class="n">BufferedReader</span> <span class="n">reader</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">Files</span><span class="o">.</span><span class="na">newBufferedReader</span><span class="o">(</span><span class="n">logFile</span><span class="o">,</span> <span class="n">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">String</span> <span class="n">line</span><span class="o">;</span>
</span><span class='line'>  <span class="k">while</span><span class="o">((</span><span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">//...</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//写入</span>
</span><span class='line'><span class="k">try</span><span class="o">(</span><span class="n">BufferedWriter</span> <span class="n">writer</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">Files</span><span class="o">.</span><span class="na">newBufferedWrite</span><span class="o">(</span><span class="n">logFile</span><span class="o">,</span> <span class="n">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">,</span> <span class="n">StandardOpenOption</span><span class="o">.</span><span class="na">WRITE</span><span class="o">))</span> <span class="c1">//变参，可多个</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>  <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">&quot;Hello!&quot;</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Files工具类提供的方法还有<code>newInputStream()</code>, <code>newOutputStream()</code>等方法，用于配合现有IO类。还有更方便的方式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">Files</span><span class="o">.</span><span class="na">readAllLines</span><span class="o">(</span><span class="n">logFile</span><span class="o">,</span> <span class="n">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
</span><span class='line'><span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">Files</span><span class="o">.</span><span class="na">readAllBytes</span><span class="o">(</span><span class="n">logFile</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3.5. 文件修改通知</h3>

<p>WatchService可用于监测文件或目录的变化，可监测的事件包括：ENTRY_CREATE, ENTRY_DELETE, OVERFLOW(事件已经丢弃或丢失)。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">import</span> <span class="nn">static</span> <span class="n">java</span><span class="o">.</span><span class="na">nio</span><span class="o">.</span><span class="na">file</span><span class="o">.</span><span class="na">StandardWatchEventKinds</span><span class="o">.*;</span>
</span><span class='line'>
</span><span class='line'><span class="k">try</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">WatchService</span> <span class="n">watcher</span> <span class="o">=</span> <span class="n">FileSystems</span><span class="o">.</span><span class="na">getDefault</span><span class="o">().</span><span class="na">newWatchService</span><span class="o">();</span>
</span><span class='line'>  <span class="n">Path</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">FileSystems</span><span class="o">.</span><span class="na">getDefault</span><span class="o">().</span><span class="na">getPath</span><span class="o">(</span><span class="s">&quot;/usr/mxs&quot;</span><span class="o">);</span>
</span><span class='line'>  <span class="n">WatchKey</span> <span class="n">key</span> <span class="o">=</span> <span class="n">dir</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">watcher</span><span class="o">,</span> <span class="n">ENTRY_MODIFY</span><span class="o">);</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">while</span><span class="o">(!</span><span class="n">shutdown</span> <span class="o">)</span> <span class="o">{</span> <span class="c1">//一个标志，判断循环是否该结束</span>
</span><span class='line'>      <span class="n">key</span> <span class="o">=</span> <span class="n">watcher</span><span class="o">.</span><span class="na">take</span><span class="o">();</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="n">WatchEvent</span><span class="o">&lt;?&gt;</span> <span class="nl">event:</span> <span class="n">key</span><span class="o">.</span><span class="na">pollEvents</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">if</span> <span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">kind</span><span class="o">()</span> <span class="o">==</span> <span class="n">ENTRY_MODIFY</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>              <span class="c1">//dir changed</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="n">key</span><span class="o">.</span><span class="na">reset</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">IOException</span> <span class="o">|</span> <span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">//...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3.6 SeekableByteChannel</h3>

<p>这是Java 7引入的新接口，用于改变字节通道的位置和大小。例如用多个线程去分析一个大型日志文件的字节通道。FileChannel是这个接口的一种实现，下面的示例读取日志文件的最后1000个字符：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Path</span> <span class="n">logFile</span> <span class="o">=</span> <span class="n">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;c:\\temp.log&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">ByteBuffer</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="mi">1024</span><span class="o">);</span>
</span><span class='line'><span class="n">FileChannel</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">FileChannel</span><span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="n">logFile</span><span class="o">,</span> <span class="n">StandardOpenOption</span><span class="o">.</span><span class="na">READ</span><span class="o">);</span>
</span><span class='line'><span class="n">channel</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="n">channel</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1000</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>4. 异步I/O操作</h2>

<p>异步I/O操作主要有两种方式：Future和回调。Java 7提供了三个新的异步通道：</p>

<ul>
<li>AsynchronousFileChannel 用于文件I/O</li>
<li>AsynchronousSocketChannel 用于Socket I/O, 支持超时</li>
<li>AsynchronousServerSocketChannel 用于Socket接受异步连接</li>
</ul>


<h3>4.1 Future方式</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">try</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">Path</span> <span class="n">file</span> <span class="o">=</span> <span class="n">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;/usr/mxs/foobar.txt&quot;</span><span class="o">);</span>
</span><span class='line'>  <span class="n">AsynchronousFileChannel</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">AsynchronousFileChannel</span><span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
</span><span class='line'>  
</span><span class='line'>  <span class="c1">//读取100 000字节</span>
</span><span class='line'>  <span class="n">ByteBuffer</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="mi">100</span><span class="n">_1000</span><span class="o">);</span>
</span><span class='line'>  <span class="n">Future</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span><span class="c1">//返回值为Integer</span>
</span><span class='line'>  
</span><span class='line'>  <span class="c1">//如果未结束</span>
</span><span class='line'>  <span class="k">while</span><span class="o">(!</span> <span class="n">result</span><span class="o">.</span><span class="na">isDone</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">//...干点别的事。</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="c1">//获取结果</span>
</span><span class='line'>  <span class="n">Integer</span> <span class="n">byteRead</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">IOException</span> <span class="o">|</span> <span class="n">ExecutionException</span> <span class="o">|</span> <span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">//...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>4.2 回调方式</h3>

<p>CompletionHandler&lt;V, A>是回调的接口。V表示结果类型，A是提供结果的附着对象。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">try</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">Path</span> <span class="n">file</span> <span class="o">=</span> <span class="n">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;/usr/mxs/foobar.txt&quot;</span><span class="o">);</span>
</span><span class='line'>  <span class="n">AsynchronousFileChannel</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">AsynchronousFileChannel</span><span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
</span><span class='line'>  <span class="c1">//读取100 000字节</span>
</span><span class='line'>  <span class="n">ByteBuffer</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="mi">100</span><span class="n">_1000</span><span class="o">);</span>
</span><span class='line'>  
</span><span class='line'>  <span class="n">channel</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">buffer</span><span class="o">,</span> <span class="k">new</span> <span class="n">CompletionHandler</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">ByteBuffer</span><span class="o">&gt;(){</span>
</span><span class='line'>      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">completed</span><span class="o">(</span><span class="n">Integer</span> <span class="n">result</span><span class="o">,</span> <span class="n">ByteBuffer</span> <span class="n">attachment</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="c1">//完成时的回调方法</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      
</span><span class='line'>      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">failed</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">exception</span><span class="o">,</span> <span class="n">ByteBuffer</span> <span class="n">attachment</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="c1">//失败时的回调方法</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">});</span>
</span><span class='line'><span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">//...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>5. Socket与Channel整合</h2>

<p>NetworkChannel把Socket和Channel结合起来，更好地应对网络编程。而MulticastChannel则可以用于像BitTorrent这样的多播编程。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 7的6个新特性]]></title>
    <link href="http://blog.ubone.com/blog/2014/11/18/java-7de-6ge-xin-te-xing/"/>
    <updated>2014-11-18T22:20:52+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/11/18/java-7de-6ge-xin-te-xing</id>
    <content type="html"><![CDATA[<p>Java 8早都出来了，现在来了解一下Java 7语言上的几个新特性。 :) switch语句支持String、数字常量的新形式、改进的异常处理、TWR语句、钻石语法和变参警告位置的修改。</p>

<!--more-->


<h2>1. switch语句支持String</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">printDay</span><span class="o">(</span><span class="n">String</span> <span class="n">dayOfWeek</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">switch</span><span class="o">(</span><span class="n">dayOfWeek</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="s">&quot;Sunday&quot;</span><span class="o">:</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;周日&quot;</span><span class="o">);</span> <span class="k">break</span><span class="o">;</span>
</span><span class='line'>      <span class="k">case</span> <span class="s">&quot;Saturday&quot;</span><span class="o">:</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;周六&quot;</span><span class="o">);</span> <span class="k">break</span><span class="o">;</span>
</span><span class='line'>      <span class="o">...</span>
</span><span class='line'>      <span class="k">default</span><span class="o">:</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;不知道&quot;</span><span class="o">);</span> <span class="k">break</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>2. 更强的数值文本表示法</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b1100110</span><span class="o">;</span> <span class="c1">//0b表示二进制</span>
</span><span class='line'><span class="kt">int</span> <span class="n">bitPattern</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b0001_1100_0011</span><span class="o">;</span> <span class="c1">//也可以加下划线</span>
</span><span class='line'><span class="kt">long</span> <span class="n">longValue</span> <span class="o">=</span> <span class="mi">2</span><span class="n">_111_000_888L</span><span class="o">;</span> <span class="c1">//加下划线便于阅读</span>
</span></code></pre></td></tr></table></div></figure>


<h2>3. 改善的异常处理</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">try</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">String</span> <span class="n">fileText</span> <span class="o">=</span> <span class="n">getFile</span><span class="o">(</span><span class="n">fileName</span><span class="o">);</span>
</span><span class='line'>  <span class="n">cfg</span> <span class="o">=</span> <span class="n">verifyConfig</span><span class="o">(</span><span class="n">parseConfig</span><span class="o">(</span><span class="n">fileText</span><span class="o">));</span>
</span><span class='line'><span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">FileNotFoundException</span> <span class="o">|</span> <span class="n">ParseException</span> <span class="o">|</span> <span class="n">ConfigurationException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">//可以用或来表示可能的异常</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'><span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">IOException</span> <span class="n">iox</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>另一个新语法对需要重新抛出异常时很有用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">try</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">doSomethingWhichMightThrowIOException</span><span class="o">();</span>
</span><span class='line'>  <span class="n">doSomethingElseWhichMightThrowSQLException</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="kd">final</span> <span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'>  <span class="c1">//不再是抛出笼统的Exception，而是抛出实际的异常。</span>
</span><span class='line'>  <span class="c1">//final不是必须的，但留着提个醒有好处。</span>
</span><span class='line'>  <span class="k">throw</span> <span class="n">e</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>4. TWR(try-with-resources)</h2>

<p>这个很有用，特别是io操作时，可以抛掉大串丑陋的代码了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">try</span> <span class="o">(</span>
</span><span class='line'>  <span class="n">OutputStream</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileOutputStream</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
</span><span class='line'>  <span class="n">InputStream</span> <span class="n">is</span> <span class="o">=</span> <span class="n">url</span><span class="o">.</span><span class="na">openStream</span><span class="o">()</span>
</span><span class='line'><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">byte</span><span class="o">[]</span> <span class="n">buf</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">4096</span><span class="o">];</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">len</span><span class="o">;</span>
</span><span class='line'>  <span class="k">while</span> <span class="o">(</span><span class="n">len</span> <span class="o">=</span> <span class="n">is</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buf</span><span class="o">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>      <span class="n">out</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">buf</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码将资源放在try的圆括号内，当处理完后会自动关闭！但一定要注意不要嵌套创建，否则可能无法正确关闭。一定要声明变量。例如下面的代码就应该修改：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">try</span> <span class="o">(</span><span class="n">ObjectInputStream</span> <span class="n">in</span> <span class="o">=</span>
</span><span class='line'>  <span class="k">new</span> <span class="nf">ObjectInputStream</span><span class="o">(</span>
</span><span class='line'>      <span class="k">new</span> <span class="nf">FileInputStream</span><span class="o">(</span><span class="s">&quot;someFile.bin&quot;</span><span class="o">)))</span> <span class="o">{</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//要改为：</span>
</span><span class='line'><span class="k">try</span> <span class="o">(</span>
</span><span class='line'>  <span class="n">FileInputStream</span> <span class="n">fin</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="s">&quot;someFile.bin&quot;</span><span class="o">);</span>
</span><span class='line'>  <span class="n">ObjectInputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectInputStream</span><span class="o">(</span><span class="n">fin</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>TWR特性依赖于try从句中的资源类实现新接口AutoCloseable。Java 7平台的大多数资源都已经修改过了。</p>

<h2>5. 钻石语法</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">//不用这么麻烦了：</span>
</span><span class='line'><span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">userList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;&gt;();</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//可以直接写成：</span>
</span><span class='line'><span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">userList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</span></code></pre></td></tr></table></div></figure>


<h2>6. 简化变参方法调用</h2>

<p>在Java 7之前，如果泛型和变参结合起来会怎么样？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Collection</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">doSomething</span><span class="o">(</span><span class="n">T</span><span class="o">...</span> <span class="n">entries</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Java处理变参实际上是把它放到一个编译器自动创建的数组中。但我们知道泛型的实现其实是通过<a href="http://blog.ubone.com/blog/2014/07/02/javafan-xing/">擦拭法</a>实现的。所以Java数组不支持泛型:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;[</span><span class="mi">3</span><span class="o">];</span> <span class="c1">//编译错误</span>
</span><span class='line'>
</span><span class='line'><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">[</span><span class="mi">3</span><span class="o">];</span> <span class="c1">//编译可通过，但会有警告：</span>
</span><span class='line'><span class="c1">//Type safety: The expression of type HashMap[] needs unchecked conversion to conform to HashMap&lt;String,String&gt;[]</span>
</span></code></pre></td></tr></table></div></figure>


<p>因此，当泛型遇到变参时，编译器只好给你个警告。但这个问题更应该由API的设计者去关注，而不是API使用者。所以Java 7把警告信息挪到了定义API的地方。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[B树]]></title>
    <link href="http://blog.ubone.com/blog/2014/11/17/bshu/"/>
    <updated>2014-11-17T21:44:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/11/17/bshu</id>
    <content type="html"><![CDATA[<p>B树就是B-树，英语原文为B-Tree，但不知道以前的翻译为何要翻译成B-树。它是对平衡树的扩展，支持对保存在磁盘或网络上的符号表进行外部查找。只需要4～5个指向一小块数据的引用就可以支持在含有数百亿或者更多元素的符号表中进行查找和插入操作。</p>

<!--more-->


<h2>1. B树</h2>

<p>B树与2-3树的关键不同在于，数据不会保存在树中，而是会构造一棵由键的副本组成的树。每个副本都关联着一条链接。这种方式能够更加方便地将索引和符号表本身分开。与2-3树一样，也限制了“键-链接”对的上下数量界限。对于M阶B树，每个结点最多含有M-1对键和链接，最少含有M/2对键和链接。根结点例外，可以含有少于M/2对键和链接，但不能少于2对。M必须是正偶数。</p>

<p>“页”表示一块连续的数据，用“探查”表示访问一个页。一个页可能是本地计算机上的一个文件，也可能是另一计算机上的一网页等等。对于B树，使用两种不同类型的结点：</p>

<ol>
<li>内部结点：含有与页相关联的键的副本。</li>
<li>外部结点：含有指向实际数据的引用。</li>
</ol>


<p>内部结点中的每个键都与一个结点相关联，以此结点为根的子树中，所有的键都大于等于与此结点关联的键，但小于原内部结点中的更大的键（如果存在的话）。为了描述方便，使用一个特殊的哨兵键“*”，它小于其他所有键。一开始B树只有一个根结点，并且根结点只有哨兵键。同时符号表不含有重复键，但B树中会使用键的多个副本来引导查找。一棵B树如下图所示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-17-btree.jpg" alt="image" /></p>

<h2>2. 查找与插入</h2>

<p>B树中查找的方法是在可能含有被查找键的唯一子树中进行递归搜索。当且仅当被查找的键包含在集合中时，每次查找便会结束于一个外部结点。在内部结点中遇到被查找的键的副本时就判断查找命中并结束，但总会找到相应的外部结点。</p>

<p>在查找时，从根结点开始，根据被查找的键选择当前结点中的适当区间并根据适当的链接从一个结点移动到下一个结点。最终，查找过程会到达树底的一个含有键的页。如果被查找的键在该页中，查找命中并结束；如果不在，则查找未命中。</p>

<p>和2-3树一样，要在树的底部插入一个新键，可以使用递归代码。如果空间不足，那么可以允许被插入的结点暂时“溢出”（也就是利用最后一个结点），并在递归调用后向上不断分裂结点，直到根结点。如果根结点也溢出就把它分裂成两个结点。如下图所示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-17-btreeinsert.jpg" alt="image" /></p>

<h2>3. 数据表示与实现</h2>

<p>我们将B树结点的表示方法及其操作封装在Page API中。它可以关联键与指向Page对象的链接，支持检测页是否溢出、分裂页并区分内部页和外部页的操作。可以将Page看作一张符号表，但是是保存在外部介质上。Page<Key> API定义如下：</p>

<table>
<thead>
<tr>
<th>方法 </th>
<th> 说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Page(boolean bottom) </td>
<td> 创建并打开一个页</td>
</tr>
<tr>
<td>void close() </td>
<td> 关闭页</td>
</tr>
<tr>
<td>void add(Key key) </td>
<td> 将键插入（外部的）页中</td>
</tr>
<tr>
<td>void add(Page p) </td>
<td> 打开p，向这个（内部）而中插入一个条目，并将p和p中的最小键相关联</td>
</tr>
<tr>
<td>boolean isExternal() </td>
<td> 这是一个外部页吗</td>
</tr>
<tr>
<td>boolean contains(Key key) </td>
<td> 键key在页中吗</td>
</tr>
<tr>
<td>Page next(Key key) </td>
<td> 可能含有键key的子树</td>
</tr>
<tr>
<td>boolean isFull() </td>
<td> 页是否已经溢出</td>
</tr>
<tr>
<td>Page split() </td>
<td> 将较大的中间键移动到一个新页中</td>
</tr>
<tr>
<td>Iterable<Key> keys() </td>
<td> 页中所有键的迭代器</td>
</tr>
</tbody>
</table>


<p>open和close操作是指将外部页读入内存和将内存内容写加外部页（如果需要的话）的过程。</p>

<p>内部页的add方法是一个符号表操作，将给定页和以该页为根结点的子树中的最小键关联起来。外部页的add和contains方法和SET中相应的方法类似。</p>

<p>最重要的是split方法，分裂一张饱和页时，将排序后位置正好大于M/2的键移动到一个新的Page对象中，并返回该对象的引用。</p>

<p>有了Page，B树集合的实现就简单了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BTreeSET</span><span class="o">&lt;</span><span class="n">Key</span> <span class="kd">extends</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="n">Page</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Page</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="nf">BTreeSET</span><span class="o">(</span><span class="n">Key</span> <span class="n">sentinel</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">add</span><span class="o">(</span><span class="n">sentinel</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="n">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="nf">contains</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="n">Page</span> <span class="n">h</span><span class="o">,</span> <span class="n">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">isExternal</span><span class="o">())</span> <span class="k">return</span> <span class="n">h</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="nf">contains</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">next</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">add</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">isFull</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">Page</span> <span class="n">lefthalf</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
</span><span class='line'>          <span class="n">Page</span> <span class="n">righthalf</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">split</span><span class="o">();</span>
</span><span class='line'>          <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Page</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
</span><span class='line'>          <span class="n">root</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">lefthalf</span><span class="o">);</span>
</span><span class='line'>          <span class="n">root</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">righthalf</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">Page</span> <span class="n">h</span><span class="o">,</span> <span class="n">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">isExternal</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">h</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span><span class='line'>          <span class="k">return</span><span class="o">;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      
</span><span class='line'>      <span class="n">Page</span> <span class="n">next</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">next</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span><span class='line'>      <span class="n">add</span><span class="o">(</span><span class="n">next</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">next</span><span class="o">.</span><span class="na">isFull</span><span class="o">())</span>
</span><span class='line'>          <span class="n">h</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">next</span><span class="o">.</span><span class="na">split</span><span class="o">());</span>      
</span><span class='line'>      <span class="n">next</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>    
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>4. 性能与空间</h2>

<p><strong>B树最重要的性质就是，在实际应用中对于适当的参数M，查找的成本是常数级别的。</strong></p>

<blockquote><p>含有N个元素的M阶B树中的一次查找或者插入操作需要log<sub>M</sub>N ~ log<sub>M/2</sub>N 次探查，在实际情况下这基本是一个常数。</p></blockquote>

<p>B树的空间至少是半满的，在最坏的情况下，B树所需的空间是所有键占用的实际空间的两倍再加上链接所需的空间。对于随机键，B树浪费的空间约占44%。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单词查找树]]></title>
    <link href="http://blog.ubone.com/blog/2014/11/16/dan-ci-cha-zhao-shu/"/>
    <updated>2014-11-16T22:37:38+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/11/16/dan-ci-cha-zhao-shu</id>
    <content type="html"><![CDATA[<p>在<a href="http://blog.ubone.com/blog/2014/10/02/cha-zhao-suan-fa-fu-hao-biao/">符号表</a>中学习了二叉树、红黑树等，单词查找树比这些通用算法更加有效。它查找命中所需的时间与被查找的键的长度成正比，查找未命中只需检查若干个字符。这样的性能是相当惊人的，它们是算法研究的最高成就之一。</p>

<!--more-->


<p>我们扩展符号表的API，增加基于字符的用于处理字符串类型的键的操作。</p>

<p>以字符串为键的符号表的API(<code>StringST&lt;Value&gt;</code>)</p>

<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>StringST()</code> </td>
<td> 创建一个符号表</td>
</tr>
<tr>
<td><code>void put(String key, Value val)</code> </td>
<td> 向表中插入键值对（如果值为null则删除键key）</td>
</tr>
<tr>
<td><code>Value get(String key)</code> </td>
<td> 键key所对应的值，如果不存在则返回null</td>
</tr>
<tr>
<td><code>void delete(String key)</code> </td>
<td> 删除键key（和它的值）</td>
</tr>
<tr>
<td><code>boolean contains(String key)</code> </td>
<td> 表中是否存在key的值</td>
</tr>
<tr>
<td><code>boolean isEmpty()</code> </td>
<td> 符号表是否为空</td>
</tr>
<tr>
<td><strong><code>String longestPrefixOf(String s)</code></strong> </td>
<td> s的前缀中最长的键 </td>
</tr>
<tr>
<td><strong><code>Iterable&lt;String&gt; keysWithPrefix(String s)</code></strong> </td>
<td> 所有以s为前缀的键</td>
</tr>
<tr>
<td><strong><code>Iterable&lt;String&gt; keysThatMatch(String s)</code></strong> </td>
<td> 所有和s匹配的键（其中“.”能够匹配任意字符）</td>
</tr>
<tr>
<td><code>int size()</code>  </td>
<td> 键值对的数量 </td>
</tr>
<tr>
<td><code>Iterable&lt;String&gt; keys()</code> </td>
<td> 符号表中的所有键 </td>
</tr>
</tbody>
</table>


<p>上面的API与符号表API的不同之处在于Key换成了String, 增加了粗体显示的三个方法。</p>

<h2>1. R向单词查找树</h2>

<p>与各种查找树一样，单词查找树也是由链接的结点所组成的数据结构。每个结点只有一个父结点（根结点除外），每个结点都含有R条链接，其中R为字母表的大小。每个键所关联的值保存在该键的最后一个字母所对应的结点中。值为空的结点在符号表中没有对应的键，它们的存在是为了简化单词查找树中的查找操作。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-16-tries-node.jpg" alt="image" /></p>

<h3>1.1 查找操作</h3>

<p>单词查找树的查找操作非常简单，从首字母开始延着树结点查找就可以：</p>

<ul>
<li>键的尾字符所对应的结点中的值非空，命中！</li>
<li>键的尾字符所对应的结点中的值为空，未命中！</li>
<li>查找结束于一条空链接，未命中！</li>
</ul>


<h3>1.2 插入操作</h3>

<p>和二叉查找树一样，在插入之前要进行一次查找。</p>

<ul>
<li>在到达键的尾字符之前就遇到了一个空链接。证明不存在匹配的结点，为键中还未被检查的每个字符创建一个对应的结点，并将键对应的值保存到最后一个字符的结点中。</li>
<li>在遇到空链接之前就到达了键的尾字符。将该结点的值设为键对应的值（无论该值是否为空）。</li>
</ul>


<h3>1.3 删除操作</h3>

<p>删除的第一步是找到键所对应的结点并将它的值设为空null. 如果该结点含有一个非空的链接指向某个子结点，那么就不需要再进行其他操作了。如果它的所有链接均为空，那就需要从数据结构中删除这个结点。如果删除它使得它的父结点的所有链接也均为空，就要继续删除它的父结点，依此类推。</p>

<h3>1.4 实现</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TrieST</span><span class="o">&lt;</span><span class="n">Value</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">R</span> <span class="o">=</span> <span class="mi">256</span><span class="o">;</span>        <span class="c1">// extended ASCII</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Node</span> <span class="n">root</span><span class="o">;</span>      <span class="c1">// root of trie</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">N</span><span class="o">;</span>          <span class="c1">// number of keys in trie</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// R-way trie node</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">private</span> <span class="n">Object</span> <span class="n">val</span><span class="o">;</span>
</span><span class='line'>        <span class="kd">private</span> <span class="n">Node</span><span class="o">[]</span> <span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">[</span><span class="n">R</span><span class="o">];</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">TrieST</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>   <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Initializes an empty string symbol table.</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Returns the value associated with the given key.</span>
</span><span class='line'><span class="cm">     * @param key the key</span>
</span><span class='line'><span class="cm">     * @return the value associated with the given key if the key is in the symbol table</span>
</span><span class='line'><span class="cm">     *     and &lt;tt&gt;null&lt;/tt&gt; if the key is not in the symbol table</span>
</span><span class='line'><span class="cm">     * @throws NullPointerException if &lt;tt&gt;key&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Value</span> <span class="nf">get</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">get</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="o">(</span><span class="n">Value</span><span class="o">)</span> <span class="n">x</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Does this symbol table contain the given key?</span>
</span><span class='line'><span class="cm">     * @param key the key</span>
</span><span class='line'><span class="cm">     * @return &lt;tt&gt;true&lt;/tt&gt; if this symbol table contains &lt;tt&gt;key&lt;/tt&gt; and</span>
</span><span class='line'><span class="cm">     *     &lt;tt&gt;false&lt;/tt&gt; otherwise</span>
</span><span class='line'><span class="cm">     * @throws NullPointerException if &lt;tt&gt;key&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nf">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Node</span> <span class="nf">get</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">key</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="nf">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">],</span> <span class="n">key</span><span class="o">,</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Inserts the key-value pair into the symbol table, overwriting the old value</span>
</span><span class='line'><span class="cm">     * with the new value if the key is already in the symbol table.</span>
</span><span class='line'><span class="cm">     * If the value is &lt;tt&gt;null&lt;/tt&gt;, this effectively deletes the key from the symbol table.</span>
</span><span class='line'><span class="cm">     * @param key the key</span>
</span><span class='line'><span class="cm">     * @param val the value</span>
</span><span class='line'><span class="cm">     * @throws NullPointerException if &lt;tt&gt;key&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">val</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="n">delete</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span><span class='line'>        <span class="k">else</span> <span class="n">root</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Node</span> <span class="nf">put</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">();</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">key</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="n">N</span><span class="o">++;</span>
</span><span class='line'>            <span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
</span><span class='line'>        <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">],</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Returns the number of key-value pairs in this symbol table.</span>
</span><span class='line'><span class="cm">     * @return the number of key-value pairs in this symbol table</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">N</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Is this symbol table empty?</span>
</span><span class='line'><span class="cm">     * @return &lt;tt&gt;true&lt;/tt&gt; if this symbol table is empty and &lt;tt&gt;false&lt;/tt&gt; otherwise</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nf">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Returns all keys in the symbol table as an &lt;tt&gt;Iterable&lt;/tt&gt;.</span>
</span><span class='line'><span class="cm">     * To iterate over all of the keys in the symbol table named &lt;tt&gt;st&lt;/tt&gt;,</span>
</span><span class='line'><span class="cm">     * use the foreach notation: &lt;tt&gt;for (Key key : st.keys())&lt;/tt&gt;.</span>
</span><span class='line'><span class="cm">     * @return all keys in the sybol table as an &lt;tt&gt;Iterable&lt;/tt&gt;</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">keys</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nf">keysWithPrefix</span><span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Returns all of the keys in the set that start with &lt;tt&gt;prefix&lt;/tt&gt;.</span>
</span><span class='line'><span class="cm">     * @param prefix the prefix</span>
</span><span class='line'><span class="cm">     * @return all of the keys in the set that start with &lt;tt&gt;prefix&lt;/tt&gt;,</span>
</span><span class='line'><span class="cm">     *     as an iterable</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">keysWithPrefix</span><span class="o">(</span><span class="n">String</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
</span><span class='line'>        <span class="n">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">get</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">prefix</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</span><span class='line'>        <span class="n">collect</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">(</span><span class="n">prefix</span><span class="o">),</span> <span class="n">results</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">results</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">collect</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">StringBuilder</span> <span class="n">prefix</span><span class="o">,</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">results</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">results</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">prefix</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>  <span class="c1">//有值才是键</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">prefix</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
</span><span class='line'>            <span class="n">collect</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">],</span> <span class="n">prefix</span><span class="o">,</span> <span class="n">results</span><span class="o">);</span>
</span><span class='line'>            <span class="n">prefix</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">prefix</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Returns all of the keys in the symbol table that match &lt;tt&gt;pattern&lt;/tt&gt;,</span>
</span><span class='line'><span class="cm">     * where . symbol is treated as a wildcard character.</span>
</span><span class='line'><span class="cm">     * @param pattern the pattern</span>
</span><span class='line'><span class="cm">     * @return all of the keys in the symbol table that match &lt;tt&gt;pattern&lt;/tt&gt;,</span>
</span><span class='line'><span class="cm">     *     as an iterable, where . is treated as a wildcard character.</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">keysThatMatch</span><span class="o">(</span><span class="n">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
</span><span class='line'>        <span class="n">collect</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">(),</span> <span class="n">pattern</span><span class="o">,</span> <span class="n">results</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">results</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">collect</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">StringBuilder</span> <span class="n">prefix</span><span class="o">,</span> <span class="n">String</span> <span class="n">pattern</span><span class="o">,</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">results</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">prefix</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>            <span class="n">results</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">prefix</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>
</span><span class='line'>            <span class="k">return</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">ch</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">ch</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">prefix</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
</span><span class='line'>                <span class="n">collect</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">ch</span><span class="o">],</span> <span class="n">prefix</span><span class="o">,</span> <span class="n">pattern</span><span class="o">,</span> <span class="n">results</span><span class="o">);</span>
</span><span class='line'>                <span class="n">prefix</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">prefix</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">prefix</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
</span><span class='line'>            <span class="n">collect</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">],</span> <span class="n">prefix</span><span class="o">,</span> <span class="n">pattern</span><span class="o">,</span> <span class="n">results</span><span class="o">);</span>
</span><span class='line'>            <span class="n">prefix</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">prefix</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Returns the string in the symbol table that is the longest prefix of &lt;tt&gt;query&lt;/tt&gt;,</span>
</span><span class='line'><span class="cm">     * or &lt;tt&gt;null&lt;/tt&gt;, if no such string.</span>
</span><span class='line'><span class="cm">     * @param query the query string</span>
</span><span class='line'><span class="cm">     * @throws NullPointerException if &lt;tt&gt;query&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;</span>
</span><span class='line'><span class="cm">     * @return the string in the symbol table that is the longest prefix of &lt;tt&gt;query&lt;/tt&gt;,</span>
</span><span class='line'><span class="cm">     *     or &lt;tt&gt;null&lt;/tt&gt; if no such string</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">String</span> <span class="nf">longestPrefixOf</span><span class="o">(</span><span class="n">String</span> <span class="n">query</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">longestPrefixOf</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">query</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">query</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">length</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// returns the length of the longest string key in the subtrie</span>
</span><span class='line'>    <span class="c1">// rooted at x that is a prefix of the query string,</span>
</span><span class='line'>    <span class="c1">// assuming the first d character match and we have already</span>
</span><span class='line'>    <span class="c1">// found a prefix match of length length</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">longestPrefixOf</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">String</span> <span class="n">query</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">,</span> <span class="kt">int</span> <span class="n">length</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">length</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">length</span> <span class="o">=</span> <span class="n">d</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">query</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="k">return</span> <span class="n">length</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="nf">longestPrefixOf</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">],</span> <span class="n">query</span><span class="o">,</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">length</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Removes the key from the set if the key is present.</span>
</span><span class='line'><span class="cm">     * @param key the key</span>
</span><span class='line'><span class="cm">     * @throws NullPointerException if &lt;tt&gt;key&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">delete</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">root</span> <span class="o">=</span> <span class="n">delete</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Node</span> <span class="nf">delete</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">key</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">N</span><span class="o">--;</span>
</span><span class='line'>            <span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
</span><span class='line'>            <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="n">delete</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">],</span> <span class="n">key</span><span class="o">,</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// remove subtrie rooted at x if it is completely empty</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>                <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码可以处理扩展ASCII码，但很容易就可以修改为能够处理由任意字母表得到的键：</p>

<ol>
<li>实现一个构造函数，接受Alphabet，将R设置为字母表大小。</li>
<li>在get()、put()中使用Alphabet的toIndex()，将字符串中的字符转化为0到R-1的索引值。</li>
<li>在keys()、keysWithPrefix()和keysThatMatch()方法中，使用Alphabet的toChar()方法，将0到R-1之间的索引值转化为字符型(char)值。</li>
</ol>


<h3>1.5 单词查找树的性质</h3>

<p>单词查找树的链表结构（形状）和键的插入或删除顺序无关，对于任意给定的一组键，其单词查找树都是唯一的。</p>

<p>在单词查找树中查找一个键或是插入一个键时，访问数组的次数最多为键的长度加1！</p>

<p>字母表的大小为R，在一棵由N个随机键构造的单词树中，未命中查找平均所需检查的结点数量为~log<sub>R</sub><sup>N</sup>。</p>

<p>一棵单词查找树中的链接总数在RN到RNw之间，其中w为键的平均长度。因此单词查找树的空间消耗非常大。长键也可能占用大量空间，因为它通常有一条长长的尾巴。单词查找树的内部也可能存在单向的分支。例如两个长键可能只有最后一个字符不同。</p>

<p>如果能够负担得起R向单词查找树的庞大空间，它的性能是无可匹敌的。</p>

<h2>2. 三向单词查找树</h2>

<p>三向单词查找树可以避免R向单词查找树过度的空间消耗。它的每个结点都含有一个字符、三条链接和一个值。三条链接分别对应当前字母小于、等于和大于结点字母的所有键。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-16-tst.jpg" alt="image" /></p>

<h3>2.1 查找、插入和删除操作</h3>

<p>在查找时，首先比较键的首字母和根结点的字母。如果键的首字母较小，就选择左链接；如果较大，就选择右链接；如果相等则选择中链接。然后递归地使用相同的算法。如果遇到一个空链接或者当键结束时结点的值为空，那么查找未命中。如果键结束时结点的值非空则查找命中。</p>

<p>插入一个新键时，首先进行查找，然后和单词查找树一样，在树中补全键末尾的所有结点。</p>

<p>在三向单词查找树中，需要使用在二叉查找树中删除结点的方法来删去与该字符对应的结点。</p>

<h3>2.2 实现</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TST</span><span class="o">&lt;</span><span class="n">Value</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">N</span><span class="o">;</span>       <span class="c1">// size</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Node</span> <span class="n">root</span><span class="o">;</span>   <span class="c1">// root of TST</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">private</span> <span class="kt">char</span> <span class="n">c</span><span class="o">;</span>                 <span class="c1">// character</span>
</span><span class='line'>        <span class="kd">private</span> <span class="n">Node</span> <span class="n">left</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">right</span><span class="o">;</span>  <span class="c1">// left, middle, and right subtries</span>
</span><span class='line'>        <span class="kd">private</span> <span class="n">Value</span> <span class="n">val</span><span class="o">;</span>              <span class="c1">// value associated with string</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// return number of key-value pairs</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">N</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>   <span class="cm">/**************************************************************</span>
</span><span class='line'><span class="cm">    * Is string key in the symbol table?</span>
</span><span class='line'><span class="cm">    **************************************************************/</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nf">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Value</span> <span class="nf">get</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;key must have length &gt;= 1&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="n">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">get</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// return subtrie corresponding to given key</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Node</span> <span class="nf">get</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;key must have length &gt;= 1&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span>      <span class="o">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">.</span><span class="na">c</span><span class="o">)</span>              <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span>  <span class="n">key</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
</span><span class='line'>        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="na">c</span><span class="o">)</span>              <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
</span><span class='line'>        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">key</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">mid</span><span class="o">,</span>   <span class="n">key</span><span class="o">,</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'>        <span class="k">else</span>                           <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>   <span class="cm">/**************************************************************</span>
</span><span class='line'><span class="cm">    * Insert string s into the symbol table.</span>
</span><span class='line'><span class="cm">    **************************************************************/</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(!</span><span class="n">contains</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="n">N</span><span class="o">++;</span>
</span><span class='line'>        <span class="n">root</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Node</span> <span class="nf">put</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">String</span> <span class="n">s</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">();</span>
</span><span class='line'>            <span class="n">x</span><span class="o">.</span><span class="na">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">if</span>      <span class="o">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">.</span><span class="na">c</span><span class="o">)</span>             <span class="n">x</span><span class="o">.</span><span class="na">left</span>  <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span>  <span class="n">s</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
</span><span class='line'>        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="na">c</span><span class="o">)</span>             <span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
</span><span class='line'>        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>  <span class="n">x</span><span class="o">.</span><span class="na">mid</span>   <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">mid</span><span class="o">,</span>   <span class="n">s</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'>        <span class="k">else</span>                          <span class="n">x</span><span class="o">.</span><span class="na">val</span>   <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>   <span class="cm">/**************************************************************</span>
</span><span class='line'><span class="cm">    * Find and return longest prefix of s in TST</span>
</span><span class='line'><span class="cm">    **************************************************************/</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">String</span> <span class="nf">longestPrefixOf</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>        <span class="n">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(</span><span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span><span class='line'>            <span class="k">if</span>      <span class="o">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">.</span><span class="na">c</span><span class="o">)</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
</span><span class='line'>            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="na">c</span><span class="o">)</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
</span><span class='line'>            <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">i</span><span class="o">++;</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">length</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
</span><span class='line'>                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">mid</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">length</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// all keys in symbol table</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">keys</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
</span><span class='line'>        <span class="n">collect</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="s">&quot;&quot;</span><span class="o">,</span> <span class="n">queue</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// all keys starting with given prefix</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">prefixMatch</span><span class="o">(</span><span class="n">String</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
</span><span class='line'>        <span class="n">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">get</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">prefix</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">queue</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">prefix</span><span class="o">);</span>
</span><span class='line'>        <span class="n">collect</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">mid</span><span class="o">,</span> <span class="n">prefix</span><span class="o">,</span> <span class="n">queue</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// all keys in subtrie rooted at x with given prefix</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">collect</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">String</span> <span class="n">prefix</span><span class="o">,</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
</span><span class='line'>        <span class="n">collect</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span>  <span class="n">prefix</span><span class="o">,</span>       <span class="n">queue</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">queue</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="na">c</span><span class="o">);</span>
</span><span class='line'>        <span class="n">collect</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">mid</span><span class="o">,</span>   <span class="n">prefix</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="na">c</span><span class="o">,</span> <span class="n">queue</span><span class="o">);</span>
</span><span class='line'>        <span class="n">collect</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">prefix</span><span class="o">,</span>       <span class="n">queue</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// return all keys matching given wildcard pattern</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">wildcardMatch</span><span class="o">(</span><span class="n">String</span> <span class="n">pat</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
</span><span class='line'>        <span class="n">collect</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="s">&quot;&quot;</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">pat</span><span class="o">,</span> <span class="n">queue</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">collect</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">String</span> <span class="n">prefix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">String</span> <span class="n">pat</span><span class="o">,</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">pat</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">.</span><span class="na">c</span><span class="o">)</span> <span class="n">collect</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">prefix</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">pat</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="na">c</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">pat</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">q</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="na">c</span><span class="o">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">pat</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="n">collect</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">mid</span><span class="o">,</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="na">c</span><span class="o">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">pat</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="na">c</span><span class="o">)</span> <span class="n">collect</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">prefix</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">pat</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2.3 三向单词查找树的性质</h3>

<p>三向单词查找树与R向单词查找树的数据结构性质截然不同。它和其他所有二叉查找树一样，每个单词查找树结点的二叉查找树表示也取决于键的插入顺序。</p>

<p>它的每个结点只含有三个链接，因此所需空间远小于对应的单词查找树。由N个平均长度为w的字符串构造的三向单词查找树中的链接总数在3N到3Nw之间。</p>

<p>在一棵由N个随机字符串构造的三向单词查找树中，查找未命中平均需要比较字符~lnN次。除~lnN次外，一次插入或命中的查找会比较一次被查找的键中的每个字符。</p>

<p>使用三向单词查找树的最大好处是它能够很好地适应实际应用中可能出现的被查找键的不规则性。它可以使用256个字符的ASCII编码或者65536个字符的Unicode编码，而不必担心分支带来的巨大开销。</p>

<h2>3. 总结</h2>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-16-wordsfind-conclude.jpg" alt="image" /></p>

<p>参考：<a href="http://algs4.cs.princeton.edu/52trie/">http://algs4.cs.princeton.edu/52trie/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字符串排序]]></title>
    <link href="http://blog.ubone.com/blog/2014/11/15/zi-fu-chuan-pai-xu/"/>
    <updated>2014-11-15T09:49:02+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/11/15/zi-fu-chuan-pai-xu</id>
    <content type="html"><![CDATA[<p>字符串是最常用的数据类型，因此它的排序算法非常重要。虽然Java的字符串排序已经非常快，但了解一些字符串的排序算法仍然很必要，也是进一步了解字符串其它应用的基础。</p>

<!--more-->


<p>在Java中表示字符串的两种方法：</p>

<table>
<thead>
<tr>
<th>操作 </th>
<th> 字符数组 </th>
<th> Java字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>声明</td>
<td> char[] a</td>
<td> String s</td>
</tr>
<tr>
<td>根据索引访问字符</td>
<td> a[i] </td>
<td> s.charAt(i)</td>
</tr>
<tr>
<td>获取字符串长度</td>
<td> a.length </td>
<td> s.length()</td>
</tr>
<tr>
<td>表示方法转换</td>
<td> a = s.toCharArray(); </td>
<td> s= new String(a);</td>
</tr>
</tbody>
</table>


<h2>1. 字母表</h2>

<p>字母表是字符串相关算法的基础，表示字符串由哪些字母组成。字符索引的数组能够提高算法的效率。在这个数组中，用字符作为索引来获取与之相关联的信息。在一些算法中会产生大量的这类数组。如果使用Java的String类，就必须使用大小为65536的数组。有了字母表，则只需要使用一个字母表大小的数组即可。</p>

<p>字母表(Alphabet)API定义如下：</p>

<table>
<thead>
<tr>
<th>方法 </th>
<th>  说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alphabet(String s) </td>
<td> 构造方法，根据s中的字符创建一张新的字母表</td>
</tr>
<tr>
<td>char toChar(int index) </td>
<td> 获取字母表中索引位置的字符</td>
</tr>
<tr>
<td>int toIndex(char c)  </td>
<td> 获取c的索引，在0到R-1之间</td>
</tr>
<tr>
<td>boolean contains(char c) </td>
<td> c在字母表中吗</td>
</tr>
<tr>
<td>int R() </td>
<td> 基数（字母表中的字符数量）</td>
</tr>
<tr>
<td>int lgR() </td>
<td> 表示一个索引所需的比特数</td>
</tr>
<tr>
<td>int[] toIndices(String s) </td>
<td> 将s转换为R进制的整数数组</td>
</tr>
<tr>
<td>String toChars(int[] indices) </td>
<td> 将R进制的整数数组转换为基于该字母表的字符串</td>
</tr>
</tbody>
</table>


<h3>标准字母表</h3>

<table>
<thead>
<tr>
<th>名称 </th>
<th> R() </th>
<th> lgR() </th>
<th> 字符集</th>
</tr>
</thead>
<tbody>
<tr>
<td>BINARY </td>
<td> 2 </td>
<td> 1 </td>
<td> 01</td>
</tr>
<tr>
<td>DNA </td>
<td> 4 </td>
<td> 2 </td>
<td> ACTG</td>
</tr>
<tr>
<td>OCTAL </td>
<td> 8 </td>
<td> 3 </td>
<td> 0..7</td>
</tr>
<tr>
<td>DECIMAL </td>
<td> 10 </td>
<td> 4 </td>
<td> 0..9</td>
</tr>
<tr>
<td>HEXADECIMAL </td>
<td> 16 </td>
<td> 4 </td>
<td> 0..9ABCDEF</td>
</tr>
<tr>
<td>PROTEIN </td>
<td> 20 </td>
<td> 5 </td>
<td> ACDEFGHIKLMNPQRSTVWY</td>
</tr>
<tr>
<td>LOWERCASE </td>
<td> 26 </td>
<td> 5 </td>
<td> a..z</td>
</tr>
<tr>
<td>UPPERCASE </td>
<td> 26 </td>
<td> 5 </td>
<td> A..Z</td>
</tr>
<tr>
<td>BASE64 </td>
<td> 64 </td>
<td> 6 </td>
<td> A..Za..z0..9+/</td>
</tr>
<tr>
<td>ASCII </td>
<td> 128 </td>
<td> 7 </td>
<td> ASCII字符集</td>
</tr>
<tr>
<td>EXTENDED_ASCII </td>
<td> 256 </td>
<td> 8 </td>
<td> 扩展ASCII字符集</td>
</tr>
<tr>
<td>UNICODE16 </td>
<td> 65536 </td>
<td> 16 </td>
<td> Unicode字符集</td>
</tr>
</tbody>
</table>


<h2>2. 键索引计数法</h2>

<p>假设老师在统计学生分数时，学生被分为若干组，标号为0、1、2、3等。老师希望将全班同学按组分类，也就是按组排序。因为组的编号是较小的整数，使用键索引计数法来排序非常合适。</p>

<p>我们用一个数组a[]来保存数据。每个元素都保存了一个姓名和一个组号。组号在0到R-1之间，a[i].key()会返回指定学生的组号。键索引计数法通过四个步骤来完成排序。</p>

<p><strong>第一步，频率统计</strong>
使用一个int数组count[]来计算每个键（组号）出现的频率。遍历一遍数组，如果键为r，则将count[r+1]加1。因此对第1组的学生，将会把count[2]++。（在第二步的代码中可以看到为什么是r+1）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">count</span><span class="o">[</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">key</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]++;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>第二步，将频率转换为索引</strong>
有了count[]中每个键出现的次数，就可以得到每个键在排序结果中的起始索引位置。假如第1组3个人，第2组5个人，那么第三种的同学在排序结果中的起始位置就是8. 因此可以将count[]转化为一张索引表。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">r</span><span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">r</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">count</span><span class="o">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">+=</span> <span class="n">count</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>第三步，数据分类</strong>
在第二步中，得到了每个键的起始序号。我们就可以将所有元素（学生）移动到一个辅助数组aux[]。元素在aux[]中的位置由count[]值决定，在移动的过程中将count[]中对应的元素值加1。这个过程只需要遍历一遍数据就可以产生排序结果。并且这种方式是稳定的！键相同的元素在排序后会被聚集到一起，而且相对顺序没有变化。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">aux</span><span class="o">[</span><span class="n">count</span><span class="o">[</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">key</span><span class="o">()]++]</span>  <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>第四步，回写</strong>
在第三步已经完成了排序，只需要将排序结果复制回原数组。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>键索引计数法是一种对于小整数键排序非常有效却常常被忽略的排序方法。它排序N个键为0到R-1之间的整数的元素需要访问数组11N+4R+1次。也就是说<strong>它突破了NlogN的排序算法运行时间下限（<a href="http://blog.ubone.com/blog/2014/09/27/kuai-su-pai-xu-suan-fa/">快速排序算法</a>）。原因是什么？因为它是不需要比较的，它只通过key()方法访问数据。只要当R在N的一个常数因子范围之内，它都是一个线性时间级别的排序方法。</strong></p>

<p>理解键索引计数法的工作原理非常重要。学生的组号对应字母表中的元素，利用字母表大小的数组count[]来统计每个字母出现的次数，计算出每个字母在最终数组的起始序号，从而完成排序。</p>

<p>有了键索引计数法，我们来看如何实现两种字符串排序算法。</p>

<h2>3. 低位优先(Least-Significant-DigitFirst, LSD)的字符串排序</h2>

<p>这种算法适用于<strong>键的长度相等</strong>的字符串排序应用。例如对车牌号进行排序。它会从右往左检查键中的字符，所以称为低位优先。</p>

<p>如果字符串的长度均为W，在排序的过程中，从右向左，将每个位置的字符作为键，用键索引计数法将字符串排序W遍。理解了键索引计数法，实现低位优先的字符串排序就很容易了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LSD</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">W</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">R</span> <span class="o">=</span> <span class="mi">256</span><span class="o">;</span>   <span class="c1">// extend ASCII alphabet size</span>
</span><span class='line'>        <span class="n">String</span><span class="o">[]</span> <span class="n">aux</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">N</span><span class="o">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">W</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">d</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">d</span><span class="o">--)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">//将第d个字符用键索引计数法排序</span>
</span><span class='line'>            <span class="c1">// 计算出现次数</span>
</span><span class='line'>            <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">R</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
</span><span class='line'>                <span class="n">count</span><span class="o">[</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]++;</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// 将次数转换为索引</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">r</span><span class="o">++)</span>
</span><span class='line'>                <span class="n">count</span><span class="o">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">+=</span> <span class="n">count</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// 移到辅助数组，进行排序</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
</span><span class='line'>                <span class="n">aux</span><span class="o">[</span><span class="n">count</span><span class="o">[</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">)]++]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// 回写数据</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
</span><span class='line'>                <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>低位优先的字符串排序算法能够将定长字符串排序，其中的键索引计数法的稳定性起了关键作用。</p>

<p>对于基于R个字符的字母表的N个以长为W的字符串为键的元素，低位优先的字符串排序需要访问~7WN+3WR次数组，使用的额外空间与N+R成正比。</p>

<h2>4. 高位优先(MSD)的字符串排序</h2>

<p>这种算法从左往右检查键中的字符，所以称为高位优先。它不一定要检查所有的输入才能完成排序。它是更通用的字符串排序算法，字符串的长度不一定相同。</p>

<p>和快速排序一样，高位优先的字符串排序会将数组切分为能够独立排序的子数组来完成排序任务，但它的切分会为每个首字母得到一个子数组，而不是像快速排序中那样产生固定的两个或三个切分。首先用键索引计数法将所有字符串按照首字母排序，然后（递归地）再将每个首字母所对应的子数组排序（忽略首字母，因为每个子数组中的首字母是相同的）。</p>

<p>由于高位优先字符串排序算法要处理不等长的字符串，因此要处理字符串已经结束的情况。因此约定charAt方法中，如果指定位置超出字符串长度则返回-1. 其它情况则加1后返回。因此字符串中的每个字符都可能产生R+1种不同的值，0表示结束，1表示字母表的第一个字符。而键索引计数法还需要一个额外的位置，所以count[]的长度应为R+2。</p>

<p>对于很小的子数组（15个以内），采用插入排序更快。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MSD</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">R</span>             <span class="o">=</span> <span class="mi">256</span><span class="o">;</span>   <span class="c1">// 基数 extended ASCII alphabet size</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CUTOFF</span>        <span class="o">=</span>  <span class="mi">15</span><span class="o">;</span>   <span class="c1">// 小数组的切换阈值 cutoff to insertion sort</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// sort array of strings</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
</span><span class='line'>        <span class="n">String</span><span class="o">[]</span> <span class="n">aux</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">N</span><span class="o">];</span>
</span><span class='line'>        <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">aux</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// return dth character of s, -1 if d = length of string</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">charAt</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">assert</span> <span class="n">d</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// sort from a[lo] to a[hi], starting at the dth character</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">,</span> <span class="n">String</span><span class="o">[]</span> <span class="n">aux</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// cutoff to insertion sort for small subarrays</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">CUTOFF</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">insertion</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
</span><span class='line'>            <span class="k">return</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 计算次数</span>
</span><span class='line'>        <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">R</span><span class="o">+</span><span class="mi">2</span><span class="o">];</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">charAt</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">d</span><span class="o">);</span>
</span><span class='line'>            <span class="n">count</span><span class="o">[</span><span class="n">c</span><span class="o">+</span><span class="mi">2</span><span class="o">]++;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 将次数转换为索引</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">r</span><span class="o">++)</span>
</span><span class='line'>            <span class="n">count</span><span class="o">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">+=</span> <span class="n">count</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 生成辅助数据内容，完成排序。</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">charAt</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">d</span><span class="o">);</span>
</span><span class='line'>            <span class="n">aux</span><span class="o">[</span><span class="n">count</span><span class="o">[</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="o">]++]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 回写</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
</span><span class='line'>            <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">lo</span><span class="o">];</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 递归地以每个字符为键进行排序。</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">r</span><span class="o">++)</span>
</span><span class='line'>            <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">count</span><span class="o">[</span><span class="n">r</span><span class="o">],</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">count</span><span class="o">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">aux</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 插入排序算法insertion sort a[lo..hi], starting at dth character</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">insertion</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">lo</span> <span class="o">&amp;&amp;</span> <span class="n">less</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">],</span> <span class="n">d</span><span class="o">);</span> <span class="n">j</span><span class="o">--)</span>
</span><span class='line'>                <span class="n">exch</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// exchange a[i] and a[j]</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">exch</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>        <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
</span><span class='line'>        <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// is v less than w, starting at character d</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">less</span><span class="o">(</span><span class="n">String</span> <span class="n">v</span><span class="o">,</span> <span class="n">String</span> <span class="n">w</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// assert v.substring(0, d).equals(w.substring(0, d));</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">d</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">v</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">w</span><span class="o">.</span><span class="na">length</span><span class="o">());</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">v</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">w</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">v</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">w</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">w</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>4.1 三个必须解决的问题</h3>

<h4>4.1.1 小型子数组</h4>

<p>高位优先的字符串排序算法能够快速地将需要排序的数组切分小的数组，但这肯定会需要处理大量的微型数组，因此必须快速处理它们。<strong>小型子数组对于高位优先的字符串排序性能至关重要！</strong>假设要将数百万个不同的ASCII字符串排序，每个字符串最终都会产生一个只含有它自己的子数组，因此你需要将数百万个大小为1的子数组排序。每次排序还需要将count[]r 258个元素初始化为0并转化为索引。这个代价比排序其他部分高得多。如果使用Unicode(R=65536)则可能会慢上千倍！</p>

<p>所以对小型子数组要切换到插入排序。在一个典型应用中，当长度小于等于10时切换到插入排序能够将运行时间降低到原来的十分之一。</p>

<h4>4.1.2 等值键</h4>

<p>如果字符串有大量重复的前缀，排序会较慢。高位优先字符串排序算法的最坏情况就是所有的键均相同。</p>

<h4>4.1.3 额外空间</h4>

<p>为了进行切分，高位优先的算法使用了两个辅助数组：aux[]和count[]. aux可以在递归方法sort()外创建。而count[]所需的空间是主要问题，它在内循环中创建。</p>

<p>解决这三个问题需要新算法。</p>

<h2>5. 三向字符串快速排序</h2>

<p>在高位优先的字符串排序算法上改进快速排序。根据键的首字母进行三向切分，分成三个数组：首字母小于、等于和大于切分字符的三个数组。仅在中间子数组中的下一个字符（因为首字母就是切分字符）继续递归排序。这是一种将高位优先字符串排序与快速排序结合的算法。</p>

<p>这种算法不会像高位优先算法那样创建大量（空）子数组，它的切分总是只有三个。能解决所有高位优先字符串排序算法不擅长的各种情况。并且它也不需要额外的空间。</p>

<p>对于所有递归算法都可以通过对小型子数组进行特殊处理高效率，所以它同样使用到了插入排序。</p>

<p>和快速排序一样，最好在排序之前将数组打乱，或者将第一个元素和一个随机位置的元素交换以得到一个随机的切分元素。这么做主要是预防数组已经有序或者接近有序的最坏情况。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Quick3string</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CUTOFF</span> <span class="o">=</span>  <span class="mi">15</span><span class="o">;</span>   <span class="c1">// cutoff to insertion sort</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// sort the array a[] of strings</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">StdRandom</span><span class="o">.</span><span class="na">shuffle</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
</span><span class='line'>        <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</span><span class='line'>        <span class="k">assert</span> <span class="nf">isSorted</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// return the dth character of s, -1 if d = length of s</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">charAt</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">assert</span> <span class="n">d</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 3-way string quicksort a[lo..hi] starting at dth character</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// cutoff to insertion sort for small subarrays</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">CUTOFF</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">insertion</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
</span><span class='line'>            <span class="k">return</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">int</span> <span class="n">lt</span> <span class="o">=</span> <span class="n">lo</span><span class="o">,</span> <span class="n">gt</span> <span class="o">=</span> <span class="n">hi</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">charAt</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">lo</span><span class="o">],</span> <span class="n">d</span><span class="o">);</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">gt</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">charAt</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">d</span><span class="o">);</span>
</span><span class='line'>            <span class="k">if</span>      <span class="o">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">v</span><span class="o">)</span> <span class="n">exch</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lt</span><span class="o">++,</span> <span class="n">i</span><span class="o">++);</span>
</span><span class='line'>            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="n">v</span><span class="o">)</span> <span class="n">exch</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">gt</span><span class="o">--);</span>
</span><span class='line'>            <span class="k">else</span>              <span class="n">i</span><span class="o">++;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi]. </span>
</span><span class='line'>        <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">lt</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lt</span><span class="o">,</span> <span class="n">gt</span><span class="o">,</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'>        <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">gt</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// sort from a[lo] to a[hi], starting at the dth character</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">insertion</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">lo</span> <span class="o">&amp;&amp;</span> <span class="n">less</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">],</span> <span class="n">d</span><span class="o">);</span> <span class="n">j</span><span class="o">--)</span>
</span><span class='line'>                <span class="n">exch</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// exchange a[i] and a[j]</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">exch</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>        <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
</span><span class='line'>        <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// is v less than w, starting at character d</span>
</span><span class='line'>    <span class="c1">// DEPRECATED BECAUSE OF SLOW SUBSTRING EXTRACTION IN JAVA 7</span>
</span><span class='line'>    <span class="c1">// private static boolean less(String v, String w, int d) {</span>
</span><span class='line'>    <span class="c1">//    assert v.substring(0, d).equals(w.substring(0, d));</span>
</span><span class='line'>    <span class="c1">//    return v.substring(d).compareTo(w.substring(d)) &lt; 0; </span>
</span><span class='line'>    <span class="c1">// }</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// is v less than w, starting at character d</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">less</span><span class="o">(</span><span class="n">String</span> <span class="n">v</span><span class="o">,</span> <span class="n">String</span> <span class="n">w</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">assert</span> <span class="n">v</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">d</span><span class="o">).</span><span class="na">equals</span><span class="o">(</span><span class="n">w</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">d</span><span class="o">));</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">d</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">v</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">w</span><span class="o">.</span><span class="na">length</span><span class="o">());</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">v</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">w</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">v</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">w</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">w</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// is the array sorted</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isSorted</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">compareTo</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>要将含有N个随机字符串的数组排序，三向字符串快速排序平均需要比较字符~2NlnN次。</p>

<p>Java系统的标准实现中的字符串比较非常快，因此它的排序性能与上面的算法不相上下。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-15-string-sort.jpg" alt="image" /></p>

<p>参考：<a href="http://algs4.cs.princeton.edu/51radix/">http://algs4.cs.princeton.edu/51radix/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android应用打破65K方法数限制]]></title>
    <link href="http://blog.ubone.com/blog/2014/11/12/androidying-multidex/"/>
    <updated>2014-11-12T16:52:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/11/12/androidying-multidex</id>
    <content type="html"><![CDATA[<p>普通Android应用的方法总数不能超过65536，这是开发者长期以来非常头疼的一个问题。最近Google发布了新的Multidex支持库，为方法总数超过65K的Android应用提供官方支持。</p>

<p>本文已经发表在<a href="http://www.infoq.com/cn/news/2014/11/android-multidex">InfoQ</a>。</p>

<!--more-->


<p>近日，<a href="https://plus.google.com/108967384991768947849">Android Developers</a>在Google+上宣布了<a href="http://developer.android.com/tools/support-library/features.html#multidex">新的Multidex支持库</a>，为方法总数超过65K的Android应用提供官方支持。</p>

<p>如果你是一名幸运的Android应用开发者，正在开发一个前景广阔的应用，不断地加入新功能、添加新的类库，那么终有一天，你会不幸遇到这个错误：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Conversion to Dalvik format failed:
</span><span class='line'>Unable to execute dex: method ID not in [0, 0xffff]: 65536</span></code></pre></td></tr></table></div></figure>


<p>这个错误是Android应用的方法总数限制造成的。Android平台的Java虚拟机Dalvik在执行DEX格式的Java应用程序时，使用原生类型short来索引DEX文件中的方法。这意味着单个DEX文件可被引用的方法总数被限制为65536。通常APK包含一个classes.dex文件，因此Android应用的方法总数不能超过这个数量，这包括Android框架、类库和你自己开发的代码。</p>

<p>这个问题可以通过将一个DEX文件分拆成多个DEX文件解决。Facebook介绍了为Android应用开发的<a href="https://www.facebook.com/notes/facebook-engineering/under-the-hood-dalvik-patch-for-facebook-for-android/10151345597798920">Dalvik补丁</a>；Android Developers博客介绍了通过<a href="http://android-developers.blogspot.com/2011/07/custom-class-loading-in-dalvik.html">自定义类加载过程</a>的方法来解决此问题。但这些方法有些复杂而且并不优雅。</p>

<p>随着<a href="http://developer.android.com/tools/support-library/features.html#multidex">新的MultiDex支持库发布</a>，Google正式为解决此问题提供官方支持。<a href="http://developer.android.com/tools/building/multidex.html">构建超过65K方法数的应用</a>介绍了如何使用Gradle构建多DEX应用。</p>

<p>首先使用Android SDK Manager升级到最新的Android SDK Build Tools和Android Support Library R21。然后进行以下两步操作：</p>

<p>1.修改Gradle配置文件，启用MultiDex并包含MultiDex支持：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>android {
</span><span class='line'>    compileSdkVersion 21
</span><span class='line'>    buildToolsVersion "21.1.0"
</span><span class='line'>
</span><span class='line'>    defaultConfig {
</span><span class='line'>        ...
</span><span class='line'>        minSdkVersion 14
</span><span class='line'>        targetSdkVersion 21
</span><span class='line'>        ...
</span><span class='line'>
</span><span class='line'>        // Enabling multidex support.
</span><span class='line'>        multiDexEnabled true
</span><span class='line'>    }
</span><span class='line'>    ...
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>dependencies {
</span><span class='line'>  compile 'com.android.support:multidex:1.0.0'
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>2.让应用支持多DEX文件。在<a href="http://developer.android.com/reference/android/support/multidex/MultiDexApplication.html">MultiDexApplication JavaDoc</a>中描述了三种可选方法：</p>

<ul>
<li>在AndroidManifest.xml的application中声明android.support.multidex.MultiDexApplication；</li>
<li>如果你已经有自己的Application类，让其继承MultiDexApplication；</li>
<li>如果你的Application类已经继承自其它类，你不想/能修改它，那么可以重写attachBaseContext()方法：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Override
</span><span class='line'>protected void attachBaseContext(Context base) {
</span><span class='line'>    super.attachBaseContext(base);
</span><span class='line'>    MultiDex.install(this);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>经过以上步骤，你的应用已经可以实现多个DEX文件了。当应用构建时，构建工具会分析哪些类必须放在第一个DEX文件，哪些类可以放在附加的DEX文件中。当它创建了第一个DEX文件（classes.dex）后，如果必要会继续创建附加的DEX文件，如classes2.dex, classes3.dex。Multidex的支持类库将被包含在应用的第一个DEX文件中，帮助实现对其它DEX文件的访问。</p>

<p>文中还介绍了在开发多DEX应用时，通过设置productFlavors提高开发效率以及多DEX应用的测试方法。</p>

<p>Android 5.0和更高版本使用名为ART的运行时，它原生支持从APK文件加载多个DEX文件。在应用安装时，它会执行预编译，扫描classes(..N).dex文件然后将其编译成单个.oat文件用于执行。<a href="https://source.android.com/devices/tech/dalvik/art.html">了解更多关于ART的信息</a>。</p>

<p>虽然Google解决了应用总方法数限制的问题，但并不意味着开发者可以任意扩大项目规模。Multidex仍有一些限制：</p>

<ol>
<li>DEX文件安装到设备的过程非常复杂，如果第二个DEX文件太大，可能导致应用无响应。此时应该使用<a href="http://developer.android.com/tools/help/proguard.html">ProGuard</a>减小DEX文件的大小。</li>
<li>由于Dalvik linearAlloc的<a href="http://b.android.com/22586">Bug</a>，应用可能无法在Android 4.0之前的版本启动，如果你的应用要支持这些版本就要多执行测试。</li>
<li>同样因为Dalvik linearAlloc的限制，如果请求大量内存可能导致崩溃。Dalvik linearAlloc是一个固定大小的缓冲区。在应用的安装过程中，系统会运行一个名为dexopt的程序为该应用在当前机型中运行做准备。dexopt使用LinearAlloc来存储应用的方法信息。Android 2.2和2.3的缓冲区只有5MB，Android 4.x提高到了8MB或16MB。当方法数量过多导致超出缓冲区大小时，会造成dexopt崩溃。</li>
<li>Multidex构建工具还不支持指定哪些类必须包含在首个DEX文件中，因此可能会导致某些类库（例如某个类库需要从原生代码访问Java代码）无法使用。</li>
</ol>


<p>避免应用过大、方法过多仍然是Android开发者要注意的问题。Mihai Parparita的开源项目<a href="https://github.com/mihaip/dex-method-counts">dex-method-counts</a>可以用于统计APK中每个包的方法数量。</p>

<p>通常开发者自己的代码很难达到这样的方法数量限制，但随着第三方类库的加入，方法数就会迅速膨胀。因此选择合适的类库对Android开发者来说尤为重要。</p>

<p>开发者应该避免使用Google Guava这样的类库，它包含了13000多个方法。尽量使用专为移动应用设计的Lite/Android版本类库，或者使用小类库替换大类库，例如用<a href="https://code.google.com/p/google-gson/">Google-gson</a>替换Jackson JSON。而对于Google Protocol Buffers这样的数据交换格式，其标准实现会自动生成大量的方法。采用<a href="https://github.com/square/wire">Square Wire</a>的实现则可以很好地解决此问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最短路径]]></title>
    <link href="http://blog.ubone.com/blog/2014/11/03/zui-duan-lu-jing/"/>
    <updated>2014-11-03T20:22:31+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/11/03/zui-duan-lu-jing</id>
    <content type="html"><![CDATA[<p>最短路径算法可以解决很多问题，例如地图导航、任务调度和网络路由等。本章的主题就是找到从一个顶点到达另一个顶点的成本最小的路径。</p>

<blockquote><p>在一幅加权有向图中，从顶点s到顶点t的最短路径是所有从s到t的路径中的权重最小者。</p></blockquote>

<p>本章要涉及以下问题：</p>

<ul>
<li>加权有向图的API、单点最短路径的API及它们的实现；</li>
<li>解决边的权重非负的最短路径问题的经典Dijkstra算法；</li>
<li>在无环加权有向图中解决该问题的一种快速算法，边的权重甚至可以是负值；</li>
<li>适用于一般情况的经典Bellman-Ford算法，其中图可以含有环，边的权重也可以是负值。</li>
</ul>


<!--more-->


<h2>1. 最短路径的性质</h2>

<ul>
<li>路径是有向的；</li>
<li>权重不一定等价于距离，但示例图会用距离代表权重；</li>
<li>并不是所有顶点都是可达的；</li>
<li>负权重会使问题更复杂，暂时假定边的权重是非负的；</li>
<li>算法会忽略构成环的零权重边，找到的最短路径都不会含有环；</li>
<li>最短路径不一定是唯一的，只找到其中一条即可；</li>
<li>可能存在平行边和自环，为避免歧义假设不存在平行边，但代码处理它们并没有困难。</li>
</ul>


<p>单点最短路径的计算结果是一棵最短路径树（SPT），它包含了顶点s到达所有可达的顶点的最短路径。</p>

<blockquote><p>给定一幅加权有向图和一个顶点s，以s为起点的一棵最短路径树是图的一幅子图，它包含s和从s可达的所有顶点。这棵有向树的根结点是s，树的每条路径都是有向图中的一条最短路径。</p></blockquote>

<h2>2. 加权有向图的数据结构</h2>

<p>有向边的数据结构比无向边更简单，因为有向边只有一个方向。其API定义如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-04-directed-edge-api.png" alt="image" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DirectedEdge</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">v</span><span class="o">;</span>                <span class="c1">//边的起点</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">w</span><span class="o">;</span>                <span class="c1">//边的终点</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">weight</span><span class="o">;</span>        <span class="c1">//边的权重</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">DirectedEdge</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">,</span> <span class="kt">double</span> <span class="n">weight</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">IndexOutOfBoundsException</span><span class="o">(</span><span class="s">&quot;Vertex names must be nonnegative integers&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">w</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">IndexOutOfBoundsException</span><span class="o">(</span><span class="s">&quot;Vertex names must be nonnegative integers&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">Double</span><span class="o">.</span><span class="na">isNaN</span><span class="o">(</span><span class="n">weight</span><span class="o">))</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;Weight is NaN&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">weight</span> <span class="o">=</span> <span class="n">weight</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">from</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">v</span><span class="o">;}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">to</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">w</span><span class="o">;}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">weight</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">weight</span><span class="o">;}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">v</span> <span class="o">+</span> <span class="s">&quot;-&gt;&quot;</span> <span class="o">+</span> <span class="n">w</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&quot;%5.2f&quot;</span><span class="o">,</span> <span class="n">weight</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>加权有向图的API也与无向图类似：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-04-edge-weighted-digraph-api.png" alt="image" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EdgeWeightedDigraph</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">V</span><span class="o">;</span>                    <span class="c1">//顶点总数</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">E</span><span class="o">;</span>                          <span class="c1">//边的总数</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;[]</span> <span class="n">adj</span><span class="o">;</span>      <span class="c1">//邻接表</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">EdgeWeightedDigraph</span><span class="o">(</span><span class="kt">int</span> <span class="n">V</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">V</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;Number of vertices in a Digraph must be nonnegative&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">V</span> <span class="o">=</span> <span class="n">V</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">E</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>        <span class="n">adj</span> <span class="o">=</span> <span class="o">(</span><span class="n">Bag</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;[])</span> <span class="k">new</span> <span class="n">Bag</span><span class="o">[</span><span class="n">V</span><span class="o">];</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">V</span><span class="o">;</span> <span class="n">v</span><span class="o">++)</span>
</span><span class='line'>            <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">V</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">V</span><span class="o">;}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">E</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">E</span><span class="o">;}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//将e添加到有向图中</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addEdge</span><span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">adj</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">from</span><span class="o">()].</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>        <span class="n">E</span><span class="o">++;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//从v指出的边</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;</span> <span class="nf">adj</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//有向图中的所有边</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;</span> <span class="nf">edges</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Bag</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;();</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">V</span><span class="o">;</span> <span class="n">v</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>加权有向图的表示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-04-edge-weighted-digraph-representation.png" alt="image" /></p>

<h3>2.1 最短路径</h3>

<p>最短路径的API：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-04-sp-api.png" alt="image" /></p>

<p>在实现时，分别用两个数组来表示最短路径：</p>

<ul>
<li>最短路径树中的边：DirectedEdge[] edgeTo，edgeTo[v]的值为树中连接v和它的父结点的边。</li>
<li>到达起点的距离：Double[] distTo，distTo[v]为从起点s到v的已知最短路径的长度。</li>
</ul>


<p>同时约定edgeTo[s] == null, distTo[s] == 0; 不可达的顶点的距离为Double.POSITIVE_INFINITY。</p>

<h3>2.2 松弛操作</h3>

<p>松弛（Relaxation）操作是最短路径实现中使用的关键操作。对边v->w松弛意味着检查从s到w的最短路径是否是先从s到v，然后再由v到w。如果是，则由v到达w的最短路径是distTo[v] + e.weight()。如果这个值不小于distTo[w]，则证明刚才的边失效可忽略，否则证明现在的值更小，需要更新数据。</p>

<p>下图演示了这种情况，左侧的v->w不满足条件，被忽略。而右侧的图v->满足条件，替换为新的最短路径。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-04-relaxation-edge.png" alt="image" /></p>

<p>对顶点的松弛操作就是对该顶点指出的所有边进行松弛操作。每次顶点的松弛操作都能得出到达某个顶点的更短的路径。算法就这样最终找出到达每个顶点的最短路径。</p>

<h2>3. 最短路径算法的理论基础</h2>

<p>最短路径的最优性条件：</p>

<blockquote><p>令G为一幅加权有向图，顶点s是G中的起点，distTo[]是一个由顶点索引的数组，保存的是G中路径的长度。对于从s可达的所有顶点v，distTo[v]的值是从s到v的某条路径的长度，对于从s不可达的所有顶点v，该值为无穷大。当且仅当对于从v到w的任意一条边e, 这些值都满足distTo[w] &lt;= distTo[v] + e.weight()时，它们是最短路径的长度。</p></blockquote>

<p>根据最优性条件，我们可以得到一个通用算法，暂时只考虑非负权重的情况：</p>

<blockquote><p>将distTo[s]初始化为0，其它distTo[]元素初始化为无穷大，继续如下操作：放松G中的任意边，直到不存在有效边为止。对于任意从s可达的顶点w，进行这些操作后，distTo[w]的值即为从s到w的最短路径的长度。</p></blockquote>

<h2>4. Dijkstra算法</h2>

<p>Dijkstra算法能够解决边权重非负的加权有向图的单起点最短路径问题。它与无向图的最小生成树的Prim算法（每一步都向最小生成树中添加一条新的边）非常相似。首先将distTo[s]初始华为0，distTo[]的其他元素初始化为正无穷。然后<strong>将distTo[]最小的非树顶点放松并加入树中，如此这般，直到所有的顶点都在树中或者所有的非树顶点的distTo[]值均为无穷大。</strong></p>

<p>Dijkstra算法实现时，除了要distTo[]和edgeTo[]之外，还需要一条索引优先队列pa，以保存需要被放松的顶点并确认下一个被放松的顶点。只要将v和distTo[v]关联起来放入队列就可以立即实现Dijkstra算法。Prim算法每次添加的都是离树最近的非树顶点，而Dijkstra算法每次添加的都是离起点最近的非树顶点。如果将加权无向图看成加权有向图，对无向图中的每条边都相应地创建方向相反的有向边，最短路径的问题是等价的。Dijkstra算法实现实现如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DijkstraSP</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">double</span><span class="o">[]</span> <span class="n">distTo</span><span class="o">;</span>          <span class="c1">// distTo[v] = distance  of shortest s-&gt;v path</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">DirectedEdge</span><span class="o">[]</span> <span class="n">edgeTo</span><span class="o">;</span>    <span class="c1">// edgeTo[v] = last edge on shortest s-&gt;v path</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">IndexMinPQ</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;</span> <span class="n">pq</span><span class="o">;</span>    <span class="c1">// priority queue of vertices</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Computes a shortest paths tree from &lt;tt&gt;s&lt;/tt&gt; to every other vertex in</span>
</span><span class='line'><span class="cm">     * the edge-weighted digraph &lt;tt&gt;G&lt;/tt&gt;.</span>
</span><span class='line'><span class="cm">     * @param G the edge-weighted digraph</span>
</span><span class='line'><span class="cm">     * @param s the source vertex</span>
</span><span class='line'><span class="cm">     * @throws IllegalArgumentException if an edge weight is negative</span>
</span><span class='line'><span class="cm">     * @throws IllegalArgumentException unless 0 &amp;le; &lt;tt&gt;s&lt;/tt&gt; &amp;le; &lt;tt&gt;V&lt;/tt&gt; - 1</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">DijkstraSP</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">edges</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>                <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;edge &quot;</span> <span class="o">+</span> <span class="n">e</span> <span class="o">+</span> <span class="s">&quot; has negative weight&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">distTo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>        <span class="n">edgeTo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DirectedEdge</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
</span><span class='line'>            <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">POSITIVE_INFINITY</span><span class="o">;</span>
</span><span class='line'>        <span class="n">distTo</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// relax vertices in order of distance from s</span>
</span><span class='line'>        <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">IndexMinPQ</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;(</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">());</span>
</span><span class='line'>        <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">distTo</span><span class="o">[</span><span class="n">s</span><span class="o">]);</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">delMin</span><span class="o">();</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
</span><span class='line'>                <span class="n">relax</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// relax edge e and update pq if changed</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">relax</span><span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">from</span><span class="o">(),</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">();</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">();</span>
</span><span class='line'>            <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">pq</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">w</span><span class="o">))</span> <span class="n">pq</span><span class="o">.</span><span class="na">decreaseKey</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]);</span>
</span><span class='line'>            <span class="k">else</span>                <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Returns the length of a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;.</span>
</span><span class='line'><span class="cm">     * @param v the destination vertex</span>
</span><span class='line'><span class="cm">     * @return the length of a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;;</span>
</span><span class='line'><span class="cm">     *    &lt;tt&gt;Double.POSITIVE_INFINITY&lt;/tt&gt; if no such path</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">distTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Is there a path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;?</span>
</span><span class='line'><span class="cm">     * @param v the destination vertex</span>
</span><span class='line'><span class="cm">     * @return &lt;tt&gt;true&lt;/tt&gt; if there is a path from the source vertex</span>
</span><span class='line'><span class="cm">     *    &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;, and &lt;tt&gt;false&lt;/tt&gt; otherwise</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasPathTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">Double</span><span class="o">.</span><span class="na">POSITIVE_INFINITY</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Returns a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;.</span>
</span><span class='line'><span class="cm">     * @param v the destination vertex</span>
</span><span class='line'><span class="cm">     * @return a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;</span>
</span><span class='line'><span class="cm">     *    as an iterable of edges, and &lt;tt&gt;null&lt;/tt&gt; if no such path</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;</span> <span class="nf">pathTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(!</span><span class="n">hasPathTo</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;</span> <span class="n">path</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;();</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span> <span class="o">=</span> <span class="n">edgeTo</span><span class="o">[</span><span class="n">v</span><span class="o">];</span> <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">edgeTo</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">from</span><span class="o">()])</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">path</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">path</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>要解决<strong>加权有向图中给定两点（从s到t）的最短路径</strong>这个问题，只要使用Dijkstra算法并从优先队列中取到t之后终止搜索。</p>

<h2>5. 无环加权有向图中的最短路径算法</h2>

<p>如果加权有向图是不含有有向环的，那么可以采用一种比Dijkstra更快、更简单的最短路径算法。它能够在线性时间内解决单点最短路径问题，能够处理负权重的边，还能解决一些其它问题，如找出最长的路径。</p>

<p>根据在<a href="http://blog.ubone.com/blog/2014/10/30/you-xiang-tu/">有向图</a>中学习的拓扑顺序知识，我们知道一幅有向无环图的拓扑顺序就是所有顶点的逆后序排列。如果我们按照拓扑顺序放松顶点，就能在E+V成正比的时间内解决无环加权有向图的单点最短路径问题。代码实现如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AcyclicSP</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">double</span><span class="o">[]</span> <span class="n">distTo</span><span class="o">;</span>         <span class="c1">// distTo[v] = distance  of shortest s-&gt;v path</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">DirectedEdge</span><span class="o">[]</span> <span class="n">edgeTo</span><span class="o">;</span>   <span class="c1">// edgeTo[v] = last edge on shortest s-&gt;v path</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Computes a shortest paths tree from &lt;tt&gt;s&lt;/tt&gt; to every other vertex in</span>
</span><span class='line'><span class="cm">     * the directed acyclic graph &lt;tt&gt;G&lt;/tt&gt;.</span>
</span><span class='line'><span class="cm">     * @param G the acyclic digraph</span>
</span><span class='line'><span class="cm">     * @param s the source vertex</span>
</span><span class='line'><span class="cm">     * @throws IllegalArgumentException if the digraph is not acyclic</span>
</span><span class='line'><span class="cm">     * @throws IllegalArgumentException unless 0 &amp;le; &lt;tt&gt;s&lt;/tt&gt; &amp;le; &lt;tt&gt;V&lt;/tt&gt; - 1</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">AcyclicSP</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">distTo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>        <span class="n">edgeTo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DirectedEdge</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
</span><span class='line'>            <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">POSITIVE_INFINITY</span><span class="o">;</span>
</span><span class='line'>        <span class="n">distTo</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// visit vertices in toplogical order</span>
</span><span class='line'>        <span class="n">Topological</span> <span class="n">topological</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Topological</span><span class="o">(</span><span class="n">G</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(!</span><span class="n">topological</span><span class="o">.</span><span class="na">hasOrder</span><span class="o">())</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;Digraph is not acyclic.&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">topological</span><span class="o">.</span><span class="na">order</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
</span><span class='line'>                <span class="n">relax</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// relax edge e</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">relax</span><span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">from</span><span class="o">(),</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">();</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">();</span>
</span><span class='line'>            <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Returns the length of a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;.</span>
</span><span class='line'><span class="cm">     * @param v the destination vertex</span>
</span><span class='line'><span class="cm">     * @return the length of a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;;</span>
</span><span class='line'><span class="cm">     *    &lt;tt&gt;Double.POSITIVE_INFINITY&lt;/tt&gt; if no such path</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">distTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Is there a path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;?</span>
</span><span class='line'><span class="cm">     * @param v the destination vertex</span>
</span><span class='line'><span class="cm">     * @return &lt;tt&gt;true&lt;/tt&gt; if there is a path from the source vertex</span>
</span><span class='line'><span class="cm">     *    &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;, and &lt;tt&gt;false&lt;/tt&gt; otherwise</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasPathTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">Double</span><span class="o">.</span><span class="na">POSITIVE_INFINITY</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Returns a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;.</span>
</span><span class='line'><span class="cm">     * @param v the destination vertex</span>
</span><span class='line'><span class="cm">     * @return a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;</span>
</span><span class='line'><span class="cm">     *    as an iterable of edges, and &lt;tt&gt;null&lt;/tt&gt; if no such path</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;</span> <span class="nf">pathTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(!</span><span class="n">hasPathTo</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;</span> <span class="n">path</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;();</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span> <span class="o">=</span> <span class="n">edgeTo</span><span class="o">[</span><span class="n">v</span><span class="o">];</span> <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">edgeTo</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">from</span><span class="o">()])</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">path</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">path</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面这个算法的效率几乎已经没有提高的空间。<strong>在已知加权图是无环的情况下，它是找出最短路径的最好方法。</strong>而且它与边的权重是否非负无关，因此无环加权有向图不会受到任何限制。</p>

<h3>5.1 最长路径</h3>

<p><strong>无环加权有向图中的单点最长路径。</strong>给定一幅无环加权有向图（边的权重可能为负）和一个起点s，回答“是否存在一条从s到达给定的顶点v的路径？如果有，找出最长（总权重最大）的那条路径。”</p>

<p>最短路径的算法可以稍加改动就可以用于最长路径的计算。</p>

<ul>
<li>方法一：将无环加权有向图复制一份，将副本的所有边的权重取反数。这样副本中的最短路径即为原图中的最长路径。</li>
<li>方法二：改变AcyclicLP类中relax()方法中的不等式方向。这种方法更加简单。</li>
</ul>


<p>最长路径有什么意义？例如并行任务调度中的关键路径问题。关键路径是最长的任务序列，是任务调度中的关键手段。如何利用无环加权有向图计算关键路径？</p>

<blockquote><p>解决并行任务调度问题的关键路径方法的步骤如下：创建一幅无环加权有向图，其中包含一个起点s和一个终点t且每个任务都对应两个顶点（一个起点和一个结点顶点）。对于每个任务都有一条从它的起始顶点指向结束顶点的边，边的权重为任务所需的时间。对于每条优先级限制v->w，添加一条从v的结束顶点指向w的起始顶点的权重为零的边。为每个任务添加一条从起点指向该任务的起始顶点的权重为零的边以及一条从该任务的结束顶点到终点的权重为零的边。这样，每个任务预计的开始时间即为从起点到它的起始顶点的最长距离。</p></blockquote>

<p>下图展示了一个任务调度的无环加权有向图表示。共有0-9个任务，红线表示任务依赖关系（如任务1、7和9依赖于任务0）其权重为0，图形表示如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-05-scheduling-reduction.png" alt="image" /></p>

<p>通过计算最长路径，得到任务的关键路径：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-05-scheduling-critical-path.png" alt="image" /></p>

<p>最后期限是任务调度中常见的问题，即某个任务必须在指定的时间点之前开始，这种类型的问题如何解决？相对最后期限限制下的并行任务调度问题是一个加权有向图中的最短路径问题（可能存在环和负权重边）。这时可以为每条最后期限限制添加一条边：如果任务v必须在任务w启动后的d个时间单位内开始，则添加一条从v指向w的负权重为d的边。将所有边的权重取反即可将该问题转化为一个最短路径问题。</p>

<p>因此，负权重的边具有实际作用，但前面的算法Dijkstra只适用于非负权重的边，AcyclicSP要求有向图是无环的。它们都无法完成任务，因此需要一种更通用的方法。</p>

<h2>6. 一般加权有向图中的最短路径问题</h2>

<p>所谓一般加权有向图的最短路径问题，就是能够处理有环、负权重边的加权有向图最短路径问题。一幅加权有向图中包含环并不可怕，可怕的是这个环的总权重为负，这时候最短路径就会失去意义。因为无论何时绕这个环一圈都能得到权重更小的路径。<strong>负权重环</strong>就是这样一个总权重（环上的所有边的权重之和）为负的有向环。</p>

<blockquote><p>当且仅当加权有向图中至少存在一条从s到v的有向路径且所有从s到v的有向路径上的任意顶点都不存在于任何负权重环中时，s到v的最短路径才是存在的。</p></blockquote>

<p>Bellman-Ford算法，在任意含有V个顶点的加权有向图中给定起点s，从s无法到达任何负权重环，以下算法能够解决其中的单点最短路径问题：将distTo[s]初始化为0，其他distTo[]元素初始化为无穷大。以任意顺序放松有向图的所有边，重复V轮。</p>

<p>Bellman-Ford算法所需的时间和EV成正比，空间和V成正比。因为每一轮算法都会放松E条边，共重复了V轮。把这个算法稍加改进可以提高效率。每一轮放松所有边的过程中，许多边的放松都不会成功。只有上一轮中的distTo[]值发生变化的顶点指出的边才能够改变其他distTo[]元素的值。因此可以用FIFO队列记录这样的顶点，不需要放松所有边。代码实现如下（先忽略负权重环的代码）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BellmanFordSP</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">double</span><span class="o">[]</span> <span class="n">distTo</span><span class="o">;</span>               <span class="c1">// distTo[v] = 从起点到某个顶点的路径长度</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">DirectedEdge</span><span class="o">[]</span> <span class="n">edgeTo</span><span class="o">;</span>         <span class="c1">// edgeTo[v] = 从起点到某个顶点的最后一条边</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">onQueue</span><span class="o">;</span>             <span class="c1">// onQueue[v] = 该顶点是否存在于队列中</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">;</span>          <span class="c1">// 正在被放松的顶点</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">cost</span><span class="o">;</span>                      <span class="c1">// relax()的调用次数</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;</span> <span class="n">cycle</span><span class="o">;</span>  <span class="c1">// edgeTo[]是否有负权重环</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Computes a shortest paths tree from &lt;tt&gt;s&lt;/tt&gt; to every other vertex in</span>
</span><span class='line'><span class="cm">     * the edge-weighted digraph &lt;tt&gt;G&lt;/tt&gt;.</span>
</span><span class='line'><span class="cm">     * @param G the acyclic digraph</span>
</span><span class='line'><span class="cm">     * @param s the source vertex</span>
</span><span class='line'><span class="cm">     * @throws IllegalArgumentException unless 0 &amp;le; &lt;tt&gt;s&lt;/tt&gt; &amp;le; &lt;tt&gt;V&lt;/tt&gt; - 1</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">BellmanFordSP</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">distTo</span>  <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>        <span class="n">edgeTo</span>  <span class="o">=</span> <span class="k">new</span> <span class="n">DirectedEdge</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>        <span class="n">onQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
</span><span class='line'>            <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">POSITIVE_INFINITY</span><span class="o">;</span>
</span><span class='line'>        <span class="n">distTo</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Bellman-Ford algorithm</span>
</span><span class='line'>        <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
</span><span class='line'>        <span class="n">queue</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
</span><span class='line'>        <span class="n">onQueue</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hasNegativeCycle</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">dequeue</span><span class="o">();</span>
</span><span class='line'>            <span class="n">onQueue</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>            <span class="n">relax</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// relax vertex v and put other endpoints on queue if changed</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">relax</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">();</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>                <span class="c1">//成功放松的边指向的所有顶点加入到FIFO队列</span>
</span><span class='line'>                <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">();</span>
</span><span class='line'>                <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(!</span><span class="n">onQueue</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">queue</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
</span><span class='line'>                    <span class="n">onQueue</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="c1">//周期性地检查是否有负权重环，避免无限循环</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">cost</span><span class="o">++</span> <span class="o">%</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>                <span class="n">findNegativeCycle</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Is there a negative cycle reachable from the source vertex &lt;tt&gt;s&lt;/tt&gt;?</span>
</span><span class='line'><span class="cm">     * @return &lt;tt&gt;true&lt;/tt&gt; if there is a negative cycle reachable from the</span>
</span><span class='line'><span class="cm">     *    source vertex &lt;tt&gt;s&lt;/tt&gt;, and &lt;tt&gt;false&lt;/tt&gt; otherwise</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNegativeCycle</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">cycle</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Returns a negative cycle reachable from the source vertex &lt;tt&gt;s&lt;/tt&gt;, or &lt;tt&gt;null&lt;/tt&gt;</span>
</span><span class='line'><span class="cm">     * if there is no such cycle.</span>
</span><span class='line'><span class="cm">     * @return a negative cycle reachable from the soruce vertex &lt;tt&gt;s&lt;/tt&gt; </span>
</span><span class='line'><span class="cm">     *    as an iterable of edges, and &lt;tt&gt;null&lt;/tt&gt; if there is no such cycle</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;</span> <span class="nf">negativeCycle</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">cycle</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// by finding a cycle in predecessor graph</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">findNegativeCycle</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">V</span> <span class="o">=</span> <span class="n">edgeTo</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
</span><span class='line'>        <span class="n">EdgeWeightedDigraph</span> <span class="n">spt</span> <span class="o">=</span> <span class="k">new</span> <span class="n">EdgeWeightedDigraph</span><span class="o">(</span><span class="n">V</span><span class="o">);</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">V</span><span class="o">;</span> <span class="n">v</span><span class="o">++)</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">edgeTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>                <span class="n">spt</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="n">edgeTo</span><span class="o">[</span><span class="n">v</span><span class="o">]);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">EdgeWeightedDirectedCycle</span> <span class="n">finder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">EdgeWeightedDirectedCycle</span><span class="o">(</span><span class="n">spt</span><span class="o">);</span>
</span><span class='line'>        <span class="n">cycle</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="na">cycle</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Returns the length of a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;.</span>
</span><span class='line'><span class="cm">     * @param v the destination vertex</span>
</span><span class='line'><span class="cm">     * @return the length of a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;;</span>
</span><span class='line'><span class="cm">     *    &lt;tt&gt;Double.POSITIVE_INFINITY&lt;/tt&gt; if no such path</span>
</span><span class='line'><span class="cm">     * @throws UnsupportedOperationException if there is a negative cost cycle reachable</span>
</span><span class='line'><span class="cm">     *    from the source vertex &lt;tt&gt;s&lt;/tt&gt;</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">distTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">hasNegativeCycle</span><span class="o">())</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">UnsupportedOperationException</span><span class="o">(</span><span class="s">&quot;Negative cost cycle exists&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Is there a path from the source &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;?</span>
</span><span class='line'><span class="cm">     * @param v the destination vertex</span>
</span><span class='line'><span class="cm">     * @return &lt;tt&gt;true&lt;/tt&gt; if there is a path from the source vertex</span>
</span><span class='line'><span class="cm">     *    &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;, and &lt;tt&gt;false&lt;/tt&gt; otherwise</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasPathTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">Double</span><span class="o">.</span><span class="na">POSITIVE_INFINITY</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Returns a shortest path from the source &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;.</span>
</span><span class='line'><span class="cm">     * @param v the destination vertex</span>
</span><span class='line'><span class="cm">     * @return a shortest path from the source &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;</span>
</span><span class='line'><span class="cm">     *    as an iterable of edges, and &lt;tt&gt;null&lt;/tt&gt; if no such path</span>
</span><span class='line'><span class="cm">     * @throws UnsupportedOperationException if there is a negative cost cycle reachable</span>
</span><span class='line'><span class="cm">     *    from the source vertex &lt;tt&gt;s&lt;/tt&gt;</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;</span> <span class="nf">pathTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">hasNegativeCycle</span><span class="o">())</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">UnsupportedOperationException</span><span class="o">(</span><span class="s">&quot;Negative cost cycle exists&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(!</span><span class="n">hasPathTo</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;</span> <span class="n">path</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;();</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span> <span class="o">=</span> <span class="n">edgeTo</span><span class="o">[</span><span class="n">v</span><span class="o">];</span> <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">edgeTo</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">from</span><span class="o">()])</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">path</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">path</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>6.1 负权重环的检测</h3>

<p>BellmanFordSP的实现会检测负权重环来避免陷入无限循环。当BellmanFordSP构造函数运行之后，将所有边放松V轮之后当且仅当队列非空时有向图中才存在从起点可达的负权重环。如果是这样，edgeTo[]数组中所表示的子图必然含有这个负权重环。因此nagativeCycle()的实现中，会根据edgeTo[]中的边构造一幅加权有向图并在该图中检测环。我们修改DirectedCycle类来在加权有向图中寻找环：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EdgeWeightedDirectedCycle</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>             <span class="c1">// marked[v] = has vertex v been marked?</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">DirectedEdge</span><span class="o">[]</span> <span class="n">edgeTo</span><span class="o">;</span>        <span class="c1">// edgeTo[v] = previous edge on path to v</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">onStack</span><span class="o">;</span>            <span class="c1">// onStack[v] = is vertex on the stack?</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;</span> <span class="n">cycle</span><span class="o">;</span>    <span class="c1">// directed cycle (or null if no such cycle)</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Determines whether the edge-weighted digraph &lt;tt&gt;G&lt;/tt&gt; has a directed cycle and,</span>
</span><span class='line'><span class="cm">     * if so, finds such a cycle.</span>
</span><span class='line'><span class="cm">     * @param G the edge-weighted digraph</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">EdgeWeightedDirectedCycle</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">marked</span>  <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>        <span class="n">onStack</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>        <span class="n">edgeTo</span>  <span class="o">=</span> <span class="k">new</span> <span class="n">DirectedEdge</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">])</span> <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// check that algorithm computes either the topological order or finds a directed cycle</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">onStack</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// short circuit if directed cycle found</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">cycle</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">//found new vertex, so recur</span>
</span><span class='line'>            <span class="k">else</span> <span class="nf">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span><span class='line'>                <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// trace back directed cycle</span>
</span><span class='line'>            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">onStack</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">cycle</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;();</span>
</span><span class='line'>                <span class="k">while</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">from</span><span class="o">()</span> <span class="o">!=</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">cycle</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>                    <span class="n">e</span> <span class="o">=</span> <span class="n">edgeTo</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">from</span><span class="o">()];</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>                <span class="n">cycle</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">onStack</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Does the edge-weighted digraph have a directed cycle?</span>
</span><span class='line'><span class="cm">     * @return &lt;tt&gt;true&lt;/tt&gt; if the edge-weighted digraph has a directed cycle,</span>
</span><span class='line'><span class="cm">     * &lt;tt&gt;false&lt;/tt&gt; otherwise</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasCycle</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">cycle</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Returns a directed cycle if the edge-weighted digraph has a directed cycle,</span>
</span><span class='line'><span class="cm">     * and &lt;tt&gt;null&lt;/tt&gt; otherwise.</span>
</span><span class='line'><span class="cm">     * @return a directed cycle (as an iterable) if the edge-weighted digraph</span>
</span><span class='line'><span class="cm">     *    has a directed cycle, and &lt;tt&gt;null&lt;/tt&gt; otherwise</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;</span> <span class="nf">cycle</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">cycle</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>6.2 套汇</h3>

<p>前面的问题都是权重之和，而套汇问题演示了另一种方式。套汇是通过不同货币间进行兑换赚取利润。这也是一个加权有向图的应用。顶点是货币，s->t表示货币s到t的汇率。如何交易使得利润最大，就是找到各权重之<strong>积</strong>最大者。但我们之前所学的都是权重之和，那么如何解决这个问题呢？</p>

<p>套汇问题等价于加权有向图中的负权重环的检测问题：</p>

<blockquote><p>取每条边权重的自然对数并取反，这样在原始问题中所有边的权重之积的计算就转化为新图中所有边的权重之和的计算。任意权重之积 w<sub>1</sub>w<sub>2</sub>&hellip;w<sub>k</sub>即对应-ln(w<sub>1</sub>)-ln(w<sub>2</sub>)&ndash;&hellip;-ln(w<sub>k</sub>)之和。转换后边的权重可能为正也可能为负。一条从v到w的路径表示将货币v兑换为货币w，任意负权重环都是一次套汇的好机会。</p></blockquote>

<h2>7. 总结</h2>

<p>最短路径算法的性能特点如下表：</p>

<table>
<thead>
<tr>
<th>算法</th>
<th>局限</th>
<th>一般情况</th>
<th>最坏情况</th>
<th>所需空间</th>
<th> 优势</th>
</tr>
</thead>
<tbody>
<tr>
<td>Dijkstra算法（即时版本） </td>
<td> 边的权重必须为正 </td>
<td> ElogV </td>
<td> ElogV </td>
<td> V </td>
<td> 最坏情况下仍有较好的性能</td>
</tr>
<tr>
<td>拓扑排序</td>
<td> 只适用于无环加权有向图</td>
<td> E + V </td>
<td> E + V </td>
<td> V </td>
<td> 是无环图中的最优算法</td>
</tr>
<tr>
<td>Bellman-Ford算法（基于队列）</td>
<td>不能存在负权重环</td>
<td> E+V </td>
<td> EV </td>
<td> V</td>
<td> 适用领域广泛</td>
</tr>
</tbody>
</table>


<p>参考：<a href="http://algs4.cs.princeton.edu/44sp/">http://algs4.cs.princeton.edu/44sp/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最小生成树]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/31/zui-xiao-sheng-cheng-shu/"/>
    <updated>2014-10-31T22:38:49+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/31/zui-xiao-sheng-cheng-shu</id>
    <content type="html"><![CDATA[<p>加权图是一种为每条边关联一个权值或成本的图模型。这种图最令人感兴趣的是将成本最小化。本节学习加权无向图模型并找到它的一棵最小生成树。</p>

<p>图的生成树是它的一棵含有其所有顶点的无环连通子图。一幅加权图的最小生成树（MST）是它的一棵权值（树中所有边的权值之和）最小的生成树。</p>

<!--more-->


<h2>1. 一些约定</h2>

<p>为了方便说明，有以下这些约定：</p>

<ul>
<li>只考虑连通图。如果图是非连通的，只能计算它的所有连通分量的最小生成树，合并起来称为最小生成森林。</li>
<li>边的权重不一定表示距离。但为了看起来方便，示意图会用距离来表示权重。</li>
<li>边的权重可能是0或者负数。</li>
<li>所有边的权重都各不相同。如果权重可以相同，最小生成树就不一定唯一，算法证明会更复杂。但实际上算法也适用于存在权重相等的情况。</li>
</ul>


<h2>2. 原理</h2>

<p>图的一种<strong>切分</strong>是将图的所有顶点分为两个非空且不重叠的两个集合。<strong>横切边</strong>是一条连接两个属于不同集合的顶点的边。</p>

<blockquote><p>切分定理：在一幅加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图的最小生成树。</p></blockquote>

<p>切分定理会把加权图中的所有顶点分为两个集合，检查横跨两个集合的所有边并识别哪边边应属于图的最小生成树。</p>

<h2>3. 加权无向图的数据结构</h2>

<p>通过扩展无向图的邻接矩阵来表示加权无向图。在无向图的邻接表表示中，第v个顶点的列表中每个元素都是和顶点v相邻的顶点。在加权无向图中，我们将其替换为一个加权边Edge：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-02-edge-api.png" alt="image" /></p>

<p>上图中，eaither()表示边的两个顶点中的某一个，而other()则返回另一个顶点。有了加权边Edge，加权无向图的API就与无向图非常接近，在实现上，只是在邻接表中用Edge对象替代了无向图Graph中的整数作为链表的结点：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-02-edge-weighted-graph-api.png" alt="image" /></p>

<p>加权无向图的表示如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-02-edge-weighted-graph-representation.png" alt="image" /></p>

<p>代码实现如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Edge</span> <span class="kd">implements</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">v</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">w</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">weight</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Edge</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">,</span> <span class="kt">double</span> <span class="n">weight</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">IndexOutOfBoundsException</span><span class="o">(</span><span class="s">&quot;Vertex name must be a nonnegative integer&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">w</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">IndexOutOfBoundsException</span><span class="o">(</span><span class="s">&quot;Vertex name must be a nonnegative integer&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">Double</span><span class="o">.</span><span class="na">isNaN</span><span class="o">(</span><span class="n">weight</span><span class="o">))</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;Weight is NaN&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">weight</span> <span class="o">=</span> <span class="n">weight</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">weight</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">weight</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">either</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">v</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">other</span><span class="o">(</span><span class="kt">int</span> <span class="n">vertex</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span>      <span class="o">(</span><span class="n">vertex</span> <span class="o">==</span> <span class="n">v</span><span class="o">)</span> <span class="k">return</span> <span class="n">w</span><span class="o">;</span>
</span><span class='line'>        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">vertex</span> <span class="o">==</span> <span class="n">w</span><span class="o">)</span> <span class="k">return</span> <span class="n">v</span><span class="o">;</span>
</span><span class='line'>        <span class="k">else</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;Illegal endpoint&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="n">Edge</span> <span class="n">that</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span>      <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">weight</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">that</span><span class="o">.</span><span class="na">weight</span><span class="o">())</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
</span><span class='line'>        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">weight</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">that</span><span class="o">.</span><span class="na">weight</span><span class="o">())</span> <span class="k">return</span> <span class="o">+</span><span class="mi">1</span><span class="o">;</span>
</span><span class='line'>        <span class="k">else</span>                                    <span class="k">return</span>  <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&quot;%d-%d %.5f&quot;</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span> <span class="n">weight</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EdgeWeightedGraph</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">V</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">E</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;[]</span> <span class="n">adj</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Initializes an empty edge-weighted graph with &lt;tt&gt;V&lt;/tt&gt; vertices and 0 edges.</span>
</span><span class='line'><span class="cm">     * param V the number of vertices</span>
</span><span class='line'><span class="cm">     * @throws java.lang.IllegalArgumentException if &lt;tt&gt;V&lt;/tt&gt; &lt; 0</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">EdgeWeightedGraph</span><span class="o">(</span><span class="kt">int</span> <span class="n">V</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">V</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;Number of vertices must be nonnegative&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">V</span> <span class="o">=</span> <span class="n">V</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">E</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>        <span class="n">adj</span> <span class="o">=</span> <span class="o">(</span><span class="n">Bag</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;[])</span> <span class="k">new</span> <span class="n">Bag</span><span class="o">[</span><span class="n">V</span><span class="o">];</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">V</span><span class="o">;</span> <span class="n">v</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Initializes a random edge-weighted graph with &lt;tt&gt;V&lt;/tt&gt; vertices and &lt;em&gt;E&lt;/em&gt; edges.</span>
</span><span class='line'><span class="cm">     * param V the number of vertices</span>
</span><span class='line'><span class="cm">     * param E the number of edges</span>
</span><span class='line'><span class="cm">     * @throws java.lang.IllegalArgumentException if &lt;tt&gt;V&lt;/tt&gt; &lt; 0</span>
</span><span class='line'><span class="cm">     * @throws java.lang.IllegalArgumentException if &lt;tt&gt;E&lt;/tt&gt; &lt; 0</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">EdgeWeightedGraph</span><span class="o">(</span><span class="kt">int</span> <span class="n">V</span><span class="o">,</span> <span class="kt">int</span> <span class="n">E</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">(</span><span class="n">V</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">E</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;Number of edges must be nonnegative&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">E</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="n">V</span><span class="o">);</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="n">V</span><span class="o">);</span>
</span><span class='line'>            <span class="kt">double</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">round</span><span class="o">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">Math</span><span class="o">.</span><span class="na">random</span><span class="o">())</span> <span class="o">/</span> <span class="mf">100.0</span><span class="o">;</span>
</span><span class='line'>            <span class="n">Edge</span> <span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Edge</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span> <span class="n">weight</span><span class="o">);</span>
</span><span class='line'>            <span class="n">addEdge</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**  </span>
</span><span class='line'><span class="cm">     * Initializes an edge-weighted graph from an input stream.</span>
</span><span class='line'><span class="cm">     * The format is the number of vertices &lt;em&gt;V&lt;/em&gt;,</span>
</span><span class='line'><span class="cm">     * followed by the number of edges &lt;em&gt;E&lt;/em&gt;,</span>
</span><span class='line'><span class="cm">     * followed by &lt;em&gt;E&lt;/em&gt; pairs of vertices and edge weights,</span>
</span><span class='line'><span class="cm">     * with each entry separated by whitespace.</span>
</span><span class='line'><span class="cm">     * @param in the input stream</span>
</span><span class='line'><span class="cm">     * @throws java.lang.IndexOutOfBoundsException if the endpoints of any edge are not in prescribed range</span>
</span><span class='line'><span class="cm">     * @throws java.lang.IllegalArgumentException if the number of vertices or edges is negative</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">EdgeWeightedGraph</span><span class="o">(</span><span class="n">In</span> <span class="n">in</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="na">readInt</span><span class="o">());</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">E</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">E</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;Number of edges must be nonnegative&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">E</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>
</span><span class='line'>            <span class="kt">double</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readDouble</span><span class="o">();</span>
</span><span class='line'>            <span class="n">Edge</span> <span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Edge</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span> <span class="n">weight</span><span class="o">);</span>
</span><span class='line'>            <span class="n">addEdge</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Initializes a new edge-weighted graph that is a deep copy of &lt;tt&gt;G&lt;/tt&gt;.</span>
</span><span class='line'><span class="cm">     * @param G the edge-weighted graph to copy</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">EdgeWeightedGraph</span><span class="o">(</span><span class="n">EdgeWeightedGraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">(</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">());</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">E</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="na">E</span><span class="o">();</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">// reverse so that adjacency list is in same order as original</span>
</span><span class='line'>            <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">reverse</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;();</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="n">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">[</span><span class="n">v</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">reverse</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="n">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">reverse</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//图的顶点数</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">V</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">V</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//图的边数</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">E</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">E</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//向图中添加一条边e</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addEdge</span><span class="o">(</span><span class="n">Edge</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">either</span><span class="o">();</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">other</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="n">V</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">IndexOutOfBoundsException</span><span class="o">(</span><span class="s">&quot;vertex &quot;</span> <span class="o">+</span> <span class="n">v</span> <span class="o">+</span> <span class="s">&quot; is not between 0 and &quot;</span> <span class="o">+</span> <span class="o">(</span><span class="n">V</span><span class="o">-</span><span class="mi">1</span><span class="o">));</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">w</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">w</span> <span class="o">&gt;=</span> <span class="n">V</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">IndexOutOfBoundsException</span><span class="o">(</span><span class="s">&quot;vertex &quot;</span> <span class="o">+</span> <span class="n">w</span> <span class="o">+</span> <span class="s">&quot; is not between 0 and &quot;</span> <span class="o">+</span> <span class="o">(</span><span class="n">V</span><span class="o">-</span><span class="mi">1</span><span class="o">));</span>
</span><span class='line'>        <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>        <span class="n">adj</span><span class="o">[</span><span class="n">w</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>        <span class="n">E</span><span class="o">++;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//与v相关联的所有边</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="nf">adj</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="n">V</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">IndexOutOfBoundsException</span><span class="o">(</span><span class="s">&quot;vertex &quot;</span> <span class="o">+</span> <span class="n">v</span> <span class="o">+</span> <span class="s">&quot; is not between 0 and &quot;</span> <span class="o">+</span> <span class="o">(</span><span class="n">V</span><span class="o">-</span><span class="mi">1</span><span class="o">));</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//图中的所有边</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="nf">edges</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;();</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">V</span><span class="o">;</span> <span class="n">v</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">selfLoops</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="n">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">other</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>                <span class="c1">// only add one copy of each self loop (self loops will be consecutive)</span>
</span><span class='line'>                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">other</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">==</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                    <span class="k">if</span> <span class="o">(</span><span class="n">selfLoops</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>                    <span class="n">selfLoops</span><span class="o">++;</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">NEWLINE</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">&quot;line.separator&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="n">StringBuilder</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
</span><span class='line'>        <span class="n">s</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">V</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">E</span> <span class="o">+</span> <span class="n">NEWLINE</span><span class="o">);</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">V</span><span class="o">;</span> <span class="n">v</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">s</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">v</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="n">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">s</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">e</span> <span class="o">+</span> <span class="s">&quot;  &quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="n">s</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">NEWLINE</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>4. 最小生成树的API及实现</h2>

<p>下面API定义的构造函数接受加权无向图作为参数，并返回最小生成树和其权重。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-02-mst-api.png" alt="image" /></p>

<p>Prim算法和Kruskal算法都可以实现最小生成树，它们都基于贪心算法，区别在于保存切分和判定权重最小的横切边的方式。</p>

<blockquote><p>贪心算法：初始状态下所有边均为灰色，找到一种切分，它产生的横切边均不为黑色。将权重最小的横切边标记为黑色。反复这个步骤直到标记了V-1条黑色边为止。</p></blockquote>

<h3>4.1 Prim算法</h3>

<p>Prim算法每一步都会为一棵生长中的树添加一条边。一开始这棵树只有一个顶点，然后会向它添加V-1条边，每次总是找到这样一条边并将其加入树中：这条边的一端在树中，另一端不在树中，并且权值最小。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-02-prim-eager.png" alt="image" /></p>

<p>每当向树中添加一条边后，也向树中添加了一个顶点。要维护一个包含所有横切边的集合，可以将连接这个顶点和其他所有不在树中的顶点的边加入优先队列。这样就可以得到符合条件的权值最小的边。当一个顶点加入树中后，连接这个顶点与树中其它顶点的所有边就失效了，因为这些边的两个顶点都已经在树中，这些边不再是横切边。那么何时删除这些边就形成了Prim算法的两种实现：</p>

<ul>
<li>延时(Lazy)实现会先把它们留在队列中，等要删除时再检查边的有效性；</li>
<li>即时实现可以将它们从优先队列中删除。</li>
</ul>


<p>这两种实现所需的时间都与ElogE成正比（最坏情况下），延时实现所需的空间与E成正比，瓶颈在于优先队列的insert()和delMin()中比较边的权重次数。而即时实现所需空间的上限与V成正比，比延时实现有优势。两种实现代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LazyPrimMST</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">double</span> <span class="n">weight</span><span class="o">;</span>       <span class="c1">// total weight of MST</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">mst</span><span class="o">;</span>     <span class="c1">// edges in the MST</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>    <span class="c1">// marked[v] = true if v on tree</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">MinPQ</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">pq</span><span class="o">;</span>      <span class="c1">// edges with one endpoint in tree</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Compute a minimum spanning tree (or forest) of an edge-weighted graph.</span>
</span><span class='line'><span class="cm">     * @param G the edge-weighted graph</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">LazyPrimMST</span><span class="o">(</span><span class="n">EdgeWeightedGraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">mst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;();</span>
</span><span class='line'>        <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MinPQ</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;();</span>
</span><span class='line'>        <span class="n">marked</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>     <span class="c1">// run Prim from all vertices to</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">])</span> <span class="n">prim</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>     <span class="c1">// get a minimum spanning forest</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// run Prim&#39;s algorithm</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">prim</span><span class="o">(</span><span class="n">EdgeWeightedGraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">scan</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>                        <span class="c1">// better to stop when mst has V-1 edges</span>
</span><span class='line'>            <span class="n">Edge</span> <span class="n">e</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">delMin</span><span class="o">();</span>                      <span class="c1">// smallest edge on pq</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">either</span><span class="o">(),</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">other</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>        <span class="c1">// two endpoints</span>
</span><span class='line'>            <span class="k">assert</span> <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">||</span> <span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">];</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="k">continue</span><span class="o">;</span>      <span class="c1">// lazy, both v and w already scanned</span>
</span><span class='line'>            <span class="n">mst</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>                            <span class="c1">// add e to MST</span>
</span><span class='line'>            <span class="n">weight</span> <span class="o">+=</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">();</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">])</span> <span class="n">scan</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>               <span class="c1">// v becomes part of tree</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="n">scan</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>               <span class="c1">// w becomes part of tree</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//标记顶点v并将所有连接v和未被标记顶点的边加入pq</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">scan</span><span class="o">(</span><span class="n">EdgeWeightedGraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">assert</span> <span class="o">!</span><span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>
</span><span class='line'>        <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">other</span><span class="o">(</span><span class="n">v</span><span class="o">)])</span> <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//树的所有边</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="nf">edges</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">mst</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//树的权重</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">weight</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">weight</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PrimMST</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Edge</span><span class="o">[]</span> <span class="n">edgeTo</span><span class="o">;</span>        <span class="c1">// 距离树最近的边，edgeTo[v] = shortest edge from tree vertex to non-tree vertex</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">double</span><span class="o">[]</span> <span class="n">distTo</span><span class="o">;</span>      <span class="c1">// distTo[v] = weight of shortest such edge</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>     <span class="c1">// marked[v] = true if v on tree, false otherwise</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">IndexMinPQ</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;</span> <span class="n">pq</span><span class="o">;</span>  <span class="c1">//有效的横切边</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Compute a minimum spanning tree (or forest) of an edge-weighted graph.</span>
</span><span class='line'><span class="cm">     * @param G the edge-weighted graph</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">PrimMST</span><span class="o">(</span><span class="n">EdgeWeightedGraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">edgeTo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Edge</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>        <span class="n">distTo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>        <span class="n">marked</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>        <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">IndexMinPQ</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;(</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">());</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">POSITIVE_INFINITY</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>      <span class="c1">// run from each vertex to find</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">])</span> <span class="n">prim</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>      <span class="c1">// minimum spanning forest</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// run Prim&#39;s algorithm in graph G, starting from vertex s</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">prim</span><span class="o">(</span><span class="n">EdgeWeightedGraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">distTo</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span>
</span><span class='line'>        <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">distTo</span><span class="o">[</span><span class="n">s</span><span class="o">]);</span> <span class="c1">//用顶点0和权重0初始化pq</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">delMin</span><span class="o">();</span>
</span><span class='line'>            <span class="n">scan</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>          <span class="c1">//将最近的顶点添加到树中</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// scan vertex v</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">scan</span><span class="o">(</span><span class="n">EdgeWeightedGraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="c1">//将顶点v添加到树中，更新数据</span>
</span><span class='line'>        <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">other</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="k">continue</span><span class="o">;</span>         <span class="c1">// v-w 已经失效</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>                  <span class="c1">//连接w和树的最佳边Edge变为e</span>
</span><span class='line'>                <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">();</span>
</span><span class='line'>                <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">pq</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">w</span><span class="o">))</span> <span class="n">pq</span><span class="o">.</span><span class="na">decreaseKey</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]);</span>
</span><span class='line'>                <span class="k">else</span>                <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//所有边</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="nf">edges</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">mst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;();</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">edgeTo</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">v</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">Edge</span> <span class="n">e</span> <span class="o">=</span> <span class="n">edgeTo</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">mst</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">mst</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//权重</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">weight</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">double</span> <span class="n">weight</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">edges</span><span class="o">())</span>
</span><span class='line'>            <span class="n">weight</span> <span class="o">+=</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">();</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">weight</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>4.2 Kruskal算法</h3>

<p>Kruskal算法构造最小生成树时也是一条边一条边地构造，但它寻找的边会连接一片森林中的两棵树。我们从一片由V棵单顶点的树构成的森林开始并不断将两棵树合并（用可以找到的最短边）直到只剩下一棵树。其主要思想是按边的权重顺序处理它们，将边加入最小生成树中，加入的边不会与已经加入的边构成环，直到树中含有V-1条边为止。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-02-kruskal.png" alt="image" /></p>

<p>实现时，采用优先队列将边按照权重排序，用一个union-find数据结构识别会形成环的边，以及一个队列来保存最小生成树的所有边。代码实现如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">KruskalMST</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">double</span> <span class="n">weight</span><span class="o">;</span>  <span class="c1">// weight of MST</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">mst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;();</span>  <span class="c1">// edges in MST</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">KruskalMST</span><span class="o">(</span><span class="n">EdgeWeightedGraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// more efficient to build heap by passing array of edges</span>
</span><span class='line'>        <span class="n">MinPQ</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MinPQ</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;();</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">edges</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// run greedy algorithm</span>
</span><span class='line'>        <span class="n">UF</span> <span class="n">uf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">UF</span><span class="o">(</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">());</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">mst</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">Edge</span> <span class="n">e</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">delMin</span><span class="o">();</span>  <span class="c1">//从pq得到权重最小的边和它的顶点</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">either</span><span class="o">();</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">other</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(!</span><span class="n">uf</span><span class="o">.</span><span class="na">connected</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// v-w does not create a cycle</span>
</span><span class='line'>                <span class="n">uf</span><span class="o">.</span><span class="na">union</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>  <span class="c1">// merge v and w components</span>
</span><span class='line'>                <span class="n">mst</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>  <span class="c1">// add edge e to mst</span>
</span><span class='line'>                <span class="n">weight</span> <span class="o">+=</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">();</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//树的所有边</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="nf">edges</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">mst</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//树的权重</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">weight</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">weight</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Kruskal算法所需的空间与E成正比，所需时间与ElogE成正比（最坏情况下）。</p>

<p>Prim和Kruskal算法不能处理有向图。</p>

<p>参考：<a href="http://algs4.cs.princeton.edu/43mst/">http://algs4.cs.princeton.edu/43mst</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[有向图]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/30/you-xiang-tu/"/>
    <updated>2014-10-30T20:10:54+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/30/you-xiang-tu</id>
    <content type="html"><![CDATA[<p>有向图也就是有方向性的图，是由一组顶点和一组有方向的边组成，每条有方向的边都连接着有序的一对顶点。本文要解决的有向图问题：</p>

<ol>
<li>单点和多点的可达性</li>
<li>单点有向路径</li>
<li>单点最短有向路径</li>
<li>有向环检测</li>
<li>深度优先的顶点排序</li>
<li>优先级限制下的调度问题</li>
<li>拓扑排序</li>
<li>强连通性</li>
<li>顶点对的可达性</li>
</ol>


<!--more-->


<h2>1. 术语</h2>

<ul>
<li>出度：一个顶点指出的边的总数；</li>
<li>入度：指向该顶点的边的总数；</li>
<li>一条有向边的第一个顶点称为头，第二个顶点称为尾。</li>
<li>在一幅有向图中，有向路径由一系列顶点组成，对于其中的每个顶点都存在一条有向边从它指向序列中的下一个顶点。</li>
</ul>


<h2>2. 有向图的数据类型</h2>

<p>有向图的API与无向图本质相同，只是多了一个取反操作。如下图：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-20-digraph-api.png" alt="image" /></p>

<p>其中，reverse()方向返回有向图的一个副本，但是将其中的方向反转。adj()返回的是每个顶点指出的边所连接的所有顶点。</p>

<p>Diagraph的实现与无向图Graph非常类似，也是采用邻接表实现，但由于边是有向的，所以假设7&mdash;>8的一条边，则在顶点7的邻接表中有8，而顶点8的邻接表却没有7. <a href="http://algs4.cs.princeton.edu/42directed/Digraph.java.html">实现代码</a>不再重复。</p>

<h2>3. 有向图中的可达性</h2>

<ul>
<li>单点可达性：是否存在一条从s到达给定顶点v的有向路径？</li>
<li>多点可达性：是否存在一条从集合中的任意顶点到达给定顶点v的有向路径？</li>
</ul>


<p>API定义和实现如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class DirectedDFS {
</span><span class='line'>  private boolean[] marked;
</span><span class='line'>  
</span><span class='line'>  //在G中找到从s可达的所有顶点
</span><span class='line'>  public DirectedDFS(Digraph G, int s) {
</span><span class='line'>      marked = new boolean[G.V()];
</span><span class='line'>      dfs(G, s);
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  //在G中找到从sources中的所有顶点可达的所有顶点
</span><span class='line'>  public DirectedDFS(Digraph G, Iterable&lt;Integer&gt; sources) {
</span><span class='line'>      marked = new boolean[G.V()];
</span><span class='line'>      for(int s : sources) {
</span><span class='line'>          if (! marked[s]) dfs(G, s);
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  private void dfs(Digraph G, int v) {
</span><span class='line'>      marked[v] = true;
</span><span class='line'>      for(int w : G.adj(v)){
</span><span class='line'>          if (!marked[w]) dfs(G, w);
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  //v是可达的吗？
</span><span class='line'>  public boolean marked(int v) {
</span><span class='line'>      return marked[v];
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>标记-清除：</strong>多点可达性的一个重要典型应用就是内存管理，包括许多Java的实现。一个顶点表示一个对象，一条边表示一个对象对另一个对象的引用。在程序执行任何时候，都有某些对象是可以被直接访问的，而不能通过这些对象访问到的所有对象都应该被回收。标记-清除的垃圾回收策略会为每个对象保留一个位做垃圾收集之用。</p>

<p><strong>有向图的寻路：</strong></p>

<ul>
<li>单点有向路径：从s到给定的顶点v是否存在一条有向路径？如果有，找出这条路径。</li>
<li>单点最短有向路径：从s到给定的顶点v是否存在一条有向路径？如果有，找出最短的那边。</li>
</ul>


<p>这两个问题都可以通过深度优先和广度优先解决，它们仍是有向图的重要算法。API和代码也基本相同。</p>

<h2>4. 环和有向无环图</h2>

<h3>4.1 有向图中的环</h3>

<p>任务调度是一个典型的有向图用例，其限制条件包括任务的起始时间、时耗、优先级限制（某个任务是另一个任务的前置条件）等。如何进行正确的任务调度？这需要<strong>拓扑排序</strong>：给定一幅有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素。拓扑排序的例子还包括课程安排（先导课程限制）、继承（Java extends）、电子表格公式等等。</p>

<p>如果一个有优先级限制的问题中存在有向环，例如任务x必须在任务y之前完成，而y必须在z之前完成，但z又必须在x之前完成，那么这个问题就无解了！所以首先要解决<strong>有向环的检测</strong>：给定的有向图中包含有向环吗？</p>

<p><strong>有向无环图（DAG）是一幅不含有向环的有向图。</strong></p>

<p>有向环的检测可以通过深度优先搜索来解决。用一个栈表示正在遍历的有向路径，一旦找到一条有向边v->w且w已经在堆栈中，就找到了一个环。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DirectedCycle</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>        <span class="c1">// marked[v] = 顶点v是否已经访问过?</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">edgeTo</span><span class="o">;</span>            <span class="c1">// edgeTo[v] = 指向v的前一个顶点</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">onStack</span><span class="o">;</span>       <span class="c1">// onStack[v] = 顶点v在递归调用的堆栈上吗？</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cycle</span><span class="o">;</span>    <span class="c1">// 有向环 (null表示不存在有向环)</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">DirectedCycle</span><span class="o">(</span><span class="n">Digraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">marked</span>  <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>        <span class="n">onStack</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>        <span class="n">edgeTo</span>  <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">])</span> <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">Digraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">onStack</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">// 如果环已找到，退出</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">cycle</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                 <span class="k">return</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="c1">//找到新顶点，继续</span>
</span><span class='line'>            <span class="k">else</span> <span class="nf">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
</span><span class='line'>                <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="c1">// 找到有向环，记录下路径</span>
</span><span class='line'>            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">onStack</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">cycle</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
</span><span class='line'>                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">w</span><span class="o">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">edgeTo</span><span class="o">[</span><span class="n">x</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">cycle</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>                <span class="n">cycle</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
</span><span class='line'>                <span class="n">cycle</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">onStack</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//是否含有有向环</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasCycle</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">cycle</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//有向环中的所有顶点（如果存在有向环的话）</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">cycle</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">cycle</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>4.2 顶点的深度优先次序与拓扑排序</h3>

<p>优先级限制下的调度问题等价于计算有向无环图中的所有顶点的拓扑排序。只需要在标准深度优先搜索中，将<code>dfs()</code>的顶点参数保存在一个数据结构中，遍历这个数据结构就能访问所有的顶点。遍历的顺序取决于这个数据结构的性质以及是在递归调用之前还是之后进行保存。主要有3种排序顺序：</p>

<ol>
<li>前序(pre)：在递归调用之前将顶点加入队列。</li>
<li>后序(post)：在递归调用之后将顶点加入队列。</li>
<li>逆后序(reversePost)：在递归调用之后将顶点压入堆栈。</li>
</ol>


<p>对于这样一张有向图，三种顺序遍历过程如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-29-dag.png" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-29-depth-first-orders.png" alt="image" /></p>

<p>下面实现的DepthFirstOrder实现了这三种排序：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DepthFirstOrder</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>          <span class="c1">// marked[v] = has v been marked in dfs?</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">pre</span><span class="o">;</span>                 <span class="c1">// pre[v]    = preorder  number of v</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">post</span><span class="o">;</span>                <span class="c1">// post[v]   = postorder number of v</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">reversePost</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">DepthFirstOrder</span><span class="o">(</span><span class="n">Digraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">pre</span>    <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
</span><span class='line'>        <span class="n">post</span>   <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
</span><span class='line'>        <span class="n">reversePost</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
</span><span class='line'>        <span class="n">marked</span>    <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">])</span> <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">Digraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">pre</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">post</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
</span><span class='line'>        <span class="n">reversePost</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">pre</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">pre</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">post</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">post</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">reversePost</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">reversePost</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>DepthFirstOrder提供了三种排序的顶点列表：pre, post, reversePost，因此拓扑排序就非常简单了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Topological</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">order</span><span class="o">;</span>    <span class="c1">// topological order</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Topological</span><span class="o">(</span><span class="n">Digraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">DirectedCycle</span> <span class="n">finder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DirectedCycle</span><span class="o">(</span><span class="n">G</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(!</span><span class="n">finder</span><span class="o">.</span><span class="na">hasCycle</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">DepthFirstOrder</span> <span class="n">dfs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DepthFirstOrder</span><span class="o">(</span><span class="n">G</span><span class="o">);</span>
</span><span class='line'>            <span class="n">order</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">.</span><span class="na">reversePost</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//拓扑有序的所有顶点</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">order</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">order</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//G是有向无环图吗？</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isDAG</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">order</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>一幅有向无环图的拓扑顺序就是所有顶点的逆后序排列。</strong>这是一个重要结论！证明如下：对于任意边v->w, 在调用dfs(v)时，必有以下三种情况之一：</p>

<ol>
<li>dfs(w)已经被调用过且已经返回（w已经被标记）。</li>
<li>dfs(w)还没有被调用，因此v->会直接或间接调用并返回dfs(w)，且dfs(w)会在dfs(v)返回前返回。</li>
<li>dfs(w)已经被调用但未返回。</li>
</ol>


<p>第3种情况表示存在环，所以在有向无环图中是不可能出现的。第1、2种情况都证明了dfs(w)会先于dfs(v)完成。后序排列时w在v之前，只有逆后序时，w排在v之后。因此逆后序是有向无环图的拓扑顺序。</p>

<p>再次说明，拓扑排序和有向环的检测总是一起出现的，因为有向环的检测是排序的前提。</p>

<h2>5. 有向图的强连通性</h2>

<p>如果两个顶点v和w是互相可达的，也就是存在一条从v到w的有向路径，同时还存在一条从w到v的有向路径，那么v和w是<strong>强连通</strong>的。</p>

<p>强连通性将所有顶点分为一些等价类，每个等价类都由相互均为强连通的顶点的最大子集组成，这些子集称为<strong>强连通分量</strong>。强连通分量的典型应用包括：网络（网页和超链接）、软件（模块和调用）、食物链（物种和捕食关系）等。强连通分量的API:</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-30-scc-api.png" alt="image" /></p>

<h3>5.1 Kosaraju算法</h3>

<p>Kosaraju算法实现了SCC API：</p>

<ul>
<li>在给定的一幅有向图G中，使用DepthFirstOrder来计算它的反向图G<sup>R</sup>的逆后序排列。</li>
<li>在G中进行标准的深度优先搜索，但是要按照刚才计算得到的顺序而非标准的顺序来访问所有未被标记的顶点。</li>
<li>在构造函数中，所有在同一个递归dfs()调用中被访问到的顶点都在同一个强连通分量中，将它们按照和CC相同的方式识别出来。</li>
</ul>


<p>要证明Kosaraju算法的正确性，首先证明：“每个和s强连通的顶点v都会在构造函数调用的dfs(G,s)中被访问到。”这个毫无疑问。然后再证明：“构造函数调用的dfs(G,s)所到达的任意顶点v都必然是和s强连通的。”设v为dfs(G,s)到达的某个顶点。那么G中必然存在一条从s到v的路径，因此只需证明G中还存在一条从v到s的路径即可。也就等价于证明G<sup>R</sup>中存在一条从s到v的路径：</p>

<blockquote><p>按照逆后序进行的深度优先搜索意味着，在G<sup>R</sup>中进行的深度优先搜索中，dfs(G,v)必然在dfs(G,s)之前就已经结束了，这样dfs(G,v)的调用就只会出现两种情况：</p>

<ol>
<li>调用在dfs(G,s)的调用之前（并且也在dfs(G,s)的调用之前结束）</li>
<li>调用在dfs(G,s)的调用之后（并且也在dfs(G,s)的调用之前结束）</li>
</ol>


<p>第一种情况不可能出现，因为在G<sup>R</sup>中存在一条从v到s的路径；而第二种情况说明G<sup>R</sup>中存在一条从s到v的路径。证毕。</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">KosarajuSharirSCC</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>     <span class="c1">//已访问过的顶点</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">id</span><span class="o">;</span>             <span class="c1">//强连通分量的标识符</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>            <span class="c1">//强连通分量的数量</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">KosarajuSharirSCC</span><span class="o">(</span><span class="n">Digraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// compute reverse postorder of reverse graph</span>
</span><span class='line'>        <span class="n">DepthFirstOrder</span> <span class="n">dfs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DepthFirstOrder</span><span class="o">(</span><span class="n">G</span><span class="o">.</span><span class="na">reverse</span><span class="o">());</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// run DFS on G, using reverse postorder to guide calculation</span>
</span><span class='line'>        <span class="n">marked</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>        <span class="n">id</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">dfs</span><span class="o">.</span><span class="na">reversePost</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
</span><span class='line'>                <span class="n">count</span><span class="o">++;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">Digraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="n">id</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">count</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//图中的强连通分量的总数</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">count</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//v和w是强连通的吗</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">stronglyConnected</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">id</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">==</span> <span class="n">id</span><span class="o">[</span><span class="n">w</span><span class="o">];</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//v所在的强连通分量的标识符（在0至count()-1之间）</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">id</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">id</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>5.2 顶点对的可达性</h3>

<p>给定一幅有向图，回答“是否存在一条从一个给定的顶点v到达另一个给定的顶点w的路径？”对于无向图，这个问题等价于连通性问题。而对有向图，有很大区别。看似简单的问题困难了专家数十年。如何大幅减少预处理所需的时间和空间，又保证常数的查询时间。这仍然是一个有待解决的问题。而且这个问题有重要的实际意义：处理互联网这样的巨型有向图。</p>

<p>下面的算法只是简单地实现了可达性，但不适用于处理大型有向图，因为它所需的空间与V<sup>2</sup>成正比，所需时间和V(V+E)成正比。但如果图小的话，仍然是一个理想的解决办法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TransitiveClosure</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">DirectedDFS</span><span class="o">[]</span> <span class="n">tc</span><span class="o">;</span>  <span class="c1">// tc[v] = reachable from v</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//预处理的构造方法</span>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">TransitiveClosure</span><span class="o">(</span><span class="n">Digraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">tc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DirectedDFS</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
</span><span class='line'>            <span class="n">tc</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DirectedDFS</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//w是从v可达的吗？</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">reachable</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">tc</span><span class="o">[</span><span class="n">v</span><span class="o">].</span><span class="na">marked</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>参考：<a href="http://algs4.cs.princeton.edu/42directed/">http://algs4.cs.princeton.edu/42directed/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[发布两款自用的GAE应用]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/27/fa-bu-liang-kuan-zi-yong-de-gaeying-yong/"/>
    <updated>2014-10-27T22:58:19+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/27/fa-bu-liang-kuan-zi-yong-de-gaeying-yong</id>
    <content type="html"><![CDATA[<p>今天正式公开我的两款GAE(Google App Engine)应用：RSS2EPUB和背单词应用。供有需要的朋友使用。</p>

<!--more-->


<h2>RSS2EPUB/MOBI</h2>

<p>RSS2EPUB用于将RSS订阅全文转换成Epub或者MOBI格式，每天推送至邮箱或Kindle等阅读器。开发这款应用的目的主要是想专注于阅读，少一些网络的干扰。使用说明见：<a href="https://github.com/meixuesong/rss2epub">https://github.com/meixuesong/rss2epub</a></p>

<p>网址：<a href="rss2epub.appspot.com">http://rss2epub.appspot.com</a></p>

<h2>背单词</h2>

<p>背单词应用是我数年前开发的一款应用，也是第一次使用GAE。之后对页面升级改造过一次。这个应用提供了“词典”和“我的生词本”功能。词典内容来源于Collins英语学习词典和Collins英汉双解词典，并按四、六级和专四、专八进行了分类。系统按照记忆曲线列出您每天应该复习的单词。另外例句默写是非常有效的强化记忆功能，系统自动列出单词的所有例句，将单词空出来，默写完后可以检查答案。</p>

<p>网址：<a href="http://enubone.appspot.com">http://enubone.appspot.com</a></p>

<h2>注</h2>

<p>这两个应用都部署在Google的云上，所以需要翻墙才能使用。翻墙是我等这么多年练出的拿手绝活，应该不在话下。</p>

<p>GAE与几年前相比，不论是功能还是文档都有了长足进步，现在上手已经很简单了，最关键是免费，并且从GAE访问国外资源不会被墙。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[终于完成RSS2EPUB的项目]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/18/zhong-yu-wan-cheng-rss2epubde-xiang-mu/"/>
    <updated>2014-10-18T22:37:33+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/18/zhong-yu-wan-cheng-rss2epubde-xiang-mu</id>
    <content type="html"><![CDATA[<p>国庆期间，自从10月5日完成博客转EPUB电子书后，脑子突然短路，是不是可以把RSS订阅的内容也自动转成EPUB电子书呢？然后就没停下来，利用业余时间终于完成了，各项功能基本完善！</p>

<p>这个项目运行于GAE平台，接受用户订阅，然后每天把最新内容生成电子书发邮件给用户。</p>

<p>运行于GAE平台的好处是直接使用Google的云服务，特别是邮件服务和图片服务非常棒！但坏处是Google被墙，国内无法直接访问。所以又开发了邮件订阅的方法。总体来说效果不错！</p>

<p>项目地址：<a href="http://rss2epub.appspot.com/">http://rss2epub.appspot.com</a></p>

<p>使用方法参考：<a href="https://github.com/meixuesong/rss2epub">RSS2EPUB</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于Jekyll(Octopress)将博客生成EPUB和Mobi电子书]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/05/ji-yu-jekyll-sheng-cheng-dian-zi-shu/"/>
    <updated>2014-10-05T21:03:50+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/05/ji-yu-jekyll-sheng-cheng-dian-zi-shu</id>
    <content type="html"><![CDATA[<p>采用Octopress，基于Jekyll，<a href="http://blog.ubone.com/blog/2014/06/25/zai-githubshang-xie-bo-ke/">在GitHub上写博客</a>已经快一年了。随着博客的增多，有了一个想法，如果能将这些博客整理成册，变成电子书放入Kindle，有空时温习一下，那该多好。今天进行了尝试，效果还不错。</p>

<!--more-->


<p>Kindle默认支持的电子书格式是Mobi，但开源软件很少支持这种格式。电子书格式最普及的还是EPUB，而Amazon提供了从EPUB转为Mobi的支持。因此我们的第一步是将博客转换成EPUB格式的电子书。</p>

<h2>1. 准备工作</h2>

<p>在Github上找到了一个项目<a href="https://github.com/lmullen/jekyll-ebook">Jekyll E-book</a>，支持将Jekyll博客转换成EPUB电子书。按照其说明，以管理员身份安装：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>gem install jekyll-ebook
</span></code></pre></td></tr></table></div></figure>


<p>然后安装Pandoc，打开<a href="https://github.com/jgm/pandoc/releases">下载页面</a>，下载相应系统的安装包，安装完成后，确保命令能够识别：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>pandoc --version
</span></code></pre></td></tr></table></div></figure>


<p>现在就可以开始准备生成EPUB电子书了。需要先定义这本书的标题等信息，以及书中包括哪些博客。这些信息都保存在manifest.yml中，这是一个YAML格式的文件。分两部分说明这个文件的内容，我们先看第一部分：文件的定义。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">title</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">meixuesong blog</span>
</span><span class='line'><span class="l-Scalar-Plain">author</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Jason Mei</span>
</span><span class='line'><span class="l-Scalar-Plain">date</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">October 2014</span>
</span><span class='line'><span class="l-Scalar-Plain">epub-filename</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/Users/mxs/Documents/jasonblog.epub</span>
</span><span class='line'><span class="l-Scalar-Plain">epub-cover-image</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">myresource/epub/cover.jpg</span>
</span><span class='line'><span class="l-Scalar-Plain">epub-stylesheet</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">myresource/epub/stylesheet.css</span>
</span><span class='line'><span class="l-Scalar-Plain">epub-metadata</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">myresource/epub/metadata.xml</span>
</span><span class='line'><span class="l-Scalar-Plain">epub-dir</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/Users/mxs/Documents/blog/</span>
</span><span class='line'><span class="l-Scalar-Plain">header-items</span><span class="p-Indicator">:</span>
</span><span class='line'><span class="p-Indicator">-</span> <span class="l-Scalar-Plain">title</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">meixuesong blog</span>
</span><span class='line'><span class="p-Indicator">-</span> <span class="l-Scalar-Plain">author</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">meixuesong</span>
</span><span class='line'><span class="p-Indicator">-</span> <span class="l-Scalar-Plain">author-note</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">na</span>
</span><span class='line'><span class="p-Indicator">-</span> <span class="l-Scalar-Plain">citation</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">na</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中要注意的是路径，<code>epub-dir</code>是博客资源的根路径，其中文件夹如<code>epub-cover-image</code>, <code>epub-stylesheet</code>和<code>epub-metadata</code>都是相对根路径的相对路径。<code>metadata.xml</code>是EPUB文件所需的文件，可以是个空文件。为了美观，我们稍微修改了stylesheet.css：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="c">/*stylesheet.css*/</span>
</span><span class='line'><span class="nt">body</span> <span class="p">{</span> <span class="k">margin</span><span class="o">:</span> <span class="m">5</span><span class="o">%</span><span class="p">;</span> <span class="k">text-align</span><span class="o">:</span> <span class="k">justify</span><span class="p">;</span> <span class="k">font-size</span><span class="o">:</span> <span class="k">medium</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="nt">code</span> <span class="p">{</span> <span class="k">font-family</span><span class="o">:</span> <span class="k">monospace</span><span class="p">;</span> <span class="k">font-size</span><span class="o">:</span><span class="m">0.75em</span><span class="p">;}</span>
</span><span class='line'><span class="nt">h1</span> <span class="p">{</span> <span class="k">text-align</span><span class="o">:</span> <span class="k">center</span><span class="p">;</span> <span class="k">margin</span><span class="o">:</span><span class="m">0px</span><span class="p">;</span> <span class="k">padding</span><span class="o">:</span><span class="m">0px</span><span class="p">;</span><span class="k">font-size</span><span class="o">:</span><span class="m">1.5em</span><span class="p">;</span> <span class="k">border-bottom</span><span class="o">:</span> <span class="nb">black</span> <span class="k">solid</span> <span class="m">1px</span><span class="p">;}</span>
</span><span class='line'><span class="nt">h2</span> <span class="p">{</span> <span class="k">text-align</span><span class="o">:</span> <span class="k">left</span><span class="p">;</span> <span class="k">margin</span><span class="o">:</span><span class="m">0px</span><span class="p">;</span> <span class="k">padding</span><span class="o">:</span><span class="m">0px</span><span class="p">;</span><span class="k">font-size</span><span class="o">:</span><span class="m">1.2em</span><span class="p">;}</span>
</span><span class='line'><span class="nt">h3</span> <span class="p">{</span> <span class="k">text-align</span><span class="o">:</span> <span class="k">left</span><span class="p">;</span> <span class="k">margin</span><span class="o">:</span><span class="m">0px</span><span class="p">;</span> <span class="k">padding</span><span class="o">:</span><span class="m">0px</span><span class="p">;</span><span class="k">font-size</span><span class="o">:</span><span class="m">1.1em</span><span class="p">;}</span>
</span><span class='line'><span class="nt">h4</span> <span class="p">{</span> <span class="k">text-align</span><span class="o">:</span> <span class="k">left</span><span class="p">;</span> <span class="k">margin</span><span class="o">:</span><span class="m">0px</span><span class="p">;</span> <span class="k">padding</span><span class="o">:</span><span class="m">0px</span><span class="p">;</span> <span class="k">font-size</span><span class="o">:</span><span class="m">1em</span><span class="p">;}</span>
</span><span class='line'><span class="nt">h5</span> <span class="p">{</span> <span class="k">text-align</span><span class="o">:</span> <span class="k">left</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="nt">h6</span> <span class="p">{</span> <span class="k">text-align</span><span class="o">:</span> <span class="k">left</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="nt">h1</span><span class="nc">.title</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'><span class="nt">h2</span><span class="nc">.author</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'><span class="nt">h3</span><span class="nc">.date</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'><span class="nt">ol</span><span class="nc">.toc</span> <span class="p">{</span> <span class="k">padding</span><span class="o">:</span> <span class="m">0</span><span class="p">;</span> <span class="k">margin-left</span><span class="o">:</span> <span class="m">1em</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="nt">ol</span><span class="nc">.toc</span> <span class="nt">li</span> <span class="p">{</span> <span class="k">list-style-type</span><span class="o">:</span> <span class="k">none</span><span class="p">;</span> <span class="k">margin</span><span class="o">:</span> <span class="m">0</span><span class="p">;</span> <span class="k">padding</span><span class="o">:</span> <span class="m">0</span><span class="p">;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>开始定义第二部分，章节定义。这部分比较简单，就是定义书中包含哪几章，名字是什么，每章包括哪些博客。示例如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nt">content-dir</span><span class="o">:</span> <span class="nt">_posts</span><span class="o">/</span>   <span class="err">#博客所在的相对路径</span>
</span><span class='line'><span class="nt">contents</span><span class="o">:</span>
</span><span class='line'>  <span class="nt">-</span> <span class="nt">section-title</span><span class="o">:</span> <span class="nt">Articles</span>   <span class="err">#章节名称</span>
</span><span class='line'>    <span class="nt">files</span><span class="o">:</span>                    <span class="err">#该章以下包括哪些内容</span>
</span><span class='line'>    <span class="nt">-</span> <span class="nt">article1</span><span class="nc">.markdown</span>
</span><span class='line'>    <span class="nt">-</span> <span class="nt">article2</span><span class="nc">.markdown</span>
</span><span class='line'>  <span class="nt">-</span> <span class="nt">section-title</span><span class="o">:</span> <span class="nt">Reviews</span>
</span><span class='line'>    <span class="nt">files</span><span class="o">:</span>
</span><span class='line'>    <span class="nt">-</span> <span class="nt">review</span><span class="nc">.markdown</span>
</span></code></pre></td></tr></table></div></figure>


<h2>2. 生成EPUB电子书</h2>

<p>完成<code>manifest.yml</code>的定义之后，就可以开始生成电子书了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>jekyll-ebook manifest.yml
</span></code></pre></td></tr></table></div></figure>


<p>EPUB电子书就这样生成了，字体完美，甚至还有代码高亮显示功能，电子书的目录默认显示到第三级，在Kindle上看显得多了，需要改为只显示第1级，即目录只显示文章标题，而不用详细到每章的<code>h3</code>级内容。另外图片显示不正常，应该是路径不正确。</p>

<p>先来解决第一个问题，将目录级别改为只显示第1级标题。可以修改文件<code>ebook.rb</code>，在Mac OSX下，这个文件位于：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1">#文件路径：</span>
</span><span class='line'><span class="sr">/Library/</span><span class="no">Ruby</span><span class="o">/</span><span class="no">Gems</span><span class="o">/</span><span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="o">/</span><span class="n">gems</span><span class="o">/</span><span class="n">jekyll</span><span class="o">-</span><span class="n">ebook</span><span class="o">-</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">2</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">jekyll</span><span class="o">-</span><span class="n">ebook</span><span class="o">/</span><span class="n">ebook</span><span class="o">.</span><span class="n">rb</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># 修改代码，加上：&#39;toc-depth&#39; =&gt; 1,</span>
</span><span class='line'><span class="no">PandocRuby</span><span class="o">.</span><span class="n">new</span><span class="p">(</span> <span class="nb">self</span><span class="o">.</span><span class="n">generate_content</span> <span class="p">,</span>
</span><span class='line'>                   <span class="p">{</span><span class="ss">:f</span> <span class="o">=&gt;</span> <span class="ss">:markdown</span><span class="p">,</span> <span class="ss">:to</span> <span class="o">=&gt;</span> <span class="ss">:epub</span><span class="p">},</span>
</span><span class='line'>                   <span class="s1">&#39;smart&#39;</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span> <span class="o">=&gt;</span> <span class="nb">self</span><span class="o">.</span><span class="n">manifest</span><span class="o">[</span><span class="s1">&#39;epub-filename&#39;</span><span class="o">]</span><span class="p">,</span>
</span><span class='line'>                   <span class="s1">&#39;toc-depth&#39;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
</span></code></pre></td></tr></table></div></figure>


<p>再来解决图片不显示的问题。该问题主要是因为写博客时，图片的地址为<code>/myresource/images/</code>，因此在生成电子书无法找到这个绝对路径。解决办法使用<code>ln</code>命令在根文件夹下建立一个符号连接myresource，Windows下好像是<code>mklink</code>命令。重新生成电子书，问题解决。</p>

<p>现在，我们的EPUB电子书通过Kindle多看系统阅读已经非常完美了。接下来我们尝试一下Mobi格式的电子书。</p>

<h2>3. 生成Mobi电子书</h2>

<p>Amazon提供了一个工具包<a href="http://www.amazon.com/gp/feature.html?docId=1000765211">KindleGen</a>。该工具可以将html、EPUB等转换成Mobi格式。下载解压缩后，就可以执行命令转换了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>./kindlegen -locale zh aaa.epub
</span></code></pre></td></tr></table></div></figure>


<p>分别在原生Kindle和多看系统下查看这个mobi电子书，整体效果还是不错的，但是相比EPUB来说，还是差了那么一点点。例如h1到h3的标题下方空白的内容太多，也就是CSS中的margin-bottom值太大，但不论怎么修改，Mobi格式的显示效果好像都没有变化。最后还是选择继续使用多看系统，阅读EPUB格式的电子书。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[无向图]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/03/wu-xiang-tu/"/>
    <updated>2014-10-03T18:18:44+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/03/wu-xiang-tu</id>
    <content type="html"><![CDATA[<p>无向图由一组顶点(Vertex)和一组能够将两个顶点相连的边(Edge)组成。本章学习无向图的邻接表实现，以及相关的搜索和应用，例如深度优先和广度优先搜索，路径查找和最短路径计算，连通分量和符号图。本文要解决的无向图问题包括：</p>

<ol>
<li>单点连通性</li>
<li>单点路径</li>
<li>单点最短路径</li>
<li>连通性</li>
<li>检测环</li>
<li>双色问题（图的二分性）</li>
</ol>


<!--more-->


<h2>1. 术语</h2>

<p>v-w表示连接v和w的边。自环和平行边是两种特殊的图。<strong>自环</strong>即一条连接一个顶点和其自身的边；<strong>平行边</strong>是连接同一对顶点的两条边。含有平行边的图称为多重图，没有平行边和自环的图称为<strong>简单图</strong>。</p>

<p>当两个顶点通过一条边相连时，这两个顶点是<strong>相邻的</strong>。某个顶点的<strong>度数(Degree)</strong>即为依附于它的边的总数。<strong>子图</strong>是由一幅图的所有边的一个子集（以及它们所依附的所有顶点）组成的图。</p>

<p>在图中，<strong>路径</strong>是由边顺序连接的一系列顶点。<strong>简单路径</strong>是一条没有重复顶点的路径。<strong>环</strong>是一条至少含有一条边，并且起点和终点相同的路径。<strong>简单环</strong>是一条（除了起点和终点必须相同之外）不含有重复顶点和边的环。路径或环的<strong>长度</strong>为其中所包含的边数。</p>

<p>如果从任意一个顶点都存在一条路径到达另一个任意顶点，这幅图就是<strong>连通图</strong>。一幅非连通的图由若干连通的部分组成，它们都是其极大连通子图。</p>

<p>树是一幅无环(Acyclic)连通图。互不相连的树组成的集合称为<strong>森林</strong>。连通图的<strong>生成树</strong>是它的一幅子图，它含有图中的所有顶点且是一棵树。图的<strong>生成树森林</strong>是它的所有连通子图的生成树的集合。</p>

<p>当且仅当一幅含有V个顶点的图G满足下列5个条件之一时，它就是一棵树：</p>

<ul>
<li>G有V-1条边且不含有环；</li>
<li>G有V-1条边且是连通的；</li>
<li>G是连通的，但删除任意一条边都会使它不再连通；</li>
<li>G是无环图，但添加任意一条边都会产生一条环；</li>
<li>G中的任意一对顶点之间仅存在一条简单路径。</li>
</ul>


<h2>2. API</h2>

<p>先看一份定义了无向图的基本操作的API：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-04_graph-api.png" alt="image" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">//////////////////常用的图处理代码//////////////////</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//计算v的度数</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">degree</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">degree</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">w:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="n">degree</span><span class="o">++;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">degree</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//计算所有顶点的最大度数</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxDegree</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">degree</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">)</span>
</span><span class='line'>          <span class="n">max</span> <span class="o">=</span> <span class="n">degree</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//计算所有顶点的平均度数</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">double</span> <span class="nf">avgDegree</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">G</span><span class="o">.</span><span class="na">E</span><span class="o">()</span> <span class="o">/</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//计算自环的个数</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numberOfSelfLoops</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
</span><span class='line'>      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
</span><span class='line'>          <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">w</span><span class="o">)</span> <span class="n">count</span><span class="o">++;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">count</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="c1">//每条边都被记过2次</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2.1 邻接表</h3>

<p>图有多种表示方法，包括邻接矩阵（V乘V的布尔矩阵，占用空间过大），边的数组（边类含有两个int实例变量，实现adj方法需要检查图中的所有边）和邻接表数组。</p>

<p>邻接表数组是以顶点为索引的列表数组，例如第0个顶点的列表中每个元素都是和顶点0相邻的顶点。示意图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-03_adjacency-lists.png" alt="image" /></p>

<p>它具有以下特点：</p>

<ul>
<li>使用的空间和V+E成正比；</li>
<li>添加一条边所需的时间为常数；</li>
<li>遍历顶点v的所有相邻顶点所需的时间和v的度数成正比。</li>
</ul>


<p>代码实现示意如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Graph</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">V</span><span class="o">;</span>        <span class="c1">//顶点数目</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">int</span> <span class="n">E</span><span class="o">;</span>              <span class="c1">//边的数目</span>
</span><span class='line'>  <span class="kd">private</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;[]</span> <span class="n">adj</span><span class="o">;</span> <span class="c1">//邻接表</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addEdge</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
</span><span class='line'>      <span class="n">adj</span><span class="o">[</span><span class="n">w</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
</span><span class='line'>      <span class="n">E</span><span class="o">++;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">adj</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2.2 图的处理算法API</h3>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-04_search-api.png" alt="image" /></p>

<h2>3. 深度优先搜索(DFS)</h2>

<p>深度优先搜索一幅图，只需要一个递归方法来遍历所有顶点。在访问其中一个顶点时：</p>

<ul>
<li>将它标记为已访问；</li>
<li>递归地访问它的所有没有被标记过的邻居顶点。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">//深度优先搜索</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DepthFirstSearch</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="nf">DepthFirstSearch</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">marked</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>      <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>      <span class="n">count</span><span class="o">++;</span>
</span><span class='line'>      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
</span><span class='line'>          <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">marked</span><span class="o">(</span><span class="kt">int</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">];}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">count</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">count</span><span class="o">;}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>利用深度优先搜索很容易找到一些问题的答案。例如“两个给定的顶点是否连通？有多少个连通子图？从s到给定目的顶点v是否存在一条路径？如果有，找到这条路径。”</p>

<h2>4. 寻找路径</h2>

<p>路径的API:</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-04_paths-api.png" alt="image" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">//使用深度优先搜索查找图的路径</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DepthFirstPaths</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>   <span class="c1">//这个顶点上调用过dfs()吗？</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">edgeTo</span><span class="o">;</span>       <span class="c1">//从起点到一个顶点的已知路径上的最后一个顶点</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">s</span><span class="o">;</span>        <span class="c1">//起点</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="nf">DepthFirstPaths</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">marked</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>      <span class="n">edgeTo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
</span><span class='line'>      <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
</span><span class='line'>          <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
</span><span class='line'>              <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasPathTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">];}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">pathTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(!</span><span class="n">hasPathTo</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>      <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">path</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
</span><span class='line'>      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">s</span><span class="o">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">edgeTo</span><span class="o">[</span><span class="n">x</span><span class="o">])</span>
</span><span class='line'>          <span class="n">path</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
</span><span class='line'>      <span class="n">path</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">path</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>5. 广度优先搜索(BFS)</h2>

<p>广度优先搜索可以解决单点最短路径的问题，即“从s到给定目的顶点v是否存在一条路径？如果有，找出其中最短的那条。”要找到从s到v的最短路径，从s开始，在所有由一条边就可以到达的顶点中寻找v，如果找不到就继续在与s距离两条边的所有顶点中找v，如此一直进行。实现广度优先搜索时，可以使用先进先出（FIFO）队列。代码示意如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BreadthFirstPaths</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>  <span class="c1">//到达该顶点的最短路径已知吗？</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">edgeTo</span><span class="o">;</span>      <span class="c1">//到达该顶点的已知路径上的最后一个顶点</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">s</span><span class="o">;</span>       <span class="c1">//起点</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="nf">BreadthFirstPaths</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">marked</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>      <span class="n">edgeTo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">v</span><span class="o">()];</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
</span><span class='line'>      <span class="n">bfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">bfs</span><span class="o">(</span><span class="n">Grapth</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
</span><span class='line'>      <span class="n">marked</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>  <span class="c1">//标记起点</span>
</span><span class='line'>      <span class="n">queue</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>  <span class="c1">//入列</span>
</span><span class='line'>      <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>          <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">dequeue</span><span class="o">();</span>
</span><span class='line'>          <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
</span><span class='line'>              <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>                  <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
</span><span class='line'>                  <span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>                  <span class="n">queue</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
</span><span class='line'>              <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasPathTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">];}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">pathTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span><span class="c1">//与深度优先实现相同}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>6. 连通分量</h2>

<p>所谓连通分量就是连通子图，深度优先搜索可用于找出一幅图的所有连通分量。其API定义如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-04_cc-api.png" alt="image" /></p>

<p>递归的深度优先搜索第一次调用的参数是顶点0，它会标记所有与0连通的顶点。然后构造函数中的for循环会查找每个没有被标记的顶点并递归调用dfs()来标记和它相邻的所有顶点。代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CC</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">id</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="nf">CC</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">marked</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>      <span class="n">id</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
</span><span class='line'>      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">s</span><span class="o">++)</span>
</span><span class='line'>          <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">s</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
</span><span class='line'>              <span class="n">count</span><span class="o">++;</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>      <span class="n">id</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">count</span><span class="o">;</span>
</span><span class='line'>      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
</span><span class='line'>          <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span>
</span><span class='line'>              <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">connected</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">id</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">==</span> <span class="n">id</span><span class="o">[</span><span class="n">w</span><span class="o">];</span> <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">id</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">id</span><span class="o">[</span><span class="n">v</span><span class="o">];</span> <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">count</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">count</span><span class="o">;}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>深度优先搜索还可用于解决两个问题：1. 给定的图是无环图吗（假定不存在自环和平行边）？<a href="http://algs4.cs.princeton.edu/41undirected/Cycle.java.html">代码实现</a> 2. 这是一幅二分图吗？也就是说能够用两种颜色将图的所有顶点着色，使得任意一条边的两个端点的颜色都不相同。<a href="http://baike.baidu.com/view/501081.htm">二分图</a>，<a href="http://algs4.cs.princeton.edu/41undirected/Bipartite.java.html">代码实现</a></p>

<h2>7. 符号图</h2>

<p>在典型应用中，通常使用字符串而非整数来表示和指代顶点。为了适应这样的应用，需要符号图。符号图使用字符串代替整数索引。其API定义如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-04_symbol-graph-api.png" alt="image" /></p>

<p>符号图的实现可以在无向图的基础上增加一个符号表和反向索引。符号表完成符号到邻接表索引的映射，键为String(顶点名)，值的类型为int(邻接表的索引)。反向索引是一个数组keys[]，保存每个顶点索引所对应的顶点名。结构如下图：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-04_symbol-graph.png" alt="image" /></p>

<p>其实现较为简单，<a href="http://algs4.cs.princeton.edu/41undirected/SymbolGraph.java.html">查看代码</a>。</p>

<p><strong>利用符号图可以处理一个经典问题，找到一个社交网络中两个人间隔的度数。这其实就是用符号图+广度优先求最短路径的用例。</strong></p>

<h2>总结</h2>

<p>本文主要学习无向图的邻接表实现，以及深度、广度优先算法及其应用：</p>

<p>深度优先：</p>

<ol>
<li>两个顶点是否连通？如果有，给出路径。</li>
<li>有多少个连通子图？找出所有连通分量。</li>
<li>给定的图是无环图吗？</li>
<li>是一幅二分图吗？</li>
</ol>


<p>广度优先：</p>

<ol>
<li>找出两个顶点间的最短路径。</li>
</ol>


<p>参考：<a href="http://algs4.cs.princeton.edu/41undirected/">http://algs4.cs.princeton.edu/41undirected/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[散列表(HashTable)]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/03/san-lie-biao/"/>
    <updated>2014-10-03T10:03:40+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/03/san-lie-biao</id>
    <content type="html"><![CDATA[<p>散列表也是一种符号表，它通过算法将键转化为数组的索引来访问数组中的键值对。散列表查找的第一步是用散列函数将被查找的键转化为一数组索引，第二步是处理碰撞冲突。解决碰撞冲突的方法有拉链法和线性探测法。</p>

<!--more-->


<h2>1. 散列函数</h2>

<p>散列函数用于将键转化为数组的索引，它应该易于计算并且能够均匀分布所有的键。散列函数和键的类型有关，对于每种类型的键都需要一个与之对应的散列函数。</p>

<p>Java对正整数采用除留余数法计算散列值。选择大小为素数M的数组，对于任意正整数k，计算余数：<code>k%M</code>，能够有效地将键散布在0到M-1的范围内。素数又称为质数，是一个大于1的自然数，除了1和它本身外，不能被其他自然数整除（除0以外）的数。Java对浮点数会将键表示为二进制数然后再使用除留余数法。对字符串采用类似Homer方法，用N次乘法、加法和取余来计算散列值。</p>

<p>对Java程序，<code>hashCode()</code>和<code>equals()</code>方法必须一致。如果<code>equals()</code>返回<code>true</code>那么<code>hashCode()</code>返回值必须一致，反过来则可以不同。</p>

<h2>2. 基于拉链法的散列表</h2>

<p>当<code>hashCode()</code>返回值相同，但<code>equals()</code>为false时，就发生了碰撞。解决碰撞的一种方法是拉链法。拉链法是指数组中的每个元素都指向一个链表，链表中的每个结点都存储了散列值为该元素的索引的键值对。因此这样的散列表由数组+链表构成。查找时先根据散列值找到对应的链表，然后沿着链表顺序查找相应的键。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-03_separate-chaining.png" alt="image" /></p>

<p>可以看出，散列表的查找性能与散列表的大小有很大关系，对N个元素来说，当散列表的大小M过小时，碰撞机率就会增加，链表的长度必然增加，从而降低了查找效率。因此在内存不紧张时，可以选择一个足够大的M，内存紧张时，选择尽量大的M。另一种方法是动态调整数据的大小以保持短小的链表。</p>

<p>执行删除操作时，先用散列值找到索引及对应的链表，然后调用链表的删除方法即可。</p>

<p>对于有序性相关的符号表操作，散列表都不是合适的选择，因为这些操作的运行时间都是线性的。</p>

<p>Java的TreeMap和HashMap分别是基于红黑树和拉链法的散列表的符号表实现。</p>

<h2>3. 基于线性探测法的散列表</h2>

<p>实现散列表的另一种方式是用大小为M的数组保存N个键值对，其中M>N。依靠数据中的空位解决碰撞冲突。基于这种策略的所有方法都统称为开放地址散列表。其中最简单的方法叫做线性探测法：当碰撞发生时，直接检查散列表的下一个位置（索引加1），可能产生三种结果：</p>

<ul>
<li>命中，该位置的键和被查找的键相同；</li>
<li>未命中，键为空（该位置没有键）；</li>
<li>继续查找，该位置的键和被查找的键不同。</li>
</ul>


<p>其核心思想是与其将内存用作链表，不如将它们作为散列表的空元素。即用散列函数找到索引，检查其中的键和被查找的键是否相同。如果不同则继续查找（增加索引，到达数组结尾后再折回数组开头），直到找到该键或者遇到一个空元素。过程如下图所示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-03_linear-probing.png" alt="image" /></p>

<p>在基于线性探测法的散列表中执行删除操作比较复杂，如果将该键所在位置为为null是不行的。需要将簇中被删除键的右侧的所有键重新插入散列表。</p>

<p>这种散列表的性能也依赖于N/M，但在这里表示散列表的利用率。如果利用率达到1，即散列表满了，会造成未命中的查找无限循环。为了保证性能，要动态调整数组的大小来保证利用率在1/8到1/2之间。</p>

<h2>4. 数组的大小和内存使用</h2>

<p>对于线性探测法，调整数组的大小是必需的。对于拉链法，如果你能准确估计所需的散列表大小N，调整数据的工作不是必需的，只需要根据查找耗时和<code>(1+N/M)</code>成正比来选取一个适当的M即可。</p>

<p>符号表的内存使用：</p>

<table>
<thead>
<tr>
<th>方法 </th>
<th> N个元素所需的内存（引用类型）</th>
</tr>
</thead>
<tbody>
<tr>
<td>基于拉链法的散列表 </td>
<td> ~48N + 32M</td>
</tr>
<tr>
<td>基于线性探测的散列表 </td>
<td> 在~32N和~128N之间</td>
</tr>
<tr>
<td>各种二叉查找树 </td>
<td> ~56N</td>
</tr>
</tbody>
</table>


<h2>Q&amp;A</h2>

<p>Q: Java的Integer, Double和Long类型的hashCode()是如何实现的？</p>

<blockquote><p>Integer类型直接返回该整数的32位值。对Double和Long返回机器表示的前32位和后32位异或的结果。</p></blockquote>

<p>Q: 为什么不将<code>hash(x)</code>实现为<code>x.hashCode() % M</code>?</p>

<blockquote><p>Java中，取余的结果可能是负数。</p></blockquote>

<p>Q: 为什么不将<code>hash(x)</code>实现为<code>Math.abs(x.hashCode()) % M</code>?</p>

<blockquote><p>对于最大的整数<code>Math.abs()</code>会返回一个负值，这种溢出可能使程序崩溃。</p></blockquote>

<p>Q: 在拉链法中，链表是否可以使用二叉查找树或者红黑树？</p>

<blockquote><p>一般来说，散列表碰撞机率越少越好，因此链表越短越好。所以链表的初级实现的性能一般会更好，特殊情况下最好由专家进行这种调优。</p></blockquote>

<p>Q: 散列表的查找比红黑树更快吗？</p>

<blockquote><p>取决于键的类型，也就是hashCode()的计算成本是否大于compareTo()的比较成本。但通常散列表会比红黑树快得多。但散列表无法高效支持有序性相关的操作。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[符号表]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/02/cha-zhao-suan-fa-fu-hao-biao/"/>
    <updated>2014-10-02T11:26:20+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/02/cha-zhao-suan-fa-fu-hao-biao</id>
    <content type="html"><![CDATA[<p>符号表就是用键和值的方式来存储和检索数据。其关键点在于如何快速检索和高效插入。本章介绍了符号表的简单实现、二叉查找树、红黑树的实现。</p>

<!--more-->


<p>首先还是来定义一下简单的符号表API：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20141002_170641.jpg" alt="image" /></p>

<h2>1. API定义</h2>

<p>符号表遵循以下规则：</p>

<ul>
<li>每个键只对应一个值；</li>
<li>当存入的键值对和表中已有的键冲突时，新的值会替代旧的值；</li>
<li>键不能为空；</li>
<li>值不允许为空；</li>
</ul>


<p>在简单的符号表中，键的等价性由equals()方法保证。而很多典型应用中，键都是Comparable对象，因此有序符号表可以保持键的有序并扩展其API：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20141002_170651.jpg" alt="image" /></p>

<ul>
<li>floor：向下取整，找出小于等于该键的最大键；</li>
<li>ceiling：向上取整，找出大于等于该键的最小键；</li>
<li>rank：小于key的键的数量；</li>
<li>select：获得排名为第k的键。</li>
</ul>


<p>对于0到size()-1的所有i都有：i == rank(select(i))，且所有键都满足：key == select(rank(key))。</p>

<h2>2. 实现</h2>

<h3>2.1 无序链表的顺序查找</h3>

<p>可以用链表来实现符号表，每个结点存储一个键值对，并保持一个链接指向下一个结点。这种方式非常简单，但是效率非常低。不论是get方法还是put方法，都需要从首节点开始一个一个地遍历。</p>

<h3>2.2 有序数组中的二分查找</h3>

<p>另一种实现方法是通过两个平行的数组来存储符号表。一个储存键，一个存储值。二分法可以用于保证数组中Comparable类型的键有序，并高效地实现get和其他操作(如select)。</p>

<p>对N个键的有序数组进行二分查找最多需要（lgN + 1）次比较。然而put方法却仍然很慢，向大小为N的有序数组插入一个新的元素，在最坏的情况下需要访问约2N次数组。因此向一个空的符号表插入N个元素时，最坏的情况下需要访问约N<sup>2</sup>次数组。</p>

<p>因此，我们需要一种结构，能够同时拥有二分法的查找效率和链表的插入效率。这就是二叉查找树。</p>

<h3>2.3 二叉查找树(BST)</h3>

<p>二叉查找树的定义：它是一棵二叉树，其中每个结点都含有一个Comparable的键以及相关联的值，每个结点的键都大于其左子树任意结点的键，同时小于右子树任意结点的键。</p>

<h4>2.3.1 基本实现</h4>

<p>如果将一棵二叉查找树的所有键投影到一条直线上，我们可以得到一条有序的键列，如下图所示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-02_15.10.37.png" alt="image" /></p>

<p>树结点的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Key</span> <span class="n">key</span><span class="o">;</span>           <span class="c1">// sorted by key</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Value</span> <span class="n">val</span><span class="o">;</span>         <span class="c1">// associated data</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Node</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">;</span>  <span class="c1">// left and right subtrees</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">N</span><span class="o">;</span>             <span class="c1">// number of nodes in subtree</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="n">Key</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">N</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h5>查找</h5>

<p>可以使用递归算法在二叉查找树中查找一个键：如果树是空的，则查找未命中；如果被查找的键和根结点的键相等，查找命中；否则就（递归地）在某个子树中继续查找。如果被查找的键较小就选择左子树，较大则选择右子树。查找过程与二分查找一样简单，代码实现如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">Value</span> <span class="nf">get</span><span class="o">(</span><span class="n">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nf">get</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">private</span> <span class="n">Value</span> <span class="nf">get</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
</span><span class='line'>    <span class="k">if</span>      <span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
</span><span class='line'>    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
</span><span class='line'>    <span class="k">else</span>              <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h5>插入</h5>

<p>二叉查找树的插入实现难度和查找差不多。当查找到一个不存在于树中的结点并结束于一条空链接时，我们需要做的就是将链接指向一个含有被查找的键的新结点。代码实现如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">Key</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">val</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="n">delete</span><span class="o">(</span><span class="n">key</span><span class="o">);</span> <span class="k">return</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'>    <span class="n">root</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">private</span> <span class="n">Node</span> <span class="nf">put</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">Key</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
</span><span class='line'>    <span class="k">if</span>      <span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span><span class="o">.</span><span class="na">left</span>  <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span>  <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span><span class='line'>    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span><span class='line'>    <span class="k">else</span>              <span class="n">x</span><span class="o">.</span><span class="na">val</span>   <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
</span><span class='line'>    <span class="n">x</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h5>分析</h5>

<p>二叉查找树的算法效率取决于树的形状。在最好的情况下，树是完全平衡的，此时查找和插入的效率都非常高。</p>

<p>但是，树的结构与结点插入的顺序是相关的。在最坏的情况下（例如升序队列中的元素按顺序插入）可能形成一条单边的树，就变成了链表的结构。这种不平衡的树完全失去了二分查找的效率。</p>

<p>因此，如何保持树的平衡是一个重要问题。要在二叉树动态插入中保证树的完美平衡，代价太高了。因此需要对结构进行一些调整，这就是平衡查找树。</p>

<h3>2.4 2-3查找树</h3>

<p>所谓2-3查找树，是指它或者为一棵空树，或者由以下结点组成：</p>

<ul>
<li>2-结点，含有一个键（及其对应的值）和两条链接，左链接指向的树的所有键都小于该结点，右链接指向的树的所有键都大于该结点。</li>
<li>3-结点，含有两个键（及其对应的值）和两条链接，左链接指向的树的所有键都小于该结点，中链接指向的树的所有键都位于该结点的两个键之间，右链接指向的树的所有键都大于该结点。</li>
</ul>


<p>利用2-3查找树，可以方便地实现完美平衡的查找树，2-3查找树示意图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-02_17_49.png" alt="image" /></p>

<h4>2.4.1 查找</h4>

<p>查找的过程与二叉查找树类似，区别仅在于3-结点树多了一个中链接。</p>

<h4>2.4.2 插入</h4>

<p>2-3查找树实现平衡的关键是插入过程，插入时先进行查找，如果未命中，将根据结束位置的多种情况，采用不同的方法。详细说明如下：</p>

<h5>向2-结点插入新键</h5>

<p>如果查找结束于一个2-结点，只要把这个2-结点替换为一个3-结点，将要插入的键保存在其中即可。如下图所示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-02_23tree-insert2.png" alt="image" /></p>

<h5>向一棵只含有一个3-结点的树中插入新键</h5>

<p>向3-结点的树中插入新键，也有多种情况，先看最简单的这种。如下图所示，先将3-结点变成4-结点，然后再分解为2-3树。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-02_23tree-insert3a.png" alt="image" /></p>

<h5>向一个父结点为2-结点的3-结点插入新键</h5>

<p>如果父结点为2-结点，则先把3-结点变成4-结点，然后将2-结点变成3-结点，如下图所示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-02_23tree-insert3b.png" alt="image" /></p>

<h5>向一个父结点为3-结点的3-结点插入新键</h5>

<p>跟前一步一样，先变成4-结点并分解它，然后再将它的中键插入它的父结点中。但其父结点也是3-结点，因此再用这个中键构造一个临时的4-结点，进行相同的变化，直到遇到一个2-结点将它变成3-结点。如果一直到根结点都是3-结点，则需要分解根结点。插入新键的过程如下图所示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10_02_23tree-insert3c.png" alt="image" /></p>

<h5>分解根结点</h5>

<p>在上一步中，根结点变成了一个临时的4-结点，此时我们按照向一棵只有一个3-结点的树中插入新键的方法处理此问题。将4-结点分解成3个2-结点，树高加1。如下图所示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-02_23tree-split.png" alt="image" /></p>

<h4>2.4.3 性能分析</h4>

<p>从上面这些情况可以看出，插入过程都是进行局部变换，除了相关的结点和链接之外不必修改或检查树的其他部分，因此效率非常高。经过变换后，保持了树的有序性和平衡性。因此在一棵大小为N的2-3树中，查找和插入操作访问的结点必然不超过lgN个！例如含有10亿个结点的一棵2-3树的高度仅在19-30之间，最多只需要访问30个结点就能够在10亿个键中进行任意查找和插入操作，这是多么惊人！这也是<a href="http://blog.ubone.com/blog/2014/08/25/cheng-xu-yuan-de-shu-zi/">程序员的数学</a>中提到的利用指数爆炸解决问题。</p>

<h3>2.5 红黑二叉查找树</h3>

<p>2-3查找树很容易理解，现在我们通过红黑二叉树来表达并实现它。其关键是3-结点如何实现。我们将树中的链接分为两种类型：红链接将两个2-结点连接起来构成一个3-结点，黑链接则是普通链接。如下图所示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-02_redblack-encoding.png" alt="image" /></p>

<p>红黑树是含有红黑链接并满足以下条件的二叉查找树：</p>

<ul>
<li>红链接均为左链接；</li>
<li>没有任何一个结点同时和两条红链接相连；</li>
<li>该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。</li>
</ul>


<p>因此在节点类（Node）中，增加一个属性color表示从父结点指向自己的链接是否为红链接：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Key</span> <span class="n">key</span><span class="o">;</span>           <span class="c1">// sorted by key</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Value</span> <span class="n">val</span><span class="o">;</span>         <span class="c1">// associated data</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Node</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">;</span>  <span class="c1">// left and right subtrees</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">N</span><span class="o">;</span>             <span class="c1">// number of nodes in subtree</span>
</span><span class='line'>    <span class="kt">boolean</span> <span class="n">color</span><span class="o">;</span>             <span class="c1">//是否红链接   </span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="n">Key</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">color</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">N</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">color</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在进一步实现红黑树之前，要了解几个基本的动作：左旋转、右旋转和颜色转换。</p>

<h4>2.5.1 旋转</h4>

<p>左旋转是将一条红色的右链接转化为左链接。转换的过程为：将两个键中的较小者作为根结点变为将较大者作为根结点。如下图所示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-02_redblack-left-rotate.png" alt="image" /></p>

<p>右旋转是将一条红色的左链接转化为右链接，实现过程与左旋转相似，只需要将left和right互换即可：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-02_redblack-right-rotate.png" alt="image" /></p>

<h4>2.5.2 颜色转换</h4>

<p>颜色转换是对一个结点的两个红色子结点的颜色进行转换。除了将子结点的颜色由红变黑外，还要同时将父结点的颜色由黑变红。如下图所示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-02_color-flip.png" alt="image" /></p>

<h4>2.5.3 插入处理过程</h4>

<p>插入新键时，都使用红链接与父结点相连，然后谨慎地使用左旋转、右旋转和颜色转换这三个简单的操作，就能够保证操作后的红黑树与2-3树一一对应的关系。在沿着插入点到根结点的路径向上移动时在所经过的每个结点中顺序完成以下操作，我们就能完成插入操作：</p>

<ol>
<li>如果右子结点是红色，而左子结点是黑色，进行左旋转；</li>
<li>如果左子结点是红色，且它的左子结点也是红色，进行右旋转；</li>
<li>如果左右子结点都是红色，进行颜色转换。</li>
</ol>


<p>下面是各种情况的示例：</p>

<p><img src="http://blog.ubone.com/myresource/images/IMG_20141002_222628.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/IMG_20141002_222714.jpg" alt="image" /></p>

<h4>2.5.4 插入算法的实现</h4>

<p>以下为红黑树的插入算法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedBlackBST</span><span class="o">&lt;</span><span class="n">Key</span> <span class="kd">extends</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;,</span> <span class="n">Value</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">RED</span>   <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">BLACK</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Node</span> <span class="n">root</span><span class="o">;</span>     <span class="c1">// root of the BST</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// BST helper node data type</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">private</span> <span class="n">Key</span> <span class="n">key</span><span class="o">;</span>           <span class="c1">// key</span>
</span><span class='line'>        <span class="kd">private</span> <span class="n">Value</span> <span class="n">val</span><span class="o">;</span>         <span class="c1">// associated data</span>
</span><span class='line'>        <span class="kd">private</span> <span class="n">Node</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">;</span>  <span class="c1">// links to left and right subtrees</span>
</span><span class='line'>        <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">color</span><span class="o">;</span>     <span class="c1">// color of parent link</span>
</span><span class='line'>        <span class="kd">private</span> <span class="kt">int</span> <span class="n">N</span><span class="o">;</span>             <span class="c1">// subtree count</span>
</span><span class='line'>
</span><span class='line'>        <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="n">Key</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">color</span><span class="o">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
</span><span class='line'>            <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
</span><span class='line'>            <span class="k">this</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">color</span><span class="o">;</span>
</span><span class='line'>            <span class="k">this</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">N</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// insert the key-value pair; overwrite the old value with the new value</span>
</span><span class='line'>    <span class="c1">// if the key is already present</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">Key</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">root</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span><span class='line'>        <span class="n">root</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// insert the key-value pair in the subtree rooted at h</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Node</span> <span class="nf">put</span><span class="o">(</span><span class="n">Node</span> <span class="n">h</span><span class="o">,</span> <span class="n">Key</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="n">RED</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span>      <span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">h</span><span class="o">.</span><span class="na">left</span>  <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">,</span>  <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span><span class='line'>        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">h</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span><span class='line'>        <span class="k">else</span>              <span class="n">h</span><span class="o">.</span><span class="na">val</span>   <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// fix-up any right-leaning links</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">))</span>      <span class="n">h</span> <span class="o">=</span> <span class="n">rotateLeft</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span>  <span class="o">&amp;&amp;</span>  <span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span><span class="o">))</span> <span class="n">h</span> <span class="o">=</span> <span class="n">rotateRight</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span>  <span class="o">&amp;&amp;</span>  <span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">))</span>     <span class="n">flipColors</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
</span><span class='line'>        <span class="n">h</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">h</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>2.5.5 删除操作</h4>

<h5>删除最小键</h5>

<p>先来看删除最小键。从树底部的3-结点删除键很简单，但2-结点则不然。为了保证我们不会删除一个2-结点，我们沿着左链接向下进行变换，确保当前结点不是2-结点。在沿着左链接向下的过程中，保证以下情况之一成立：</p>

<ul>
<li>如果当前结点的左子结点不是2-结点，完成；</li>
<li>如果当前结点的左子结点是2-结点而它的亲兄弟结点不是2-结点，将左子结点的兄弟结点中的一个键移到左子结点；</li>
<li>如果当前结点的左子结点和它的亲兄弟结点都是2-结点，将左子结点、父结点中的最小键和左子结点最近的兄弟结点合并为一个4-结点，使父结点由3-结点变为2-结点或者4-结点变为3-结点。</li>
</ul>


<p>在遍历的过程中执行这个过程，最后能够得到一个含有最小键的3-结点或者4-结点，然后我们就可以直接从中将其删除，将3-结点变为2-结点，或者将4-结点变为3-结点。然后我们再回头向上分解所有临时的4-结点。</p>

<p><img src="http://blog.ubone.com/myresource/images/IMG_20141002_232607.jpg" alt="image" /></p>

<h5>删除操作</h5>

<p>在查找路径上进行和删除最小键相同的变换同样可以保证在查找过程中任意当前结点均不是2-结点。如果被查找的键在树的底部，我们可以直接删除它。如果不在，我们需要将它和它的后续结点交换，就和二叉查找树一样。因为当前结点必然不是2-结点，问题已经转化为在一棵根结点不是2-结点的子树中删除最小键，我们可以在这棵子树中使用上面的算法。删除之后，同样需要向上回溯并分解余下的4-结点。</p>

<p><a href="http://blog.ubone.com/myresource/code/RedBlackBST.java">红黑树完整代码</a></p>

<h4>2.5.6 红黑树的性能</h4>

<p>一棵大小为N的红黑树的高度不会超过2lgN，根结点到任意结点的平均路径长度为1.00lgN，以下操作在最坏的情况下所需的时间是对数级别的：get, put, min, max, floor, ceiling, rank, select, deleteMin, deleteMax, delete, range。</p>

<h2>总结</h2>

<p>各种符号表实现的性能总结：</p>

<p><img src="http://blog.ubone.com/myresource/images/IMG_20141002_233353.jpg" alt="image" /></p>

<p>在信息世界的汪洋大海中，表的大小可能是上千亿，但我们仍然能够确保在几十次比较之内就完成这些操作！</p>
]]></content>
  </entry>
  
</feed>
