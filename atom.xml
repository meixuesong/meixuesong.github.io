<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[码出人生]]></title>
  <link href="http://blog.ubone.com/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2014-08-26T20:59:59+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[程序员的数学]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/25/cheng-xu-yuan-de-shu-zi/"/>
    <updated>2014-08-25T22:22:26+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/25/cheng-xu-yuan-de-shu-zi</id>
    <content type="html"><![CDATA[<p>这是一篇《程序员的数学》读书笔记。这本书没有讲高深的数学理论，而是用浅显易懂的道理推导出一些数学知识。整本书浅显易懂，学不了太多东西，但对启发数学思维有一点用处。</p>

<!--more-->


<p>全书共分为8章，每章的内容或要点摘录如下：</p>

<h2>第1章 0的故事</h2>

<p>本章首先介绍了10进制、2进制计数法。它们都属于<strong>按位计数</strong>，例如10进制的2503可表示为：</p>

<blockquote><p><strong>2</strong> * 10<sup>3</sup> + <strong>5</strong> * 10<sup>2</sup> + <strong>0</strong> * 10<sup>1</sup> + <strong>3</strong> * 10<sup>0</sup></p></blockquote>

<p>同样地，2进制的1100可表示为：</p>

<blockquote><p><strong>1</strong> * 2<sup>3</sup> + <strong>1</strong> * 2<sup>2</sup> + <strong>0</strong> * 2<sup>1</sup> + <strong>0</strong> * 2<sup>0</sup></p></blockquote>

<p>将10进制的转换成2进制，只需要除以2，将将余数排列起来就可以了，如下图，将12转换成2进制，变成1100：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140825_m01.jpg" alt="image" /></p>

<p>除了按位计数，还有<strong>罗马计数法</strong>，例如钟表表盘。没有0，使用I(1), V(5), X(10), L(50), C(100), D(500), M(1000)来记数，将并排的数字加起来就是所表示的数。其中有“减法规则”，如IV，在V的左侧写I，表示5-1。例如：</p>

<blockquote><p>MCMXCVIII = (M) + (CM) + (XC) + (V) + (III) = (1000) + (1000 &ndash; 100) + (100 &ndash; 10) + (5) + (3) = 1998</p></blockquote>

<h3>第2章 逻辑</h3>

<p>逻辑的基本思路：完整性（有没有遗漏？）和排他性（有没有重复？）。可以画一根数轴来检查：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140825_m02.jpg" alt="image" /></p>

<p><strong>最容易出错的地方往往发生在边界值上！</strong></p>

<p>除了常见的逻辑运算（非、并且、或者）外，异或指的是：A⊕B，仅当A和B不同时为True, 相同时为False。</p>

<p>德摩根定律指的是(﹁指非，^表示并且， V表示或者)：</p>

<blockquote><p>(﹁A)V(﹁B) = ﹁(A ^ B), (﹁A)<sup>﹁B</sup> = ﹁(A V B)</p></blockquote>

<h3>卡诺图</h3>

<p>卡诺图是一个非常好的工具，它能够简化复杂的逻辑表达式。例如对于这样的规则：</p>

<p>当发生以下情况时按下按钮：</p>

<ol>
<li>绿灯、黄灯、红灯都灭</li>
<li>黄灯灭，红灯亮</li>
<li>绿灯灭，黄灯亮</li>
<li>绿灯、黄灯、红灯都亮</li>
</ol>


<p>可以设有以下命题，画出卡诺图：</p>

<ol type="a">
<li>绿灯亮</li>
<li>黄灯亮</li>
<li>红灯亮</li>
</ol>


<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140825_m03.jpg" alt="image" /></p>

<p>最后得出逻辑表达式：当(﹁A)V C时，按下按钮。</p>

<h2>第3章 余数</h2>

<p>将较大的数字除一下，就能根据余数分组。例如求10<sup>100</sup>天以后是星期几？此外，还有奇偶校验的问题。将大问题转换成小问题，余数是一种重要武器。</p>

<h2>第4章 数学归纳法</h2>

<p>两个步骤：</p>

<ol>
<li>证明P(0)成立。</li>
<li>证明不论k为0以上的哪个整数，若P(k)成立，则P(k + 1)也成立。</li>
</ol>


<h2>第5章 排列组合</h2>

<ul>
<li>加法法则：|A U B| = |A| + |B|</li>
<li>乘法法则：|A x B| = |A| x |B|</li>
</ul>


<p>基本知识：n位2进制数可以表示的数的总数为2<sup>n</sup>。</p>

<h3>置换</h3>

<p>如果将A, B, C三张牌按照ABC, ACB, BAC&hellip;等顺序排列，共有多少种排法？</p>

<ul>
<li>第1张牌有3种选法</li>
<li>第2张牌，扣除了第1张牌，因此有2种选法</li>
<li>第3张牌，有1张选法。</li>
</ul>


<p>因此共有3 x 2 x 1 = 6种排法。</p>

<p>将n个事务按顺序进行排列称为置换（Substitution）。n张牌的置换总数为n的阶乘：n! = n x (n &ndash; 1) x (n &ndash; 2) x &hellip; x 2 x 1。</p>

<h3>排列</h3>

<p>从n个事物中取出一部分进行排列（Permutation）。从A、B、C、D、E共5张牌，选出3张牌进行排列，有多少种排法？</p>

<ul>
<li>第1张的取法有5种</li>
<li>第2张的取法有4种</li>
<li>第3张的取法有3种</li>
</ul>


<p>因此共有：5x4x3=60种排列。即从n张牌中取出k张进行排列的种数为：P<sub>n</sub><sup>k</sup> = n x (n &ndash; 1) x (n &ndash; 2) x &hellip; x (n &ndash; k + 1) = n! /(n-k)!</p>

<h3>组合</h3>

<p>从n个事物中取出一部分，不考虑它们的顺序，称为组合（Combination）。从n张牌，选出k张牌，不考虑顺序，有多少种取法？可以先按排列一样，考虑顺序进行计数，然后除以重复计数的部分。即：</p>

<ul>
<li>C<sub>n</sub><sup>k</sup> = n张里面取k张的排列总数 / k张的置换总数</li>
<li>= P<sub>n</sub><sup>k</sup> / P<sub>k</sub><sup>k</sup></li>
<li>= n! / ((n-1)!k!)</li>
</ul>


<h3>置换、排列和组合的关系</h3>

<p>置换和组合相结合就是排列。为什么？置换表示“3张牌的交替排列方法”，组合表示“3张牌的取法”，两者结合起来就是“取出3张牌，进行交替排列”，即表示排列。</p>

<h2>第6章 递归</h2>

<p>递归就是要将复杂的问题简化。假设现在要找出问题中的递归结构，可以按以下步骤进行：
* 从n层的整体问题中隐去部分问题。
* 判断剩余部分是否是n-1层的问题。</p>

<p>即要发现F(n)与F(n-1)，甚至F(n-2)之间的关系。</p>

<h2>第7章 指数爆炸</h2>

<p>1mm厚的纸，在对折39次之后，就达到54万公里，超过了地球与月亮之间的距离！这就是指数爆炸。利用指数爆炸可以解决一些计算问题。例如二分法查找，在15个数中查找特定的数，最多只需要3次。</p>

<p>对于很大的数，处理时可以转换成对数处理。</p>

<p>处理指数爆炸的四种方法：</p>

<ol>
<li>极力求解，即增加计算机性能。</li>
<li>变相求解，即转换成简单问题求解。</li>
<li>近似求解。</li>
<li>概率求解，处于研究中。</li>
</ol>


<h2>第8章 不可解问题</h2>

<p>反证法，就是首先假设“命题的否定形式”成立，然后根据假设论证，推导出矛盾的结果。例如论证“为什么不存在最大的整数”。假设存在，且M就是最大的整数，那么M + 1 > M，与假设矛盾。因此不存在最大的整数。</p>

<p>什么是<strong>可数</strong>？集合的元素是有限的，或者集合中的所有元素都与正整数一一对应，那么这个集合就被定义为<strong>可数（Countable）</strong>。书中举例了一些可数的集合（有限集合、0以上的所有偶数的集合、所有整数的集合、所有有理数的集合、程序的集合），以及不可数的集合（所有整数数列的集合、所有实数的集合、所有函数的集合），并用反证法进行了证明。</p>

<p>不可解问题是“原则上不能用程序来解决的问题”。书中举了“停机”问题的例子，即判断“某程序在给定数据下，是否会在有限时间内结束运行”的问题。</p>

<h2>总结</h2>

<p>在解决问题时，要学会使用“先用较小的数试算”的方法，发现规律、性质、结构、循环、一致性等，认清隐含在问题中的模式。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Java-通用程序设计]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/22/effective-java-tong-yong-cheng-xu-she-ji/"/>
    <updated>2014-08-22T20:06:07+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/22/effective-java-tong-yong-cheng-xu-she-ji</id>
    <content type="html"><![CDATA[<p>Effective Java 通用程序设计，读书笔记：</p>

<ol>
<li>将局部变量的作用域最小化</li>
<li>for-each循环优先于传统的for循环</li>
<li>使用类库</li>
<li>如果需要精确值，就避免使用float和double</li>
<li>基本类型优先于装箱基本类型</li>
<li>如果其它类型更合适，则尽量避免使用字符串</li>
<li>小心字符串拼接的性能问题</li>
<li>通过接口引用对象</li>
<li>接口优先于反射机制</li>
<li>谨慎使用本地方法</li>
<li>谨慎进行优化</li>
<li>遵守普遍接受的命名惯例</li>
</ol>


<!--more-->


<h2>45 将局部变量的作用域最小化</h2>

<p>局部变量只在第一次使用它的地方声明。每个局部变量的声明都应该包含一个初始化表达式。</p>

<h2>46 for-each循环优先于传统的for循环</h2>

<p><code>for(String str : list)</code>这样的for-each语句在简洁性和预防Bug方面有着传统for循环无法比拟的优势，并且没有性能损失。但如果在遍历时删除、替换、前移等操作时，无法使用for-each语句。</p>

<h2>47 使用类库</h2>

<p>不要重新发明轮子，尽量使用标准类库。例如随机数应该使用Random.nextInt(int)，而不是自己去写一个生成随机数的类。Java程序员应该精通java.lang, java.util包中的内容，还应该熟悉java.io, Collection, concurrent类库。</p>

<h2>48 如果需要精确值，就避免使用float和double</h2>

<p>要计算精确的结果，可以使用BigDecimal，它还包括8种舍入模式。但是它的缺点是不太方便并且有性能上的损失。也可以自己处理小数点和舍入，使用int, long。数据数值没有超过9位十进制数字，可以使用int，如果不超过18位数字，可以使用long。如果可能超过18位，就必须使用BigDecimal</p>

<h2>49 基本类型优先于装箱基本类型</h2>

<p>也就是int，boolean等优先于Integer和Boolean等。下面方法的返回值是多少？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Integer</span> <span class="n">first</span><span class="o">,</span> <span class="n">Integer</span> <span class="n">second</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>     <span class="k">return</span> <span class="n">first</span> <span class="o">&lt;</span> <span class="n">second</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="o">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">second</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">compare</span><span class="o">(</span><span class="k">new</span> <span class="n">Integer</span><span class="o">(</span><span class="mi">42</span><span class="o">),</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">(</span><span class="mi">42</span><span class="o">));</span>  <span class="c1">//结果为1</span>
</span></code></pre></td></tr></table></div></figure>


<p>原因是装箱类型是对象引用，<code>first == second</code> 为false。除此之外，需要注意的是装箱类型可能是null，可能因此引起一些潜在隐患。而装箱类型的性能也可能是个问题（如创建和销毁对象中第5条“避免创建不必要的对象”中提到的循环累计时的Long性能不如long）/blog/2014/06/27/effective-java-chuang-jian-he-xiao-hui-dui-xiang/</p>

<h2>50 如果其它类型更合适，则尽量避免使用字符串</h2>

<ol>
<li>字符串不适合代替其它的值类型，例如从文件中的int值以字符串存在，读出后就应该还原成int类型。</li>
<li>字符串不适合代替枚举类型</li>
<li>字符串不适合代替聚集类型。如用001_003代表两个东西，更好的办法是用一个私有静态成员类。</li>
</ol>


<h2>51 小心字符串拼接的性能问题</h2>

<h2>52 通过接口引用对象</h2>

<p>养成用接口作为类型的习惯。如果没有合适的接口存在，完全可以用（基）类来引用对象。</p>

<h2>53 接口优先于反射机制</h2>

<p>反射机制是一种功能强大的机制，对于特定的复杂系统编程任务，它是非常必要的，但它也有一些缺点：</p>

<ol>
<li>丧失了编译时类型检查的好处</li>
<li>执行反射访问所需的代码笨拙而冗长</li>
<li>性能损失</li>
</ol>


<p>因此，如果你编写的程序必须要与编译时未知的类一起工作，如有可能，就应该仅仅使用反射机制来实例化对象，而访问对象时则使用编译时已知的某个接口或者父类。例如未知的类实现了Set，则可以用反射机制实例化它，但访问它的方法时，使用Set的方法。</p>

<h2>54 谨慎使用本地方法</h2>

<p>Java Native Interface(JNI)允许Java调用本地方法（指本地程序设计语言如C, C++编写的特殊方法）。Java早期时，本地方法的用途是访问特定平台的能力（如注册表）、访问遗留代码库和提高性能。但现在已经没有太大必要了。</p>

<h2>55 谨慎进行优化</h2>

<p>不要费力去编写快速的程序，应该努力编写好的程序。在设计API、数据格式时，一定要考虑性能的因素。例如API，如果后期将公有的类型变成可变的（mutable），可能会导致大量不必要的保护性拷贝，影响性能。同样地，在适合使用复合模式的公有类使用了继承，会把这个类永远与父类绑在一起，人为地限制了子类的性能。如果在API中使用实现类型而不是接口，就会被束缚在一个具体的实现上，即使将来出现了更快的实现你也无法使用。</p>

<h2>56 遵守普遍接受的命名惯例</h2>

<p>对于类型参数：</p>

<ul>
<li>T表示任意类型</li>
<li>E表示集合的元素类型</li>
<li>K和V表示Map的键和值</li>
<li>X表示异常</li>
<li>任何类型的序列可以是T, U, V或者T1, T2, T3</li>
</ul>


<p>对于转换对象的方法，返回不同类型的独立对象的方法，通常被称为toType，如toString, toArray。返回视图的方法通常称为asType，如asList。静态工厂的常用名称为valueOf, of, getInstance, newInstance, getType和newType。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:解释器模式与调停者模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/20/she-ji-mo-shi-jie-shi-qi-mo-shi/"/>
    <updated>2014-08-20T22:31:36+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/20/she-ji-mo-shi-jie-shi-qi-mo-shi</id>
    <content type="html"><![CDATA[<p>之所以将这两个模式放在一起，是因为它们很少用得到。</p>

<h3>解释器(Interpreter)模式</h3>

<p>给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。例如对于数学运算表达式（a + b + c），如果a, b和c的值已知，如何得到结果？一种办法是使用直接计算值的方法写一个算法，但是如果有很多个表达式呢？不可能为每一个表达式写一个算法。这时候解释器模式就能派上用场了。</p>

<h3>调停者(Mediator)模式</h3>

<p>当对象之间的关系成网状时，就会耦合得过于紧密。通过调停者模式转换成星状结构，调停者在中心，所有对象都只与调停者打交道，实现对象间的解耦。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Java-方法]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/20/effective-java-fang-fa/"/>
    <updated>2014-08-20T19:32:51+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/20/effective-java-fang-fa</id>
    <content type="html"><![CDATA[<p>读书笔记：</p>

<ol>
<li>检查参数的有效性</li>
<li>必要时进行保护性拷贝</li>
<li>谨慎设计方法签名</li>
<li>慎用重载</li>
<li>慎用可变参数</li>
<li>返回零长度的数组或者集合，而不是null
44. 为所有导出的API元素编写文档注释</li>
</ol>


<!--more-->


<h2>38 检查参数的有效性</h2>

<p>检查方法参数的有效性，以便更早地发现问题。对于公有方法，要用Javadoc的@throw标签在文档中说明违反参数限制时会抛出的异常。例如：IllegalArgumentException, IndexOutOfBundsException或NullPointerException。对于非公有方法，一般采用断言来检查参数。</p>

<p>通常在计算过程之前，应该进行有效性检查。但如果有效性检查工作成本较高，或者有效性检查已经隐含在计算过程中，那么就不用先进行检查。但计算过程中由于参数的问题造成的异常可能不是方法文档中标明的那个异常，此时可以使用异常转译（第61条）技术，将其转换为正确的异常。</p>

<h2>39 必要时进行保护性拷贝</h2>

<p>如果类的内部状态使用了客户端传入的对象，而该对象是可变的，那么尽量不要直接引用这个外部对象，而是将其复制一份。对于构造器的每个可变参数进行保护性拷贝是必要的。而且保护性拷贝应该在有效性检查之前进行。如果参数类型可以被不可信任方子类化，那么不要使用clone方法进行保护性拷贝。</p>

<p>对于访问方法(如get)，为了防御类似的攻击，可以返回内部属性的保护性拷贝。例如对于Date类属性，在返回时，可以新建一个Date对象返回。另一种方式是返回Date.getTime()，即返回long基本类型的时间。访问方法在进行保护性拷贝时，允许使用clone方法，原因是我们知道返回类型时什么，只要它不会是其他某个潜在不可信子类，就可以使用clone方法。</p>

<p>对于内部长度非零的数组，在返回给客户端之前，应该总是进行保护性拷贝。另一种解决方案是，返回数组的不可变视图。（见第13条）</p>

<p>如果类信任它的调用者不会修改内部组件，例如在同一个包中，那么不进行保护性拷贝也是可以的，但类文档中应该清楚说明，调用者绝不能修改受到影响的参数或返回值。</p>

<h2>40 谨慎设计方法签名</h2>

<ol>
<li>谨慎选择方法的名称。</li>
<li>不要过于追求提供便利的方法。每个方法都应该尽其所能，方法太多会使类难以学习。只有某一项操作经常使用时，才考虑为其提供快捷方式。</li>
<li>避免过长的参数列表。解决方法：一是将方法分解成多个方法；二是创建辅助类（一般为静态成员类），保存这些参数。三是使用Builder模式。</li>
</ol>


<p>对于参数类型，优先使用接口。</p>

<p>对于boolean参数，优先使用两个元素的枚举类型。它使代码更易于阅读和编写。而且未来扩展时，可以轻易增加更多状态。</p>

<h2>41 慎用重载</h2>

<p>下面的代码执行结果可能与预期不同：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">classify</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;?&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>     <span class="k">return</span> <span class="s">&quot;List&quot;</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">classify</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;?&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>     <span class="k">return</span> <span class="s">&quot;Collection&quot;</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>     <span class="n">Collection</span><span class="o">&lt;?&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">BigInteger</span><span class="o">&gt;();</span>
</span><span class='line'>     <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">classify</span><span class="o">(</span><span class="n">c</span><span class="o">));</span>
</span><span class='line'>     <span class="c1">//结果是Collection</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>原因是重载(overload)方法的选择是静态的，即在编译期决定。而被覆盖(override)的方法的选择是动态的，即在运行时决定。在上面的例子中，程序编译时，参数的类型是Collection，所以打印的结果是Collection。正如<a href="http://blog.ubone.com/blog/2014/08/19/she-ji-mo-shi-fang-wen-zhe-mo-shi">访问者模式</a>提到的：</p>

<blockquote><p>Java语言支持静态的多分派和动态的单分派。对于Java方法重载（Overload），在编译期会根据方法的接收者类型和方法的所有参量类型进行分派，因此是静态多分派。而方法覆盖（Override），是在运行时仅仅根据方法的接收者类型进行分派。</p></blockquote>

<p>因此，安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法。如果方法使用了可变参数，最好是不要重载它。例如ObjectOutputStream类中，没有使用重载方法，而是对于每种类型都提供了read和write方法: writeBoolean(boolean), writeInt(int)。对于构造器，没有办法使用不同的方法名称，但可以使用静态工厂方法或者Builder模式。</p>

<p>Java 1.5的自动装箱出现之后，重载也导致了一些麻烦。例如下面的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
</span><span class='line'><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>     <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>     <span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;list: &quot;</span> <span class="o">+</span> <span class="n">list</span><span class="o">);</span>
</span><span class='line'><span class="c1">//打印结果：list: [-2, 0, 2]</span>
</span></code></pre></td></tr></table></div></figure>


<p>原因是List.remove是重载方法：<code>remove(int i); remove(Object o);</code> 所以为了达到预期效果，要改为：<code>list.remove((Integer)i);</code></p>

<p>因此，能够重载方法并不意味着就应该重载方法。请慎用重载方法。</p>

<h2>42 慎用可变参数</h2>

<p>可变参数接受0或多个指定类型的参数。如果希望参数最少要1个，则可以这样定义方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">someOperation</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span><span class="o">...</span> <span class="n">otherArgs</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>43 返回零长度的数组或者集合，而不是null</h2>

<p>如果返回null，那么客户端始终要进行null判断。返回零长度的数组或集合时，不用在这个级别担心性能问题。</p>

<h2>44 为所有导出的API元素编写文档注释</h2>

<p>其中要注意的是，文档注释也应该描述类或者方法的线程安全性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:访问者模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/19/she-ji-mo-shi-fang-wen-zhe-mo-shi/"/>
    <updated>2014-08-19T22:17:28+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/19/she-ji-mo-shi-fang-wen-zhe-mo-shi</id>
    <content type="html"><![CDATA[<p>访问者(Visitor)模式的目的是封装一些施加于某种数据结构元素之上的操作，一旦这些操作需要修改的话，接受这个操作的数据结构则可以保持不变。假如要对一个不同类型的聚集进行遍历，为了判断不同的类型对象，需要写很多的if else，而访问者模式可以解决此问题。示意类图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140819_232009.jpg" alt="image" /></p>

<!--more-->


<ol>
<li>Visitor角色：声明一个或多个访问操作。</li>
<li>ConcreteVisitor角色：实现接口方法。</li>
<li>Node角色：声明一个接受操作，接受一个访问者对象作为一个参数。</li>
<li>Concrete Node角色：实现接受操作。</li>
<li>ObjectStructure角色：遍历结构中的所有元素，如果需要，提供高层次的接口让访问者对象可以访问每一个元素；如果需要，可以设计成一个复合对象或者一个聚集，如List或Set。</li>
</ol>


<h3>单分派和多分派</h3>

<p>方法的接收者（即方法所属的对象）和方法的参量统称为方法的宗量。单分派语言根据一个宗量的类型进行方法的选择，多分派语言根据多于一个的宗量的类型对方法进行选择。</p>

<p>Java语言支持静态的多分派和动态的单分派。对于Java方法重载（Overload），在编译期会根据方法的接收者类型和方法的所有参量类型进行分派，因此是静态多分派。而方法覆盖（Override），是在运行时仅仅根据方法的接收者类型进行分派。</p>

<p>在访问者模式中，数据结构的每一个节点都可以接受一个访问者的调用，此节点向访问者对象传入节点对象，而访问者对象则反过来执行节点对象的操作。这样的过程就叫做“双重分派”。</p>

<h3>示例代码</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">//class ConcreteVisitor</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">visitA</span><span class="o">(</span><span class="n">NodeA</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">operationA</span><span class="o">());</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//class NodeA</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="n">Visitor</span> <span class="n">visitor</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">visitor</span><span class="o">.</span><span class="na">visitA</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//class ObjectStructure</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">action</span><span class="o">(</span><span class="n">Visitor</span> <span class="n">visitor</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">for</span><span class="o">(</span><span class="n">Enumeration</span> <span class="n">e</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="na">elements</span><span class="o">();</span> <span class="n">e</span><span class="o">.</span><span class="na">hasMoreElements</span><span class="o">();)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">node</span> <span class="o">=</span> <span class="o">(</span><span class="n">Node</span><span class="o">)</span><span class="n">e</span><span class="o">.</span><span class="na">nextElement</span><span class="o">();</span>
</span><span class='line'>      <span class="n">node</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">visitor</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//class Client</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">ObjectStructure</span> <span class="n">aObjects</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectStructure</span><span class="o">();</span>
</span><span class='line'>  <span class="n">aObjects</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">NodeA</span><span class="o">());</span>
</span><span class='line'>  <span class="n">aObjects</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">NodeB</span><span class="o">());</span>
</span><span class='line'>  <span class="n">Visitor</span> <span class="n">visitor</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcreteVisitor</span><span class="o">();</span>
</span><span class='line'>  <span class="n">aObjects</span><span class="o">.</span><span class="na">action</span><span class="o">(</span><span class="n">visitor</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>访问者模式的优缺点</h3>

<p>访问者模式仅应当用在被访问的类结构非常稳定的情况。如果出现需要加入新的Node的情况，则必须在每一个访问对象中加入一个对应于这个新节点的访问操作，这将是一个大规模修改，违背“开-闭”原则。</p>

<p>如果系统有比较稳定的数据结构，又有易于变化的算法，使用访问者模式就比较合适。</p>

<p>访问者模式的优点包括：</p>

<ol>
<li>增加新的操作变得非常容易，只需要增加一个新的访问者。</li>
<li>此模式将行为集中到一个访问者对象中，而不是分散到节点类中。因此可以在访问的过程中将执行操作的状态积累在自己内部（例如计算合计值）。</li>
</ol>


<p>访问者模式的缺点：增加新的节点类变得很困难。每增加一个新的节点都要在抽象访问者角色中增加一个新的抽象操作，并在每个具体访问者类中增加相应的具体操作。</p>

<p>访问者模式是一个存争议的设计模式。</p>

<p>——《Java与模式》读书笔记</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:状态模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/18/she-ji-mo-shi-zhuang-tai-mo-shi/"/>
    <updated>2014-08-18T20:22:06+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/18/she-ji-mo-shi-zhuang-tai-mo-shi</id>
    <content type="html"><![CDATA[<p>状态模式把对象的行为包装在不同的状态对象里，所有状态对象都属于抽象状态类的子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。类图示意如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140818_224041.jpg" alt="image" /></p>

<!--more-->


<ol>
<li>State角色：定义接口，用于封装Context对象的一个特定的状态所对应的行为。</li>
<li>ConcreteState角色：每个具体状态类实现Context的一个状态所对应的行为。</li>
<li>Context角色：定义客户端所感兴趣的接口，并且保留一个具体状态类的实例，即当前的状态。上图中Context.someOperation的行为是委派给具体State类来执行的。当Context.state变化时，动态地将具体类指向另一个具体状态类，从而改变改变其行为。</li>
</ol>


<h3>什么情况下使用状态模式</h3>

<ol>
<li>对象的行为依赖于它所处的状态，对象的行为必须随着其状态的改变而改变。</li>
<li>对象在某个方法里依赖于一重或多重的条件转移语句，其中有大量的代码。状态模式可以把条件转移语句的每一个分支包装到一个状态类中。</li>
</ol>


<p>TcpConnection就是一个状态模式的经典例子，TCP连接的三个状态（Established, Listening, Closed）分别对应三个状态类（TcpEstablished, TcpListen, TcpClosed）。</p>

<p>在绘图软件中，状态模式广泛用于建立编辑器框架。使客户端能够轻易地挂接新工具。</p>

<h3>模式实现</h3>

<p>状态的变化由谁来定义？状态模式并没有对此进行规定。可以由外部事件、Context控制或者具体State自行决定。</p>

<p>状态对象的创建和销毁，可以按需创建或者预先创建。</p>

<h3>与其它模式的关系</h3>

<p>状态模式与策略模式很相似，类图也很相似。但是策略模式的特点是，一旦环境类选择了一个具体策略，那么在其生命周期内就不会改变这个具体策略类。而状态模式在环境类的生命周期中会有多个不同的状态对象被使用。</p>

<p>——《Java与模式》读书笔记</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:备忘录模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/13/she-ji-mo-shi-bei-wang-lu-mo-shi/"/>
    <updated>2014-08-13T23:00:58+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/13/she-ji-mo-shi-bei-wang-lu-mo-shi</id>
    <content type="html"><![CDATA[<p>备忘录(Memento)模式又叫做快照模式。备忘录对象是一个用来存储另外一个对象内部状态快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态存储在外部，从而在合适的时候把这个对象还原到原来的状态。通常系统不止存储一个状态，而是存储多个状态（快照）。每一个快照所处的位置就是Check Point。其结构如下图：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140813_231854.jpg" alt="image" /></p>

<!--more-->


<ol>
<li>备忘录(Memento)角色：一是将发起人(Originator)对象的内部状态存储起来；二是保护其内容不被发起人以外的任何对象所读取，即图中宽接口和窄接口的作用。</li>
<li>发起人(Originator)角色：创建备忘录对象，并使用该对象存储其内部状态。</li>
<li>负责人(Caretaker)角色：负责保存备忘录对象，不管备忘录对象的内容。</li>
</ol>


<h3>白箱实现</h3>

<p>在Java中实现宽、窄两个接口并不容易，白箱实现就是只提供宽接口。类图示意如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140813_235928.jpg" alt="image" /></p>

<p>上面的发起人只有一个状态“state”，发起人创建备忘录对象，并传入state，而负责人可以保存和获得备忘录对象。上图中备忘录对负责人也是宽接口，因此负责人可以访问到state值。<strong>所以，白箱实现的缺点是破坏了对发起人状态的封闭。</strong>下面的Client的示意代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Originator</span> <span class="n">o</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Originator</span><span class="o">();</span>
</span><span class='line'><span class="n">Caretaker</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Caretaker</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="na">setState</span><span class="o">(</span><span class="s">&quot;On&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">Memento</span> <span class="n">m</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="na">createMemento</span><span class="o">();</span>
</span><span class='line'><span class="n">c</span><span class="o">.</span><span class="na">saveMemento</span><span class="o">(</span><span class="n">m</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="na">setState</span><span class="o">(</span><span class="s">&quot;Off&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="na">restoreMemento</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="na">retrieveMemento</span><span class="o">());</span>
</span><span class='line'><span class="c1">//此时o.state = &quot;On&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>双重接口实现（黑盒实现）</h3>

<p>如何用Java实现宽、窄两个接口呢？也就是对发起人是宽接口，对其它任何对象都是窄接口。可以将备忘录对象作为发起人的内部类，因此发起人可以访问备忘录的所有属性和方法。而窄接口，是备忘录对象实现一个标识接口(MementoIF，没有任何方法的接口)，同时备忘录对象的方法为私有方法，所有其它对象都通过标识接口获得备忘录对象的引用，却无法访问备忘录对象的状态和方法。这就是双重接口的实现。如下图所示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140814_220438.jpg" alt="image" /></p>

<p>客户端的代码与白盒实现完全相同，但是Caretaker再也无法访问备忘录对象的状态了。</p>

<p>上面的两种实现，都由客户端持有发起人和负责人的引用。实际上也可以由负责人完成备忘录对象的创建和必要时恢复发起人状态。</p>

<h3>多重检查点</h3>

<p>前面的例子都只存储一个状态，在实际业务中，常需要存储多个状态，也就是多个检查点。实现方式可以在备忘录对象中建立<code>List&lt;String&gt; states</code>存储多个检查点。</p>

<h3>“自述历史”模式</h3>

<p>自述历史模式其实是指发起人角色兼任负责人角色时的备忘录模式。类图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140815_221228.jpg" alt="image" /></p>

<p>Memento类是发起人的内部类。</p>

<h3>“假如”协议模式</h3>

<p>备忘录的操作过程是，先创建备忘录对象保存发起人状态，然后修改发起人状态，如果需要的话，可以撤消这一步。也就是通过备忘录对象恢复发起人的状态。简单地说，就是先保存状态，然后执行修改，如果需要则恢复原状态。</p>

<p>而“假如”协议则是将发起人对象做一个拷贝，然后再拷贝上执行备忘录操作，如果成功并且状态有效，则在原对象上执行这个操作。如果失败或者状态无效，则扔掉拷贝并触发异常处理。</p>

<p>“假如”协议的优点是安全，相当于先试验没总是后才在原始对象上执行。缺点是同一个操作要执行两遍。因此“假如”协议适合于成功率较低的场景。</p>

<h3>备忘录模式的优点</h3>

<ol>
<li>有时一些发起人对象的内部信息必须保存在发起人对象以外的地方，但是必须要由发起人对象自己读取，这时，使用备忘录模式可以把复杂的发起人内部信息对其他的对象屏蔽起来，从而可以恰当地保持封装的边界。</li>
<li>本模式简化了发起人。发起人不再需要管理和保存其内部状态的一个个版本，客户端可以自行管理他们所需要的这些状态的版本。</li>
<li>当发起人角色的状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原。</li>
</ol>


<h3>备忘录模式的缺点：</h3>

<ol>
<li>如果发起人角色的状态需要完整地存储到备忘录对象中，那么在资源消耗上面备忘录对象会很昂贵。</li>
<li>当负责人角色将一个备忘录存储起来的时候，负责人可能并不知道这个状态会占用多大的存储空间，从而无法提醒用户一个操作是否很昂贵。</li>
<li>当发起人角色的状态改变的时候，有可能这个协议无效。如果状态改变的成功率不高的话，不如采取“假如”协议模式。</li>
</ol>


<p>——《Java与模式》读书笔记。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:命令模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/11/she-ji-mo-shi-ming-ling-mo-shi/"/>
    <updated>2014-08-11T22:58:11+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/11/she-ji-mo-shi-ming-ling-mo-shi</id>
    <content type="html"><![CDATA[<p>命令模式将发出命令和执行命令的责任分割开，委派给不同的对象。类图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140811_233515.jpg" alt="image" /></p>

<!--more-->


<ol>
<li>Client角色：创建具体命令对象，并确定接收者。</li>
<li>Command角色：声明抽象接口，通常是接口或抽象类。</li>
<li>ConcreteCommand角色：定义一个接收者和行为之间的弱耦合；负责调用接收者的相应操作。</li>
<li>Invoker角色：负责调用命令对象执行请求。</li>
<li>Reciever角色：负责具体实施和执行一个请求。任何一个类都可以成为接收者。</li>
</ol>


<p>Client的示例代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">Receiver</span> <span class="n">receiver</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Receiver</span><span class="o">();</span>
</span><span class='line'>  <span class="n">Command</span> <span class="n">command</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcreteCommand</span><span class="o">(</span><span class="n">receiver</span><span class="o">);</span>
</span><span class='line'>  <span class="n">Invoker</span> <span class="n">invoker</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Invoker</span><span class="o">(</span><span class="n">command</span><span class="o">);</span>
</span><span class='line'>  <span class="n">invoker</span><span class="o">.</span><span class="na">action</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码中，invoker.action调用command.execute，execute方法调用receiver.action，receiver.action是真正实施命令的方法。</p>

<p>模式实现时，可以考虑命令是“重”还是“轻”。如果轻，则命令只是提供请求者与接收者之间的耦合。如果是重，则命令执行也可放在命令中，接收者可以省略。更常见的是中间情况，由命令类动态决定调用哪一个接收者类。如果要支持undo, redo，则命令类要存储状态信息。</p>

<p>可以把命令对象集合在一起，实现宏命令。命令模式的缺点是命令可能会非常多。命令模式可用于：</p>

<ol>
<li>需要在不同的时间指定请求，将请求排队。命令对象可以在序列化之后发送到另一台机器上。</li>
<li>支持undo, redo操作。</li>
<li>从日志中读回所有命令，重新执行execute方法，恢复系统数据。</li>
<li>需要支持交易的系统，一个交易结构封装了一组数据更新命令。命令模式可以使系统增加新的交易类型。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:责任链模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-ze-ren-lian-mo-shi/"/>
    <updated>2014-08-10T23:24:28+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-ze-ren-lian-mo-shi</id>
    <content type="html"><![CDATA[<p>多个对象和下家的引用连接起来形成一条链。请求在这个链上传递，直到链上的某个对象处理此请求。类图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140810_235454.jpg" alt="image" /></p>

<!--more-->


<p>一个纯的责任链模式要求具体的处理者对象只能在两个行为中选择一个：一是处理请求；二是把责任传给下家。不允许出现一个对象即处理请求，又把责任往下传。纯的责任链很难找到，一般看到的例子都是不纯的。</p>

<p>Java 1.0版的AWT事件处理机制就是责任链模式。事件触发后，可以一直浮升，直到有容器处理事件。容器可以选择继续传下去或者处理事件。</p>

<p>针对DHTML的事件处理，Netscape与IE是不一样的。Netscape是从Window->Document往下，最后到达事件产生的对象。而IE则相反，事件产生的对象是链的第一个。</p>

<p>责任链模式并不负责创建责任链，责任链的创建必须由系统的其它部分完成。一个链可以是一条线、树甚至环。责任链模式并不指定链的拓扑结构，但要求在同一时间里，命令只可以被传给一个下家（或者处理请求），不可以同时传给多个下家。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:迭代子模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-die-dai-zi-mo-shi/"/>
    <updated>2014-08-10T12:18:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-die-dai-zi-mo-shi</id>
    <content type="html"><![CDATA[<p>迭代子模式是最常见的几个设计模式之一，Java Collection广泛使用迭代子来遍历其元素。之所以需要迭代子模式，是因为它将迭代逻辑与聚集对象分离，两者可以自由演变。其结构示意图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140810_163841.jpg" alt="image" /></p>

<!--more-->


<ol>
<li>Iterator：定义遍历元素所需的接口。</li>
<li>ConcreteIterator：实现Iterator接口，维护迭代过程中的游标位置。</li>
<li>Aggregate：给出创建迭代子对象的接口。</li>
<li>ConcreteAggregate：实现创建迭代子对象的接口，返回一个合适的具体迭代子实例。</li>
<li>Client：拥有对聚集和迭代子对象的引用，调用迭代子对象的迭代接口。</li>
</ol>


<h3>宽接口与窄接口</h3>

<p>宽接口是指聚集提供了可以用来修改聚集元素的方法；否则就是窄接口。宽接口的典型示例是公开了类的一个List，因此破坏了聚集对象的封装。</p>

<p>聚集对象可以提供两个接口，对迭代子公开宽接口，而对外提供窄接口。因此，可以将迭代子类设计成聚集类的内部成员类。</p>

<h3>Java Iterator和ListIterator</h3>

<p>Java Collection接口方法iterator()返回Iterator，而Java的List接口的listIterator()返回ListIterator类型。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140810_163856.jpg" alt="image" /></p>

<p>ListIterator提供了安全的修改方法add, remove和set。它们能够在迭代的过程中安全地修改List的内容。</p>

<ul>
<li>add()方法，在List当前位置插入一个对象。所谓当前位置就是：add方法增加对象后，调用previous()方法将返回这个对象。</li>
<li>remove()方法，将当前元素删除。所谓当前元素就是：如果刚调用了next()或previous()方法，当前元素就是它们返回的元素。<strong>注：每调用一次remove()，都需要先调用一次next()或者previous()，如果刚调用了add()，也必须先调用一次next()或者previous()。</strong></li>
<li>set()方法，更新当前元素。当前元素的定义与remove()方法相同。每次set()之前，也必须调用next()或previous()。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:观察者模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-guan-cha-zhe-mo-shi/"/>
    <updated>2014-08-10T11:36:40+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-guan-cha-zhe-mo-shi</id>
    <content type="html"><![CDATA[<p>观察者模式也称为发布-订阅模式，它定义了一种一对多的依赖关系，让多个观察者同时监听一个主题对象。当主题对象的状态发生变化时，会通知观察者对象，使它们能够自动更新自己。它的类图如下所示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140810_115301.jpg" alt="image" /></p>

<p>在实际应用中，如果有多个ConcreteSubject，也可以将Subject变成抽象类，将observers和notifyObservers方法上移到抽象Subject。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:模板方法模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-mo-ban-fang-fa-mo-shi/"/>
    <updated>2014-08-10T09:52:25+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/10/she-ji-mo-shi-mo-ban-fang-fa-mo-shi</id>
    <content type="html"><![CDATA[<p>模板方法（Template Method）模式是最常见的模式，几乎每个人都用过。它将部分逻辑以具体方法以及具体构造子的形式实现。抽象类定义顶级逻辑，具体类实现具体方法。类图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140810_095857.jpg" alt="image" /></p>

<ol>
<li>抽象模板角色：定义一个或多个抽象操作，以便让子类实现。定义并实现一个模板方法，给出顶级逻辑的骨架。</li>
<li>具体模板角色：实现父类的抽象方法。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:策略模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/09/she-ji-mo-shi-ce-lue-mo-shi/"/>
    <updated>2014-08-09T22:55:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/09/she-ji-mo-shi-ce-lue-mo-shi</id>
    <content type="html"><![CDATA[<p>策略模式把行为和环境分割开。环境类负责维持和查询行为类，各种算法则在具体策略类中提供。由于算法和环境独立开来，算法的增减、修改都不会影响环境和客户端。准备一组算法，并将每一个算法封装起来，使得它们可以互换。策略模式的类图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140809_230502.jpg" alt="image" /></p>

<!--more-->


<p>各角色如下：</p>

<ol>
<li>环境角色：持有一个Strategy类的引用。</li>
<li>抽象策略角色：抽象角色，通常是接口或者抽象类，给出接口。</li>
<li>具体策略角色：包装相关的算法或行为。通常具体策略角色会有多个。</li>
</ol>


<p>从策略模式中是看不出具体策略适用于哪一种情况的，应当由客户端自己决定在什么情况下使用什么具体策略角色。策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中退出。</p>

<p>策略模式适合于在多个算法中选择一种的情形，不适用于需要多个算法或者嵌套多于一个算法的情形。</p>

<p>什么情况下使用策略模式？</p>

<ol>
<li>如果系统有很多类，它们之间的区别仅在于它们的行为，策略模式可动态地让一个对象在许多行为中选择一种行为。</li>
<li>系统需要动态地在几种算法中选择一种。</li>
</ol>


<p>策略模式的缺点：客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:不变模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/09/she-ji-mo-shi-bu-bian-mo-shi/"/>
    <updated>2014-08-09T18:08:28+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/09/she-ji-mo-shi-bu-bian-mo-shi</id>
    <content type="html"><![CDATA[<p>从这个模式开始学习行为模式。行为模式是对在不同的对象之间划分责任和算法的抽象化。行为模式不仅仅是关于类和对象的，而且是关于它们之间的相互作用的。行为模式分为类的行为模式（使用继承在几个类之间分配行为）和对象的行为模式（使用对象的聚合来分配行为）。</p>

<p>不变（Immutable）模式是指一个对象创建之后，它的状态将不再变化。不变模式不需要类图描述，它分为弱不变模式和强不变模式。</p>

<p>不变与只读的区别：只读表示值不能直接修改，但可能随其它变量改变而发生改变。例如出生日期是不变的，但年龄是只读的，因为它会随着时间而改变。</p>

<!--more-->


<h3>弱不变模式</h3>

<p>类的实例状态是不可变化的，但其子类的实例可能会变化，这就是弱不变模式。要实现弱不变模式，必须满足以下条件：</p>

<ol>
<li>类没有任何方法会修改对象的状态；</li>
<li>所有属性都应当是私有的；</li>
<li>如果引用了其它可变对象，必须设法限制外界对可变对象的访问。应当尽量避免在客户端初始化可变对象，否则应该复制一份，而不要直接使用客户端传入的引用。</li>
</ol>


<h3>强不变模式</h3>

<p>类的实例状态是不可变化的，同时它的子类也是不可变化的状态，这就是强不变模式。一个类在满足弱不变模式的前提下，需要满足以下条件之一才是强不变模式：</p>

<ol>
<li>类的所有方法都应当是final，因此子类不能置换掉此类的方法。</li>
<li>这个类本身就是final的，因此不可能会有子类。</li>
</ol>


<h3>不变模式的优缺点</h3>

<p>一个不变的对象比可变的对象更加容易维护。不变对象天生就是线程安全的，可以省掉同步化的开销。不变模式唯一的缺点是如果需要频繁地修改不变对象，会创建出大量的对象，这是一种资源的浪费。</p>

<p>在设计任何一个类时，除非有变化的必要，不然就应该将它设计成不变类。</p>

<p>与享元模式的区别：不变模式可以用于实现享元模式，但享元对象并不一定非得是不变对象，只要它的内部状态与环境无关就不会影响享元对象的共享。</p>

<p>几个问题：</p>

<ol>
<li>构造方法需不需要同步化？（不需要，对象创建只可能发生在一个纯种中）</li>
<li>子类是否可以置换掉父类的同步方法，它是同步还是不同步？（可以置换，但父类的同步特性没有改变，如果明显地调用父类的同步方法，那么这个方法将是同步调用的）</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[哈尔滨印象]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/07/ha-er-bin-yin-xiang/"/>
    <updated>2014-08-07T20:16:24+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/07/ha-er-bin-yin-xiang</id>
    <content type="html"><![CDATA[<p>8月初，恰逢有机会去哈尔滨出差，来到这个古老、精致的城市，印象还不错。街道很干净，建筑很有特色。</p>

<p>街边一景</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1304.jpg" alt="image" /></p>

<!--more-->


<p>圣索菲亚教堂</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1266.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1268.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1269.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1275.jpg" alt="image" /></p>

<p>随处可见的音乐一角，都是俄罗斯风格的音乐。</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1276.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1277.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1278.jpg" alt="image" /></p>

<p>松花江畔</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1279.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1281.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1282.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1283.jpg" alt="image" /></p>

<p>防洪纪念塔，本以为是98年建的，其实不是，以前就有了，但可以看到水位高度。</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1285.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1288.jpg" alt="image" /></p>

<p>中央大街一景</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1289.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1291.jpg" alt="image" /></p>

<p>这么多人排队</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1295.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1298.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1300.jpg" alt="image" /></p>

<p>从黑龙江移动大楼上看松花江</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1306.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1307.jpg" alt="image" /></p>

<p>哈尔滨火车站</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1316.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1317.jpg" alt="image" /></p>

<p>哈工大</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1319.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1320.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1321.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1322.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1323.jpg" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:桥梁模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-qiao-liang-mo-shi/"/>
    <updated>2014-08-03T22:09:23+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-qiao-liang-mo-shi</id>
    <content type="html"><![CDATA[<p>桥梁模式的用意是“将抽象化与实现化解耦，使二者可以独立变化。”这里的解耦就是将它们之间的强关联改变成弱关联。所谓强关联就是继承关系，在编译期就已经确定。而弱关联就是动态确定并且可以在运行期动态改变的关联。因此对于Java，继承是强关联，而聚合关系是弱关联。因此桥梁模式中的解耦，就是指将抽象化与实现化之间的继承关系换成组合/聚合关系，使两者可以独立变化。桥梁模式的结构图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140803_233716.jpg" alt="image" /></p>

<!--more-->


<ol>
<li>抽象化角色（Abstraction）：抽象化给出的定义，并保存一个对实现化对象的引用。</li>
<li>修正抽象化角色（Refined Abstraction）：扩展抽象化角色，改变和修正父类的定义。</li>
<li>实现化角色（Implementor）：给出实现化角色的接口，但不给出具体实现。这个接口不一定与抽象化角色接口相同，实际上，这两个接口可以非常不一样。<strong>实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。</strong></li>
<li>具体实现化角色（Concrete Implementor）：给出实现化角色接口的具体实现。当具体实现化类只有一个ConcreteImplementor的情况下，实现化角色就可以省略了。</li>
</ol>


<p>抽象化等级结构中的方法通过向对应的实现化对象的委派实现自己的功能。一般来说，实现化角色中的每一个方法都应当有一个抽象化角色中的某一个方法与之对应，但反过来则不一定。即抽象化角色的接口比实现化角色的接口宽，抽象化角色还可能提供其它的商业方法。而实现化角色则仅仅为实现抽象化角色的相关行为而存在。</p>

<p>桥梁模式是为了分享抽象化与实现，使两者的接口可以不同。而适配器模式是为了改变已有接口，使它们相容。因此这两种模式是不一样的。</p>

<p>什么情况下应当使用桥梁模式？</p>

<ul>
<li>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的联系。</li>
<li>设计要求实现化角色的任何改变不应当影响客户端。</li>
<li>一个构件有多个抽象化角色和实现化角色，系统需要它们之间进行动态耦合。</li>
<li>虽然在系统中使用继承没有问题，但由于抽象化角色和具体角色需要独立变化，设计要求需要独立管理这两者。</li>
</ul>


<p>桥梁模式的一个例子是Java AWT的Peer架构。Java应用在不同的操作系统上有不同的Look and Feel。Java为AWT中的每一个GUI构件都提供了一个Peer构件。Java程序员只需要关心Button对象提供的接口，当运行时，Button对象动态地与一个本地环境的底层Peer对象联系起来，这个Peer对象会按照指令执行正确的操作。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140825_200404.jpg" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:门面模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-men-mian-mo-shi/"/>
    <updated>2014-08-03T21:59:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-men-mian-mo-shi</id>
    <content type="html"><![CDATA[<p>门面(Facade)模式的作用是屏蔽众多子系统的复杂性，为客户端提供一个统一的门面(Facade)对象，方便客户端调用。门面模式没有统一的结构。一般是一个子系统提供一个门面。要注意的是门面只负责协调子系统去服务客户端的请求，不能在门面类中增加功能和职责。</p>

<p>什么情况下使用门面模式？如果子系统演化得越来越复杂，客户端的调用变得很复杂，产生很大的依赖性，则可以引入门面模式将一个子系统与它的客户端以及其他子系统分离。</p>

<p>这与迪米特法则也是相符的，该法则要求不要与陌生人说话，只与你直接朋友通信。采用门面模式，客户端只要与门面打交道，不需要去协调多个子系统。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:享元模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-xiang-yuan-mo-shi/"/>
    <updated>2014-08-03T19:10:40+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-xiang-yuan-mo-shi</id>
    <content type="html"><![CDATA[<p>享元模式以共享的方式支持大量的细粒度对象。Java的String类型其实就使用了享元模式。享元对象具有内部状态(Internal State)和外部状态(External State)。内部状态是享元对象内部的，一旦创建就不会再改变，因此具有内部状态的享元对象可以进行共享。外部状态是随环境改变而改变的，是不可以共享的状态。享元对象的外部状态必须由客户端保存，通常以方法参数的方式传给享元对象，以改变方法的行为，但不会改变内在状态。享元模式可以分为单纯享元模式和复合享元模式。结构图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140803_193842.jpg" alt="image" /></p>

<!--more-->


<p>左边为单纯享元模式，右边为复合享元模式。复合享元模式只多了一个ConcreteCompositeFlyweight，它们的角色如下：</p>

<ul>
<li>抽象享元角色(Flyweight)：定义公共接口。</li>
<li>具体享元角色(ConcreteFlyweight)：实现抽象享元角色接口，维护内部状态。内部状态必须与外部环境元关，一旦创建就不能修改。</li>
<li>享元工厂角色(FlyweightFactory)：负责创建和管理享元角色，保证享元对象可以被系统共享。当客户端调用工厂方法时，通常会判断是否有符合要求的享元对象，如果有就返回，如果没有则创建。此角色一般只有一个，可以使用单例模式。</li>
<li>客户端角色(Client)：调用享元工厂创建享元对象，维护享元对象的外部状态。</li>
<li>复合享元角色(ConcreteCompositeFlyweight)：由单纯的享元对象复合而成，因此提供了add这样的方法。由于聚焦元素是在复合享元对象创建之后加入的，因此复合享元对象的状态是可以改变的，所以此角色<strong>不可以共享</strong>。</li>
</ul>


<p><strong>一些例子</strong></p>

<p>一个咖啡摊所售的咖啡只有固定的几种口味，一坏咖啡一旦生产出来它的口味就不会改变，其内部状态就是口味。因此系统不用为每一杯咖啡创建一个对象，可以使用享元模式为每种口味创建一个对象，然后进行共享。</p>

<p>又例如一个文字编辑器，输入的内部是固定的A..Z，但字母所处的位置、字体是变化的。如果用享元模式，内部状态就是字母，外部状态是位置和字体。</p>

<p><strong>什么情况下使用享元模式</strong></p>

<p>当以下条件都满足时，可以考虑使用享元模式：</p>

<ol>
<li>系统有大量的对象。</li>
<li>这些对象耗费大量的内存。</li>
<li>这些对象的大部分状态都可以外部化。</li>
<li>这些对象可以按照内部状态分成很多组，剔除外部状态后，每一组都可以仅用一个对象代替。</li>
<li>系统不依赖于这些对象的身份，即这些对象可以是不可分辨的。</li>
<li>系统需要记录所有已有的享元对象，这需要消耗资源，因此应当在只有足够多的享元实例可供共享时才值得使用享元模式。</li>
</ol>


<p>享元模式的优点是大幅降低内存中对象的数量，但享元模式可能使系统更复杂，需要将一些状态外部化，这可能使逻辑变得复杂。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:代理模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-dai-li-mo-shi/"/>
    <updated>2014-08-03T11:56:48+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-dai-li-mo-shi</id>
    <content type="html"><![CDATA[<p>代理模式是对象的结构模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。代理模式的结构如下图：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140803_120304.jpg" alt="image" /></p>

<!--more-->


<p>各角色说明如下：</p>

<ul>
<li>抽象主题角色：是真实主题和代理主题的共同接口，任何可以使用真实主题的地方都可以使用代理主题。</li>
<li>代理主题角色：内部含有对真实主题的引用，可以在任何时候操作真实主题对象。</li>
<li>真实主题角色：真实的对象。</li>
</ul>


<p><strong>常见的代理种类：</strong></p>

<ul>
<li>远程(Remote)代理：位于不同地址空间的代理对象。</li>
<li>虚拟(Virtual)代理：当创建真实对象需要消耗较大资源时，通过虚拟代理实现只有真正需要时才创建资源。例如加载图像。</li>
<li>Copy-on-Write代理：虚拟代理的一种，把复制拖延到只有客户端需要时才执行。</li>
<li>保护(Protect or Access)代理：控制对一个对象的访问，可以为不同的客户端提供不同级别的权限。</li>
<li>Cache代理：为真实对象操作的结果提供临时的存储空间，以便多个客户端可共享该结果。</li>
<li>防火墙(Firewall)代理：保护目标，不让恶意用户接近。</li>
<li>同步化(Synchronization)代理：使多个用户能够同时使用一个对象而没有冲突。</li>
<li>智能(Smart Reference)引用：当一个对象被引用时，提供一些额外的操作，例如记录调用次数。</li>
</ul>


<p>反射与代理常常一起使用，<a href="http://blog.ubone.com/blog/2014/06/28/li-yong-fan-zhang-hao/">这篇博文</a>就是代理模式的一个例子。</p>

<p>代理模式与适配器模式的区别是，后者的用意是改变接口，而前者不能改变接口。代理模式与装饰模式都保持接口不变，但它们区别是，后者应当提供增加的功能/性能，而前者是对原对象施加控制，并不提供增强功能。</p>

<h3>虚拟代理的例子</h3>

<p>为了更好的用户体验，在应用中显示网络图片时，先显示“加载中”或者占位符，等待图片下载完成后再替换成图片。这就是虚拟代理的真实例子。对于客户端仍然是创建图片并显示，但实际创建的是图片代理，图片代理先显示“加载中”，然后启动另一线程去下载图片，当下载完成后，才真正显示图片。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:装饰模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/01/she-ji-mo-shi-zhuang-shi-mo-shi/"/>
    <updated>2014-08-01T20:00:16+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/01/she-ji-mo-shi-zhuang-shi-mo-shi</id>
    <content type="html"><![CDATA[<p>装饰模式以对客户端透明的方式扩展对象的功能。客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。其类图所下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-08-01_20.13.33.jpg" alt="image" /></p>

<!--more-->


<p>图中4个角色说明如下：</p>

<ol>
<li>Component角色，一个抽象接口，被装饰对象和装饰对象都遵循的接口。在实际中可以是接口、抽象或具体类。</li>
<li>Concrete Component角色，被装饰的具体对象。</li>
<li>Decorator角色，持有Component对象的实例，可以是抽象类。</li>
<li>ConcreteDecorator角色，负责给构件对象贴上附加的责任。</li>
</ol>


<h3>什么情况下使用装饰模式？</h3>

<ol>
<li>需要扩展一个类的功能，或给一个类增加附加责任。</li>
<li>需要动态给一个对象增加功能，这些功能可以再动态地撤销。</li>
<li>需要增加由一些基本功能的排列组合而产生的非常大量的功能，而继承关系就变得不现实。</li>
</ol>


<h3>装饰模式的优缺点</h3>

<p>装饰模式的优点包括：</p>

<ol>
<li>可以动态地贴上一个需要的装饰，或者除掉一个不需要的装饰。</li>
<li>通过使用不同的具体装饰类，以及这些装饰类的排列组合，可以创造出很多不同行为的组合。</li>
</ol>


<p>装饰模式的缺点是比继承要使用更多的对象，更多的对象会使得查错变得困难。</p>

<h3>装饰模式的简化</h3>

<p>不论如何简化，必须保证：</p>

<ol>
<li>ConcreteDecorator类必须实现/继承自一个共同的父类Component。</li>
<li>尽量保持Component作为一个“轻”类。</li>
</ol>


<p>常见的简化包括：</p>

<ol>
<li>没有Component，只有ConcreteComponent，此时，Decorator可以是ConcreteComponent的子类，ConcreteComponent扮演双重角色。</li>
<li>没有Decorator，只有ConcreteDecorator，但如果有两个以上的。</li>
</ol>


<h3>其它</h3>

<p>纯粹的装饰模式对客户端的要求是不要声明ConcreteDecorator类型的变量，而应当声明Component类型的变量。这也就是针对抽象编程。因此，ConcreteDecorator不能有Component接口之外的方法。但现实中的装饰模式允许改变接口，增加新方法，即客户端可以声明ConcreteDecorator类型的变量。这就有点像是适配器模式。</p>

<p>装饰模式与适配器模式其实是不一样的。适配器模式的目的是改变接口，常常改写或者增加新的方法来适配接口。而装饰模式是保持接口不变，增强或增加功能。它们的类图是不一样的。</p>

<p>以Java的IO库为例，Reader类型的对象读入字符(Character)流，而InputStreamReader是一种Reader类型，把InputStream类型对象包装起来，从而把byte的API转换成字符流的API。这就是适配器模式的例子。即InputStreamReader把InputStream的API适配成Reader的API。</p>

<p>而BufferredReader则是一个装饰类，因为它实现Reader，并且包装一个Reader，接口未变，但提供更优的性能。但它不是一个100％的装饰类，因为它提供了一个readLine()的新方法。</p>

<p>以InputStream相关类为例，如下所示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140803_002859.jpg" alt="image" /></p>

<p>图中，红色类为适配器模式，将其它类型（如Byte数组）接口转换成InputStream接口。而绿色及其子类为适配器模式，各角色：</p>

<ol>
<li>Component角色：InputStream</li>
<li>Concrete Component角色：红色的类</li>
<li>Decorator角色：绿色的类</li>
<li>ConcreteDecorator角色：最下面的四个类。</li>
</ol>


<p>附各类的主要用途：</p>

<ol>
<li>ByteArrayInputStream: 为多线程的通信提供缓冲区操作功能，接收Byte数组作为流的源。</li>
<li>FileInputStream：接收一个File对象作为流的源。</li>
<li>PipedInputStream：与PipedOutputStream配合使用，用于读入一个数据管道的数据，接收PipedOutputStream作为源。</li>
<li>StringBufferInputStream：接收一个String对象作为流的源。</li>
<li>FilterInputStream：过滤输入流，将另一个输入流作为流的源。</li>
<li>BufferInputStream：内部提供内存缓冲区，从此缓冲区提供数据。</li>
<li>DataInputStream：提供多字节的读取方法，读取原始数据类型的数据。</li>
<li>LineNumberInputStream: 提供带有行计数功能和按行号读取数据的过滤输入流。不常用，主要用于编译器。</li>
<li>PushbackInputStream：提供特殊功能，将已经读取的字节“推回”到输入流中。不常用，主要用于编译器。</li>
<li>ObjectInputStream：读取使用ObjectOutputStream序列化的流，将其反序列化。</li>
<li>SequenceInputStream：将两个已有的输入流连接起来，形成一个输入流。</li>
</ol>

]]></content>
  </entry>
  
</feed>
