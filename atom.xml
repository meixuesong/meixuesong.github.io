<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[码出人生]]></title>
  <link href="http://blog.ubone.com/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2014-08-09T20:45:24+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[哈尔滨印象]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/09/ha-er-bin-yin-xiang/"/>
    <updated>2014-08-09T20:16:24+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/09/ha-er-bin-yin-xiang</id>
    <content type="html"><![CDATA[<p>8月初，恰逢有机会去哈尔滨出差，来到这个古老、精致的城市，印象还不错。街道很干净，建筑很有特色。</p>

<p>街边一景</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1304.jpg" alt="image" /></p>

<!--more-->


<p>圣索菲亚教堂</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1266.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1268.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1269.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1275.jpg" alt="image" /></p>

<p>随处可见的音乐一角，都是俄罗斯风格的音乐。</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1276.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1277.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1278.jpg" alt="image" /></p>

<p>松花江畔</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1279.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1281.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1282.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1283.jpg" alt="image" /></p>

<p>防洪纪念塔，本以为是98年建的，其实不是，以前就有了，但可以看到水位高度。</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1285.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1288.jpg" alt="image" /></p>

<p>中央大街一景</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1289.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1291.jpg" alt="image" /></p>

<p>这么多人排队</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1295.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1298.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1300.jpg" alt="image" /></p>

<p>从黑龙江移动大楼上看松花江</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1306.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1307.jpg" alt="image" /></p>

<p>哈尔滨火车站</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1316.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1317.jpg" alt="image" /></p>

<p>哈工大</p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1319.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1320.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1321.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1322.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/haerbin201408/HA_ER_BIN_IMG_1323.jpg" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:不变模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/09/she-ji-mo-shi-bu-bian-mo-shi/"/>
    <updated>2014-08-09T18:08:28+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/09/she-ji-mo-shi-bu-bian-mo-shi</id>
    <content type="html"><![CDATA[<p>从这个模式开始学习行为模式。行为模式是对在不同的对象之间划分责任和算法的抽象化。行为模式不仅仅是关于类和对象的，而且是关于它们之间的相互作用的。行为模式分为类的行为模式（使用继承在几个类之间分配行为）和对象的行为模式（使用对象的聚合来分配行为）。</p>

<p>不变（Immutable）模式是指一个对象创建之后，它的状态将不再变化。不变模式不需要类图描述，它分为弱不变模式和强不变模式。</p>

<p>不变与只读的区别：只读表示值不能直接修改，但可能随其它变量改变而发生改变。例如出生日期是不变的，但年龄是只读的，因为它会随着时间而改变。</p>

<!--more-->


<h3>弱不变模式</h3>

<p>类的实例状态是不可变化的，但其子类的实例可能会变化，这就是弱不变模式。要实现弱不变模式，必须满足以下条件：</p>

<ol>
<li>类没有任何方法会修改对象的状态；</li>
<li>所有属性都应当是私有的；</li>
<li>如果引用了其它可变对象，必须设法限制外界对可变对象的访问。应当尽量避免在客户端初始化可变对象，否则应该复制一份，而不要直接使用客户端传入的引用。</li>
</ol>


<h3>强不变模式</h3>

<p>类的实例状态是不可变化的，同时它的子类也是不可变化的状态，这就是强不变模式。一个类在满足弱不变模式的前提下，需要满足以下条件之一才是强不变模式：</p>

<ol>
<li>类的所有方法都应当是final，因此子类不能置换掉此类的方法。</li>
<li>这个类本身就是final的，因此不可能会有子类。</li>
</ol>


<h3>不变模式的优缺点</h3>

<p>一个不变的对象比可变的对象更加容易维护。不变对象天生就是线程安全的，可以省掉同步化的开销。不变模式唯一的缺点是如果需要频繁地修改不变对象，会创建出大量的对象，这是一种资源的浪费。</p>

<p>在设计任何一个类时，除非有变化的必要，不然就应该将它设计成不变类。</p>

<p>与享元模式的区别：不变模式可以用于实现享元模式，但享元对象并不一定非得是不变对象，只要它的内部状态与环境无关就不会影响享元对象的共享。</p>

<p>几个问题：</p>

<ol>
<li>构造方法需不需要同步化？（不需要，对象创建只可能发生在一个纯种中）</li>
<li>子类是否可以置换掉父类的同步方法，它是同步还是不同步？（可以置换，但父类的同步特性没有改变，如果明显地调用父类的同步方法，那么这个方法将是同步调用的）</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:桥梁模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-qiao-liang-mo-shi/"/>
    <updated>2014-08-03T22:09:23+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-qiao-liang-mo-shi</id>
    <content type="html"><![CDATA[<p>桥梁模式的用意是“将抽象化与实现化解耦，使二者可以独立变化。”这里的解耦就是将它们之间的强关联改变成弱关联。所谓强关联就是继承关系，在编译期就已经确定。而弱关联就是动态确定并且可以在运行期动态改变的关联。因此对于Java，继承是强关联，而聚合关系是弱关联。因此桥梁模式中的解耦，就是指将抽象化与实现化之间的继承关系换成组合/聚合关系，使两者可以独立变化。桥梁模式的结构图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140803_233716.jpg" alt="image" /></p>

<!--more-->


<ol>
<li>抽象化角色（Abstraction）：抽象化给出的定义，并保存一个对实现化对象的引用。</li>
<li>修正抽象化角色（Refined Abstraction）：扩展抽象化角色，改变和修正父类的定义。</li>
<li>实现化角色（Implementor）：给出实现化角色的接口，但不给出具体实现。这个接口不一定与抽象化角色接口相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。</li>
<li>具体实现化角色（Concrete Implementor）：给出实现化角色接口的具体实现。当具体实现化类只有一个ConcreteImplementor的情况下，实现化角色就可以省略了。</li>
</ol>


<p>抽象化等级结构中的方法通过向对应的实现化对象的委派实现自己的功能。一般来说，实现化角色中的每一个方法都应当有一个抽象化角色中的某一个方法与之对应，但反过来则不一定。即抽象化角色的接口比实现化角色的接口宽，抽象化角色还可能提供其它的商业方法。而实现化角色则仅仅为实现抽象化角色的相关行为而存在。</p>

<p>桥梁模式是为了分享抽象化与实现，使两者的接口可以不同。而适配器模式是为了改变已有接口，使它们相容。因此这两种模式是不一样的。</p>

<p>什么情况下应当使用桥梁模式？</p>

<ul>
<li>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的联系。</li>
<li>设计要求实现化角色的任何改变不应当影响客户端。</li>
<li>一个构件有多个抽象化角色和实现化角色，系统需要它们之间进行动态耦合。</li>
<li>虽然在系统中使用继承没有问题，但由于抽象化角色和具体角色需要独立变化，设计要求需要独立管理这两者。</li>
</ul>


<p>桥梁模式的一个例子是Java AWT的Peer架构。Java应用在不同的操作系统上有不同的Look and Feel。Java为AWT中的每一个GUI构件都提供了一个Peer构件。Java程序员只需要关心Button对象提供的接口，当运行时，Button对象动态地与一个本地环境的底层Peer对象联系起来，这个Peer对象会按照指令执行正确的操作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:门面模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-men-mian-mo-shi/"/>
    <updated>2014-08-03T21:59:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-men-mian-mo-shi</id>
    <content type="html"><![CDATA[<p>门面(Facade)模式的作用是屏蔽众多子系统的复杂性，为客户端提供一个统一的门面(Facade)对象，方便客户端调用。门面模式没有统一的结构。一般是一个子系统提供一个门面。要注意的是门面只负责协调子系统去服务客户端的请求，不能在门面类中增加功能和职责。</p>

<p>什么情况下使用门面模式？如果子系统演化得越来越复杂，客户端的调用变得很复杂，产生很大的依赖性，则可以引入门面模式将一个子系统与它的客户端以及其他子系统分离。</p>

<p>这与迪米特法则也是相符的，该法则要求不要与陌生人说话，只与你直接朋友通信。采用门面模式，客户端只要与门面打交道，不需要去协调多个子系统。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:享元模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-xiang-yuan-mo-shi/"/>
    <updated>2014-08-03T19:10:40+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-xiang-yuan-mo-shi</id>
    <content type="html"><![CDATA[<p>享元模式以共享的方式支持大量的细粒度对象。Java的String类型其实就使用了享元模式。享元对象具有内部状态(Internal State)和外部状态(External State)。内部状态是享元对象内部的，一旦创建就不会再改变，因此具有内部状态的享元对象可以进行共享。外部状态是随环境改变而改变的，是不可以共享的状态。享元对象的外部状态必须由客户端保存，通常以方法参数的方式传给享元对象，以改变方法的行为，但不会改变内在状态。享元模式可以分为单纯享元模式和复合享元模式。结构图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140803_193842.jpg" alt="image" /></p>

<!--more-->


<p>左边为单纯享元模式，右边为复合享元模式。复合享元模式只多了一个ConcreteCompositeFlyweight，它们的角色如下：</p>

<ul>
<li>抽象享元角色(Flyweight)：定义公共接口。</li>
<li>具体享元角色(ConcreteFlyweight)：实现抽象享元角色接口，维护内部状态。内部状态必须与外部环境元关，一旦创建就不能修改。</li>
<li>享元工厂角色(FlyweightFactory)：负责创建和管理享元角色，保证享元对象可以被系统共享。当客户端调用工厂方法时，通常会判断是否有符合要求的享元对象，如果有就返回，如果没有则创建。此角色一般只有一个，可以使用单例模式。</li>
<li>客户端角色(Client)：调用享元工厂创建享元对象，维护享元对象的外部状态。</li>
<li>复合享元角色(ConcreteCompositeFlyweight)：由单纯的享元对象复合而成，因此提供了add这样的方法。由于聚焦元素是在复合享元对象创建之后加入的，因此复合享元对象的状态是可以改变的，所以此角色<strong>不可以共享</strong>。</li>
</ul>


<p><strong>一些例子</strong></p>

<p>一个咖啡摊所售的咖啡只有固定的几种口味，一坏咖啡一旦生产出来它的口味就不会改变，其内部状态就是口味。因此系统不用为每一杯咖啡创建一个对象，可以使用享元模式为每种口味创建一个对象，然后进行共享。</p>

<p>又例如一个文字编辑器，输入的内部是固定的A..Z，但字母所处的位置、字体是变化的。如果用享元模式，内部状态就是字母，外部状态是位置和字体。</p>

<p><strong>什么情况下使用享元模式</strong></p>

<p>当以下条件都满足时，可以考虑使用享元模式：</p>

<ol>
<li>系统有大量的对象。</li>
<li>这些对象耗费大量的内存。</li>
<li>这些对象的大部分状态都可以外部化。</li>
<li>这些对象可以按照内部状态分成很多组，剔除外部状态后，每一组都可以仅用一个对象代替。</li>
<li>系统不依赖于这些对象的身份，即这些对象可以是不可分辨的。</li>
<li>系统需要记录所有已有的享元对象，这需要消耗资源，因此应当在只有足够多的享元实例可供共享时才值得使用享元模式。</li>
</ol>


<p>享元模式的优点是大幅降低内存中对象的数量，但享元模式可能使系统更复杂，需要将一些状态外部化，这可能使逻辑变得复杂。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:代理模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-dai-li-mo-shi/"/>
    <updated>2014-08-03T11:56:48+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/03/she-ji-mo-shi-dai-li-mo-shi</id>
    <content type="html"><![CDATA[<p>代理模式是对象的结构模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。代理模式的结构如下图：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140803_120304.jpg" alt="image" /></p>

<!--more-->


<p>各角色说明如下：</p>

<ul>
<li>抽象主题角色：是真实主题和代理主题的共同接口，任何可以使用真实主题的地方都可以使用代理主题。</li>
<li>代理主题角色：内部含有对真实主题的引用，可以在任何时候操作真实主题对象。</li>
<li>真实主题角色：真实的对象。</li>
</ul>


<p><strong>常见的代理种类：</strong></p>

<ul>
<li>远程(Remote)代理：位于不同地址空间的代理对象。</li>
<li>虚拟(Virtual)代理：当创建真实对象需要消耗较大资源时，通过虚拟代理实现只有真正需要时才创建资源。例如加载图像。</li>
<li>Copy-on-Write代理：虚拟代理的一种，把复制拖延到只有客户端需要时才执行。</li>
<li>保护(Protect or Access)代理：控制对一个对象的访问，可以为不同的客户端提供不同级别的权限。</li>
<li>Cache代理：为真实对象操作的结果提供临时的存储空间，以便多个客户端可共享该结果。</li>
<li>防火墙(Firewall)代理：保护目标，不让恶意用户接近。</li>
<li>同步化(Synchronization)代理：使多个用户能够同时使用一个对象而没有冲突。</li>
<li>智能(Smart Reference)引用：当一个对象被引用时，提供一些额外的操作，例如记录调用次数。</li>
</ul>


<p>反射与代理常常一起使用，<a href="http://blog.ubone.com/blog/2014/06/28/li-yong-fan-zhang-hao/">这篇博文</a>就是代理模式的一个例子。</p>

<p>代理模式与适配器模式的区别是，后者的用意是改变接口，而前者不能改变接口。代理模式与装饰模式都保持接口不变，但它们区别是，后者应当提供增加的功能/性能，而前者是对原对象施加控制，并不提供增强功能。</p>

<h3>虚拟代理的例子</h3>

<p>为了更好的用户体验，在应用中显示网络图片时，先显示“加载中”或者占位符，等待图片下载完成后再替换成图片。这就是虚拟代理的真实例子。对于客户端仍然是创建图片并显示，但实际创建的是图片代理，图片代理先显示“加载中”，然后启动另一线程去下载图片，当下载完成后，才真正显示图片。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:装饰模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/08/01/she-ji-mo-shi-zhuang-shi-mo-shi/"/>
    <updated>2014-08-01T20:00:16+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/08/01/she-ji-mo-shi-zhuang-shi-mo-shi</id>
    <content type="html"><![CDATA[<p>装饰模式以对客户端透明的方式扩展对象的功能。客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。其类图所下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-08-01_20.13.33.jpg" alt="image" /></p>

<!--more-->


<p>图中4个角色说明如下：</p>

<ol>
<li>Component角色，一个抽象接口，被装饰对象和装饰对象都遵循的接口。在实际中可以是接口、抽象或具体类。</li>
<li>Concrete Component角色，被装饰的具体对象。</li>
<li>Decorator角色，持有Component对象的实例，可以是抽象类。</li>
<li>ConcreteDecorator角色，负责给构件对象贴上附加的责任。</li>
</ol>


<h3>什么情况下使用装饰模式？</h3>

<ol>
<li>需要扩展一个类的功能，或给一个类增加附加责任。</li>
<li>需要动态给一个对象增加功能，这些功能可以再动态地撤销。</li>
<li>需要增加由一些基本功能的排列组合而产生的非常大量的功能，而继承关系就变得不现实。</li>
</ol>


<h3>装饰模式的优缺点</h3>

<p>装饰模式的优点包括：</p>

<ol>
<li>可以动态地贴上一个需要的装饰，或者除掉一个不需要的装饰。</li>
<li>通过使用不同的具体装饰类，以及这些装饰类的排列组合，可以创造出很多不同行为的组合。</li>
</ol>


<p>装饰模式的缺点是比继承要使用更多的对象，更多的对象会使得查错变得困难。</p>

<h3>装饰模式的简化</h3>

<p>不论如何简化，必须保证：</p>

<ol>
<li>ConcreteDecorator类必须继承自一个共同的父类Component。</li>
<li>尽量保持Component作为一个“轻”类。</li>
</ol>


<p>常见的简化包括：</p>

<ol>
<li>没有Component，只有ConcreteComponent，此时，Decorator可以是ConcreteComponent的子类，ConcreteComponent扮演双重角色。</li>
<li>没有Decorator，只有ConcreteDecorator，但如果有两个以上的。</li>
</ol>


<h3>其它</h3>

<p>纯粹的装饰模式对客户端的要求是不要声明ConcreteDecorator类型的变量，而应当声明Component类型的变量。这也就是针对抽象编程。因此，ConcreteDecorator不能有Component接口之外的方法。但现实中的装饰模式允许改变接口，增加新方法，即客户端可以声明ConcreteDecorator类型的变量。这就有点像是适配器模式。</p>

<p>装饰模式与适配器模式其实是不一样的。适配器模式的目的是改变接口，常常改写或者增加新的方法来适配接口。而装饰模式是保持接口不变，增强或增加功能。它们的类图是不一样的。</p>

<p>以Java的IO库为例，Reader类型的对象读入字符(Character)流，而InputStreamReader是一种Reader类型，把InputStream类型对象包装起来，从而把byte的API转换成字符流的API。这就是适配器模式的例子。即InputStreamReader把InputStream的API适配成Reader的API。</p>

<p>而BufferredReader则是一个装饰类，因为它实现Reader，并且包装一个Reader，接口未变，但提供更优的性能。但它不是一个100％的装饰类，因为它提供了一个readLine()的新方法。</p>

<p>以InputStream相关类为例，如下所示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_20140803_002859.jpg" alt="image" /></p>

<p>图中，红色类为适配器模式，将其它类型（如Byte数组）接口转换成InputStream接口。而绿色及其子类为适配器模式，各角色：</p>

<ol>
<li>Component角色：InputStream</li>
<li>Concrete Component角色：红色的类</li>
<li>Decorator角色：绿色的类</li>
<li>ConcreteDecorator角色：最下面的四个类。</li>
</ol>


<p>附各类的主要用途：</p>

<ol>
<li>ByteArrayInputStream: 为多线程的通信提供缓冲区操作功能，接收Byte数组作为流的源。</li>
<li>FileInputStream：接收一个File对象作为流的源。</li>
<li>PipedInputStream：与PipedOutputStream配合使用，用于读入一个数据管道的数据，接收PipedOutputStream作为源。</li>
<li>StringBufferInputStream：接收一个String对象作为流的源。</li>
<li>FilterInputStream：过滤输入流，将另一个输入流作为流的源。</li>
<li>BufferInputStream：内部提供内存缓冲区，从此缓冲区提供数据。</li>
<li>DataInputStream：提供多字节的读取方法，读取原始数据类型的数据。</li>
<li>LineNumberInputStream: 提供带有行计数功能和按行号读取数据的过滤输入流。不常用，主要用于编译器。</li>
<li>PushbackInputStream：提供特殊功能，将已经读取的字节“推回”到输入流中。不常用，主要用于编译器。</li>
<li>ObjectInputStream：读取使用ObjectOutputStream序列化的流，将其反序列化。</li>
<li>SequenceInputStream：将两个已有的输入流连接起来，形成一个输入流。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:组合（Composite）模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/31/she-ji-mo-shi-zu-he-mo-shi/"/>
    <updated>2014-07-31T21:08:30+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/31/she-ji-mo-shi-zu-he-mo-shi</id>
    <content type="html"><![CDATA[<p>组合模式将对象以树状结构组织起来，达成“部分－整体”的层次结构，使得客户端对单个对象和组合对象的使用具有一致性。结构示意图：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-31_21.14.15.jpg" alt="image" /></p>

<!--more-->


<p>此模式涉及三个角色：</p>

<ol>
<li>Component角色：定义共有的接口及其默认行为。</li>
<li>Leaf角色：叶节点，不能有下级子对象。</li>
<li>Composite角色：树枝节点，可以有下级子对象的节点。</li>
</ol>


<p>组合模式根据实现方式的不同，分为安全方式和透明方式。区别主要在于接口的定义。Composite角色拥有add、remove、getChild等方法，这些方法对于Leaf角色完全没有用处。因此Component角色是否定义这些方法，就形成了两种实现方式。</p>

<h3>透明方式</h3>

<p>这种方式在Component中定义所有的方法，不管这些方法对于Leaf角色是否有用。这样做的好处是所有角色都有相同的接口，客户端可以统一的方式对待所有对象。缺点是不够安全，因为Leaf角色的add方法没有意义，可能在运行期出错。透明方式的组合模式结构图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-31_21.29.20.jpg" alt="image" /></p>

<p>可以看出，这种方式的Leaf和Composite没有什么区别，都实现了Component的所有接口方法。但Leaf角色的add, remove等方法都是平庸实现。</p>

<h3>安全方式</h3>

<p>这种方式的Component只定义公共的接口，不包括Composite角色的add, remove等方法。结构如下图：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-31_22.11.35.jpg" alt="image" /></p>

<p>不论采用哪种方式，其中composite属性都是指向父节点的引用。这样就可以很容易地遍历所有的父对象。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:缺省适配模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/31/she-ji-mo-shi-que-sheng-gua-pei-mo-shi/"/>
    <updated>2014-07-31T20:31:57+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/31/she-ji-mo-shi-que-sheng-gua-pei-mo-shi</id>
    <content type="html"><![CDATA[<p>缺省适配模式其实很简单，就是一个接口有很多方法，通过一个抽象类为这些方法提供默认实现，而具体的类继承这个抽象类，实现自己关心的方法即可。其结构如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-31_20.37.12.jpg" alt="image" /></p>

<p>什么情况下用缺省适配模式？如果不准备实现一个接口的所有方法时，可以通过一个抽象类，给出所有方法的实现。有用的方法要有实现，没用的方法也要有空的、平庸的实现。这样子类就不必实现所有方法了。对应适配器模式的三个角色：</p>

<ul>
<li>Adapter：子类</li>
<li>Adaptee：抽象类</li>
<li>Target：接口</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:适配器模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/30/she-ji-mo-shi-gua-pei-qi-mo-shi/"/>
    <updated>2014-07-30T22:31:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/30/she-ji-mo-shi-gua-pei-qi-mo-shi</id>
    <content type="html"><![CDATA[<p>适配器模式分为类的适配器和对象的适配器。它们都是把被适配类的API转换成目标类的API。但前者使用继承关系，而后者使用委派关系。它们的结构如下图：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-30_22.38.26.jpg" alt="image" /> <img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-30_22.40.21.jpg" alt="image" /></p>

<!--more-->


<p>上图中的三个角色：</p>

<ol>
<li>Target接口，这是目标接口，表示要适配成这个接口。</li>
<li>Adaptee，这是被适配的对象，表示要将它适配成Target。</li>
<li>Adapter，适配器，将Adaptee适配成Target。</li>
</ol>


<p>第一张图对应的是类的适配器，第二张图是对象的适配器。从图上看，区别主要是Adapter到Adaptee的连线不一样，一个是继承，一个是依赖。</p>

<h2>类的适配器</h2>

<p>先看类的适配器，即第一张图。Adapter继承自Adaptee，因此继承了方法operation1，再加上它自己实现的方法operation2，从而实现了Target接口，完成适配。由于是继承关系，因此Adaptee必须是一个类，不能是接口。</p>

<h2>对象的适配器</h2>

<p>对第二张图，Adaptee是被适配的接口，可以是接口或者类。Adapter包含一个对Adaptee的引用。Adapter的operation1方法，只需调用Adaptee.operation1，同时增加operation2，从而实现Target接口，完成适配。</p>

<p>因为没有了继承关系，因此一个适配器可以把多种不同的源适配到同一个目标。</p>

<h2>什么情况下使用适配器模式</h2>

<ol>
<li>系统需要使用现有类，而此类的接口不符合系统需要。</li>
<li>建立一个可重复使用的类，用于与一些彼此没有太大关联的一些类一起工作。</li>
<li>对象的适配器可用于改变多个已有的子类的接口。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式: 原型（Prototype）模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/30/she-ji-mo-shi-prototypemo-shi/"/>
    <updated>2014-07-30T20:58:15+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/30/she-ji-mo-shi-prototypemo-shi</id>
    <content type="html"><![CDATA[<p>原型（Prototype）模式的用处是：对于给定的原型对象，用复制的方法创建出更多的同类型对象。之前学习的工厂方法模式常常需要有一个与产品等级相同的等级结构，而原型模式则不需要这样。Java语言天生就支持原型模式。原型模式的结构图如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-30_21.10.50.jpg" alt="image" /></p>

<!--more-->


<h2><code>clone()</code>方法</h2>

<p>Java的Object类提供了<code>protected Object clone()</code>方法，用于复制对象。而<code>Cloneable</code>接口用于在运行期告诉JVM可以安全地使用<code>clone()</code>方法，否则JVM将会抛出<code>CloneNotSupportedException</code>异常。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">//复制一个pandaA</span>
</span><span class='line'><span class="n">pandaB</span> <span class="o">=</span> <span class="n">pandaA</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>一般而言，clone方法满足以下描述：</p>

<ol>
<li><code>x.clone() != x</code>，也就是说复制出来后，不是同一个对象。</li>
<li>复制对象与被复制对象是同一种类型。</li>
<li>在Java的API中，<code>x.clone().equals(x)</code>是成立的，因此建议要遵守这一条。</li>
</ol>


<h2>深复制和浅复制</h2>

<ul>
<li>浅复制：对象所有的变量与原来的对象值相同，所有对其它对象的引用仍然指向原来的对象。</li>
<li>深复制：对象所有的变量与原来的对象值相同，所有对其它对象的引用也指向被复制的新对象。</li>
</ul>


<p><code>clone()</code>方法是浅复制，而深复制可以通过序列化实现。例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DeepCloneDemo</span> <span class="kd">implements</span> <span class="n">Serializable</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="n">DeepCloneDemo</span> <span class="nf">deepClone</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">ByteArrayOutputStream</span> <span class="n">bo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ByteArrayOutputStream</span><span class="o">();</span>
</span><span class='line'>      <span class="n">ObjectOutputStream</span> <span class="n">oo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectOutputStream</span><span class="o">(</span><span class="n">bo</span><span class="o">);</span>
</span><span class='line'>      <span class="n">oo</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'>      
</span><span class='line'>      <span class="n">ByteArrayInputStream</span> <span class="n">bi</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ByteArrayInputStream</span><span class="o">(</span><span class="n">bo</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">());</span>
</span><span class='line'>      <span class="n">ObjectInputStream</span> <span class="n">oi</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectInputStream</span><span class="o">(</span><span class="n">bi</span><span class="o">);</span>
</span><span class='line'>      
</span><span class='line'>      <span class="k">return</span> <span class="o">(</span><span class="n">DeepCloneDemo</span><span class="o">)</span> <span class="n">oi</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">//...</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">//...</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1">//测试代码</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DeepCloneDemoTest</span> <span class="kd">extends</span> <span class="n">TestCase</span><span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testDeepClone</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">DeepCloneDemo</span> <span class="n">demo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DeepCloneDemo</span><span class="o">();</span>
</span><span class='line'>      <span class="n">demo</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;Demo&quot;</span><span class="o">);</span>
</span><span class='line'>      
</span><span class='line'>      <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">DeepCloneDemo</span> <span class="n">demo2</span> <span class="o">=</span> <span class="n">demo</span><span class="o">.</span><span class="na">deepClone</span><span class="o">();</span>
</span><span class='line'>          <span class="n">Assert</span><span class="o">.</span><span class="na">assertFalse</span><span class="o">(</span><span class="n">demo2</span> <span class="o">==</span> <span class="n">demo</span><span class="o">);</span>
</span><span class='line'>          <span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">demo</span><span class="o">,</span> <span class="n">demo2</span><span class="o">);</span>
</span><span class='line'>          
</span><span class='line'>      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClassNotFoundException</span> <span class="o">|</span> <span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>          <span class="n">Assert</span><span class="o">.</span><span class="na">assertFalse</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意要实现Serializable接口。如果不希望某个属性被序列化，可以使用<code>transient</code>关键字，例如：<code>private transient int age;</code>。</p>

<h2>什么时候用原型模式</h2>

<p>如果类是动态加载的，给每个类配备clone方法，就可以在运行时创建。</p>

<p>原型模式的优点是：允许动态地增加或减少产品类；提供简化的创建结构，不需要工厂方法那样的等级结构；为软件提供动态加载新功能的能力；</p>

<p>原型模式的缺点是：每个类都必须有clone方法，这对新类来说很容易，但已有的类就不一定，例如引用了不支持序列化的间接对象时，或者含有循环结构的时候。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:Builder模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/29/she-ji-mo-shi-buildermo-shi/"/>
    <updated>2014-07-29T22:28:54+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/29/she-ji-mo-shi-buildermo-shi</id>
    <content type="html"><![CDATA[<p>Builder模式感觉没什么特别的，甚至都不值得称为一种模式。无非就是由Director构建部分，然后再使用一个方法完成构建过程。但Builder模式对于参数太多的构造器却非常有用。先看Builder模式的类图：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-29_22.38.17.png" alt="image" /></p>

<p><a href="http://blog.ubone.com/blog/2014/06/27/effective-java-chuang-jian-he-xiao-hui-dui-xiang/">这篇博客</a>建议当构造器参数比较多时，考虑使用Builder模式。这是一种非常优雅的方式。</p>

<p>我觉得Builder模式的好处一是使客户端的代码很清晰，不需要那么多的set方法；二是实现了产品构建的原子性，也就是可以在build时，确保产品构建是有效的，如果某些部分或者参数有问题、冲突，就能够在build时失败，避免残次的半成品出现。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式在序列生成器的应用]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/28/she-ji-mo-shi-zai-xu-lie-sheng-cheng-qi-de-ying-yong/"/>
    <updated>2014-07-28T22:21:23+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/28/she-ji-mo-shi-zai-xu-lie-sheng-cheng-qi-de-ying-yong</id>
    <content type="html"><![CDATA[<p>序列生成器是常见的一个应用组件。Oracle数据库有Sequence，但不是所有数据库都有序列。本文尝试将单例模式、多例模式应用于序列生成器。采用了以下方式实现：</p>

<ol>
<li>没有数据库的单例实现</li>
<li>有数据库的单例实现</li>
<li>有缓存的单例实现</li>
<li>有缓存的多序列实现</li>
<li>多序列的多例实现。</li>
</ol>


<!--more-->


<h2>1. 没有数据库的单例实现</h2>

<p>当没有数据库时，使用单例实现序列生成器非常简单，示例代码如下，注意<code>synchronized</code>关键字：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * 没有数据库的序列键生成器</span>
</span><span class='line'><span class="cm"> * @author mxs</span>
</span><span class='line'><span class="cm"> *</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">KeyGenerator</span> <span class="o">{</span>    
</span><span class='line'>  <span class="kd">private</span> <span class="kt">long</span> <span class="n">key</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="n">KeyGenerator</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">KeyGenerator</span><span class="o">();</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">private</span> <span class="nf">KeyGenerator</span><span class="o">()</span> <span class="o">{}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="n">KeyGenerator</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">long</span> <span class="nf">getNextKey</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">key</span><span class="o">++;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>单元测试代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">KeyGeneratorTest</span> <span class="kd">extends</span> <span class="n">TestCase</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testKey</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">KeyGenerator</span> <span class="n">keyGenerator</span> <span class="o">=</span> <span class="n">KeyGenerator</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
</span><span class='line'>      
</span><span class='line'>      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">keyGenerator</span><span class="o">.</span><span class="na">getNextKey</span><span class="o">());</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种实现没有持久化，一旦重启，序列又从0开始。因此我们需要一个有数据库持久化的方案。</p>

<h2>2. 有数据库的单例实现</h2>

<p>当有数据库时，每次获取序列都从数据库读取。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * 有数据库的序列键生成器</span>
</span><span class='line'><span class="cm"> * @author mxs</span>
</span><span class='line'><span class="cm"> *</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">KeyGenerator</span> <span class="o">{</span>    
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="n">KeyGenerator</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">KeyGenerator</span><span class="o">();</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">private</span> <span class="nf">KeyGenerator</span><span class="o">()</span> <span class="o">{}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="n">KeyGenerator</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">long</span> <span class="nf">getNextKey</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="nf">getNextKeyFromDB</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">private</span> <span class="kt">long</span> <span class="nf">getNextKeyFromDB</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">//update t_sequence set seq_value = seq_value + 1</span>
</span><span class='line'>      <span class="c1">//select seq_value from t_sequence</span>
</span><span class='line'>      <span class="c1">//返回结果</span>
</span><span class='line'>      <span class="k">return</span> <span class="mi">1000</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>3. 有缓存的单例实现</h2>

<p>第2种方法每次都要访问数据库，影响了性能，可以一次多取一些序列放到缓存中，只有缓存都取完时，才访问数据库。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * 有数据库、带缓存的序列键生成器</span>
</span><span class='line'><span class="cm"> * @author mxs</span>
</span><span class='line'><span class="cm"> *</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">KeyGenerator</span> <span class="o">{</span>    
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="n">KeyGenerator</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">KeyGenerator</span><span class="o">();</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">cacheSize</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="n">KeyInfo</span> <span class="n">keyInfo</span><span class="o">;</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">private</span> <span class="nf">KeyGenerator</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">keyInfo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">KeyInfo</span><span class="o">(</span><span class="n">cacheSize</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="n">KeyGenerator</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">long</span> <span class="nf">getNextKey</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">keyInfo</span><span class="o">.</span><span class="na">getNext</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">KeyInfo</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">long</span> <span class="n">max</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">long</span> <span class="n">min</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">long</span> <span class="n">nextKey</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">int</span> <span class="n">poolSize</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="nf">KeyInfo</span><span class="o">(</span><span class="kt">int</span> <span class="n">poolSize</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">poolSize</span> <span class="o">=</span> <span class="n">poolSize</span><span class="o">;</span>
</span><span class='line'>      <span class="n">retrieveFromDB</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getNext</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">nextKey</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">retrieveFromDB</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">return</span> <span class="n">nextKey</span><span class="o">++;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">retrieveFromDB</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">// update t_sequence set seq_value = seq_value + poolSize</span>
</span><span class='line'>      <span class="c1">// select seq_value from t_sequence</span>
</span><span class='line'>      <span class="c1">//以下为模拟数据库操作</span>
</span><span class='line'>      <span class="kt">long</span> <span class="n">value</span> <span class="o">=</span> <span class="n">dbvalue</span><span class="o">[</span><span class="n">dbIndex</span> <span class="o">++];</span>
</span><span class='line'>      <span class="n">min</span> <span class="o">=</span> <span class="n">value</span> <span class="o">-</span> <span class="n">poolSize</span><span class="o">;</span>
</span><span class='line'>      <span class="n">max</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
</span><span class='line'>      <span class="n">nextKey</span> <span class="o">=</span> <span class="n">min</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dbvalue</span> <span class="o">=</span> <span class="o">{</span><span class="mi">20</span><span class="o">,</span> <span class="mi">40</span><span class="o">,</span> <span class="mi">60</span><span class="o">,</span> <span class="mi">80</span><span class="o">,</span> <span class="mi">100</span><span class="o">};</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">int</span> <span class="n">dbIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>4. 有缓存的多序列实现</h2>

<p>要实现多序列，只需要用HashMap改造第3种方法，保持KeyInfo不变，KeyGenerator修改为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * 有数据库、带缓存的多序列键生成器</span>
</span><span class='line'><span class="cm"> * @author mxs</span>
</span><span class='line'><span class="cm"> *</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">KeyGenerator</span> <span class="o">{</span>    
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="n">KeyGenerator</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">KeyGenerator</span><span class="o">();</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">cacheSize</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">KeyInfo</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">;</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">private</span> <span class="nf">KeyGenerator</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">KeyInfo</span><span class="o">&gt;();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="n">KeyGenerator</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">long</span> <span class="nf">getNextKey</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">KeyInfo</span> <span class="n">keyInfo</span><span class="o">;</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">keyInfo</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">keyInfo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">KeyInfo</span><span class="o">(</span><span class="n">cacheSize</span><span class="o">);</span>
</span><span class='line'>          <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">keyInfo</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>              
</span><span class='line'>      <span class="k">return</span> <span class="n">keyInfo</span><span class="o">.</span><span class="na">getNext</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>5. 多序列的多例实现</h2>

<p>前面所有实现方案都是基于单例模式，其实还可以使用多例模式。多例模式允许一个类有多个实例，这些实例有自己的状态。保持KeyInfo不变，KeyGenerator修改为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * 有数据库、带缓存的多序列键生成器，采用多例模式</span>
</span><span class='line'><span class="cm"> * @author mxs</span>
</span><span class='line'><span class="cm"> *</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">KeyGenerator</span> <span class="o">{</span>    
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">cacheSize</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="n">KeyInfo</span> <span class="n">keyInfo</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">KeyGenerator</span><span class="o">&gt;</span> <span class="n">instances</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">KeyGenerator</span><span class="o">&gt;(</span><span class="mi">10</span><span class="o">);</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">private</span> <span class="nf">KeyGenerator</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">keyInfo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">KeyInfo</span><span class="o">(</span><span class="n">cacheSize</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">synchronized</span> <span class="n">KeyGenerator</span> <span class="nf">getInstance</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(!</span> <span class="n">instances</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">KeyGenerator</span> <span class="n">generator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">KeyGenerator</span><span class="o">();</span>
</span><span class='line'>          <span class="n">instances</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">generator</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      
</span><span class='line'>      <span class="k">return</span> <span class="n">instances</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">long</span> <span class="nf">getNextKey</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">keyInfo</span><span class="o">.</span><span class="na">getNext</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//测试代码：</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">KeyGeneratorTest</span> <span class="kd">extends</span> <span class="n">TestCase</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testKey</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">j</span> <span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">String</span> <span class="n">key</span> <span class="o">=</span> <span class="s">&quot;&quot;</span> <span class="o">+</span> <span class="n">j</span><span class="o">;</span>
</span><span class='line'>          <span class="n">KeyGenerator</span> <span class="n">keyGenerator</span> <span class="o">=</span> <span class="n">KeyGenerator</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span><span class='line'>          <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">90</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>              <span class="kt">long</span> <span class="n">ii</span> <span class="o">=</span> <span class="n">keyGenerator</span><span class="o">.</span><span class="na">getNextKey</span><span class="o">();</span>
</span><span class='line'>              <span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">ii</span><span class="o">);</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>        
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>参考：
Java与模式</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:抽象工厂方法模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/28/she-ji-mo-shi-chou-xiang-gong-han-fang-fa-mo-shi/"/>
    <updated>2014-07-28T19:45:29+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/28/she-ji-mo-shi-chou-xiang-gong-han-fang-fa-mo-shi</id>
    <content type="html"><![CDATA[<p>简单工厂方法模式采用静态方法创建产品，工厂方式模式通过多层级的工厂方法创建一种产品等级结构。而抽象工厂方法模式则可以用于创建多个产品等级结构。因此，其类图示意如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-28_20.03.46.png" alt="image" /></p>

<!--more-->


<p>从上图可见，有两个产品等级：ProductA和ProductB。抽象工厂模式与工厂方法模式的最大区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则需要面对多个产品等级结构。那么对于多个等级结构的产品，为什么要采用抽象工厂模式呢？</p>

<p>如果采用工厂模式，就要N个独立的工厂等级结构来应对N个产品等级结构。由于这些产品等级结构的相似性，会导致N个平等的工厂等级结构。随着产品等级结构数目的增加，工厂方式模式所给出的工厂等级结构数目也会随之增加。</p>

<p>所以，抽象工厂方法模式的好处是，同一个工厂等级结构应对N个这些相似的产品等级结构。例如上图中的ConcreteCreator1负责创建ProductA1和ProductB1。显然，这种方式更有效率。</p>

<p>什么情况下应当使用抽象工厂模式？</p>

<ol>
<li>满足工厂模式的条件，即：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节时。</li>
<li>多于一个的产品族，而系统只消费其中某一族的产品。如上图中有2个族（1，2），同时只消费其中一个族。</li>
<li>同属于一个产品族的产品是一起使用的。</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。</li>
</ol>


<p>举一个实际例子就很容易理解为什么需要，以及什么时候需要抽象工厂模式：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-28_21.41.37.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:工厂方法模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/27/she-ji-mo-shi-gong-han-fang-fa/"/>
    <updated>2014-07-27T22:11:04+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/27/she-ji-mo-shi-gong-han-fang-fa</id>
    <content type="html"><![CDATA[<p>前文说到简单工厂方法的工厂类，对“开－闭”原则支持不够，当有新产品时，需要修改工厂类。而工厂方法模式可以解决这个问题。工厂方法模式的用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。其结构可表示为：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-27_22.10.30.png" alt="image" /></p>

<!--more-->


<p>上图中，Factory和SomeProduct可以是接口或者抽象类，工厂方法factory的返回类型必须是SomeProduct，这也是针对接口编程的一个体现。</p>

<p>在实际项目中，产品类可能有多个层级，对应工厂类也有多个层级。当使Factory为抽象类时，可以将公共代码尽量往上层抽象。</p>

<p>工厂方法返回的对象不一定是新建的，有可能是之前新建的对象，缓存在那里。但一定是自己创建的，不可以是别的对象传入的对象。</p>

<p>ConcreteFactory1示例代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConcreteFactory1</span> <span class="kd">implements</span> <span class="n">Factory</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">SomeProduct</span> <span class="nf">factory</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="k">new</span> <span class="nf">SomeConcreteProduct1</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Client代码示例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Client</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="n">Factory</span> <span class="n">concreteFactory1</span><span class="o">,</span><span class="n">concreteFactory2</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="n">SomeProduct</span> <span class="n">concreteProduct1</span><span class="o">,</span> <span class="n">concreteProduct2</span><span class="o">;</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">concreteFactory1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcreteFactory1</span><span class="o">();</span>
</span><span class='line'>      <span class="n">concreteProduct1</span> <span class="o">=</span> <span class="n">concreteFactory1</span><span class="o">.</span><span class="na">factory</span><span class="o">();</span>
</span><span class='line'>      <span class="n">concreteFactory2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcreteFactory2</span><span class="o">();</span>
</span><span class='line'>      <span class="n">concreteProduct2</span> <span class="o">=</span> <span class="n">concreteFactory2</span><span class="o">.</span><span class="na">factory</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Titanium vs Worklight]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/27/titanium-vs-worklight/"/>
    <updated>2014-07-27T13:52:25+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/27/titanium-vs-worklight</id>
    <content type="html"><![CDATA[<p>因工作需要，对两个跨平台移动开发工具（Titanium，Worklight）进行比较的。本文主要从跨平台特性、性能、社区等进行比较。实际上，本文同样适用于Titanium VS Phonegap。</p>

<!--more-->


<h2>Workligt简介</h2>

<p>Worklight是IBM公司的产品，支持HTML5，Hybrid、Native开发方式，涵盖完整的移动应用生命周期，包括开发、运行、安全和管理。</p>

<p>Worklight以Cordova为核心。因此它与Phonegap是非常类似的产品，基于HTML5、CSS3和JavaScript，通过Adapter集成后台REST、SOA等服务。在其PPT中说提供了以下移动开发模式：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-27_15.16.22.png" alt="image" /></p>

<p><strong>但找遍其资料也未找到Worklight如何使用第4种开发模式。</strong></p>

<p>几乎支持所有移动设备：iOS, Android, BlackBerry, Windows Phone。基于Dojo的可视化UI构造。充分利用现有Javascript框架，如jQuery, dojo, Sencha等。</p>

<p>通过Worklight Server提供对企业数据和系统的安全访问：
<img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-27_15.10.37.png" alt="image" /></p>

<h3>Worklight的工作方式</h3>

<p>开发人员采用HTML、CSS和JavaScript在本地开发，就像开发静态Web网站一样。每种移动应用平台都提供了一个嵌入式的Web浏览器，Worklight应用就运行在这样一个浏览器中，因此，Worklight实质上是拥有原生外壳的Html Web应用。</p>

<p>Worklight基于Cordova提供设备的接口，相当于在JavaScript与移动设备的传感器、摄像头间建立了一连接层，使得JavaScript可以访问这些原生接口。</p>

<h3>Worklight的优势</h3>

<p>由于其本质是Web应用，因此只要原生平台有Web view，就可以移植到该平台。因此Worklight几乎支持所有移动平台。</p>

<p>采用Html、CSS和JavaScript的技术门槛比较低，同时也有现成的框架可用，如jQuery, dojo, Sencha等。</p>

<h3>Worklight的劣势</h3>

<p>Worklight应用的UI性能取决于系统的浏览器性能。iOS平台的基于Webkit引擎的浏览器性能更好，而Android平台则有一些限制。对于其它平台，可能跟OS版本有关系。</p>

<p>同时，与Web开发相似，存在一些跨平台的问题要处理。即使是基于Webkit的环境，<a href="http://westcoastlogic.com/slides/debug-mobile/#/17">也存在一些明显的区别</a>。在IBM Worklight介绍的PPT中，一个应用示例在移植到Android时仍然使用了4周的时间，见下图：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-27_18.46.36.png" alt="image" /></p>

<p>现代浏览器已经越来越强大，但即使如此，要在浏览器中达到原生的UI性能，几乎是不可能的。</p>

<p>Cordova提供的原生API非常有限，主要集中在摄像头、加速传感器、定位传感器等，因此平台集成是很有限的。当然有一些插件来填补这一空白，但是它们的质量和可维护性并不稳定。</p>

<p>移动端不支持Sqlite数据库，保存本地数据比较困难。</p>

<h2>Titanium简介</h2>

<p>Titanium是Appcelerator推出的跨平台移动应用开发工具，支持Android、Blackberry、iOS和Tizen。</p>

<p>Titanium同样采用JavaScript作为主要开发语言，支持Web应用、混合型应用和原生应用开发。</p>

<p>Titanium也同样提供了相应的云服务，包括推送、同步、企业安全认证和数据安全等。</p>

<p>当开发者开发Titanium应用时，可以用JavaScript编写原生应用，而不只是Web应用。但是，为了充分使用原生API的性能，Titanium并不是“一次编写、到处运行”的平台。Titanium可以让开发者充分利用那些平台特定的特性，它对移动开发的支持包括两部分：</p>

<ul>
<li>移动开发核心部分API，是支持跨平台的，因此这部分代码可以复用。</li>
<li>平台特定的API、UI和特性，存在于特定平台中。</li>
</ul>


<p>例如，你可以在Titanium的iOS应用中，使用某个iOS平台特有的组件，而在Android平台，采用其它方案。</p>

<h3>Titanium的工作方式</h3>

<p>Titanium开发的应用在运行时，包括三大组件：</p>

<ul>
<li>JavaScript代码</li>
<li>Titanium的系统原生API</li>
<li>JavaScript解析器（Android: V8或Rhino；iOS：JavaScriptCore）</li>
</ul>


<p>当我们用JavaScript创建一个窗口时，会发生什么呢，见下图：</p>

<p><img src="http://blog.ubone.com/myresource/images/images_download_attachments_35621751_create_proxy.png" alt="image" /></p>

<p>可以看到，JavaScript代码会调用原生API，创建的是原生的Window，而不是浏览器中的Web对象！因此所有UI与Java或Objective-c开发的原生应用没有区别，它们就是Native UI。</p>

<p>这就是为什么说Titanium是用JavaScript开发原生应用。它不需要浏览器来执行JavaScript代码，JavaScript代码也不会被编译成Java或者Objective-C。JavaScript是在运行时执行，并且在需要时调用原生的UI组件和方法。</p>

<p>开发者可以以原生的方式，自由地扩展Titanium，包括UI和其它不可见的特性。</p>

<h3>Titanium的优势</h3>

<p>Titanium提供了广泛的原生特性和功能，包括原生UI组件、网络接口、数据库和系统通知等等。因此Titnaium应用的UI是真正的原生组件，具有与原生应用相同的性能。</p>

<p>Titanium具有广泛的原生应用API。提供了90%以上常用的原生平台API，而剩余不常用的10%可以由用户自己实现。</p>

<p>Titanium应用具有更好的外观，它不需要CSS等来模拟原生界面，因为它自己就是原生界面。例如当你创建了NavigationGroup，在iOS上会创建UINavigationController，它的行为和动画效果都是原生的，更符合用户的预期。</p>

<p>具有非常好的扩展性。开发者能够针对指定平台，实现任何原生的UI，并集成到Titanium应用中。例如，你可以实现一个TableView，滚动时以每秒60帧显示。也可以无缝集成一个OpenGL绘图的游戏，并在JavaScript中执行循环。你可以将这些扩展的UI直接集成到应用中。</p>

<p>原生支持Sqlite数据库。</p>

<p>Titanium基于Apache 2.0开源协议，具有广泛的社区支持。</p>

<h3>Titanium的劣势</h3>

<p>Titanium的API范围，使得它在增加一种新的原生平台时，比较困难。这也是为什么现在Titanium只支持iOS、Android、BlackBerry、Tizen和Web的原因。<a href="http://www.appcelerator.com/blog/2014/01/windows-8-support-whats-going-on/">Titanium对Windows Phone的支持预计在2014年第4季度实现。</a></p>

<h2>谁比谁更好？</h2>

<p>从1万米高空看，两者没有太大区别，它们都提供了跨平台的移动应用开发能力。而两者间其实不存在谁比谁更好的问题，只看谁比谁更合适！</p>

<p>对于企业移动应用来说，谁更合适？我们先看看企业移动应用有哪些特点：</p>

<ul>
<li>界面以稳健风格为主</li>
<li>应用稳定可靠</li>
<li>安全性要求高</li>
<li>数据量一般比较大</li>
<li>性能要求高</li>
</ul>


<p>对于前面三点，两者没有太多区别，而关于后面两点，Titanium的性能更占优势，而SQLite数据库的支持也有利于部分企业数据（如通讯录）的本地缓存，提升用户体验。下表总结了两者的一些对比：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-27_18.41.36.png" alt="image" /></p>

<h3>参考：</h3>

<p><a href="http://www.appcelerator.com/blog/2012/05/comparing-titanium-and-phonegap/">Comparing titanium and phonegap</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:简单工厂模式]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/27/she-ji-mo-shi-jian-dan-gong-han-mo-shi/"/>
    <updated>2014-07-27T09:44:35+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/27/she-ji-mo-shi-jian-dan-gong-han-mo-shi</id>
    <content type="html"><![CDATA[<p>简单工厂模式其实就是静态工厂方法模式，即通过静态工厂方法来创建对象。其结构可表示为：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-27_1.png" alt="image" /></p>

<!--more-->


<p>来看个实际的例子，下图中，有多种水果。客户端不关心具体的水果是如何创建的，只需要告诉工厂方法，需要哪种水果类型，工厂方法负责具体水果的创建工作。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-27_2.png" alt="image" /></p>

<p>工厂方法返回的是水果接口。水果接口也可以换成抽象类。这是针对抽象编程的一种体现。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FruitFactory</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Fruit</span> <span class="nf">getFruit</span><span class="o">(</span><span class="n">String</span> <span class="n">type</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">type</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="s">&quot;apple&quot;</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="k">new</span> <span class="nf">Apple</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">type</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="s">&quot;orange&quot;</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="k">new</span> <span class="nf">Orange</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">throw</span> <span class="k">new</span> <span class="nf">FruitFactoryException</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>省略抽象产品角色</h3>

<p>如果具体产品只有一个（即只有一种水果）时，可以省略掉抽象产品角色，变成：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-27_3.png" alt="image" /></p>

<h3>合并工厂角色与抽象产品角色</h3>

<p>有些情况下，工厂角色可以由抽象产品角色扮演，例如java.text.DateFormat类，如下图所示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-27_4.png" alt="image" /></p>

<h3>三个角色全部合并</h3>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-07-27_5.png" alt="image" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConcreteProduct</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="nf">ConcreteProduct</span><span class="o">()</span> <span class="o">{}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="n">ConcreteProduct</span> <span class="nf">factory</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="k">new</span> <span class="nf">ConcreteProduct</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>多个工厂方法</h3>

<p>工厂类可以有一个或多个工厂方法，分别负责创建不同的产品对象。例如java.text.DateFormat类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="kd">static</span> <span class="n">DateFormat</span> <span class="nf">getDateInstance</span><span class="o">();</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="kd">static</span> <span class="n">DateFormat</span> <span class="nf">getDateInstance</span><span class="o">(</span><span class="kt">int</span> <span class="n">style</span><span class="o">);</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="kd">static</span> <span class="n">DateFormat</span> <span class="nf">getDateInstance</span><span class="o">(</span><span class="kt">int</span> <span class="n">style</span><span class="o">,</span> <span class="n">Local</span> <span class="n">locale</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>总结</h3>

<p>简单工厂模式是非常基本的设计模式，会在较为复杂的设计模式中出现。它的核心是工厂类，客户端完全不关心构建的细节，只需消费产品。因此，简单工厂模式实现了对责任的分割。</p>

<p>但其缺点是当产品结构变得复杂时，工厂类将变得非常复杂。由于静态方法无法继承，因此工厂角色无法形成基于继承的等级结构。</p>

<p>在这种模式中，消费者(Client)和产品（Product）都满足“开－闭原则”，都能在引进新产品时，无需对现有代码进行修改。而工厂（Factory）则必须知道每一种产品以及如何创建它们，因此必须修改这个工厂的代码，不满足“开－闭”原则。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一些设计原则]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/25/yi-xie-she-ji-yuan-ze/"/>
    <updated>2014-07-25T21:01:51+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/25/yi-xie-she-ji-yuan-ze</id>
    <content type="html"><![CDATA[<p>关于设计，有一些原则。本文总结一些常见的原则。包括：</p>

<ul>
<li>(S)单一职责原则</li>
<li>(O)开闭原则</li>
<li>(L)里氏替换原则</li>
<li>(I)接口隔离原则</li>
<li>(D)依赖反转原则</li>
<li>迪米特法则</li>
<li>组合/聚合复用原则</li>
</ul>


<!--more-->


<h2>S.单一职责原则</h2>

<p>单一职责原则（Single responsibility principle）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。</p>

<h2>O.开闭原则</h2>

<p>简单地说，就是软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的。这一原则由Bertrand Meyer提出：</p>

<blockquote><p>Software entities should be open for extension, but closed for modification.</p></blockquote>

<p>实现开闭原则的关键是抽象。找到一个系统的可变因素，将它封闭起来，这就是“对可变性的封闭原则”。</p>

<h2>L.里氏替换原则</h2>

<p>派生类（子类）对象能够替换其基类（父类）对象被使用。</p>

<h2>I.接口隔离原则</h2>

<p>接口隔离原则（Interface-segregation principles，ISP）简单地说，就是：使用多个专门的接口比使用单一的总接口要好。</p>

<p>没有客户(client)应该被迫依赖于它不使用方法。接口隔离原则(ISP)拆分非常庞大臃肿的接口成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。这种缩小的接口也被称为角色接口（role interfaces）。接口隔离原则(ISP)的目的是系统解开耦合，从而容易重构，更改和重新部署。</p>

<p>准确而恰当地划分角色以及角色所对应的接口，是面向对象的设计的一个重要的组成部分。</p>

<h2>D.依赖反转原则</h2>

<p>简单地说，就是依赖于抽象，不要依赖于具体。</p>

<p>为什么叫“反转”呢？？看看下面是怎么反转的：</p>

<p><img src="http://blog.ubone.com/myresource/images/img_blog_20140725_1.png" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/img_blog_20140725_2.png" alt="image" /></p>

<p>两种表述:</p>

<ol>
<li>抽象不应当依赖于细节；细节应该依赖于抽象。</li>
<li>要针对接口编程，不要针对实现编程。</li>
</ol>


<p>针对接口编程是指，应该使用接口和抽象类进行变量的类型声明、参数和方法返回类型的声明，以及数据类型的转换等。</p>

<p>不要针对实现编程是指，不应当使用具体Java类进行变量的类型声明、参数和方法返回类型的声明，以及数据类型的转换等。</p>

<p>如果希望遵循“开－闭原则”，那么依赖反转原则便是达到目标的途径。</p>

<h2>迪米特法则</h2>

<p>迪米特法则又叫做最少知识原则，就是说，一个对象应当对其他对象尽可能少的了解。</p>

<h3>狭义的迪米特法则</h3>

<p>如果两个类不必彼此直接通信，那么这两个类就不应该发生直接的相互作用。就是说如果某人可以通过朋友去调用陌生人的方法，那么就不用直接调用陌生人的方法，而是通过朋友去调用转发。</p>

<p>什么是朋友呢？满足任一条件都是朋友：</p>

<ul>
<li>当前对象本身</li>
<li>以参量形式传入到当前对象方法的对象</li>
<li>当前对象的实例变量直接引用的对象</li>
<li>当前对象的实例变量如果是聚集，那么其中的元素都是朋友</li>
<li>当前对象所创建的对象。</li>
</ul>


<p>狭义的迪米特法则的缺点是：产生大量小方法，与商务逻辑无关；不同模块之间的通信效率降低。</p>

<h3>广义迪米特法则在类的设计上的体现</h3>

<ul>
<li>优先考虑将一个类设置成不变类</li>
<li>尽量降低一个类的访问权限</li>
<li>尽量降低成员的访问权限</li>
</ul>


<h2>组合/聚合复用原则</h2>

<p>实际上说的就是尽量使用聚合/组合，尽量不要使用继承。这在Effective-Java中也有描述。<a href="http://blog.ubone.com/blog/2014/07/08/effective-java-lei-he-jie-kou/">Java类与接口</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一张图看懂UML类图的关系]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/23/yi-zhang-tu-kan-dong/"/>
    <updated>2014-07-23T23:37:18+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/23/yi-zhang-tu-kan-dong</id>
    <content type="html"><![CDATA[<p>在UML类图中，类之间的关系包括：继承、关联、聚合、组合和依赖关系。如何分辨这些关系呢？每种关系使用什么样的连线呢？</p>

<!--more-->


<p><strong>继承关系</strong>，这个太简单，不说了。</p>

<p><strong>关联关系</strong>，在Java中，使用实例变量来实现关系关系。如图中的Driver类有car变量。</p>

<p><strong>聚合关系</strong>，是更强的关联关系。聚合是整体与个体的关系。也需要通过实例变量实现。如果不是很确定是否聚合关系，可以使用关联关系。从Java语法是无法分辨出关联或聚合关系的区别的。</p>

<p><strong>组合关系</strong>，是比聚合关系更强的关系关系。当聚合关系中的整体需要负责个体的生命周期时，就变成了组合关系。例如公司与部门的关系，当公司不存在时，部门也不存在了。</p>

<p><strong>依赖关系</strong>，当A中有个局域变量、方法的参数是B，或者调用了B的静态方法，就是A依赖于B。</p>

<p>下面这张图演示了各种关系：</p>

<p><img src="http://blog.ubone.com/myresource/images/img_blog_20140723.jpg" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式系统的基础知识]]></title>
    <link href="http://blog.ubone.com/blog/2014/07/22/fen-bu-shi-xi-tong-de-ji-chu-zhi-shi/"/>
    <updated>2014-07-22T20:04:40+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/07/22/fen-bu-shi-xi-tong-de-ji-chu-zhi-shi</id>
    <content type="html"><![CDATA[<p>这是一篇学习笔记，内容为《大型网站系统与Java中间件实践》的第一章。</p>

<p>组成计算机的5要素为：输入、输出、运算器、控制器、存储器（内存、外存）。分布式系统也一样，可以分为这5个要素。因此这本书会对分布式系统中，这5个要素的变化进行说明。</p>

<!--more-->


<p>阿姆达尔定律（Amdahl&rsquo;s law）说明程序中可以并行的代码的比例，决定了你增加处理器能带来的速度提升的上限。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>S(N) = 1 / ((1 - P) + P / N)
</span><span class='line'>
</span><span class='line'>P: 可并行的程序在单核上执行时间的占比
</span><span class='line'>N: 处理器的个数
</span><span class='line'>S(N): 程序在N个处理器（总核心数）相对于单个处理器中的速度提升比。
</span><span class='line'>
</span><span class='line'>当P=0.2, S(N)的上限为1.25
</span><span class='line'>当P=0.5, S(N)的上限为2</span></code></pre></td></tr></table></div></figure>


<p>根据阿姆达尔定律，提升P非常的重要！</p>

<h2>1.多线程模式</h2>

<p>这里所说的多线程，是指单进程内的多线程。</p>

<h3>1.1互不通信的多线程模式</h3>

<p>线程之间没有交集，各自执行各自的任务和逻辑。这种模式的编程最简单，与单线程差不多。</p>

<h3>1.2基于共享容器的多线程模式</h3>

<p>例如多个线程共用一个队列。对于存储数据的容器或者对象，分为线程安全和线程不安全。</p>

<ul>
<li>如果是线程不安全的，一般可以通过加锁或者Copy On Write（COW）的方式控制并发。对于加锁的情况，如果是读多写少，可以用读写锁而不是互斥锁。</li>
<li>如果是线程安全的，就可以直接使用。</li>
</ul>


<h3>1.3通过事件协同的多线程模式</h3>

<p>某个线程需要等到某个状态或者事件发生后才能继续自己的工作，而这个状态或者事件与另一个线程有关，这时候就需要完成线程间的协调。<strong>为了防止死锁，一般要原子性地获取所需的多个锁，或者注意以相同的顺序获取多个锁。</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">//原子性地获取多个锁</span>
</span><span class='line'><span class="n">Thread</span> <span class="mi">1</span>
</span><span class='line'><span class="n">GetLocks</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">);</span> <span class="c1">//伪代码，一次性获取两个锁，不同平台支持不同。</span>
</span><span class='line'>
</span><span class='line'><span class="n">Thread</span> <span class="mi">2</span>
</span><span class='line'><span class="n">GetLocks</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//或者同样的顺序获取多个锁</span>
</span><span class='line'><span class="n">Thread</span> <span class="mi">1</span>
</span><span class='line'><span class="n">A</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
</span><span class='line'>  <span class="n">B</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
</span><span class='line'>  
</span><span class='line'><span class="n">Thread</span> <span class="mi">2</span>
</span><span class='line'><span class="n">A</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
</span><span class='line'>  <span class="n">B</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
</span><span class='line'><span class="c1">//两个线程的加锁顺序一致，如果Thread 2中的顺序反过来，则很可能造成锁死。      </span>
</span></code></pre></td></tr></table></div></figure>


<h2>2.多进程模式</h2>

<p>进程之间的内存空间是独立的，因此多进程相对会容易一些。但也正因为内存空间独立，因此数据共享就涉及序列化和反序列化。</p>

<p>对于多进程，单个进程的问题不会造成整体的不可用。</p>

<h2>3.网络基础</h2>

<h3>3.1 OSI七层模型</h3>

<p>OSI七层模型还记得？从上到下依次是：</p>

<ul>
<li>应用层：为应用程序（如Email）提供网络服务。</li>
<li>表示层：确保一个应用层发送的信息可被另一个系统的应用层读取。</li>
<li>会话层：通过传输层建立数据传输的通路。</li>
<li>传输层：定义传输数据的协议和端口。</li>
<li>网络层：在位于不同位置的网络中的两个主机系统之间提供连接和路径选择。</li>
<li>数据链路层：定义如何让格式化数据以进行传输。</li>
<li>物理层：定义物理设备标准，传输比特流。</li>
</ul>


<h3>3.2 网络IO实现方式</h3>

<ul>
<li>BIO（Blocking IO），阻塞方式，一个Socket需要一个线程来处理。</li>
<li>NIO（Nonblocking IO），基于事件驱动思想，采用Reactor模式。</li>
<li>AIO (Asynchronous IO)，异步IO，采用Proactor模式。</li>
</ul>


<p>Reactor模式和Proactor模式，后续要再研究一下。</p>

<h2>4.从单机到分布式</h2>

<h3>4.1 输入、输出设备的变化</h3>

<p>除了传统意义的人机交互输入、输出设备，分布式环境中的其它节点也可以看作是输入或输出设备。</p>

<h3>4.2 控制器的变化</h3>

<p>在单机中，控制器是CPU中的控制器。在分布式系统中，控制器是控制方式。</p>

<ol>
<li>使用硬件负载均衡</li>
<li>使用软件负载均衡，如LVS</li>
<li>通过名称服务器</li>
<li>通过规则服务器</li>
<li>Master + Worker的方式</li>
</ol>


<p>前面两种一般称为透明代理。有两种缺点，一是增加了流量，即代理服务器与请求处理服务器之间多了一次发送和返回。当然，LVS通过配置，可以将请求的处理结果直接返回给客户端，不通过中间代理。二是如果代理出现问题，会影响到所有请求。</p>

<p>第三、四种控制方式，都是客户端先访问名称服务器或者规则服务器，得到真正的请求处理服务器地址，然后直接与该地址进行连接。</p>

<p>第五种一般用来管理任务，由Master把任务分给不同的Worker处理。</p>

<h3>4.3 运算器的变化</h3>

<p>分布式系统中的运算器包括多个节点的计算能力。</p>

<ol>
<li>通过DNS解析，实现调度和控制</li>
<li>使用负载均衡设备或软件</li>
<li>使用Master+Worker方式</li>
<li>使用规则服务器等。</li>
</ol>


<h3>4.4 存储器的变化</h3>

<p>与前面的类似，也可以通过：</p>

<ol>
<li>直接访问存储服务器</li>
<li>通过代理服务器访问存储服务器</li>
<li>使用名称服务</li>
<li>使用规则服务</li>
<li>使用Master控制。但没有Worker了。与规则服务不同，这里的Master根据请求返回存储服务器的地址，而不是返回所有地址。</li>
</ol>


<h2>5. 分布式系统的难点</h2>

<ol>
<li>缺乏全局时钟</li>
<li>面对故障独立性。故障独立性指整个系统的一部分有问题，而其他部分正常。</li>
<li>处理单点故障。如果某个功能或角色只有一台单机在支撑，这个节点就称为单点。它发生的故障就是单点故障（SPoF, Single Point of Failure）</li>
<li>事务的挑战。即ACID和CAP。</li>
</ol>


<p>后续将研究文中提到的COW、读写锁、互斥锁，以及Reactor模式和Proactor模式。</p>
]]></content>
  </entry>
  
</feed>
