<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[码出人生]]></title>
  <link href="http://blog.ubone.com/atom.xml" rel="self"/>
  <link href="http://blog.ubone.com/"/>
  <updated>2015-01-11T20:06:47+08:00</updated>
  <id>http://blog.ubone.com/</id>
  <author>
    <name><![CDATA[梅雪松]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Titanium Alloy MVC]]></title>
    <link href="http://blog.ubone.com/blog/2015/01/11/titanium-alloy-mvc/"/>
    <updated>2015-01-11T19:25:14+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/01/11/titanium-alloy-mvc</id>
    <content type="html"><![CDATA[<p>这是一篇学习笔记，主要内容是Alloy的Controller, Model, Collection, View以及Widget.</p>

<!--more-->


<h2>1. Alloy Controllers</h2>

<p>创建Controller和获得View: Alloy.createController and Controller.getView.</p>

<p>可以继承：exports.baseController = &lsquo;baseControllerName&#8217;，子类继承父类export的方法，并可以重写。</p>

<p>可以在Controller中判断当前平台：OS_ANDROID, OS_BLACKBERRY, OS_IOS, OS_MOBILEWEB, ENV_DEV, ENV_TEST, ENV_PRODUCTION, DIST_ADHOC, DIST_STORE:</p>

<p><code>if (OS_IOS) {...}</code></p>

<p>传参：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>//index.js
var arg = {
        title: source[i].postTitle,
        url: source[i].postLink
    };
    data.push(Alloy.createController('row', arg).getView());

//row.js
var args = arguments[0] || {};
$.rowView.title = args.title || '';
$.rowView.url = args.url || '';
</code></pre>


<p>使用Alloy.Globals命名空间可以保存全局变量：<code>Alloy.Globals.xxx = ...</code></p>

<p>alloy.js运行于应用的生命周期之前，会在index.js加载之前调用，也就是任何UI加载之前。</p>

<p>lib文件夹用于类库，也可以建立平台子文件夹（如ios）。但require时，不需要指定平台名。</p>

<p>当前，Controller已经默认加载了Alloy, Underscore.js和Backbone.js，但以后可能需要自己加载：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var Alloy = require('alloy'), _ = require("alloy/underscore")._, Backbone = require("alloy/backbone");</code></pre>


<h2>2. Alloy Models</h2>

<h3>2.1 Alloy Collection and Model Objexts</h3>

<h4>2.1.1 Models</h4>

<p>In Alloy, models inherit from the <a href="http://docs.appcelerator.com/backbone/0.9.2/#Model">Backbone.Model</a> class.</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>exports.definition = {
    config : {
 // table schema and adapter information
    },
    extendModel: function(Model) {      
        _.extend(Model.prototype, {
 // Extend, override or implement Backbone.Model 
        });
 
 return Model;
    },
    extendCollection: function(Collection) {        
        _.extend(Collection.prototype, {
 // Extend, override or implement Backbone.Collection 
        });
 
 return Collection;
    }
}</code></pre>


<p>在Controller中访问Model:</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var book = Alloy.createModel('book', {title:'Green Eggs and Ham', author:'Dr. Seuss'}); 
var title = book.get('title');
var author = book.get('author');
// Label object in the view with id = 'label'
$.label.text = title + ' by ' + author;</code></pre>


<p>全局Model单例：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>// This will create a singleton if it has not been previously created,
// or retrieves the singleton if it already exists.
var book = Alloy.Models.instance('book');</code></pre>


<h5>2.1.1.1 定义表结构</h5>

<p>config对象有三部分：columns, defaults和adapter.</p>

<p>columns定义表结构。对应SQLite，支持以下类型：string, varchar, int, tinyint, smallint, bigint, double, float, decimal, number, date, datetime and boolean，其它未知类型将视为TEXT。</p>

<p>defaults对象用于设置默认值。</p>

<p>adapter对象定义存储接口。</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>exports.definition = {
    config: {
 "columns": {
 "title": "String",
 "author": "String",
 "book_id": "INTEGER PRIMARY KEY AUTOINCREMENT" //自增长
        },
 "defaults": { //默认值
 "title": "-",
 "author": "-"
        },
 "adapter": { 
 "type": "sql", //存储类型SQLite
 "collection_name": "books", //表名
  "idAttribute": "book_id" //主键
        }
    }
}</code></pre>


<h5>2.1.1.2 Extending the Backbone.Model Class</h5>

<p>在extendModel中扩展方法，例如validate方法.</p>

<h4>2.1.2 Collections</h4>

<p>在Controller中创建Collection，作用域为本Controller:</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var library = Alloy.createCollection('book'); 
library.fetch(); // Grab data from persistent storage </code></pre>


<p>创建全局单例Collection:</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>// This will create a singleton if it has not been previously created,
// or retrieves the singleton if it already exists.
var library = Alloy.Collections.instance('book');</code></pre>


<p>在extendCollection中定义扩展Backbone的方法，例如：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>// Implement the comparator method.
comparator : function(book) {
    return book.get('title');
}</code></pre>


<p></p>

<p>Backbone.Collection继承了underscore的一些集合操作方法，例如迭代：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var data = [];
library.map(function(book) {
 // The book argument is an individual model object in the collection
    var title = book.get('title');
    var row = Ti.UI.createTableViewRow({"title":title});
    data.push(row);
});
// TableView object in the view with id = 'table'
$.table.setData(data);</code></pre>


<p>事件处理：use the Backbone.Events on, off and trigger methods</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var library = Alloy.createCollection('book');
function event_callback (context) {
    var output = context || 'change is bad.';
    Ti.API.info(output);
};
// Bind the callback to the change event of the collection.
library.on('change', event_callback);
// Trigger the change event and pass context to the handler.
library.trigger('change', 'change is good.');
// Passing no parameters to the off method unbinds all event callbacks to the object.
library.off();
// This trigger does not have a response.
library.trigger('change');</code></pre>


<p>注意：如果事件名称不要使用空格。因为Backbone使用了空格来处理多事件。</p>

<h3>2.2 Alloy Data Binding</h3>

<p>当Collection或Model变化时，View也跟随变化，这就是绑定.</p>

<p><strong>注意：如果使用绑定，必须在controller关闭时，调用<code>$.destroy()</code>方法，以避免内存泄露:</strong></p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>$.win.addEventListener("close", function(){
    $.destroy();
} </code></pre>


<h4>2.2.1 Collection-View Binding</h4>

<p>以下View对象支持Collection绑定：</p>

<table>
<thead>
<tr>
<th>View Object </th>
<th> Add data binding attributes to&hellip; </th>
<th> Repeater Object</th>
</tr>
</thead>
<tbody>
<tr>
<td>ButtonBar </td>
<td> <code>&lt;Labels&gt;</code> </td>
<td> <code>&lt;Label/&gt;</code></td>
</tr>
<tr>
<td>CoverFlowView </td>
<td> <code>&lt;Images&gt;</code> </td>
<td> <code>&lt;Image/&gt;</code></td>
</tr>
<tr>
<td>ListView </td>
<td> <code>&lt;ListSection&gt;</code> </td>
<td> <code>&lt;ListItem/&gt;</code></td>
</tr>
<tr>
<td>Map Module </td>
<td> <code>&lt;Module module="ti.map" method="createView"&gt;</code>  </td>
<td> <code>&lt;Annotation/&gt;</code></td>
</tr>
<tr>
<td>Picker </td>
<td> <code>&lt;PickerColumn&gt;</code> or <code>&lt;Column&gt;</code> </td>
<td> <code>&lt;PickerRow/&gt;</code> or <code>&lt;Row/&gt;</code></td>
</tr>
<tr>
<td>ScrollableView </td>
<td> <code>&lt;ScrollableView&gt;</code> </td>
<td> <code>&lt;View/&gt;</code></td>
</tr>
<tr>
<td>TableView </td>
<td> <code>&lt;TableView&gt;</code> </td>
<td> <code>&lt;TableViewRow/&gt;</code></td>
</tr>
<tr>
<td>TabbedBar </td>
<td> <code>&lt;Labels&gt;</code> </td>
<td> <code>&lt;Label/&gt;</code></td>
</tr>
<tr>
<td>Toolbar </td>
<td> <code>&lt;Items&gt;</code> </td>
<td> <code>&lt;Item/&gt;</code></td>
</tr>
<tr>
<td>View </td>
<td> <code>&lt;View&gt;</code> </td>
<td> 除了Window和TabGroup之外的View对象</td>
</tr>
</tbody>
</table>


<p>在XML中定义以下元素，其中只有dataCollection是必须的：</p>

<ul>
<li>dataCollection: 指定一个Collection</li>
<li>dataTransform: 回调方法，传入model，返回修改的JSON对象</li>
<li>dataFilter: 过滤collection, 传入collection, 返回model数组</li>
<li>dataFunction: 指定一个方法名，controller使用这个方法来更新view。这个方法不是controller中声明的方法。该属性创建一个别名访问内在的绑定方法。（<a href="http://docs.appcelerator.com/titanium/latest/#!/guide/Alloy_Data_Binding-section-36739592_AlloyDataBinding-BackboneBinding">没搞懂</a>）</li>
</ul>


<p>对于Collection中的model，xml中可以使用<code>{}</code>来获取model的值，例如：<code>&lt;Label text="{title} by {author}" /&gt;</code>。</p>

<p>在repeater对象的controller中，可以使用<code>$model</code>来引用当前model。如<code>$model.title</code></p>

<p>Collection绑定示例：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>app/views/index.xml
&lt;Alloy&gt;
    &lt;Collection src="book"/&gt;
    &lt;Window backgroundColor="white" onClose="cleanup"&gt;
        &lt;ScrollableView dataCollection="book"&gt;
            &lt;View layout="vertical"&gt;
                &lt;ImageView image="{cover}" /&gt;
                &lt;Label text="{title} by {artist}" /&gt;
            &lt;/View&gt;
        &lt;/ScrollableView&gt; 
    &lt;/Window&gt;
&lt;/Alloy&gt;

app/controllers/index.js
$.index.open();
Alloy.Collections.album.fetch();
 
function cleanup() {
    $.destroy();
}
</code></pre>


<h4>2.2.2 Model-View Binding</h4>

<pre class='line-numbers language-javascript'><code class='language-javascript'>&lt;Alloy&gt;
    &lt;Model src="settings"/&gt;
    &lt;Window backgroundColor="white" onClose="cleanup"&gt;
        &lt;View layout="vertical"&gt;
            &lt;Label text="Text Size" /&gt;
            &lt;Slider value="{settings.textsize}" max="5" min="1"/&gt;
            &lt;Label text="Bold"/&gt;
            &lt;Switch value="{settings.bold}" /&gt;
            &lt;Label text="Italics"/&gt;
            &lt;Switch value="{settings.italics}" /&gt;
        &lt;/View&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt;</code></pre>


<p>上例中，获取值使用的格式为：<code>{modelName.attrName}</code></p>

<h4>2.2.3 Collection方法示例</h4>

<pre class='line-numbers language-javascript'><code class='language-javascript'>app/views/index.xml
&lt;Alloy&gt;
    &lt;Collection src="book" /&gt;
    &lt;Window class="container"&gt;
        &lt;TableView dataCollection="book"
                   dataTransform="transformFunction"
                   dataFilter="filterFunction"
                   dataFunction="updateUI"
                   onDragEnd="refreshTable"&gt;
            &lt;!-- Also can use Require --&gt;
            &lt;TableViewRow title="{title}" /&gt;
        &lt;/TableView&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt;

app/controllers/index.js
$.index.open();
 
// Encase the title attribute in square brackets
function transformFunction(model) {
 // Need to convert the model to a JSON object
    var transform = model.toJSON();
    transform.title = '[' + transform.title + ']';
 // Example of creating a custom attribute, reference in the view using {custom}
    transform.custom = transform.title + " by " + transform.author;
 return transform;
}
// Show only book models by Mark Twain
function filterFunction(collection) {
 return collection.where({author:'Mark Twain'});
}
 
function refreshTable(){
 // Trigger the binding function identified by the dataFunction attribute
    updateUI();
}
// Trigger the synchronization
var library = Alloy.Collections.book;
library.fetch();
 
// Free model-view data binding resources when this view-controller closes
$.index.addEventListener('close', function() {
    $.destroy();
});</code></pre>


<p>当数据变化时，上面的例子中的界面会跟着变化。如果想避免发生变化，可以在调用Backbone方法修改model数据时指定参数：<code>{silent:true}</code>.</p>

<h3>2.3 Alloy数据持久化与升级</h3>

<p>Model数据可以同步到本地或远程服务器。这项功能使用的是Backbone sync方法。</p>

<h4>2.3.1 Backbone同步方式</h4>

<p>Backbone sync时，默认会执行RESTful JSON请求到Model.urlRoot或者Collection.url。读操作使用GET方法，写操作使用POST方法。不论Model是否定义了自己的主键，Backbone都会创建Client ID(cid)。在未保存前，可以使用Model.cid或者Collection.getByCid方法来存取数据。Backbone同步示例：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>// Since the urlRoot attribute is defined, all HTTP commands are to /library
var Book = Backbone.Model.extend({urlRoot:'/library'})
var book = new Book();
 
// Performs a POST on /library with the arguments as a payload and the server returns the id as 1
book.save({title:'Bossypants',author:'Tina Fey',checkout:false}) 
 
// Performs a GET on /library/1
book.fetch({id:1}); 
 
// Performs a PUT on /library/1 with the entire modified object as a payload.
book.save({checkout:true});
 
// Performs a DELETE on /library/1
book.destroy();</code></pre>


<h4>2.3.2Alloy的同步方式</h4>

<p>Alloy支持SQLite或者properties来保存数据。Alloy查询SQLite时，可以使用简单查询或者prepared statement:</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var library = Alloy.createCollection('book');
// The table name is the same as the collection_name value from the 'config.adapter' object. This may be different from the model name.
var table = library.config.adapter.collection_name;
// use a simple query
library.fetch({query:'SELECT * from ' + table + ' where author="' + searchAuthor + '"'});
// or a prepared statement
library.fetch({query: { statement: 'SELECT * from ' + table + ' where author = ?', params: [searchAuthor] }});

//查询1条记录：
myModel.fetch({id: 123});
// is equivalent to
myModel.fetch({query: 'select * from ... where id = ' + 123 });</code></pre>


<h4>2.3.3 数据库迁移（升级或降级）</h4>

<p>Alloy采用migration对象来迁移数据库。首先，要将相应的JavaScript文件放在app/migrations文件夹下。文件名采用以下格式：<code>YYYYMMDDHHmmss_MODELNAME.js</code>，例如20150120160155_book.js。Alloy将升序执行js文件以完成数据库迁移。</p>

<p>JavaScript文件中要实现两个方法：migration.up(migrator) 和 migration.down(migrator)。migrator对象的值如下：</p>

<table>
<thead>
<tr>
<th>Key </th>
<th> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>db </td>
<td> Ti.Database实例，可以调用db.execute方法执行SQL。<strong>注意不要关闭或打开另一个实例。</strong></td>
</tr>
<tr>
<td>dbname </td>
<td> 数据库名</td>
</tr>
<tr>
<td>table </td>
<td> table名，也就是Model的config.adapter.collection_name值</td>
</tr>
<tr>
<td>idAttribute </td>
<td> 主键字段名</td>
</tr>
<tr>
<td>createTable </td>
<td> 创建表的方法，参数为Model config.columns</td>
</tr>
<tr>
<td>dropTable </td>
<td> 删除表</td>
</tr>
<tr>
<td>insertRow </td>
<td> 插入行, 参数为待插入的数据对象</td>
</tr>
<tr>
<td>deleteRow </td>
<td> 删除行，参数为待删除的数据对象</td>
</tr>
</tbody>
</table>


<p>下面的示例先创建表将初始数据，之后进行了升级:</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>app/migrations/20120610049877_book.js
var preload_data = [
    {title: 'To Kill a Mockingbird', author:'Harper Lee'}
];
 
migration.up = function(migrator)
{
    migrator.createTable({
 "columns":
        {
 "book": "TEXT",
 "author": "TEXT"
        }
    });
 for (var i = 0; i &lt; preload_data.length; i++) { 
        migrator.insertRow(preload_data[i]);
    }
};
 
migration.down = function(migrator)
{
    migrator.dropTable();
};

//升级app/migrations/20130118069778_book.js
migration.up = function(migrator) {
    migrator.db.execute('ALTER TABLE ' + migrator.table + ' ADD COLUMN isbn INT;');
};
migration.down = function(migrator) {
    var db = migrator.db;
    var table = migrator.table;
    db.execute('CREATE TEMPORARY TABLE book_backup(title,author,alloy_id);')
    db.execute('INSERT INTO book_backup SELECT title,author,alloy_id FROM ' + table + ';');
    migrator.dropTable();
    migrator.createTable({
        columns: {
            title:"TEXT",
            author:"TEXT",
        },
    });
    db.execute('INSERT INTO ' + table + ' SELECT title,author,alloy_id FROM book_backup;');
    db.execute('DROP TABLE book_backup;');
};</code></pre>


<h2>3. Alloy Widgets</h2>

<p>在Alloy XML Markup中已经介绍了如何使用Widgets，这里主要介绍如何创建Widgets。</p>

<p>Widgets应放在app/Widgets文件夹下，与app文件夹一相，每个Widget也有自己的views, controllers, models, styles and assets等。在Widget中不能访问除了i18n之外的文件。其它主要区别如下：</p>

<ul>
<li>使用WPATH()来自动处理assets和libs的路径总是。例如要在Widget中require <code>app/widgets/foo/lib/helper.js</code>，可以<code>require(WPATH('helper'))</code>。对于<code>app/widgets/foo/assets/images/foo.png</code>使用<code>WPATH('images/foo.png')</code>。</li>
<li>Widgets使用自己的配置文件widget.json</li>
<li>Widgets的主controller是widget.js，而不是index.js。创建widget内的另一个controller需要使用Widget.createController方法。</li>
<li>所有Widget控制器中的方法均为私有方法，除非使用$，例如<code>$.init=function(){...}</code>，然后就可以在项目中调用：<code>$.fooWidget.init()</code>.</li>
<li>Widget中也可以创建Model和Collection, 但要使用Widget.createModel和Widget.createCollection方法。</li>
<li>样式文件为widget.tss</li>
<li>Widget同样可以有Theme, 相关样式和资源要放到：<code>app/themes/&lt;THEME_NAME&gt;/&lt;WIDGET_NAME&gt;</code>。</li>
<li>Widget的主View是widget.xml而不是index.xml。当Widget中的某个view指定了id(eg. buttonId)时，在项目中可以这样引用：<code>$.fooWidget.buttonId.xxx</code></li>
<li>Widget可以包含其它Widget。需要在widget.json中定义依赖。在controller中可以调用：<code>Widget.createWidget(widget_name, [controller_name])</code></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Titanium Alloy基础]]></title>
    <link href="http://blog.ubone.com/blog/2015/01/10/titaniumxue-xi-bi-ji/"/>
    <updated>2015-01-10T20:32:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/01/10/titaniumxue-xi-bi-ji</id>
    <content type="html"><![CDATA[<p>这是一篇学习笔记，主要内容是Alloy的基础概念。</p>

<!--more-->


<h2>1. Alloy框架</h2>

<h3>1.1 Alloy相关概念</h3>

<p><strong>Alloy models</strong> are built on top of <a href="http://backbonejs.org/">Backbone.js</a>, taking advantage of Backbone&rsquo;s rich Model and Collection APIs.</p>

<p><strong>Alloy views</strong> are built from Titanium UI components.</p>

<p><strong>Alloy controllers</strong> generally have a one-to-one relationship with Alloy views.</p>

<p>Additionally, Alloy provides built-in support for <a href="http://underscorejs.org/">Underscore.js</a>, which provides a set of utility functions, such as array and iterative helpers.</p>

<p>资源文件放于app/assets/android or app/assets/iphone folder.</p>

<p>Titanium代码与Alloy XML:</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var button = Titanium.UI.createButton({
    text: "Foobar",
    top: 0,
    width: Ti.UI.SIZE
});

button.addEventListener('click', doClick);</code></pre>


<p>等价于：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>&lt;Button title="Foobar" top="0" width="Ti.UI.SIZE"  onClick="doClick"/&gt;</code></pre>


<p>Alloy项目文件夹：</p>

<table>
<thead>
<tr>
<th>文件夹</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>app </td>
<td> Contains the models, views, controllers and assets of the application. All work should be done here. See folder descriptions below.</td>
</tr>
<tr>
<td><code>app/alloy.jmk</code> </td>
<td> Build configuration file.</td>
</tr>
<tr>
<td><code>app/alloy.js</code> </td>
<td> Initializer file used to preconfigure components or override Alloy methods before the main controller is executed. </td>
</tr>
<tr>
<td><code>app/config.json</code> </td>
<td> Project configuration file.</td>
</tr>
<tr>
<td><code>app/assets</code> </td>
<td> Contains image assets and other files that need to be copied into the Resources directory. Reference these files in the code without the &lsquo;app/assets&rsquo; path and without the platform-specific if it is inside one.</td>
</tr>
<tr>
<td><code>app/controllers</code> </td>
<td> Contains controllers in the format filename.js to a corresponding view file <code>app/views/filename.xml</code>.</td>
</tr>
<tr>
<td><code>app/lib</code> </td>
<td> Contains application-specific library code, typically in the CommonJS format.</td>
</tr>
<tr>
<td>app/migrations </td>
<td> Contains database migration files in the format <code>&lt;DATETIME&gt;_filename.js</code>.</td>
</tr>
<tr>
<td><code>app/models</code> </td>
<td> Contains model files in the format filename.js.</td>
</tr>
<tr>
<td><code>app/styles</code> </td>
<td> Contains view styling in the format filename.tss, which is applied to a corresponding view file <code>app/views/filename.xml</code>.</td>
</tr>
<tr>
<td><code>app/themes</code> </td>
<td> Contains themes to customize the assets and styles of the entire GUI.</td>
</tr>
<tr>
<td><code>app/views</code> </td>
<td> Contains views in the format filename.xml with the optional corresponding files <code>app/controllers/filename.js</code> and <code>app/styles/filename.tss</code>.</td>
</tr>
<tr>
<td><code>app/widgets</code> </td>
<td> Contains widget files. Each widget will have its own app-like directory structure.</td>
</tr>
<tr>
<td>i18n </td>
<td> Contains internationalization and localization files. Same usage as with a Titanium application.</td>
</tr>
<tr>
<td>Resources </td>
<td> Contains the Titanium files generated by the Alloy interface from the app directory. All files will be overwritten each time the application is built. Since Alloy 1.3.0, Alloy creates a separate Titanium project for each platform you build for in the <code>Resources/&lt;platform&gt;</code> folder.</td>
</tr>
</tbody>
</table>


<p><strong>Widgets</strong> are self-contained components that can be easily dropped into Alloy-powered Titanium projects.</p>

<p>Alloy comes with additional utilities used to simplify certain functions, such as animations, string manipulation, and display unit conversion. These utilities are referred to as &lsquo;<strong>builtins</strong>.&rsquo;</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var animation = require('alloy/animation');
$.shake.addEventListener('click', function(e) {
    animation.shake($.view);
});</code></pre>


<h3>1.2 Alloy Views</h3>

<h4>1.2.1 XML Markup</h4>

<pre class='line-numbers language-javascript'><code class='language-javascript'>//app/views/index.xml
&lt;Alloy&gt;
    &lt;Window class="container"&gt;
        &lt;Label id="labelId" onClick="doClick"&gt;Hello, World&lt;/Label&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt;</code></pre>


<p>可以使用<code>$.labelId</code>引用上面的label，对于根视图可以使用<code>$.index</code>（文件名）。</p>

<p>XML中可以使用的属性：</p>

<table>
<thead>
<tr>
<th>属性名 </th>
<th> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>id </td>
<td> Identifies UI elements in the controller (prefixed with &lsquo;$.&rsquo;) and style sheet (prefixed with &lsquo;#&rsquo;).</td>
</tr>
<tr>
<td>class </td>
<td> Applies additional styles (prefixed with &lsquo;.&rsquo; in the TSS file)</td>
</tr>
<tr>
<td>autoStyle </td>
<td> 是否动态样式，当class动态变化时，控件样式动态变化。对性能有影响</td>
</tr>
<tr>
<td>formFactor </td>
<td> handheld or tablet</td>
</tr>
<tr>
<td>if </td>
<td> 使用条件表达式。See <a href="http://docs.appcelerator.com/titanium/latest/#!/guide/Alloy_XML_Markup-section-35621528_AlloyXMLMarkup-ConditionalCode">Conditional Code</a> and <a href="http://docs.appcelerator.com/titanium/latest/#!/guide/Alloy_Styles_and_Themes-section-35621526_AlloyStylesandThemes-CustomQueryStyles">Alloy Styles and Themes: Custom Query Styles</a> for more details.</td>
</tr>
<tr>
<td>module </td>
<td> Requires in a CommonJS module </td>
</tr>
<tr>
<td>ns </td>
<td> Overrides the default Titanium.UI namespace. See Namespace for more details.</td>
</tr>
<tr>
<td>platform </td>
<td> android, blackberry, ios, or mobileweb。如果多个可以使用逗号分隔。</td>
</tr>
</tbody>
</table>


<p>除了上述属性，各组件还可以包括自己特有的属性和事件。另外还有一些特殊的元素：</p>

<table>
<thead>
<tr>
<th>Element </th>
<th> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alloy </td>
<td>Root element for all view XML files. Required in all views.</td>
</tr>
<tr>
<td>Collection </td>
<td> Creates a singleton or instance of the specified collection. </td>
</tr>
<tr>
<td>Model </td>
<td> Creates a singleton or instance of the specified model. </td>
</tr>
<tr>
<td>Module </td>
<td> Imports a module view inside this view (since Alloy 1.2.0). </td>
</tr>
<tr>
<td>Require </td>
<td> Imports a widget or includes another view inside this view. </td>
</tr>
<tr>
<td>Widget </td>
<td> Imports a widget inside this view. Same as the Require Element with the type specified to &lsquo;widget&rsquo;. </td>
</tr>
</tbody>
</table>


<p>index.xml是一个特殊情况，只接受以下根节点：</p>

<ul>
<li>Ti.UI.Window or <code>&lt;Window&gt;</code></li>
<li>Ti.UI.TabGroup or <code>&lt;TabGroup&gt;</code></li>
<li>Ti.UI.iOS.NavigationWindow or <code>&lt;NavigationWindow&gt;</code></li>
<li>Ti.UI.iPad.SplitWindow or <code>&lt;SplitWindow&gt;</code></li>
</ul>


<p><strong>XML中的Collection节点</strong></p>

<p>The Collection XML element creates a singleton or instance of a collection.</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>&lt;Alloy&gt;
    &lt;Collection src="book" /&gt;
    &lt;Window&gt;
        &lt;TableView id="table" /&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt;</code></pre>


<p>上面的代码创建了一个单例集合，对应的model为book.js。在controller中可以这样访问：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var library = Alloy.Collections.book;
library.fetch();</code></pre>


<p>上面的例子 Alloy.Collections.book是全局的，但也可以创建只用于一个Controller的Collection：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>&lt;Alloy&gt;
    &lt;Collection id="localLibrary" src="book" instance="true"/&gt;
    &lt;Window&gt;
        &lt;TableView id="table" /&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt;</code></pre>


<p>注意上面的src和instance。在代码中通过id来引用：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>var library = $.localLibrary;
library.fetch();</code></pre>


<p><strong>Model Element</strong>
与Collection类似，XML中也可以创建Model单例，或者用于某个Controller的一个实例。</p>

<p>单例：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>&lt;Alloy&gt;
    &lt;Model src="book" /&gt;
    &lt;Window&gt;
        &lt;TableView id="table" /&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt;

var drama = Alloy.Models.book;
drama.set('title', 'Hamlet');
drama.set('author', 'William Shakespeare');</code></pre>


<p>某个Controller的实例：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>&lt;Alloy&gt;
    &lt;Model id="myBook" src="book" instance="true"/&gt;
    &lt;Window&gt;
        &lt;TableView id="table" /&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt;

var drama = $.myBook;
drama.set('title', 'Hamlet');
drama.set('author', 'William Shakespeare');</code></pre>


<p>注意前述的Collection和Model都要放在Alloy节点下。</p>

<p><strong>Module Attribute</strong>
XML中可以引入CommonJS module。首先，module要放入<code>app/lib</code>，并且有一个public方法createXXX，返回一个UI对象。然后，将XXX用于xml节点元素，并设置module路径(基于<code>app/lib</code>)，元素的其它属性将作为参数传入createXXX方法。示例如下：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>//app/lib/foo.js
// XML attributes are passed to the function
exports.createFoo = function (args) {
    var viewArgs = {
        backgroundColor: args.color || 'white',
        width: '100dp',
        height: '100dp'
    };
    var view = Ti.UI.createView(viewArgs);
    var labelArgs = {
        color: args.textColor || 'black',
        text: args.text || 'Foobar' 
    };
    var label = Ti.UI.createLabel(labelArgs);
    view.add(label);
 // Return a UI object that can be added to a view
 return view;
}; 

//app/views/index.xml
&lt;Alloy&gt;
    &lt;Window backgroundColor="white"&gt;
        &lt;!-- Requires in the lib/foo.js module and calls the createFoo method --&gt;
        &lt;Foo module="foo" color="blue" textColor="orange" text="Hello, World!"/&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt;</code></pre>


<p>对于Native开发的Module，也可以引入XML中，分为5步：</p>

<ol>
<li>将module引入项目</li>
<li>在XML中的View或Window的下级加入Module</li>
<li>设置属性module为module名称</li>
<li>设置属性method为创建方法名称，如果没设置则默认为createView</li>
<li>如果方法参数只需要一个简单的Javascript对象，则可以将值inline写入或者使用TSS文件。</li>
</ol>


<p>Paint Module的示例如下：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>&lt;Alloy&gt;
    &lt;Window&gt;
        &lt;Module id="paint" module="ti.paint" method="createPaintView"
            eraseMode="false" strokeWidth="1.0" strokeColor="red" strokeAlpha="100" /&gt;
        &lt;Button onClick="eraseMe" bottom="0"&gt;Erase&lt;/Button&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt;

function eraseMe(){
    $.paint.clear();
}</code></pre>


<p><strong>Require Element</strong>
require元素主要有两个用途：including external views and importing widgets into the current view.</p>

<p>including external views示例：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>//index.xml
&lt;Alloy&gt;
    &lt;TabGroup&gt;
        &lt;Tab id="leftTab"&gt;
            &lt;Require type="view" src="rss" id="rssTab"/&gt;
        &lt;/Tab&gt;
    &lt;/TabGroup&gt;
&lt;/Alloy&gt;

//rss.xml
&lt;Alloy&gt;
    &lt;Window id='rssWindow'&gt;
        &lt;WebView id='rssView' /&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt; 

var rssView = $.rssTab.getView('rssView'); 
rssView.url = 'http://www.google.com'; </code></pre>


<p><strong>Importing Widgets，</strong>引入Widgets只需要三步：</p>

<ol>
<li>将Widget放入app/widgets文件夹</li>
<li>在config.json中添加依赖</li>
<li>在XML中加入<code>&lt;Widget&gt;</code>，可以设置id和name属性。id属性用于引用并调用方法，name属性用于指定view对应的Controller，而不是使用默认的widget.js。</li>
</ol>


<pre class='line-numbers language-javascript'><code class='language-javascript'>app/views/index.xml
&lt;Alloy&gt;
    &lt;Window&gt;
        &lt;Widget src="mywidget" id="foo" name="foo" /&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt;

$.foo.myMethod();</code></pre>


<p>config.json中的依赖：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'> "dependencies": {
    "mywidget":"1.0"
  }</code></pre>


<p></p>

<p>可以直接在XML中设置属性，用于传参。与代码具有等同效果：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>&lt;Require id="foobar" src="foo" customTitle="Hello" customImage="hello.png"/&gt; 

var foobar = Alloy.createController('foo', { 
    id: "foobar", 
    customTitle: "Hello", 
    customImage: "hello.png" 
});</code></pre>


<p>对于required view，可以<strong>绑定事件</strong>。下面的例子中，parent视图引入了button视图，并绑定了回调方法：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>//Parent View:
&lt;Require id="fooButton" src="button" onClick="doClick" /&gt; 

function doClick(e) {...}

//Button View:
&lt;Alloy&gt;
    &lt;Button id="button"&gt;Click Me!&lt;/Button&gt;
&lt;/Alloy&gt;

//在子视图中trigger click事件
$.button.addEventListener('click', function(e) { 
    $.trigger('click', e); 
}); </code></pre>


<p><strong>Adding Children Views。</strong>用于将parent view中的数据传给required view。下面的例子实现了这样一个场景：index.xml require info.xml，index.xml可以将子元素传给info.xml展示，info.js可以通过<code>arguments[0].children</code>访问这些子元素。</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>//app/views/info.xml
&lt;Alloy&gt;
    &lt;View backgroundColor="yellow" borderWidth="0.5" borderColor="brown"/&gt;
&lt;/Alloy&gt;

//controllers/info.js
var args = arguments[0] || {};
// add children if there are any
_.each(args.children || [], function(child) {
    $.info.add(child);
});
$.info.height = Ti.UI.SIZE; 

//app/views/index.xml
&lt;Alloy&gt;
    &lt;Window class="container"&gt;
        &lt;Require src="info"&gt;
            &lt;Label&gt;I am an info box.&lt;/Label&gt;
        &lt;/Require&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt;</code></pre>


<p><strong>Namespace</strong></p>

<p>XML中的控件默认为Titanium.UI，如果组件不是这个命名空间，可以设置ns属性：</p>

<p><code>&lt;View ns="Ti.Map" id="map"/&gt;</code></p>

<h4>1.2.2 Alloy Styles and Themes</h4>

<h5>Titanium Style Sheets (TSS)</h5>

<p>Titanium Style Sheets (TSS) file uses a JSON-like syntax. the class name prefixed with a period (.), or the id name prefixed with a hash tag (#) 。也可以使用条件表达式。值可以是以下类型：</p>

<ul>
<li>JSON values, that is, Strings, Numbers, Objects, Array, Booleans and null</li>
<li>undefined to unset a property (do not place undefined in quotes) (since Alloy 1.4.0)</li>
<li>Titanium SDK constants, for example, Ti.UI.SIZE</li>
<li>Localization functions, either Ti.Locale.getString() and its shorthand L()</li>
<li>Variables from the Alloy.CFG or Alloy.Globals namespaces</li>
<li>Bitwise operators, which includes bit shifting (&lsquo;>>&rsquo;, &lsquo;&lt;&lt;&rsquo;, and &lsquo;>>>&rsquo;), bitwise AND (&lsquo;&amp;&rsquo;), bitwise OR (&lsquo;|&rsquo;) and bitwise XOR (&lsquo;^&rsquo;) (since Alloy 1.3.0)</li>
</ul>


<p>注释方法： //comment and multiline comments <code>/* comment */</code></p>

<p>Alloy不支持：Alloy does not support the CSS concept of child or descendent selectors</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>// 如果不使用.和#，这表示适用于所有Lable
"Label": {
    width: Ti.UI.SIZE,
    height: Ti.UI.SIZE,
    color: "#000", // black
    transform: Alloy.Globals.rotateLeft // value is defined in the alloy.js file      
},</code></pre>


<p>注意上面的transform使用了全局方法：<code>Alloy.Globals.rotateLeft = Ti.UI.create2DMatrix().rotate(-90);</code></p>

<p>app.tss中定义的是全局样式。样式的优先权：XML中输入的 <code>&gt;</code> 当前View对应的TSS <code>&gt;</code> 全局样式。</p>

<p>样式可以加平台条件，用中括号，注意中括号和平台代码间<strong>不要用空格！</strong>:</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>// iPad and iPad mini
"Label[platform=ios formFactor=tablet]": { 
    backgroundColor: "#0f0",
    text: 'iPad'
},

还可以： 
[platform=ios,android] //android, blackberry, ios, or mobileweb
[platform=!ios]
</code></pre>


<p><strong>Custom Query Styles</strong>
Custom query styles override all styles, that is, class, id, and markup element styles, except the ones defined as attributes in the XML file.</p>

<ol>
<li>使用Alloy.Globals定义一个返回boolean的方法，或者通过Alloy.createController中传入boolean属性，然后在xml或tss文件中使用。</li>
<li>在xml和tss中使用if属性。</li>
</ol>


<pre class='line-numbers language-javascript'><code class='language-javascript'>apps/controllers/index.js
function openBar (e) {
    Alloy.createController('win2', {'fooBar': true}).getView().open();
};

app/styles/win2.tss
"#label[if=$.args.fooBar]" : {
 'text' : 'Foobar',
 'color' : 'blue'
}

app/views/win2.xml
&lt;Alloy&gt;
    &lt;Window&gt;
        &lt;Label if="$.args.fooBar" color="blue"&gt;Foobar&lt;/Label&gt;
    &lt;/Window&gt;
&lt;/Alloy&gt;</code></pre>


<p>另一个例子：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>Alloy.Globals.isIos7Plus = (OS_IOS && parseInt(Ti.Platform.version.split(".")[0]) &gt;= 7);

//index.tss
// Query styles
"#info[if=Alloy.Globals.isIos7Plus]" : {
    font : { textStyle : Ti.UI.TEXT_STYLE_FOOTNOTE }
},</code></pre>


<h5>Themes</h5>

<p>使用Theme的方法。首先在app下建立themes文件夹，并在其下级以各主题名建立子文件夹，如:app-themes-mytheme, 在mytheme下分别建立assets(放图片资源)和styles(放tss文件，还可以再包含平台子文件夹)。在config.json设置当前主题：</p>

<pre class='line-numbers language-javascript'><code class='language-javascript'>{
 "global": {
 "theme":"mytheme"
    }, 
 "env:development": {}, 
 "env:test": {}, 
 "env:production": {}, 
 "os:ios": {
 "theme":"green"
    }, 
 "os:android": {
 "theme":"blue"
    }, 
 "dependencies": {}
}</code></pre>


<p>打包时，主题下的assets资源和样式将覆盖app下的资源与样式。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM监控与故障处理工具]]></title>
    <link href="http://blog.ubone.com/blog/2015/01/04/jvmjian-kong-yu-gu-zhang-chu-li-gong-ju/"/>
    <updated>2015-01-04T21:42:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2015/01/04/jvmjian-kong-yu-gu-zhang-chu-li-gong-ju</id>
    <content type="html"><![CDATA[<p>本文介绍常用的Java虚拟机性能监控与故障处理工具。</p>

<!--more-->


<h2>1. JDK命令行工具</h2>

<h3>1.1 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jps.html">jps</a></h3>

<p>与Unix下的ps命令相似，可以列出正在运行的虚拟机进程并显示主类（main()函数所在类）类名以及LVMID(Local Virtual Machine Identifier)。LVMID与PID是一致的。命令格式：</p>

<p><code>jps [options] [hostid]</code></p>

<table>
<thead>
<tr>
<th>选项 </th>
<th> 用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>-q </td>
<td> 只输出LVMID</td>
</tr>
<tr>
<td>-m </td>
<td> 输出JVM启动时传递给主类main()函数的参数</td>
</tr>
<tr>
<td>-l </td>
<td> 输出主类全名</td>
</tr>
<tr>
<td>-v </td>
<td> 输出JVM启动时的JVM参数</td>
</tr>
</tbody>
</table>


<h3>1.2 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html">jstat</a>，虚拟机统计信息监视工具</h3>

<p>在<a href="http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>中已经有描述。</p>

<h3>1.3 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jinfo.html">jinfo</a>, Java配置信息工具</h3>

<p>用于实时查看和调整虚拟机各项参数。</p>

<h3>1.4 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jmap.html">jmap</a>, Java内存映像工具</h3>

<p>在<a href="http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>中已经有描述。</p>

<h3>1.5 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jhat.html">jhat</a>， 堆转储快照分析工具</h3>

<p>用于分析堆转储快照，内置一个微型HTTP服务器，分析结果后可在浏览器中查看。但这个工具并不常用。</p>

<h3>1.6 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstack.html">jstack</a>, Java堆栈跟踪工具</h3>

<p>用于生成虚拟机当前时刻的线程快照（threaddump），即当前每一条线程正在执行的方法堆栈集合。主要目的是定位线程出现长时间停顿的原因，如死锁、死循环、请求外部资源等。</p>

<p>当线程出现停顿时，通过jstack查看各线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么。</p>

<table>
<thead>
<tr>
<th>选项 </th>
<th> 用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>-F </td>
<td> 当正常输出的请求不被响应时，强制输出线程堆栈</td>
</tr>
<tr>
<td>-l </td>
<td> 除堆栈外，显示关于锁的附加信息</td>
</tr>
<tr>
<td>-m </td>
<td> 如果调用本地方法的话，显示C/C++堆栈</td>
</tr>
</tbody>
</table>


<h2>2. JDK的可视化工具</h2>

<h3>2.1 JConsole</h3>

<p>基于JMX的可视化监视、管理工具。直接通过集令后运行jconsol。</p>

<h3>2.2 <a href="http://visualvm.java.net/">VisualVM</a>，多合一故障处理工具</h3>

<p>VisualVM Is Designed For You:</p>

<ul>
<li><strong>Application Developer</strong>: Monitor, profile, take thread dumps, browse heap dumps</li>
<li><strong>System Administrator</strong>: Monitor and control Java applications across the entire network</li>
<li><strong>Java Application User</strong>: Create bug reports containing all the necessary information</li>
</ul>


<p>在命令行执行<code>jvisualvm</code>即可</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java垃圾收集与内存分配]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/26/la-ji-shou-ji-qi-yu-nei-cun-fen-pei-ce-lue/"/>
    <updated>2014-12-26T20:20:12+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/26/la-ji-shou-ji-qi-yu-nei-cun-fen-pei-ce-lue</id>
    <content type="html"><![CDATA[<p>在<a href="http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>中，了解了Java的内存管理和垃圾收集。本文再深入学习垃圾收集算法和HotSpot中垃圾收集的实现。</p>

<!--more-->


<h2>1. 什么是垃圾</h2>

<p>Java并没有使用引用计数法来识别对象是否为垃圾，而是采用可达性分析（Reachability Analysis）判断对象是否存活。其基本思路就是通过GC Roots对象为起点，搜索其引用链，只要是通过它们可达的对象就是活对象。GC Roots对象包括以下几种：</p>

<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI(即Native方法)引用的对象</li>
</ul>


<p>而Java的引用又分为多种类型，对象是否存活也与引用类型有关：</p>

<ul>
<li>强引用：普通引用都是强引用，只要强引用还存在，对象就不会被回收。</li>
<li>软引用：SoftReference关联的对象是还有用，但不是必须的对象。在系统将要发生内存溢出异常之前，会把这些对象列入回收范围进行第二次回收。</li>
<li>弱引用：WeakReference与SoftReference更弱，它关联的对象只能生成到下一次垃圾收集发生之前（无论内存是否足够，都会被回收）。</li>
<li>虚引用：PhantomReference是最弱的一种引用，对生存时间完全没有影响，也无法通过虚引用来取得一个对象实例。其唯一目的就是在回收时收到一个系统通知。</li>
</ul>


<p>真正宣告一个对象的死亡，要经历至少两次标记过程。当扫描发现对象与GC Roots没有引用链，将进行第一次标记，并判断对象是否有必要执行finalize()方法（如果对象没有覆盖该方法，或者方法已经被调用过，视为没有必要执行）。如果有必要执行finalize()方法，虚拟机将该对象放入F-Queue队列，稍后自动由低优先级的Finalizer线程执行该方法。之后GC还会对F-Queue中的对象进行第二次标记，如果对象在finalize()方法中重新建立了一个有效引用，就会被移除出“即将回收”的集合，逃脱回收。</p>

<p>但注意finalize()方法是没有保障的，JVM只会触发它执行，并不保证它会运行结束。试想如果finalize()方法中有死循环，会造成整个内存回收系统崩溃。所以正如<a href="http://blog.ubone.com/blog/2014/06/27/effective-java-chuang-jian-he-xiao-hui-dui-xiang/">Effective Java-创建和销毁对象</a>中提到的，你就当Java没有finalize()方法吧!</p>

<p>方法区（通常所指的永久代）也是<strong>可以（非必须）</strong>垃圾收集的。主要回收废弃常量和无用的类。对于常量，例如“abc”已经进入常量池，但当前没有任何一个String对象是“abc”，那么这个常量可能会被清理出去。如何判断无用的类则要苛刻许多，需要同时满足以下条件：</p>

<ul>
<li>该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例。</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>


<p>方法区的对象仅仅是可以回收，并不是必然会回收。在大量使用反射、动态代理、CGLib等字节码框架、动态JSP和OSGi这类频繁自定义ClassLoader场景下，虚拟机需要具备类卸载的功能。</p>

<p>HotSpot提供了参数<code>-Xnoclassgc</code>参数控制方法区回收。在Product版JVM中还可以使用<code>-verbose:class</code>和<code>-XX:+TraceClassLoading</code>查看类加载信息。FastDebug版的JVM还支持<code>-XX:+TraceClassUnLoading</code>查看卸载信息。</p>

<h2>2. 垃圾收集算法</h2>

<p>各平台的虚拟机操作内存的方法各不相同，常见的垃圾收集算法说明如下：</p>

<h3>2.1 常见的垃圾收集算法</h3>

<h4>标记-清除算法(Mark-Sweep)</h4>

<p>这是最基础的收集算法，分为标记和清除两个阶段。首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。它有两个主要问题：一是效率不高，另一个是空间问题，会产生大量不连续的内存碎片。</p>

<h4>复制算法(Copying)</h4>

<p>复制算法的思路是将内存分为大小相等的两块，每次只使用其中一块，永远有一块是空的。当一块用完了，就将存活对象复制到另一块上，把前者内存空间一次清理掉。</p>

<p>复制算法特别适合那些短命的对象，现代虚拟机都采用这个算法来回收新生代。将内存分为较大的Eden区和两个较小的Survivor，每次使用Eden和其中一个Survivor。回收时，将Eden和Survivor存活的对象复制到另一个Survivor，最后清理掉Eden和前一个Survivor空间。HotSpot默认的Eden和Survivor比例是8：1. 如果另一个Survivor空间不足以放下存活对象，那些经历多少GC仍存活的对象会被放入老年代。</p>

<h4>标记-整理算法（Mark-Compact）</h4>

<p>对于长命的对象，复制算法的效率就变得太低。标记-整理算法就适合老年代。其思路是标记后，将活对象向一端移动，然后清理掉边界以外的内存。</p>

<h4>分代收集算法(Generational Collection)</h4>

<p>这个算法没有特殊之处，就是将堆分为新生代和老年代，然后根据各年代的特点选择最适当的算法。在新生代使用复制算法，在老年代使用“标记-清理”或者“标记-整理”算法。</p>

<h3>2.2 HotSpot的算法实现</h3>

<p>结合前面的垃圾收集算法，看看HotSpot是如何实现的。</p>

<h4>2.2.1 枚举GC Roots</h4>

<p>前面说到GC Roots主要是在全局性的引用和执行上下文（如栈帧中的本地变量表）中，但HotSpot并不需要逐个检查这里面的引用，因为这样的效率太低了。</p>

<p>HotSpot使用一组称为OopMap的数据结构，在类加载完成时，就把对象内各偏移量上是什么类型的数据计算出来了，因此GC扫描时，可以直接得到这些信息，并准确判断堆上的数据是否还可能被使用。</p>

<h4>2.2.2 安全点</h4>

<p>当GC时，线程会停在安全点，常见的安全点包括方法调用、循环跳转、异常跳转等。如何让线程停在安全点，有两种方案：抢先式中断和主动式中断。抢先式指中断所有线程，如果发现某个线程不在安全点，则恢复线程让它跑到安全点。但几乎所有虚拟机都没有采用这个方法。</p>

<p>主动式中断的思路是GC需要中断线程时，设置一个标志，各线程执行时会在安全点和创建对象需要分配内存的地方轮询这个标志，如果为真就把自己挂起。</p>

<p>对于那些处于Sleep或Blocked状态的线程，无法跑到安全点，则需要安全区域来解决。安全区域中任何地方GC都是安全的。当线程执行到安全区域中的代码时，先标识自己已经进入安全区，这时GC就不管这些线程了。当线程要离开安全区时，它要检查系统是否已经完成了根节点枚举或GC过程，如果完成则继续执行，否则继续等待直到收到可安全离开的信号。</p>

<h4>2.2.3 垃圾收集器</h4>

<p><a href="https://blogs.oracle.com/jonthecollector/entry/our_collectors">下图</a>展示了HotSpot用于不同年代的7种收集器，如果两个收集器间有连线，说明它们可以搭配使用。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-26-Collectors.jpg" alt="image" /></p>

<h5>Serial收集器</h5>

<p>这是一个单线程的收集器，工作于年轻代，使用复制算法。当它工作时，会把所有用户线程全部停下来。它现在仍然是Client模式下的默认收集器。它比其他收集器简单但高效，没有了线程交互的开销。桌面应用由于分配的内存相对较少，收集时停顿时间可控制在几十到一百多毫秒，对桌面应用是可以接受的。</p>

<h5>ParNew收集器</h5>

<p>它其实就是Serial收集器的多线程版本，对于单核CPU的环境下，绝对不会比Serial更好。但它适合于在服务端模式时与CMS配合(CMS用于老年代，ParNew用于年轻代)。</p>

<h5>Parallel Scavenge收集器</h5>

<p>这是一个年轻代的收集器，使用复制算法，是并行的多线程收集器。</p>

<ul>
<li>并行(Parallel):指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li>并发(Concurrent): 指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行）。</li>
</ul>


<p>Parallel Scavenge收集器与其它收集器不同，它的目标是达到一个可控制的吞吐量，即CPU用于运行用户代码的时间与CPU总消耗时间的比值。因此适合于不需要太多交互，主要是后台运算的场景。</p>

<h5>Serial Old收集器</h5>

<p>这是Serial收集器的老年代版本，同样是单线程收集器，使用“标记-整理”算法。其主要意义也是Client模式的虚拟机中使用。如果在Server模式下，主要是在JDK1.5及之前的版本中与Parallel Scavenge搭配使用，以及作为CMS的后备预案。</p>

<h5>Parallel Old收集器</h5>

<p>这是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。从JDK1.6开始提供，主要用于与Parallel Scavenge搭配使用，作为“吞吐量优先”的组合。</p>

<h5>CMS收集器(Concurrent Mark Sweep)</h5>

<p>这是一种以获取最短回收停顿时间为目标的收集器。也是基于“标记-清除”算法实现，整个过程分为4步：</p>

<ol>
<li>初始标记：标记GC Roots能直接关联到的对象，时间很快。</li>
<li>并发标记：进行GC Roots Tracing，时间很长。</li>
<li>重新标记：修正并发标记期间因用户程序继续运行而导致标记发生变化的那一部分对象的标记记录，比第一步稍长。</li>
<li>并发清除</li>
</ol>


<p>第1、3步需要Stop the World，而耗时最长的第2、4步可以与用户线程一起工作。</p>

<p>CMS是非常优秀的垃圾收集器，是Java 5推荐的高性能收集器，在Java 6仍保持了旺盛的生命力。但它的主要缺点是：</p>

<ol>
<li>对CPU资源非常敏感。在并发标记阶段，虽然用户程序不用停顿，但CMS占用了一部分CPU资源而导致应用变慢，总吞吐量降低。</li>
<li>无法处理浮动垃圾，可能出现“Concurrent Mode Failure”，导致另一次Full GC。浮动垃圾就是在并发清除阶段，用户线程还在运行并产生新的垃圾。CMS需要预留一部分内存空间给用户线程使用。如果预留的空间无法满足程序需要，就会出现“Concurrent Mode Failure”，导致JVM临时启用Serial Old收集器来重新进行老年代收集，停顿时间就很长了。</li>
<li>由于使用“标记-清除”算法，因此会有碎片产生，有时不得不提前触发一次Full GC。</li>
</ol>


<h5>G1收集器</h5>

<p>这是面向服务端应用的垃圾收集器，可用于替换CMS。具备如下特点：</p>

<ol>
<li>并行与并发：充分利用多CPU、多核优势，缩短Stop the world时间。</li>
<li>分代收集：仍保留分代概念，可以独立管理整个GC堆。</li>
<li>空间整合：G1整体上是基于“标记-清除”，但从局部看是基于“复制”算法，不会产生内存碎片。</li>
<li>可预测的停顿：G1能建立可预测的停顿时间模型，可指定一个长度为M毫秒的时间片段，G1分将停顿时间尽量控制在该时间范围内。</li>
</ol>


<p>G1将整个堆划分为多个大小相等的独立区域（Region），虽然保留分代概念，但新生代和老年代不是物理隔离的，它们是一部分Region的集合（不需要连续）。</p>

<p>它的实现方式是跟踪每个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及所需时间的经验值），维护一个优先列表，每次根据停顿目标值，回收价值最大的Region。保证在有限的时间内获得尽可能高的收集效率。</p>

<p>每个Region都有一个对应的Remembered Set，用于记录跨Region的引用。因此进行内存回收时，只需要在GC Roots枚举范围内加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SecureRandom导致Tomcat启动过慢]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/20/%5B%3F%5D-ci-jie-jue-tomcatqi-dong-guo-man-de-jing-li/"/>
    <updated>2014-12-20T12:08:33+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/20/[?]-ci-jie-jue-tomcatqi-dong-guo-man-de-jing-li</id>
    <content type="html"><![CDATA[<p>昨天晚上在Tomcat上部署一个小应用时，Tomcat启动非常慢，有时甚至需要10分钟。查看日志，发现一直停在Deploying阶段：</p>

<!--more-->




<pre  class='line-numbers language-bash'><code class='language-bash'>INFO: Starting service Catalina
Dec 19, 2014 9:56:33 AM org.apache.catalina.core.StandardEngine startInternal
INFO: Starting Servlet Engine: Apache Tomcat/7.0.52 (Ubuntu)
Dec 19, 2014 9:56:33 AM org.apache.catalina.startup.HostConfig deployWAR
INFO: Deploying web application archive /usr/mxs/kindleinstance/webapps/kindlegen.war</code></pre>


<p>难道是war文件有问题？检查了md5校验码，尝试了解压缩，完全没问题啊！到底是什么原因呢？等了十分钟后，发现Tomcat已经启动完成，可以使用了。再次查看日志：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>INFO: Deploying web application archive /usr/mxs/kindleinstance/webapps/kindlegen.war
Dec 19, 2014 10:11:25 AM org.apache.catalina.util.SessionIdGenerator createSecureRandom
INFO: Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [888,934] milliseconds.
Dec 19, 2014 10:11:25 AM org.apache.coyote.AbstractProtocol start
INFO: Starting ProtocolHandler ["http-bio-9090"]
Dec 19, 2014 10:11:25 AM org.apache.catalina.startup.Catalina start
INFO: Server startup in 892334 ms</code></pre>


<p>原来是“Creation of SecureRandom instance for session ID”消耗了888秒，这个SecureRandom实例是什么呢？在<a href="http://wiki.apache.org/tomcat/HowTo/FasterStartUp">How do I make Tomcat startup faster?</a>中，有这样的描述：</p>

<blockquote><p>Tomcat 7+ heavily relies on SecureRandom class to provide random values for its session ids and in other places. Depending on your JRE it can cause delays during startup if entropy source that is used to initialize SecureRandom is short of entropy.</p></blockquote>

<p>也就是说，Tomcat 7之后严重依赖SecureRandom类来提供随机数用于Session ID。当Tomcat启动时，取决于你使用的JRE，如果用来初始化SecureRandom的熵值（Entropy）资源是一个短熵时，将可能导致延时。</p>

<p>再看看JDK中关于<a href="http://docs.oracle.com/javase/7/docs/api/java/security/SecureRandom.html">SecureRandom类</a>:</p>

<blockquote><p>This class provides a cryptographically strong random number generator (RNG). A cryptographically strong random number minimally complies with the statistical random number generator tests specified in FIPS 140-2, Security Requirements for Cryptographic Modules, section 4.9.1. Additionally, SecureRandom must produce non-deterministic output. Therefore any seed material passed to a SecureRandom object must be unpredictable, and all SecureRandom output sequences must be cryptographically strong, as described in RFC 1750: Randomness Recommendations for Security.</p></blockquote>

<p>该类提供保密性强的随机数生成器（RNG）。一个保密性强的随机数应最低限度遵循FIPS 140-2指定的统计随机数发生器测试和4.9.1节的加密模块安全要求。并且SecureRandom必须产出非确定性的输出。因此，正如RFC 1750中描述的，传递给SecureRandom对象的任何材料必须是不可预测的，并且所有SecureRandom输出序列必须是保密性强的的。</p>

<p>在<a href="http://www.cigital.com/justice-league-blog/2014/01/06/issues-when-using-java-securerandom/">ISSUES TO BE AWARE OF WHEN USING JAVA’S SECURERANDOM</a>中，提到了使用SecureRandom可能存在的问题，主要包括三个方面：调用顺序、阻塞和内部Seeding机制。其中说明了阻塞是如何产生的：</p>

<blockquote><p>Some SecureRandom implementations in the Oracle JRE for *nix use /dev/random to get entropy at certain times. Since /dev/random can block if sufficient entropy is not available, your code will stop executing if you call certain SecureRandom methods at times when /dev/random does not have sufficient entropy available.</p></blockquote>

<p>这样看来，我的Ubuntu 14中的OpenJDK(OpenJDK Runtime Environment (IcedTea 2.5.3) (7u71-2.5.3-0ubuntu0.14.04.1))正是使用了操作系统的<code>/dev/random</code>作为信息源，而它又没有提供足够的熵，所以导致阻塞。</p>

<p>按照前文<a href="http://wiki.apache.org/tomcat/HowTo/FasterStartUp">How do I make Tomcat startup faster?</a>中给出的次安全的解决办法，改为使用<code>-Djava.security.egd=file:/dev/./urandom</code>，即在setenv.sh中加入一行：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>#!/bin/sh
export CATALINA_OPTS="-Djava.security.egd=file:/dev/./urandom"</code></pre>


<p>然后再重启Tomcat，这次非常快了，整个启动只用了3秒多：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>INFO: Starting service Catalina
Dec 19, 2014 10:51:55 PM org.apache.catalina.core.StandardEngine startInternal
INFO: Starting Servlet Engine: Apache Tomcat/7.0.52 (Ubuntu)
Dec 19, 2014 10:51:55 PM org.apache.catalina.startup.HostConfig deployWAR
INFO: Deploying web application archive /usr/mxs/kindleinstance/webapps/kindlegen.war
Dec 19, 2014 10:51:58 PM org.apache.coyote.AbstractProtocol start
INFO: Starting ProtocolHandler ["http-bio-9090"]
Dec 19, 2014 10:51:58 PM org.apache.catalina.startup.Catalina start
INFO: Server startup in 3418 ms</code></pre>


<p>修改后的<code>/dev/urandom</code>没有默认的<code>dev/random</code>安全吗？似乎也不一定，博文<a href="http://www.2uo.de/myths-about-urandom/">Myths about /dev/urandom</a>对两者进行了全面的分析，值得一看。最后作者认为用<code>/dev/urandom</code>就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java运行时数据区与内存溢出异常]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/15/javayun-xing-shi-shu-ju-qu-yu-nei-cun-yi-chu-yi-chang/"/>
    <updated>2014-12-15T21:55:31+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/15/javayun-xing-shi-shu-ju-qu-yu-nei-cun-yi-chu-yi-chang</id>
    <content type="html"><![CDATA[<p>JVM定义了各种运行时数据区用于程序执行。有些数据区随着JVM启动而创建，当JVM退出时销毁。另一些数据区则是随着线程而存亡。每个数据区都是内存，因此就存在内存溢出的异常。本文学习JVM有哪些数据区以及常见的内存溢出异常。</p>

<!--more-->


<h2>1. 运行时数据区（Run-Time Data Areas）</h2>

<p>根据<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5">JVM规范</a>，运行时数据区主要分为以下部分。</p>

<h3>1.1 程序计数器（Program Counter Register）</h3>

<p>每个JVM线程拥有自己的程序计数器，各线程之间计数器互不影响，这部分区域可以称为线程私有的内存。在任何时间点，一个CPU核心都只会执行一个线程中某个方法的指令，这就是当前方法：</p>

<ul>
<li>如果当前方法不是Native方法，程序计数器包含正在执行的虚拟机字节码指令的地址。</li>
<li>如果是Native方法计数器值为Undefined。</li>
</ul>


<p>程序计数器所占内存非常小，也是唯一没有规定任何内存溢出异常的区域。</p>

<h3>1.2 虚拟机栈（JVM Stacks）</h3>

<p>每个线程同时也有一个私有的虚拟机栈，因此虚拟机栈的生命周期与线程相同。每个栈包括帧（frames），帧与方法调用相关，每当方法被调用，就会创建一个新的帧。当方法结束，帧也就被销毁。帧包括局域变量、自己的操作栈和当前方法的运行时常量池引用。</p>

<p>虚拟机栈与C语言中的栈相似，它包括局域变量和部分结果，并在方法调用和返回中扮演角色。除了push和pop帧，虚拟机栈并不提供其它直接操作。帧可能是在堆中分配内存。虚拟机栈的内存并不需要是连续的。</p>

<p>通常人们把Java内存分为堆和栈，其中栈就是虚拟机栈。虚拟机栈的内存可以是固定大小或者根据计算动态扩展。虚拟机栈涉及两个异常：</p>

<ul>
<li>StackOverflowError: 如果线程请求的栈深度大于允许的深度。</li>
<li>OutOfMemoryError：如果栈是动态扩展的，扩展时无法申请足够的内存。</li>
</ul>


<p>本地方法栈（Native Method Stack）与虚拟机栈发挥着相似的作用，但它是为Native方法服务。JVM规范并没有对其强制规定。HotSpot直接把本地方法栈和虚拟栈合二为一，相同对待。</p>

<p>栈虽然有两个异常，但实验时，如果是单线程操作，无论是栈帧太大还是虚拟机栈容量太小，基本只会出现StackOverflowError，示例如下：</p>

<pre class='line-numbers language-java'><code class='language-java'>/**
* -Xss128k
*/
public class JavaVMStackSOF {
    private int stackLength = 1;
    public void stackLeak() {
        stackLength++;
        stackLeak();
    }
    
    public static void main(String[] args) {
        JavaVMStackSOF oom = new JavaVMStackSOF();
        try {
            oom.stackLeak();
        } catch(Throwable e) {
            ...
        }
    }
}</code></pre>


<p>实验中，只有多线程时，才会出现OutOfMemoryError。通过不停地创建线程，并且每个线程不停止，当线程足够多时就可以重现此异常。</p>

<h3>1.3 堆（Heap）</h3>

<p>堆是在JVM所管理的内存中最大的一块，它是所有线程共享的区域。当JVM启动时会创建此区域。所有对象实例和数组都在堆上分配（现在也有例外，参见<a href="http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">逸出分析</a>）。</p>

<p>堆中存储的对象由垃圾收集器负责回收。堆的大小可以是固定或者动态扩展。堆不需要连续内存空间，只要逻辑上连续即可。根据垃圾收集器的不同，堆内存有不同的管理方式。例如CMS采用分代收集算法，将堆分为年轻代和老年代；而G1则将堆分成大小相同的区域。详见<a href="http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>。</p>

<p>堆涉及的内存异常为OutOfMemoryError，如果堆中没有内存用于实例分配并且无法再扩展时，就会抛出此异常。堆内存溢出很容易模拟，示例如下：</p>

<pre class='line-numbers language-java'><code class='language-java'>/**
* -Xms20m -Xmx20m
*/
public static void main(String[] args) {
    List&lt;SomeObject&gt; list = new ArrayList&lt;&gt;();
    while(true) {
        list.add(new SomeObject());
    }
}</code></pre>


<h3>1.4 方法区（Method Area）</h3>

<p>方法区也是所有线程共享的内存区域。它存储了每个类的信息，例如运行时常量池、属性和方法数据、方法和构造方法代码，包括类和实例初始化和接口初始化的特殊方法。</p>

<p>方法区随着虚拟机启动而创建。逻辑上它是堆的一部分，但JVM实现可以选择不对它进行垃圾收集或者压缩。JVM规范并没有强制规定它的位置和管理已编译代码的策略。它可以是固定大小或者动态扩展，也不需要是连续的。</p>

<p>对于HotSpot虚拟机来说，开发者更愿意把方法区称为永久代（Permanent Generation），但本质上两者并不等价。这仅仅是因为HotSpot设计团队使用永久代来实现方法区而已。但其它虚拟机（如Bea JRocket, IBM J9）并没有永久代的概念。</p>

<p>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。如果一些框架使用CGLib这类字节码技术，增强的类过多，或者JVM上的动态语言（如Groovy）持续创建类来实现语言动态特性，可能出现此异常。</p>

<h3>1.5 运行时常量池</h3>

<p>在<a href="http://blog.ubone.com/blog/2014/12/04/lei-wen-jian-yu-zi-jie-ma/">类文件与字节码</a>中介绍了类文件的常量池，运行时常量池就是这个常量池的运行时表示。运行时常量池相对于类文件常量池主要有两个区别：</p>

<ul>
<li>除了类文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</li>
<li>运行时常量池可以在运行期间将新的常量加入池中。</li>
</ul>


<p>运行时常量池的内存是从方法区分配出来的。当JVM创建类或接口时，会为它创建运行时常量池。因此它的内存受方法区内存限制，也可能抛出OutOfMemoryError异常。</p>

<h3>1.6 直接内存</h3>

<p>直接内存（Direct Memory）并不是JVM运行时数据区的一部分，也不是JVM规范定义的内存区域。但它也被频繁使用，可能导致OutOfMemoryError异常。</p>

<p>JDK 1.4中加入NIO类，引入了基于Channel与Buffer的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过DirectByteBuffer对象作为这块内存的引用进行操作。由于避免了Java堆与Native堆之间复制数据，在一些场景能显著提高性能。</p>

<p>这部分内存虽然不受Java堆大小限制，但肯定会受本机总内存和寻址空间限制。因此动态扩展时可能出现OutOfMemoryError异常。</p>

<h2>2. 内存Dump分析</h2>

<p>在<a href="http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you/">理解Java性能调优</a>中介绍了jmap, jstat等工具可以查看内存映射和垃圾收集活动。这里介绍另一个工具Eclipse Memory Analyzer可以对堆内存溢出问题进行分析。首先需要生成堆转储文件。通过启用参数：</p>

<p><code>-XX:+HeapDumpOnOutOfMemoryError</code></p>

<p>JVM 就会在发生内存泄露时抓拍下当时的内存状态，也就是我们想要的堆转储文件。也可以在未溢出时用jmap创建转储文件。</p>

<p>有了转储文件，利用Eclipse Memory Analyzer tool打开该文件，就可以进行分析了。分析通常分为三步：</p>

<ul>
<li>对内存状态获取一个整体印象。</li>
<li>找到最有可能导致内存泄露的元凶，通常也就是消耗内存最多的对象。</li>
<li>进一步查看这个内存消耗大户的具体情况，看看是否有什么异常行为。</li>
</ul>


<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-17-20.30.59.jpg" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解Java性能调优]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you/"/>
    <updated>2014-12-06T21:00:37+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/06/li-jie-javaxing-neng-diao-you</id>
    <content type="html"><![CDATA[<p>人们总是猜不对系统变慢的原因在哪里，你必须量体裁衣。没有评测就没有合适的调优。本文重点学习性能相关的内存管理、垃圾收集、相关工具并简单了解HotSpot。</p>

<!--more-->


<h2>1. 性能指标</h2>

<h3>评价性能的常用指标</h3>

<ul>
<li>等待时间(Latency)：在给定工作量的情况下，处理一个任务单元所消耗的时长。通常用响应时间随负载增长的变化曲线来反映。</li>
<li>吞吐量(Throughput)：在某一参考平台（硬件配置、OS和软件环境）上的每秒事务处理数。</li>
<li>利用率(Utilization)：在可用资源中处理工作单元的资源百分比。例如CPU的利用率。</li>
<li>效率(Efficiency)：吞吐量除以所用资源。</li>
<li>容量(Capacity)：任一时刻能通过系统的工作单元数量。</li>
<li>扩展性(Scalability)：当系统得到更多资源时，吞吐量或等待时间的变化。如果方案A可用的服务器数量翻倍，它的吞吐量也能翻倍，那么它就实现了完美的线性扩展。</li>
<li>退化(Degradation)：分为正面退化和负面退化。当工作单元增加时，性能通常会降低，即负面退化。但也存在正面退化，例如负载超过阈值，使系统切换到高性能模式，处理时间可能缩短。JVM是动态非常强的运行时系统，有几部分可以达成这种效果。</li>
</ul>


<p>性能分析时要了解一些概念：</p>

<blockquote><p>中位数（又称中值，Median），统计学中的专有名词，代表一个样本、种群或概率分布中的一个数值，其可将数值集合划分为相等的上下两部分。对于有限的数集，可以通过把所有观察值高低排序后找出正中间的一个作为中位数。如果观察值有偶数个，通常取最中间的两个数值的平均数作为中位数。</p>

<p>方差是各个数据分别与其和的平均数之差的平方的和的平均数，用字母D表示。在概率论和数理统计中，方差（Variance）用来度量随机变量和其数学期望（即均值）之间的偏离程度。在许多实际问题中，研究随机变量和均值之间的偏离程度有着重要意义。</p>

<p>百分位数是统计学术语，如果将一组数据从小到大排序，并计算相应的累计百分位，则某一百分位所对应数据的值就称为这一百分位的百分位数。可表示为：一组n个观测值按数值大小排列。如，处于p%位置的值称第p百分位数。</p>

<p>标准差（Standard Deviation） ，中文环境中又常称均方差，但不同于均方误差（mean squared error，均方误差是各数据偏离真实值的距离平方的平均数，也即误差平方和的平均数，计算公式形式上接近方差，它的开方叫均方根误差，均方根误差才和标准差形式上接近），标准差是离均差平方和平均后的方根，用σ表示。标准差是方差的算术平方根。标准差能反映一个数据集的离散程度。平均数相同的，标准差未必相同。</p></blockquote>

<h2>2. 务实的性能分析法</h2>

<p>做性能分析最重要的是知道哪个可测环节最重要。应该把测量结果、目标和结论跟一个或多个可测环节结合起来。以下是常见的可测项，都是性能调优的好对象：</p>

<ul>
<li>方法handelRequest()运行所需的平均时间。</li>
<li>并发10客户端时，系统等待时间的第90个百分位数。</li>
<li>并发用户从1增长到1000时，响应时间的退化。</li>
</ul>


<p>要精确确定一个方法或代码片段运行需要多长时间，只有两种方法：</p>

<ul>
<li>直接测量，在源码中插入测量代码。最容易理解，但是侵入式的。如果测量结果不断增多，代码很容易就被数据淹没。</li>
<li>在类加载时把类转换成受测类。使用特殊的类加载器，在方法开始和结束的地方加上记录时间的字节码。典型的有OpTier CoreFirst等性能监测工具，但似乎还没有开源工具。</li>
</ul>


<h2>3. 时间问题</h2>

<p>为了进行性能调优，需要对时间有深刻认识。</p>

<h4>硬件时钟</h4>

<p>基于x64的机器有四种不同的硬件时间源：</p>

<ul>
<li>RTC: 实时时钟（RTC）基本和电子表里的元件一样，在系统断电时由主板上的电池供电。系统启动时从它那得到时间。很多系统会在OS启动后通过网络时间协议（Network Time Protocol, NTP）与时间服务器同步。</li>
<li>8254：是可编程计时芯片，现在基本不需要了。</li>
<li>TSC：时间戳计时器，这是应用最广泛的现代计时器。可认为是一个跟踪CPU运行了多少周期的CPU计数器。由于与CPU相关，因此运行时可能受节能或其它因素影响。不同的CPU会互相偏离，不能跟钟表时间保持一致。</li>
<li>HPET，高精度事件计时器，最近几年才出现。精度非常高，但不是所有硬件都可用，也不是所有操作系统都支持。</li>
</ul>


<h4>Java获取时间的方法</h4>

<p>Java提供了两个获取时间的方法：</p>

<ul>
<li>System.currentTimeMillis()，解析度为毫秒级，几乎所有情况下都跟钟表时间相符。</li>
<li>System.nanoTime()，用于测量比毫秒更精确的时间，时间源来自TSC，可能偏离钟表时间。</li>
</ul>


<p>对于较长的间隔时间，nanoTime()基本是不可信的，应该使用currentTimeMillis()，nanoTime()它只能测量较短的时间间隔。</p>

<h2>4. 垃圾收集</h2>

<h3>4.1 内存管理</h3>

<p>内存自动管理是Java平台最重要的组成部分之一。Java内存分为栈和堆。</p>

<p>栈内存，即虚拟机栈。每个方法被执行的时候都会同时创建一个栈帧，用来存储局部变量，操作栈，动态链接，方法出口等信息。<strong>局部变量包括各种基本类型的变量和对象的引用变量都是在方法的栈内存中分配。</strong>其中，64位长度的long和double类型的数据占用2个局部变量的空间，其他数据类型只占用1个。局部变量所需要的内存空间是在编译期间完成的，当进入一个方法时候，这个方法所需的局部变量空间已经确定，在方法运行期间不会改变。当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。当线程请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常。当虚拟机栈无法扩展时候则抛出OutOfMemoryError异常。</p>

<p>堆内存，在虚拟机启动时创建。堆内存的唯一目的就是创建对象实例，所有的对象实例和数组都要在堆上分配。对象的域即使是原始类型，也仍然分配在堆内存中。堆内存的回收由垃圾回收负责。</p>

<h4>标记和清除</h4>

<p>标记和清除是最简单、也是出现最早的垃圾收集算法。Perl和PHP等语言则采用引用计数法。</p>

<p>最简单的标记和清除算法会暂停所有正在运行的线程，并从一组“活”对象（任何用户线程的任何堆栈帧中存在引用的对象）开始遍历其引用树，标记出路径上的所有活对象。遍历完成后，所有没被标记的被当作垃圾，可以回收。被清除的内存不是还给OS，而是JVM。</p>

<p>Java平台对基本的标记清除算法进行了改进，采用“分代式垃圾收集”。内存分成了几个不同的区域：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-07-Java-Memory-Model-450x186.png" alt="image" /></p>

<ul>
<li>Eden(伊甸园)：对象最初降生的堆区域。</li>
<li>Survivor(幸存者乐园)：分为两个空间（S0, S1）,除非正在执行垃圾收集，否则总有一个空间是空的。</li>
<li>Old Generation：老年代。是那些“足够老”的幸存对象的归宿。</li>
<li>PermGen：为内部结构分配的内存，例如类定义。它不是严格的堆内存，并且普通的对象最后不会在这里结束。</li>
</ul>


<p>上面这些内存区域的垃圾收集方式不尽相同。</p>

<h4>年轻代收集（Minor GC）</h4>

<p>年轻代收集只会清理“年轻的”空间（伊甸园和幸存者乐园），其过程如下：</p>

<ul>
<li>在标记阶段发现的所有仍然存活的年轻对象都会被挪走：那些足够老的对象（从次数足够多的GC中幸存下来的）进入老年代；所有Eden中存活的对象被移到幸存者乐园的其中一个空间，幸存者乐园中的存活对象也会被移到该空间。（S0, S1总有一个是空的）</li>
<li>伊甸园和最近腾空的幸存者乐园可以重用了，因为它们里面已经全是垃圾了。</li>
</ul>


<h4>完全收集（Major GC）</h4>

<p>当年轻代收集不能把对象放进老年代时（空间不够了），就会触发一次完全收集，这通常要更长的时间。根据老年代所用的收集器，可能会牵涉到老年代对象的内部迁移。以确保必要时能从老年代对象所占的内存中给大的对象腾出足够的空间。这被称为压缩。</p>

<p>由于Major GC会消耗更长时间，消耗的时间取决于垃圾收集策略，这期间应用将无响应。因此在高响应应用中，有必要监视和优化垃圾回收以避免超时。</p>

<h4>安全点</h4>

<p>因为垃圾收集时，要暂停所有应用线程，因此线程给执行GC留出了特定的位置——安全点。常见的安全点是方法被调用的地方（调用点），不过也有其它安全点。当执行垃圾收集时，所有应用线程都必须停在安全点。</p>

<h3>4.2 工具</h3>

<p>借助一些工具可以帮你了解运行中的进程和垃圾收集。</p>

<h4>jmap</h4>

<p>jmap是Oracle JVM自带的一个工具，用来显示Java进程的内存映射，也能分析Java核心文件（Java core file，主要保存各应用线程在某一时刻的执行栈以及stack trace的显示）。</p>

<p><strong>默认视图</strong></p>

<p>jmap最简单的用法是查看连接到进程里的本地类库。用处不大，用得最多的是后面两种视图。</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>$ jmap 25154
Attaching to process ID 25154, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 24.65-b04</code></pre>


<p><strong>堆视图</strong></p>

<p>使用-heap选项，jmap会抓取进程当前的堆快照。以下是输出结果示例：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>$ jmap -heap 25164
Attaching to process ID 25164, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 24.65-b04

using thread-local object allocation.
Parallel GC with 4 thread(s)

Heap Configuration:
   MinHeapFreeRatio = 0
   MaxHeapFreeRatio = 100
   MaxHeapSize      = 2147483648 (2048.0MB)
   NewSize          = 1310720 (1.25MB)
   MaxNewSize       = 17592186044415 MB
   OldSize          = 5439488 (5.1875MB)
   NewRatio         = 2
   SurvivorRatio    = 8      //Eden = (From+To)*幸存比例
   PermSize         = 21757952 (20.75MB)
   MaxPermSize      = 85983232 (82.0MB)
   G1HeapRegionSize = 0 (0.0MB)

Heap Usage:
PS Young Generation
Eden Space:
   capacity = 69206016 (66.0MB)
   used     = 22857000 (21.798133850097656MB)
   free     = 46349016 (44.201866149902344MB)
   33.02747553045099% used
From Space:
   capacity = 5242880 (5.0MB)
   used     = 5223552 (4.9815673828125MB)
   free     = 19328 (0.0184326171875MB)
   99.63134765625% used
To Space:
   capacity = 5242880 (5.0MB)
   used     = 0 (0.0MB)
   free     = 5242880 (5.0MB)
   0.0% used
PS Old Generation
   capacity = 89128960 (85.0MB)
   used     = 14067336 (13.415657043457031MB)
   free     = 75061624 (71.58434295654297MB)
   15.78312593347886% used
PS Perm Generation
   capacity = 22020096 (21.0MB)
   used     = 15539944 (14.820045471191406MB)
   free     = 6480152 (6.179954528808594MB)
   70.57164510091145% used

10750 interned Strings occupying 1540688 bytes.</code></pre>


<p>可以看到，堆的大小是年轻代、老年代加上PermGen的总和。年轻代分为Eden和幸存者乐园（From + To）。要知道堆里面有什么，需要柱状视图。</p>

<p><strong>柱状视图</strong></p>

<p>柱状视图显示了系统中每个类型的实例占用的内存量，并按占用内存倒序排序，非常直观：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>$ jmap -histo 25164 | head -30

 num     #instances         #bytes  class name
----------------------------------------------
   1:         46155       20826544  [B
   2:         78977       13845352  [C
   3:          1777       10259592  [I
   4:         28606        3977416  &lt;constMethodKlass&gt;
   5:         28606        3670320  &lt;methodKlass&gt;
   6:          2464        2990888  &lt;constantPoolKlass&gt;
   7:          2193        1756960  &lt;constantPoolCacheKlass&gt;
   8:          2464        1728800  &lt;instanceKlassKlass&gt;
   9:         53032        1272768  java.lang.String
  10:         12669         405408  java.util.HashMap$Entry
  11:          2740         333816  java.lang.Class
  12:          4131         330480  java.lang.reflect.Method
  13:          4488         297968  [S
  14:          4204         287432  [Ljava.lang.Object;
  15:           524         271024  &lt;methodDataKlass&gt;
  16:          4277         228680  [[I
  17:          2107         185416  org.apache.naming.resources.FileDirContext$FileResourceAttributes
  18:          3047         170632  java.util.zip.ZipFile$ZipFileInputStream
  19:           987         167256  [Ljava.util.HashMap$Entry;
  20:          2929         164024  java.util.zip.ZipFile$ZipFileInflaterInputStream
  21:           259         140896  &lt;objArrayKlassKlass&gt;
  22:          4282         137024  java.io.File
  23:          2194         131888  [Ljava.lang.String;
  24:          5483         131592  java.lang.StringBuilder
  25:          2656         127488  java.util.HashMap
  26:          2520         100800  java.lang.ref.Finalizer
  27:          2341          93640  java.util.LinkedHashMap$Entry</code></pre>


<p>结果使用的是类型内部名称，例如byte数组会写成[B，char数组会写成[C（字符数组数据经常出现在String对象里）。参考<a href="http://blog.ubone.com/blog/2014/12/04/lei-wen-jian-yu-zi-jie-ma/">类文件与字节码</a>。以char数组为例，共有78977个实例，占用约13.8MB。</p>

<p>使用-histo:live选项，jmap将只处理活对象，而不是整个堆：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>$ jmap -histo:live 25164 | head -7

 num     #instances         #bytes  class name
----------------------------------------------
   1:         28573        5905704  [C
   2:         28606        3977416  &lt;constMethodKlass&gt;
   3:         28606        3670320  &lt;methodKlass&gt;
   4:          2464        2990888  &lt;constantPoolKlass&gt;</code></pre>


<p>活的字符串只有28573个实例，占用约5.9MB，证明有（13.8-5.9）MB在等待回收。需要注意的是，如果jmap正在执行时，JVM做了垃圾回收，有可能看到奇怪或太好的结果，所以应该多运行几次。</p>

<p><strong>产生离线导出文件</strong></p>

<p>jmap能创建导出文件：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>$ jmap -dump:live,format=b,file=heap.hprof 25164
Dumping heap to /Users/mxs/Documents/blog/heap.hprof ...
Heap dump file created</code></pre>


<p>导出结果可以用来做离线分析，留给jmap以后使用，或者留给Oracle的jhat（Java堆分析工具）做高级分析。</p>

<h4>jstat</h4>

<p>Oracle JVM自带的jstat可以查看内存和垃圾收集的活动，并能循环显示。下例以每秒一次的频率显示内存状况：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>meixuesongdeMacBook-Pro:blog mxs$ jstat -gc 25164 1000
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC     PU    YGC     YGCT    FGC    FGCT     GCT   
14336.0 13312.0  0.0    0.0   133632.0 85887.5   52224.0    10313.5   33280.0 15221.9      7    0.064   3      0.171    0.236
14336.0 13312.0  0.0    0.0   133632.0 85887.5   52224.0    10313.5   33280.0 15221.9      7    0.064   3      0.171    0.236</code></pre>


<ul>
<li>S0C和S1C: Survivor0和Survivor1的大小（KB）</li>
<li>S0U和S1U: Survivor0和Survivor1的已使用大小（KB）</li>
<li>EC and EU：Eden空间的大小和已经使用大小（KB）</li>
<li>OC and OU: 老年代空间的大小和已经使用大小（KB）</li>
<li>PC and PU: Perm空间的大小和已经使用大小（KB）</li>
<li>YGC and YGCT：YGC为年轻代GC的次数。YGCT显示年轻代GC的累计时间。</li>
<li>FGC and FGCT：Full GC的次数和累计时间</li>
<li>GCT：GC总时间，包括年轻代和Full GC。</li>
</ul>


<h4>Java VisualVM</h4>

<p>另一个可视化的工具是Java VisualVM，在命令行执行<code>jvisualvm</code>即可。</p>

<h3>4.3 与GC相关的JVM参数</h3>

<p>JVM的参数非常多。以<code>-X</code>开头的选项不是标准选项，在其它JVM上可能不可用。而<code>-XX</code>开头的是扩展选项，不要随便使用。很多与性能相关的选项都是扩展选项。</p>

<p>基本的垃圾收集选项可以见本文前面的内存分布图片。主要包括：</p>

<ul>
<li><code>-Xms</code>: 堆的初始大小</li>
<li><code>-Xmx</code>: 堆的最大大小</li>
<li><code>-Xmn</code>: 堆中年轻大的大小</li>
<li><code>-XX:-DisableExplicitGC</code>: 让System.gc()调用不产生任何作用。</li>
</ul>


<h3>4.4 逸出分析</h3>

<p>这是JVM最近的一项修改，开发者不能直接控制或影响这项修改。从Java 6u23之后，逸出分析是默认打开的。</p>

<p>它的基本思路是分析方法并确认其中哪个局部变量只用在方法内部，以及哪些变量不会传入其他方法或从当前方法中返回。JVM可以在当前方法的栈内部创建这个对象，不再使用堆内存。在当前方法返回时，被局部变量占用的内存就自动释放了，因此将减少程序年轻代收集的次数，提高性能。</p>

<h3>4.5 并发标记清除（CMS）</h3>

<p>CMS是Java 5推荐的高性能收集器，在Java 6仍保持了旺盛的生命力。通过以下选项激活：</p>

<table>
<thead>
<tr>
<th>选项 </th>
<th> 效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-XX:+UseConcMarkSweepGC</code> </td>
<td> 打开CMS收集</td>
</tr>
<tr>
<td><code>-XX:+CMSIncrementalMode</code> </td>
<td> 增量模式（一般都需要）</td>
</tr>
<tr>
<td><code>-XX:+CMSIncrementalPacing</code> </td>
<td> 配合增量模式，根据应用的行为自动调整每次执行垃圾回收任务的幅度（一般都需要）</td>
</tr>
<tr>
<td><code>-XX:+UseParNewGC</code> </td>
<td> 并发收集年轻代</td>
</tr>
<tr>
<td><code>-XX:ParallelGCThreads=&lt;N&gt;</code> </td>
<td> GC使用的线程数</td>
</tr>
</tbody>
</table>


<p>并发方式是如何工作的，以下是重要事实：</p>

<ul>
<li>某种世界停转（SWT）的暂停是不可避免的；</li>
<li>GC子系统绝对不能漏掉存活对象，这样做会导致JVM垮掉（或更糟）</li>
<li>只有所有应用线程都为整体收集暂停下来，才能保证收集所有的垃圾。</li>
</ul>


<p>CMS利用最后一点，制造两个非常短暂的STW暂停，并且在GC周期的剩余时间和应用程序的线程一起运行。CMS要在运行时做复杂的记账工作，记录哪些是垃圾，哪些不是。CMS在更多CPU核心的机器上表现会更好，并且会制造更频繁的短暂暂停。</p>

<h3>4.6 新的收集器：G1</h3>

<p>G1是Java平台最新的收集器，预发布于Java 6，到Java 7时已是成品。G1有望成为高性能应用的默认选择。</p>

<p>G1与原来的收集器完全不同，开发人员有更多控制权。其核心思想是暂停目标（Pause gaol），也就是程序能为GC暂停多长时间（如每5分钟20ms）。G1会努力达成该目标。</p>

<p>尽管G1仍然使用标记清除法，但它不是真正的分代式垃圾收集器。它把堆分成大小相同的区域（如每个1MB），不区分年轻、老年代。暂停时，对象被撤到其他区域（就像Eden挪到Survivor），清空的区域被放回到空白区自由列表上。</p>

<p>这个新的收集策略让Java平台统计收集单个区域所需平均时长。然后你就可以指定一个合理的暂停目标。G1只会在有限的时间内收集尽可能多的区域。与G1相关的选项如下表：</p>

<table>
<thead>
<tr>
<th>选项 </th>
<th> 效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-XX:+UseG1GC</code> </td>
<td> 打开G1收集</td>
</tr>
<tr>
<td><code>-XX:MaxGCPauseMillis=50</code> </td>
<td> 收集一次暂停的时间应尽量保持在50ms以内</td>
</tr>
<tr>
<td><code>-XX:GCPauseIntervalMillis=200</code> </td>
<td> 两次收集的时间间隔尽量保持在200ms以上。</td>
</tr>
</tbody>
</table>


<h2>5. HotSpot的JIT编译</h2>

<p>Java是一种“动态编译”语言。方法一开始都是以字节码形态存在，JVM对其解释并执行，同时会记录被调用的次数。当调用次数超过某个阈值（默认1万次）时，后台就会把字节码编译成机器码。如果编译成功，以后就会调用该方法的编译结果。编译后的机器码运行速度可能会快1000倍。</p>

<p>那为什么要动态编译，先编译好岂不是性能更好？原因之一是与平台无关的东西作为基本部署单位要更轻松。原因之二是动态编译能提供给编译器更多信息，例如某个指令是否可用，代码运行情况的统计数据等。因此Java这样的动态编译语言实际上可能会比提前编译的语言运行得更快。</p>

<p>HotSpot有两种运行模式：客户端模式和服务器模式，分别对应JVM启动选项：<code>-client</code>和<code>-server</code>。前者编译时会确保操作的一致性，较为保守。后者编译时会大胆假设，做一次运行时检查，以确保假设有效。编译结果性能好很多。</p>

<p><strong>实时Java</strong>是近年出现的，它并不一定是最快的。它关注的是让执行操作的时间尽量保持一致。为了达成这个目的，它可能会牺牲一些平均等待时间，整体性能可以受到轻微影响。</p>

<p><strong>内联</strong>是HotSpot的最大卖点之一。内联的方法不再是被调用，而是直接放到调用者内部。HotSpot会根据运行时的统计数据（方法调用频率）和其他因素来决定如何处理内联。这比提前编译更智能。它完全是自动的，通常不需要修改选项（用处不大）。</p>

<p><strong>独占调用</strong></p>

<p>独占调用是大胆优化的例子之一，只有服务端编译器才会做这种大胆优化，实时和客户端编译器都不会这样做。它是基于大量观察做出的优化，以下面的代码为例：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>MyActualClassNotInterface obj = getInstance();
obj.callMyMethod();</code></pre>


<p>如果上面的代码只会在一种类型的对象上调用（基于统计），也就是obj.callMyMethod()几乎不会同时碰到一个类和它的子类。这时就可以把Java方法查找替换为callMyMethod()编译结果的直接调用。为了防止getInstance()可能返回的是其他类，运行时会检查，确保对象的类型是由编译器按预期插入的。如果这个预期被违背，运行时会取消优化。程序不会注意到这些动作也不会犯任何错误。</p>

<p>通过启动选项<code>-XX:+PrintCompilation</code>可以告诉JIT编译线程输出标准日志。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类文件与字节码]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/04/lei-wen-jian-yu-zi-jie-ma/"/>
    <updated>2014-12-04T20:40:02+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/04/lei-wen-jian-yu-zi-jie-ma</id>
    <content type="html"><![CDATA[<p>本篇学习类加载过程、类文件的分析工具和字节码。</p>

<!--more-->


<h2>1. 类加载和类对象</h2>

<p>一个.class文件定义了JVM的一种类型。类加入到JVM当前运行态中，首先要加载并连接，进行大量验证，然后提供一个代表该类型的Class对象给正在运行的系统，用于创建新的实例。</p>

<h4>加载</h4>

<p>加载的过程首先要读取类文件的字节数据流，创建一个字节数组，然后产生对应的Class对象。这个过程会进行一些基本检查。加载结束时，Class对象还不成熟，类也不可用。</p>

<h4>连接</h4>

<p>加载完成后，类必须连接起来。这分为三个步骤：验证、准备和解析。验证类文件符合预期，不会引起系统运行时错误。准备阶段会分配内存，准备好初始化类中的静态变量（但不会现在初始化变量）。解析阶段会检查类中引用的类型是否有未知类型，如果有会加载进来。一旦需要加载的其他类型全部定位并完成解析，VM就可以初始化这个类。这时所有静态变量都可以被初始化，所有静态初始化代码块都会运行。类的加载全部完成，已经可以使用了。</p>

<h4>Class对象</h4>

<p>加载和连接过程的最终结果是一个Class对象，可以使用这个新类型创建实例了。Class对象可以和反射API一起实现对方法、域和构造方法等类成员的间接访问，通过getSuperClass()返回其父类。</p>

<h4>类加载器</h4>

<p>Java平台有几个经典的类加载器：</p>

<ul>
<li>根（或引导）类加载器：通常在VM启动后不久实例化，一般用本地代码实现。可视为VM的一部分。负责加载系统的基础JAR(主要是rt.jar),而且不做验证工作。</li>
<li>扩展类加载器：用来加载安装时自带的标准扩展。一般包括安全性扩展。</li>
<li>应用（或系统）类加载器：应用最广泛的类加载器，负责加载应用类。</li>
<li>定制类加载器：在更复杂的环境，如EE或比较复杂的SE框架，通常会有些附加（即定制）的类加载器。</li>
</ul>


<h2>2. 方法句柄</h2>

<p>反射代码有很多套路，要捕获各种讨厌的异常，代码看起来也不直观。Java 7为间接调用方法引入了java.lang.invoke包，即方法句柄，可以提高安全性和代码的可读性。</p>

<h4>MethodHandle</h4>

<p>它是对可直接执行的方法（或域、构造方法等）的类型化引用，是一个有能力安全调用方法的对象。</p>

<pre class='line-numbers language-java'><code class='language-java'>MethodHandle mh = getTwoArgMH();
MyType ret;
try {
    //调用obj对象的句柄，传入参数arg0, arg1
    ret = mh.invokeExact(obj, arg0, arg1);
} catch(Throwable e) {
    //...
}</code></pre>


<h4>MethodType</h4>

<p>它表示方法签名类型的不可变对象。每个方法句柄都有一个MethodType实例，用来指明方法的返回类型和参数类型。但它没有方法的名称和接收者类型。通过工厂方法可以得到MethodType实例：</p>

<pre class='line-numbers language-java'><code class='language-java'>//第一个参数为返回类型，随后是方法参数的类型。
//toString()
MethodType mtToString = MethodType.methodType(String.class);
//setter方法
MethodType mtSetter = MethodType.methodType(void.class, Object.class);
//Comparator&lt;String&gt;定义的compareTo()方法
MethodType mtStringComparator = MethodType.methodType(int.class, String.Class, String.class);</code></pre>


<h4>查找方法句柄</h4>

<p>通过lookup对象，你给出持有所需方法的类、方法名称以及你所需方法签名相匹配的MethodType，就可以得到方法句柄：</p>

<pre class='line-numbers language-java'><code class='language-java'>public MethodHandle getToStringMH() {
    MethodHandle mh;
    MethodType mt = MethodType.methodType(String.class);
    MethodHandles.Lookup lk = MethodHandles.lookup();
    
    try {
        mh = lk.findVirtual(getClass(), "toString", mt);
    } catch(NoSuchMethodException | IllegalAccessException mhx) {
        //...
    }
    
    return mh;
}</code></pre>


<blockquote><p>如果不是从当前类中查找，则只能看到或取得public方法的句柄。方法句柄总是在安全管理之下安全使用。没有反射中setAccessible()那种破解方法。</p></blockquote>

<p>有了方法句柄，就可以执行它了。执行方法有两个：invokeExact()和invoke()。前者要求参数类型完全匹配，后者可以在不太匹配时做些修改后执行（如装箱或拆箱）。</p>

<h4>示例：反射、代理和方法句柄的使用对比</h4>

<p>现在通过一个实例来对比这三种方法。下面的代码演示了如何通过这三种方法来访问私有方法cancel()：</p>

<pre class='line-numbers language-java'><code class='language-java'>public class ThreadPoolManager {
    //...
    private void cancel(final ScheduledFuture&lt;?&gt; hndl) {
        //...
    }
    
    /* 反射方法
    * 使用方法简单示例：
    * Method meth = manager.makeReflective();
    * meth.invoke(hndl);
    */
    public Method makeReflective() {
        Method method = null;
        try {
            Class&lt;?&gt; argTypes = new Class[] {ScheduledFuture.class};
            method = ThreadPoolManager.class.getDeclaredMethod("cancel", argTypes);
            method.setAccessible(true);
        } catch(IllegalArgumentException | NoSuchMethodException | SecurityException e) {
            //...
        }
        
        return method;
    }
    
    /* 代理方法
    *  使用方法简单示例：
    *  CancelProxy proxy = manager.makeProxy();
    *  proxy.invoke(manager, hndl);
    */
    public static class CancelProxy {
        private CancelProxy() {}
        public void invoke(ThreadPoolManager mae, ScheduledFuture&lt;?&gt; hndl) {
            mae.cancel(hndl);
        }
    }
    
    public CancelProxy makeProxy() {
        return new CancelProxy();
    }
    
    /* 方法句柄
    * 使用方法简单示例：
    * MethodHandle mh = manager.makeMh();
    * mh.invokeExact(manager, hndl);
    */
    public MethodHandle makeMh() {
        MethodHandle mh;
        MethodType desc = MethodType.methodType(void.class, ScheduledFuture.class);
        try {
            mh = MethodHandles.lookup().findVirtual(ThreadPoolManager.class, "cancel", desc);
        } catch(NoSuchMethodException | IllegalAccessException e) {
            //...
        }
        
        return mh;
    }
}</code></pre>


<p>三种方法的比较：</p>

<table>
<thead>
<tr>
<th>方法 </th>
<th> 访问控制 </th>
<th> 类型纪律 </th>
<th> 性能  </th>
</tr>
</thead>
<tbody>
<tr>
<td>反射 </td>
<td> 必须使用setAccesible。会被安全管理器禁止 </td>
<td> 不匹配就抛异常 </td>
<td> 较慢</td>
</tr>
<tr>
<td>代理 </td>
<td> 内部类可以访问受限方法 </td>
<td> 静态，为了代理全部代理类，可能需要更多PermGen </td>
<td> 跟其他方法一样快</td>
</tr>
<tr>
<td>方法句柄 </td>
<td> 取决于上下文，与安全管理器没有冲突 </td>
<td> 运行时是类型安全的，不占用PermGen </td>
<td> 力求跟其他方法调用一样快</td>
</tr>
</tbody>
</table>


<p>方法句柄还有一个特性，可以在静态上下文中确定当前类。例如下面的代码改写了logger的创建方式，可以不用将类名写死：</p>

<pre class='line-numbers language-java'><code class='language-java'>Logger logger = LoggerFactory.getLogger(MyClass.class);
//可改为：
Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());</code></pre>


<h2>3. 了解类文件</h2>

<p>有时候有必要查看类文件，但它是二进制文件，和它打交道并不容易。Oracle JVM的javap这个工具可以用来探视类文件内部和反编译。</p>

<p>我们以一个简单的Java类作为示例：</p>

<pre class='line-numbers language-java'><code class='language-java'>public class Sample {
    private byte b;
    private char c;
    private double d;
    private float f;
    private int i;
    private Integer Int;
    private long l;
    private String s;
    private boolean bl;
    private int[] array;
    
    //getter, setter</code></pre>


<h3>查看类文件的方法和属性</h3>

<pre class='line-numbers language-java'><code class='language-java'>$ javap  Sample.class 
Compiled from "Sample.java"
public class com.ubone.tdd.chapter1.javaio.Sample {
  public com.ubone.tdd.chapter1.javaio.Sample();
  public byte getB();
  public void setB(byte);
  public char getC();
  //其它getter, setter方法...
}</code></pre>


<p>javap默认显示public, protected和包级protected级别的方法和属性。加上-p选项后可以显示private方法和属性。</p>

<h3>方法签名的内部形式</h3>

<p>JVM内部用的方法签名使用紧凑形式，例如int用I表示。这称为类型描述符：</p>

<ul>
<li>B: byte</li>
<li>C: char(16位Unicode字符)</li>
<li>D: double</li>
<li>F: float</li>
<li>I: int</li>
<li>J: long</li>
<li>L&lt;类型名称>: 引用类型，如：Ljava/lang/String</li>
<li>S: short</li>
<li>Z: boolean</li>
<li>[: array-of</li>
</ul>


<p>使用javap -s可以输出签名的类型描述符：</p>

<pre class='line-numbers language-java'><code class='language-java'>$ javap -s Sample.class 
Compiled from "Sample.java"
public class com.ubone.tdd.chapter1.javaio.Sample {
  public com.ubone.tdd.chapter1.javaio.Sample();
    Signature: ()V

  public byte getB();
    Signature: ()B

  public void setB(byte);
    Signature: (B)V

  public char getC();
    Signature: ()C

  public void setC(char);
    Signature: (C)V

  public double getD();
    Signature: ()D

  public void setD(double);
    Signature: (D)V

  public float getF();
    Signature: ()F

  public void setF(float);
    Signature: (F)V

  public int getI();
    Signature: ()I

  public void setI(int);
    Signature: (I)V

  public java.lang.Integer getInt();
    Signature: ()Ljava/lang/Integer;

  public void setInt(java.lang.Integer);
    Signature: (Ljava/lang/Integer;)V

  public long getL();
    Signature: ()J

  public void setL(long);
    Signature: (J)V

  public java.lang.String getS();
    Signature: ()Ljava/lang/String;

  public void setS(java.lang.String);
    Signature: (Ljava/lang/String;)V

  public boolean isBl();
    Signature: ()Z

  public void setBl(boolean);
    Signature: (Z)V

  public int[] getArray();
    Signature: ()[I

  public void setArray(int[]);
    Signature: ([I)V
}</code></pre>


<h3>常量池</h3>

<p>常量池是为类文件中的其他（常量）元素提供快捷访问方式的区域。通过javap -v可以查看常量池的信息：</p>

<pre class='line-numbers language-java'><code class='language-java'>Constant pool:
   #1 = Class              #2             //  com/ubone/tdd/chapter1/javaio/Sample
   #2 = Utf8               com/ubone/tdd/chapter1/javaio/Sample
   #3 = Class              #4             //  java/lang/Object
   #4 = Utf8               java/lang/Object
   #5 = Utf8               b
   #6 = Utf8               B
   #7 = Utf8               c
   #8 = Utf8               C
   #9 = Utf8               d
  #10 = Utf8               D
  #11 = Utf8               f
  #12 = Utf8               F
  #13 = Utf8               i
  #14 = Utf8               I
  #15 = Utf8               Int
  #16 = Utf8               Ljava/lang/Integer;
  #17 = Utf8               l
  #18 = Utf8               J  
  ...
  #70 = Utf8               getL
  #71 = Utf8               ()J
  #72 = Fieldref           #1.#73         //  com/ubone/tdd/chapter1/javaio/Sample.l:J
  #73 = NameAndType        #17:#18        //  l:J
  #74 = Utf8               setL
  #75 = Utf8               (J)V
  ...</code></pre>


<p>如上所示，常量池的条目是带有类型的，它们还会相互引用。例如类型为Class的条目会引用类型为Utf8的条目。后者是个字符串，因此第1行为类的名称。</p>

<p>72行的Fieldref定义了一个域，解析这个域需要名称、类型和它所在的类。<code>#1.#73</code>表示来自类<code>#1</code>,域为<code>#73</code>。<code>#73</code>的NameAndType描述名称和类型，分别来自17和18，即类型J(Long)，名称为<code>l</code>。</p>

<h2>4. 字节码</h2>

<p>字节码的基本特性：</p>

<ul>
<li>字节码是程序的中间表示形式，介于人类可读的源码和机器码之间。</li>
<li>字节码由javac产生。</li>
<li>某些高级语言特性在编译时已经从字节码去掉。例如for语句在字节码中被转换成分支指令。</li>
<li>每个操作码都由一个字节表示（因此叫做字节码）。</li>
<li>字节码可以进一步编译成机器码，也就是“即时编译”。</li>
</ul>


<h3>反编译类</h3>

<p>javap可以用于反编译类：</p>

<pre class='line-numbers language-java'><code class='language-java'>$ javap -c -p Sample.class 
Compiled from "Sample.java"
public class com.ubone.tdd.chapter1.javaio.Sample {
  private byte b;

  private char c;
  ...
  
    public com.ubone.tdd.chapter1.javaio.Sample();
    Code:
       0: aload_0       
       1: invokespecial #28                 // Method java/lang/Object."&lt;init&gt;":()V
       4: return        
  ...
  
  public long getL();
    Code:
       0: aload_0       
       1: getfield      #72                 // Field l:J
       4: lreturn       

  public void setL(long);
    Code:
       0: aload_0       
       1: lload_1       
       2: putfield      #72                 // Field l:J
       5: return        

</code></pre>


<p>代码前的数字表示从方法开始算起的字节码偏移量。先看构造方法，由于void构造方法总会隐式调用父类的构造方法。因此有invokespecial指令。对于方法getL()和setL()也可以看到相应的操作码和参数。</p>

<p>javac产生的字节码没有经过特别优化，是非常简单的表示形式。大部分优化工作由JIT编译器来完成。</p>

<h3>运行时环境</h3>

<p>JVM没有处理器寄存器，而是使用堆栈机完成所有的计算和操作，所以理解堆栈机的操作对理解字节码至关重要。方法在运行时需要一块内存区域作为计算堆栈来计算新值。另外，每个运行的线程都需要一个调用堆栈来记录当前正在执行的方法。来看下面的代码是如何完成计算的：</p>

<p><code>return 3 + petRecords.getNumberOfPets("Ben");</code></p>

<p>系统首先会把3压入操作数栈，然后把接收对象（petRecords）压入计算堆栈，传入的参数尾随其后。然后invoke操作符会调用方法getNumberOfPets，把控制权移交给被调用的方法。进入新方法后，需要启用不同的操作数栈，所以已经在调用者操作数栈中的值不可能影响被调用方法的计算结果。</p>

<p>当getNumberOfPets完成时，返回结果会被放到调用者的操作数栈中，进程中与getNumberOfPets相关的部分也会从调用堆栈中移走。然后相加运算得到结果。</p>

<h3>操作码</h3>

<p>JVM字节码由操作码（opcode）序列构成，每个指令后可能会跟一些参数。每个操作码由一个单字节值表示，所以最多有255个操作码。目前用了200个左右。大致可以分为以下几类，摘要说明如下：</p>

<blockquote><ul>
<li>参数：操作码参数。如果参数出现在括号中，表示可选。以i打头的参数用来作为常量池或局部变量中的查询索引的几个字节。如果有多个此类参数，会合并在一直。例如i1,i2表示从这两个字节生成一个16位的索引。</li>
<li>堆栈布局：展示栈在操作码执行前后的状态。</li>
<li>表中操作码并不全，只用于示例。</li>
</ul>
</blockquote>

<p>加载和储存操作码，这个族系负责将值加载到栈或者检索值。有很多不同形式的变体。如dload操作码把双精度数从局部变量加载到栈上。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-05-5-4.jpg" alt="image" /></p>

<p>数学运算操作码用来执行数学运算。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-05-5-5.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-05-5-6.jpg" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-05-5-7.jpg" alt="image" /></p>

<p><strong>平台操作操作码</strong></p>

<p>在字节码这一级，构造方法被转换成带有特殊名称<init>的方法。不能由用户代码调用，但可以由字节码调用。这便形成了一个与对象创建直接相关的不同的字节码模式：new之后跟着一个dup，然后是一个调用<init>方法的invokespecial.</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-05-5-8.jpg" alt="image" /></p>

<blockquote><p>为了节省字节，很多字节码都有快捷方式。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java并发编程(四)]]></title>
    <link href="http://blog.ubone.com/blog/2014/12/01/javabing-fa-bian-cheng-si/"/>
    <updated>2014-12-01T22:43:50+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/12/01/javabing-fa-bian-cheng-si</id>
    <content type="html"><![CDATA[<p>在学习了《Java编程思想》中关于<a href="http://blog.ubone.com/blog/2014/09/02/javabing-fa-bian-cheng-san/">并发编程</a>的内容后，继续学习Java并发编程。</p>

<!--more-->


<h2>1. 常用的并发构件</h2>

<h3>为什么是synchronized?</h3>

<p>这个单词的意思是同步，那么Java中synchronized表示什么意思呢？其实就是同步被锁定对象的主内存块。</p>

<ul>
<li>当进入一个synchronized代码块时，持有锁的线程和被锁定对象主内存中的视图会进行同步。</li>
<li>当synchronized代码块执行完之后，被锁定对象所做的任何修改会在线程锁释放之前刷回到主内存中。</li>
</ul>


<p>而volatile变量，在使用之前总是会从主内存中再读出来。线程所写的值总会在指令完成之前被刷回到主内存中。volatile变量不会引入线程锁，是真正线程安全的。<strong>但只有写入时不依赖当前状态（读取的状态）的变量才应该声明为volatile变量。对于要关注当前状态的变量，只能借助线程锁保证绝对安全性。</strong></p>

<h3>Lock有什么好处？</h3>

<ul>
<li>添加不同类型的锁，比如读取锁和写入锁。</li>
<li>对锁的阻塞没有限制，即允许在一个方法中上锁，在另一个方法中解锁。</li>
<li>如果线程得不到锁，比如锁由另外一个线程持有，就允许该线程后退或继续执行，或者做点别的事情——运用tryLock()方法。</li>
<li>允许线程尝试取锁，并可以在超过等待时间后放弃。</li>
</ul>


<p>Lock接口的两个实现类：</p>

<ul>
<li>ReentranLock: 本质上与同步块一样，但更灵活些。</li>
<li>ReentranReadWriteLock: 在读多写入的时候，性能更好。</li>
</ul>


<h3>ConcurrentHashMap</h3>

<p>ConcurrentHashMap是HashMap的并发版本，改进了Collections.synchronizedMap()功能。它是concurrent包中最有用的类之一，不仅提供了多线程的安全性，而且性能更优。它提供了原子操作的新方法：</p>

<ul>
<li>putIfAbsent(): 如果没有对应键，则将键值对添加到HashMap中。</li>
<li>remove(): 如果键存在，且值与当前状态相等，则用原子方式移除键值对。</li>
<li>replace(): 当键存在时，进行原子替换。</li>
</ul>


<h3>CopyOnWriteArrayList</h3>

<p>它是标准ArrayList的替代品，通过copy-on-write来实现线程安全性，对修改列表的任何操作都会创建一个新复本。当快速、一致的数据快照（不同的读取器读到的数据偶尔可能会不一样）比完美的同步以及性能上的突破更重要时，这种共享数据的方法非常理想，经常出现在非关键任务中。</p>

<h3>Queue</h3>

<p>Java有些多线程编程模型在很大程度上依赖于Queue实现线程安全性。BlockingQueue是最简单的实现。向队列put()时，如果队列满则放入线程会等待。从队列take()时，如果队列空，则取出线程阻塞。</p>

<p>Queue接口全是泛型<code>Queue&lt;E&gt;</code>，利用这一点把工作项封装到一个人工容器中会更方便。例如工作单元MyAwesomeClass，与其用<code>BlockingQueue&lt;MyAwesomeClass&gt;</code>不如使用<code>BlockingQueue&lt;WorkUnit&lt;MyAwesomeClass&gt;&gt;</code>：</p>

<pre class='line-numbers language-java'><code class='language-java'>public class WorkUnit&lt;T&gt; {
    private final T workUnit;
    public T getWork() {return workUnit;}
    public WorkUnit(T workUnit) {
        this.workUnit = workUnit;
    }
}</code></pre>


<p>有了这层间接引用，可以添加额外的元数据而不用牺牲MyAwesomeClass的完整性。例如在WorkUnit中添加用于测试、性能指标和运行时系统信息等。</p>

<p>除了基本的put()和take()方法，BlockingQueue还提供了还超时的放入和取出方法：offer(E e, long timeout, TimeUnit unit)和poll(long timeout, TimeUnit unit)。</p>

<p>Java 7还引入了TransferQueue，本质上是多了transfer()操作的BlockingQueue。在BlockingQueue中，当上游线程池比下游快时，可能会引发一些问题，导致LinkedBlockingQueue溢出。反之，如果下游比上游快，则可能队列经常空着。TransferQueue可以优化这种情况，调控上/下游的速度。当消费线程在等待时，transfer()操作会马上把工作项传给它，否则就会阻塞直到取走工作项的线程出现。可以把这看做“挂号信”选项，即正在处理工作项的线程在交付当前工作项之前不会开始其他工作项的工作。</p>

<p>用TransferQueue取代BlockingQueue的代码性能可能会更好，因为前者的实现考虑了现代编译器和处理器的特性，执行效率更高。</p>

<h2>2. 控制执行</h2>

<p>如果每个工作单元都启动一个新线程执行，效率会太低。因此可以利用线程池来执行工作单元/任务。</p>

<h3>任务建模</h3>

<p>任务建模可以采用三种办法：Callable, Future接口和FutureTask类。</p>

<h4>Callable接口</h4>

<p>Callable接口代表一段可以调用并返回结果的代码，典型用法是匿名实现类：</p>

<pre class='line-numbers language-java'><code class='language-java'>final MyObject obj = new MyObject();

Callable&lt;String&gt; cb = new Callable&lt;String&gt;() {
    public String call() throws Exception {
        return obj.someMethod();
    }
};

String s = cb.call();</code></pre>


<h4>Future接口</h4>

<p>Future接口用来表示异步任务。主要有三个方法：</p>

<ul>
<li>get()，获取结果，如果没执行完会阻塞，直到能取得结果。</li>
<li>cancel()，在结束前取消。</li>
<li>isDonw()，判断是否结束。</li>
</ul>


<pre class='line-numbers language-java'><code class='language-java'>interface ArchiveSearcher { String search(String target); }
 class App {
   ExecutorService executor = ...
   ArchiveSearcher searcher = ...
   void showSearch(final String target)
       throws InterruptedException {
     Future&lt;String&gt; future
       = executor.submit(new Callable&lt;String&gt;() {
         public String call() {
             return searcher.search(target);
         }});
     displayOtherThings(); // do other things while searching
     try {
       displayText(future.get()); // use future
     } catch (ExecutionException ex) { cleanup(); return; }
   }
 }</code></pre>


<h4>FutureTask类</h4>

<p>FutureTask类是Future接口的常用实现类，实现了Runnable接口，因此可以由执行者调度。它提供的方法基本是Future和Runnable接口的组合：get(), cancel(), isDone(), isCancelled()和run()。它还提供了两个很方便的构造器：一个以Callable为参数，另一个以Runnable为参数。</p>

<pre class='line-numbers language-java'><code class='language-java'>FutureTask&lt;String&gt; future =
       new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() {
         public String call() {
           return searcher.search(target);
       }});
executor.execute(future);</code></pre>


<h3>ScheduledThreadPoolExecutor(STPE)</h3>

<p>STPE是Executors类工厂方法的众多执行者之一。它有以下特点：</p>

<ul>
<li>可以预定线程池大小，也可自适应</li>
<li>所安排的任务可以定期执行，也可只运行一次。</li>
</ul>


<pre class='line-numbers language-java'><code class='language-java'>ScheduledExecutorService stpe = Executors.newScheduledThreadPool(2);

final Runnable msgReader = new Runnable() {
    public void run() {
        //...
    }
};

//每10毫秒唤醒一个线程。该线程可以尝试poll一个队列...
ScheduledFuture&lt;?&gt; hndl = stpe.scheduleAtFixedRate(msgReader, 10, 10, TimeUnit.MILLISECONDS);</code></pre>


<h2>3.分支/合并框架</h2>

<p>这是Java 7重点突出的框架之一，用于轻量级并发，实现线程池中任务的自动调度。</p>

<p>先来看看之前的并发算法可能存在的问题。如果某个线程的运行队列都是小任务，而另一个全是大任务。那么小任务的线程可能会空闲很多。而基于Work-Stealing（工作窃取）算法的ForkJoin则可以很好地解决此问题。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-12-02-fork-join.GIF" alt="image" /></p>

<ul>
<li>分支/合并框架引入一种新的执行者服务，称为ForkJoinPool</li>
<li>ForkJoinPool处理比线程更小的并发单元ForkJoinTask</li>
<li>ForkJoinTask是一种由ForkJoinPool以更轻量化的方式所调度的抽象</li>
<li>通常使用两种任务（尽管都表示为ForkJoinTask实例）：“小型”任务是无需耗费太多时间就可以直接执行的任务；“大型”任务是需要分解（可能多次分解）后再执行的任务。</li>
</ul>


<p>这个框架的关键特性之一就是这些轻量的任务都能生成新的ForkJoinTask实例，而这些实例将仍由执行它们父任务的线程池来安排调度。这就是分而治之。例如在归并算法中，就可以将左侧、右侧的排序任务视为一个ForkJoinTask，在递归过程中，不断产生小型任务执行。下面的示例是一个对微博按时间归并排序的例子：</p>

<pre class='line-numbers language-java'><code class='language-java'>//RecursiveAction继承自ForkJoinTask&lt;Void&gt;
public class MicroBlogUpdateSorter extends RecursiveAction {
  private static final int SMALL_ENOUGH = 32;
  private final Update[] updates;
  private final int start, end;
  private final Update[] result;

  public MicroBlogUpdateSorter(Update[] updates_) {
    this(updates_, 0, updates_.length);
  }

  public MicroBlogUpdateSorter(Update[] upds_, int startPos_, int endPos_) {
    start = startPos_;
    end = endPos_;
    updates = upds_;
    result = new Update[updates.length];
  }

  private void merge(MicroBlogUpdateSorter left_, MicroBlogUpdateSorter right_) {
    int i = 0;
    int lCt = 0;
    int rCt = 0;
    while (lCt &lt; left_.size() && rCt &lt; right_.size()) {
      result[i++] = (left_.result[lCt].compareTo(right_.result[rCt]) &lt; 0) ? left_.result[lCt++]
          : right_.result[rCt++];
    }
    while (lCt &lt; left_.size())
      result[i++] = left_.result[lCt++];
    while (rCt &lt; right_.size())
      result[i++] = right_.result[rCt++];
  }

  public int size() {
    return end - start;
  }

  public Update[] getResult() {
    return result;
  }

  @Override
  protected void compute() {
      //如果数组太小，就用系统排序
    if (size() &lt; SMALL_ENOUGH) {
      System.arraycopy(updates, start, result, 0, size());
      Arrays.sort(result, 0, size());
    } else {
      int mid = size() / 2;
      MicroBlogUpdateSorter left = new MicroBlogUpdateSorter(updates, start,
          start + mid);
      MicroBlogUpdateSorter right = new MicroBlogUpdateSorter(updates, start
          + mid, end);
      invokeAll(left, right);
      merge(left, right);
    }
  }
  
    public static void main() {
    List&lt;Update&gt; lu = new ArrayList&lt;Update&gt;();
    String text = "";
    final Update.Builder ub = new Update.Builder();
    final Author a = new Author("Tallulah");

    for (int i = 0; i &lt; 256; i++) {
      text = text + "X";
      long now = System.currentTimeMillis();
      lu.add(ub.author(a).updateText(text).createTime(now).build());
      try {
        Thread.sleep(1);
      } catch (InterruptedException e) {
      }
    }
    Collections.shuffle(lu);
    Update[] updates = lu.toArray(new Update[0]); // Avoid allocation by passing
                                                  // zero-sized array
    MicroBlogUpdateSorter sorter = new MicroBlogUpdateSorter(updates);
    ForkJoinPool pool = new ForkJoinPool(4);
    pool.invoke(sorter);

    for (Update u : sorter.getResult()) {
      System.out.println(u);
    }
  }
}</code></pre>


<p>如果下面这些问题答案是肯定的，那么就适合于使用分支/合并框架：</p>

<ul>
<li>问题的子任务是否无需与其他子任务有显式的协作或同步也可以工作？</li>
<li>子任务是不是不会对数据进行修改，只是经过计算得出结果？</li>
<li>对于子任务来说，分而治之是不是很自然的事？子任务是不是会创建更多的子任务，而且它们要比派生出它们的任务粒度更细？</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java NIO.2]]></title>
    <link href="http://blog.ubone.com/blog/2014/11/23/java-nio-dot-2/"/>
    <updated>2014-11-23T10:59:37+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/11/23/java-nio-dot-2</id>
    <content type="html"><![CDATA[<p>Java 7提供了新的NIO(或称为NIO.2, JSR-203)，这是一组新的类和方法，用于取代File类与文件系统的交互，提供新的异步处理类并简化Socket与通道的编码工作。</p>

<!--more-->


<p>在Java 1.4之前，Java缺乏对非阻塞I/O的支持，1.4引入了非阻塞I/O，为I/O操作抽象出缓冲区和通道层；提供字符集的编码和解码能力；能够将文件映射为内存数据；实现正则表达式。Java 7进一步扩展了NIO的能力。</p>

<h2>1. PATH</h2>

<p>Path相关的类包括：</p>

<ul>
<li>Path：获取路径信息</li>
<li>Paths：工具类，提供返回一个路径的辅助方法</li>
<li>FileSystem：与文件系统交互的类</li>
<li>FileSystems：工具类，提供各种方法。</li>
</ul>


<p>Path不仅用于传统的文件系统，也能表示zip或jar这样的文件系统。</p>

<pre class='line-numbers language-java'><code class='language-java'>//创建Path
Path listing = Paths.get("/user/bin/zip")；
//相当于
Path listing = FileSystems.getDefault().getPath("/user/bin/zip");

//获取Path信息：
listing.getFileName(): zip
listing.getNameCount(): 3
listing.subpath(0, 2): /user/bin
listing.getParent(): /user/bin
listing.getRoot(): /</code></pre>


<p>如果Path是一个文件的路径，有时需要去除冗余信息。例如去除表示当前路径的<code>./</code>，或者该文件只是个符号链接，指向了另一个真正的位置，此时需要得到真实路径。</p>

<pre class='line-numbers language-java'><code class='language-java'>//移除冗余
Path testPath = Paths.get("./test.java");
Path normalizedPath = testPath.normalize();

//获取绝对路径
Path absolutePath = testPath.toAbsolutePath();
//获取绝对路径并去除冗余信息，或者获取符号连接的真实路径
Path realPath = testPath.toRealPath();</code></pre>


<p>合并路径与路径比较。</p>

<pre class='line-numbers language-java'><code class='language-java'>//合并
Path prefix = Paths.get("/usr");
Path completePath = prefix.resolve("mxs");
//completePath: /usr/mxs

//比较
Path path1 = Paths.get("/Users/mxs/Documents/Blog/");
Path path2 = Paths.get("/Users/mxs");
path1.relativize(path2): ../..
path2.relativize(path1): Documents/Blog</code></pre>


<p>新的API完全替换了java.io.File类，在处理遗留代码时，可能将其进行互换：</p>

<pre class='line-numbers language-java'><code class='language-java'>File file = new File("../abcd.txt");
Path listing = file.toPath();
file = listing.toFile();</code></pre>


<h2>2. 处理目录与目录树</h2>

<p>新的DirectoryStream<T>接口实现了目录相关的操作：</p>

<ul>
<li>循环遍历目录中的子项</li>
<li>用glob表达式（如<code>*Foobar*</code>）进行目录子项的匹配和MIME内容检测（如text/xml文件）</li>
<li>用walkFileTree实现递归移动、复制和删除操作</li>
</ul>


<p><strong>在目录中查找文件：</strong></p>

<pre class='line-numbers language-java'><code class='language-java'>Path dir = Paths.get("/user/mxs/Documents");

try(DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir, "*.properties")) {
    for(Path entry : stream){
        System.out.println(entry.getFileName());    
    }
} catch(IOException e) {
    //...
}</code></pre>


<p><strong>遍历目录树。</strong>Files.walkFileTree方法是遍历目录树的关键，该方法定义如下：</p>

<p><code>Files.walkFileTree(Path startingDir, FileVisitor&lt;? super Path&gt; visitor);
</code></p>

<p>其中Visitor是一个接口，包括5个方法，但一般使用Java的默认实现SimpleFileVisitor就可以了。</p>

<pre class='line-numbers language-java'><code class='language-java'>public void walk() {
    Path dir = Paths.get("/code/src");
    Files.walkFileTree(dir, new FindJavaVisitor());
}

private static class FindJavaVisitor extends SimpleFileVisitor&lt;Path&gt; {
    @Override
    public FileVisitresult visitFile(Path file, BasicFileAttributes attrs) {
        if (file.toString().endsWith(".java")) {
            //...
        }
        
        return FileVisitResult.CONTINUE;
    }
}</code></pre>


<p>需要注意的是，walkFileTree方法不会自动跟随符号链接（为了确保递归等操作的安全性）。因此如果你需要跟随符号链接，就需要检查相应属性并执行相应操作。</p>

<h2>3. 文件系统I/O</h2>

<p>在NIO.2中，Files和WatchService是两个重要的基础类。前者用于复制、移动、删除或处理文件，后者用于监视文件或目录，发出定制通知等。</p>

<h3>3.1 创建和删除文件</h3>

<pre class='line-numbers language-java'><code class='language-java'>Path target = Paths.get("/Users/mxs/Document/mystuff.txt");
Path file = Files.createFile(target);</code></pre>


<p>如果需要设置文件属性，如读、写和执行的权限，则需要设置FileAttribute，但文件属性与操作系统相关，因此要使用与操作系统相关的文件权限类。以下是POSIX文件系统的示例(其它文件系统参考java.nio.file.attribute.*FilePermission类)：</p>

<pre class='line-numbers language-java'><code class='language-java'>Set&lt;PosixFilePermission&gt; perms = PosixFilePermissions.fromString("rw-rw-rw-");
FileAttribute&lt;Set&lt;PosixFilePermission&gt;&gt; attr = PosixFilePermissions.asFileAttribute(perms);
Files.createFile(target, attr);</code></pre>


<p>删除文件只需要调用<code>Files.delete(target)</code>方法。</p>

<h3>3.2 文件复制与移动</h3>

<pre class='line-numbers language-java'><code class='language-java'>Path source = Paths.get("c:\\My Documents\\stuff.txt");
Path target = Paths.get("D:\backup\stuff.txt");
Files.copy(source, target);

//复制时还可以设置CopyOptions选项（变参，可多个。ATOMIC_MOVE确保两边都成功，否则回滚）
import static java.nio.file.StandardCopyOption.*;
Files.copy(source, target, REPLACE_EXISTING, COPY_ATTRIBUTES, ATOMIC_MOVE); 

//移动
Files.move(source, target);
Files.move(source, target, CopyOptions);</code></pre>


<h3>3.3 文件属性</h3>

<p>由于不同的文件系统属性不同，因此Java中的文件属性分为基本文件属性、特定文件属性。前者是各文件系统通用的文件属性。</p>

<pre class='line-numbers language-java'><code class='language-java'>Path zip = Paths.get("/usr/bin/zip");
Files.getLastModifiedTime(zip);
Files.size(zip);
Files.isSymbolicLink(zip);
Files.isDirectory(zip);
Files.readAttributes(zip, "*"); //批量读取属性</code></pre>


<p>特定文件属性独立于某个操作系统。以POSIX文件系统为例：</p>

<pre class='line-numbers language-java'><code class='language-java'>//获取文件属性
PosixFileAttributes attrs = Files.readAttributes(zip, PosixFileAttributes.class);

//修改属性
Set&lt;PosixFilePermission&gt; permissions = attrs.permissions();
permissions.clear;
permissions.add(GROUP_READ);
//...
Files.setPosixFilePermissions(zip, permissions);</code></pre>


<p>符号链接的处理：</p>

<pre class='line-numbers language-java'><code class='language-java'>Path file = Paths.get("/opt/platform/java");
if (Files.isSymbolicLink(file)) {
    file = Files.readSymbolicLink(file);
}
//继续处理文件相关操作
Files.readAttributes(file, BasicFileAttributes.class);</code></pre>


<h3>3.4. 快速读写数据</h3>

<p>Files工具类提供了更方便的方法来读写数据：</p>

<pre class='line-numbers language-java'><code class='language-java'>Path logFile = Paths.get("/tmp/app.log");
try(BufferedReader reader = 
    Files.newBufferedReader(logFile, StandardCharsets.UTF_8)) {
    String line;
    while((line = reader.readLine()) != null) {
        //...
    }
}

//写入
try(BufferedWriter writer = 
    Files.newBufferedWrite(logFile, StandardCharsets.UTF_8, StandardOpenOption.WRITE)) //变参，可多个
{ 
    writer.write("Hello!");
}</code></pre>


<p>Files工具类提供的方法还有<code>newInputStream()</code>, <code>newOutputStream()</code>等方法，用于配合现有IO类。还有更方便的方式：</p>

<pre class='line-numbers language-java'><code class='language-java'>List&lt;String&gt; lines = Files.readAllLines(logFile, StandardCharsets.UTF_8);
byte[] bytes = Files.readAllBytes(logFile);</code></pre>


<h3>3.5. 文件修改通知</h3>

<p>WatchService可用于监测文件或目录的变化，可监测的事件包括：ENTRY_CREATE, ENTRY_DELETE, OVERFLOW(事件已经丢弃或丢失)。</p>

<pre class='line-numbers language-java'><code class='language-java'>import static java.nio.file.StandardWatchEventKinds.*;

try {
    WatchService watcher = FileSystems.getDefault().newWatchService();
    Path dir = FileSystems.getDefault().getPath("/usr/mxs");
    WatchKey key = dir.register(watcher, ENTRY_MODIFY);
    
    while(!shutdown ) { //一个标志，判断循环是否该结束
        key = watcher.take();
        for (WatchEvent&lt;?&gt; event: key.pollEvents()) {
            if (event.kind() == ENTRY_MODIFY) {
                //dir changed
            }
        }
        key.reset(); 
    }
} catch(IOException | InterruptedException e) {
    //...
}</code></pre>


<h3>3.6 SeekableByteChannel</h3>

<p>这是Java 7引入的新接口，用于改变字节通道的位置和大小。例如用多个线程去分析一个大型日志文件的字节通道。FileChannel是这个接口的一种实现，下面的示例读取日志文件的最后1000个字符：</p>

<pre class='line-numbers language-java'><code class='language-java'>Path logFile = Paths.get("c:\\temp.log");
ByteBuffer buffer = ByteBuffer.allocate(1024);
FileChannel channel = FileChannel.open(logFile, StandardOpenOption.READ);
channel.read(buffer, channel.size() - 1000);</code></pre>


<h2>4. 异步I/O操作</h2>

<p>异步I/O操作主要有两种方式：Future和回调。Java 7提供了三个新的异步通道：</p>

<ul>
<li>AsynchronousFileChannel 用于文件I/O</li>
<li>AsynchronousSocketChannel 用于Socket I/O, 支持超时</li>
<li>AsynchronousServerSocketChannel 用于Socket接受异步连接</li>
</ul>


<h3>4.1 Future方式</h3>

<pre class='line-numbers language-java'><code class='language-java'>try {
    Path file = Paths.get("/usr/mxs/foobar.txt");
    AsynchronousFileChannel channel = AsynchronousFileChannel.open(file);
    
    //读取100 000字节
    ByteBuffer buffer = ByteBuffer.allocate(100_1000); 
    Future&lt;Integer&gt; result = channel.read(buffer, 0);//返回值为Integer
    
    //如果未结束
    while(! result.isDone()) {
        //...干点别的事。
    }
    
    //获取结果
    Integer byteRead = result.get();
} catch(IOException | ExecutionException | InterruptedException e) {
    //...
}</code></pre>


<h3>4.2 回调方式</h3>

<p>CompletionHandler&lt;V, A>是回调的接口。V表示结果类型，A是提供结果的附着对象。</p>

<pre class='line-numbers language-java'><code class='language-java'>try {
    Path file = Paths.get("/usr/mxs/foobar.txt");
    AsynchronousFileChannel channel = AsynchronousFileChannel.open(file);
    //读取100 000字节
    ByteBuffer buffer = ByteBuffer.allocate(100_1000); 
    
    channel.read(buffer, 0, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;(){
        public void completed(Integer result, ByteBuffer attachment) {
            //完成时的回调方法
        }
        
        public void failed(Throwable exception, ByteBuffer attachment) {
            //失败时的回调方法
        }
    });
} catch(IOException e) {
    //...
}</code></pre>


<h2>5. Socket与Channel整合</h2>

<p>NetworkChannel把Socket和Channel结合起来，更好地应对网络编程。而MulticastChannel则可以用于像BitTorrent这样的多播编程。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 7的6个新特性]]></title>
    <link href="http://blog.ubone.com/blog/2014/11/18/java-7de-6ge-xin-te-xing/"/>
    <updated>2014-11-18T22:20:52+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/11/18/java-7de-6ge-xin-te-xing</id>
    <content type="html"><![CDATA[<p>Java 8早都出来了，现在来了解一下Java 7语言上的几个新特性。 :) switch语句支持String、数字常量的新形式、改进的异常处理、TWR语句、钻石语法和变参警告位置的修改。</p>

<!--more-->


<h2>1. switch语句支持String</h2>

<pre class='line-numbers language-java'><code class='language-java'>public void printDay(String dayOfWeek) {
    switch(dayOfWeek) {
        case "Sunday": System.out.println("周日"); break;
        case "Saturday": System.out.println("周六"); break;
        ...
        default: System.out.println("不知道"); break;
    }
}</code></pre>


<h2>2. 更强的数值文本表示法</h2>

<pre class='line-numbers language-java'><code class='language-java'>int x = 0b1100110; //0b表示二进制
int bitPattern = 0b0001_1100_0011; //也可以加下划线
long longValue = 2_111_000_888L; //加下划线便于阅读</code></pre>


<h2>3. 改善的异常处理</h2>

<pre class='line-numbers language-java'><code class='language-java'>try {
    String fileText = getFile(fileName);
    cfg = verifyConfig(parseConfig(fileText));
} catch(FileNotFoundException | ParseException | ConfigurationException e) {
    //可以用或来表示可能的异常
    ...
} catch(IOException iox) {
    ...
}</code></pre>


<p>另一个新语法对需要重新抛出异常时很有用：</p>

<pre class='line-numbers language-java'><code class='language-java'>try {
    doSomethingWhichMightThrowIOException();
    doSomethingElseWhichMightThrowSQLException();
} catch (final Exception e) {
    ...
    //不再是抛出笼统的Exception，而是抛出实际的异常。
    //final不是必须的，但留着提个醒有好处。
    throw e;
}</code></pre>


<h2>4. TWR(try-with-resources)</h2>

<p>这个很有用，特别是io操作时，可以抛掉大串丑陋的代码了。</p>

<pre class='line-numbers language-java'><code class='language-java'>try (
    OutputStream out = new FileOutputStream(file);
    InputStream is = url.openStream()
) {
    byte[] buf = new byte[4096];
    int len;
    while (len = is.read(buf)) &gt; 0)
        out.write(buf, 0, len);
}</code></pre>


<p>上面的代码将资源放在try的圆括号内，当处理完后会自动关闭！但一定要注意不要嵌套创建，否则可能无法正确关闭。一定要声明变量。例如下面的代码就应该修改：</p>

<pre class='line-numbers language-java'><code class='language-java'>try (ObjectInputStream in = 
    new ObjectInputStream(
        new FileInputStream("someFile.bin"))) {
    ...
}

//要改为：
try (
    FileInputStream fin = new FileInputStream("someFile.bin");
    ObjectInputStream in = new ObjectInputStream(fin)) {
    ...
}
</code></pre>


<p>TWR特性依赖于try从句中的资源类实现新接口AutoCloseable。Java 7平台的大多数资源都已经修改过了。</p>

<h2>5. 钻石语法</h2>

<pre class='line-numbers language-java'><code class='language-java'>//不用这么麻烦了：
Map&lt;Integer, Map&lt;String, String&gt;&gt; userList = new HashMap&lt;Integer, Map&lt;String, String&gt;&gt;();

//可以直接写成：
Map&lt;Integer, Map&lt;String, String&gt;&gt; userList = new HashMap&lt;&gt;();</code></pre>


<h2>6. 简化变参方法调用</h2>

<p>在Java 7之前，如果泛型和变参结合起来会怎么样？</p>

<pre class='line-numbers language-java'><code class='language-java'>public static &lt;T&gt; Collection&lt;T&gt; doSomething(T... entries) {
    ...
}</code></pre>


<p>Java处理变参实际上是把它放到一个编译器自动创建的数组中。但我们知道泛型的实现其实是通过<a href="http://blog.ubone.com/blog/2014/07/02/javafan-xing/">擦拭法</a>实现的。所以Java数组不支持泛型:</p>

<pre class='line-numbers language-java'><code class='language-java'>HashMap&lt;String, String&gt;[] a = new HashMap&lt;String, String&gt;[3]; //编译错误

HashMap&lt;String, String&gt;[] a = new HashMap[3]; //编译可通过，但会有警告：
//Type safety: The expression of type HashMap[] needs unchecked conversion to conform to HashMap&lt;String,String&gt;[]</code></pre>


<p>因此，当泛型遇到变参时，编译器只好给你个警告。但这个问题更应该由API的设计者去关注，而不是API使用者。所以Java 7把警告信息挪到了定义API的地方。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[B树]]></title>
    <link href="http://blog.ubone.com/blog/2014/11/17/bshu/"/>
    <updated>2014-11-17T21:44:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/11/17/bshu</id>
    <content type="html"><![CDATA[<p>B树就是B-树，英语原文为B-Tree，但不知道以前的翻译为何要翻译成B-树。它是对平衡树的扩展，支持对保存在磁盘或网络上的符号表进行外部查找。只需要4～5个指向一小块数据的引用就可以支持在含有数百亿或者更多元素的符号表中进行查找和插入操作。</p>

<!--more-->


<h2>1. B树</h2>

<p>B树与2-3树的关键不同在于，数据不会保存在树中，而是会构造一棵由键的副本组成的树。每个副本都关联着一条链接。这种方式能够更加方便地将索引和符号表本身分开。与2-3树一样，也限制了“键-链接”对的上下数量界限。对于M阶B树，每个结点最多含有M-1对键和链接，最少含有M/2对键和链接。根结点例外，可以含有少于M/2对键和链接，但不能少于2对。M必须是正偶数。</p>

<p>“页”表示一块连续的数据，用“探查”表示访问一个页。一个页可能是本地计算机上的一个文件，也可能是另一计算机上的一网页等等。对于B树，使用两种不同类型的结点：</p>

<ol>
<li>内部结点：含有与页相关联的键的副本。</li>
<li>外部结点：含有指向实际数据的引用。</li>
</ol>


<p>内部结点中的每个键都与一个结点相关联，以此结点为根的子树中，所有的键都大于等于与此结点关联的键，但小于原内部结点中的更大的键（如果存在的话）。为了描述方便，使用一个特殊的哨兵键“*”，它小于其他所有键。一开始B树只有一个根结点，并且根结点只有哨兵键。同时符号表不含有重复键，但B树中会使用键的多个副本来引导查找。一棵B树如下图所示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-17-btree.jpg" alt="image" /></p>

<h2>2. 查找与插入</h2>

<p>B树中查找的方法是在可能含有被查找键的唯一子树中进行递归搜索。当且仅当被查找的键包含在集合中时，每次查找便会结束于一个外部结点。在内部结点中遇到被查找的键的副本时就判断查找命中并结束，但总会找到相应的外部结点。</p>

<p>在查找时，从根结点开始，根据被查找的键选择当前结点中的适当区间并根据适当的链接从一个结点移动到下一个结点。最终，查找过程会到达树底的一个含有键的页。如果被查找的键在该页中，查找命中并结束；如果不在，则查找未命中。</p>

<p>和2-3树一样，要在树的底部插入一个新键，可以使用递归代码。如果空间不足，那么可以允许被插入的结点暂时“溢出”（也就是利用最后一个结点），并在递归调用后向上不断分裂结点，直到根结点。如果根结点也溢出就把它分裂成两个结点。如下图所示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-17-btreeinsert.jpg" alt="image" /></p>

<h2>3. 数据表示与实现</h2>

<p>我们将B树结点的表示方法及其操作封装在Page API中。它可以关联键与指向Page对象的链接，支持检测页是否溢出、分裂页并区分内部页和外部页的操作。可以将Page看作一张符号表，但是是保存在外部介质上。Page<Key> API定义如下：</p>

<table>
<thead>
<tr>
<th>方法 </th>
<th> 说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Page(boolean bottom) </td>
<td> 创建并打开一个页</td>
</tr>
<tr>
<td>void close() </td>
<td> 关闭页</td>
</tr>
<tr>
<td>void add(Key key) </td>
<td> 将键插入（外部的）页中</td>
</tr>
<tr>
<td>void add(Page p) </td>
<td> 打开p，向这个（内部）而中插入一个条目，并将p和p中的最小键相关联</td>
</tr>
<tr>
<td>boolean isExternal() </td>
<td> 这是一个外部页吗</td>
</tr>
<tr>
<td>boolean contains(Key key) </td>
<td> 键key在页中吗</td>
</tr>
<tr>
<td>Page next(Key key) </td>
<td> 可能含有键key的子树</td>
</tr>
<tr>
<td>boolean isFull() </td>
<td> 页是否已经溢出</td>
</tr>
<tr>
<td>Page split() </td>
<td> 将较大的中间键移动到一个新页中</td>
</tr>
<tr>
<td>Iterable<Key> keys() </td>
<td> 页中所有键的迭代器</td>
</tr>
</tbody>
</table>


<p>open和close操作是指将外部页读入内存和将内存内容写加外部页（如果需要的话）的过程。</p>

<p>内部页的add方法是一个符号表操作，将给定页和以该页为根结点的子树中的最小键关联起来。外部页的add和contains方法和SET中相应的方法类似。</p>

<p>最重要的是split方法，分裂一张饱和页时，将排序后位置正好大于M/2的键移动到一个新的Page对象中，并返回该对象的引用。</p>

<p>有了Page，B树集合的实现就简单了：</p>

<pre class='line-numbers language-java'><code class='language-java'>public class BTreeSET&lt;Key extends Comparable&lt;Key&gt;&gt; {
    private Page root = new Page(true);
    
    public BTreeSET(Key sentinel) {
        add(sentinel);
    }
    
    public boolean contains(Key key) {
        return contains(root, key);
    }
    
    private boolean contains(Page h, Key key) {
        if (h.isExternal()) return h.contains(key);
        return contains(h.next(key), key);
    }
    
    public void add(Key key) {
        add(root, key);
        if (root.isFull()) {
            Page lefthalf = root;
            Page righthalf = root.split();
            root = new Page(false);
            root.add(lefthalf);
            root.add(righthalf);
        }
    }
    
    public void add(Page h, Key key) {
        if (h.isExternal()) {
            h.add(key);
            return;
        }
        
        Page next = h.next(key);
        add(next, key);
        if (next.isFull())
            h.add(next.split());        
        next.close();
    }   
}</code></pre>


<h2>4. 性能与空间</h2>

<p><strong>B树最重要的性质就是，在实际应用中对于适当的参数M，查找的成本是常数级别的。</strong></p>

<blockquote><p>含有N个元素的M阶B树中的一次查找或者插入操作需要log<sub>M</sub>N ~ log<sub>M/2</sub>N 次探查，在实际情况下这基本是一个常数。</p></blockquote>

<p>B树的空间至少是半满的，在最坏的情况下，B树所需的空间是所有键占用的实际空间的两倍再加上链接所需的空间。对于随机键，B树浪费的空间约占44%。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单词查找树]]></title>
    <link href="http://blog.ubone.com/blog/2014/11/16/dan-ci-cha-zhao-shu/"/>
    <updated>2014-11-16T22:37:38+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/11/16/dan-ci-cha-zhao-shu</id>
    <content type="html"><![CDATA[<p>在<a href="http://blog.ubone.com/blog/2014/10/02/cha-zhao-suan-fa-fu-hao-biao/">符号表</a>中学习了二叉树、红黑树等，单词查找树比这些通用算法更加有效。它查找命中所需的时间与被查找的键的长度成正比，查找未命中只需检查若干个字符。这样的性能是相当惊人的，它们是算法研究的最高成就之一。</p>

<!--more-->


<p>我们扩展符号表的API，增加基于字符的用于处理字符串类型的键的操作。</p>

<p>以字符串为键的符号表的API(<code>StringST&lt;Value&gt;</code>)</p>

<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>StringST()</code> </td>
<td> 创建一个符号表</td>
</tr>
<tr>
<td><code>void put(String key, Value val)</code> </td>
<td> 向表中插入键值对（如果值为null则删除键key）</td>
</tr>
<tr>
<td><code>Value get(String key)</code> </td>
<td> 键key所对应的值，如果不存在则返回null</td>
</tr>
<tr>
<td><code>void delete(String key)</code> </td>
<td> 删除键key（和它的值）</td>
</tr>
<tr>
<td><code>boolean contains(String key)</code> </td>
<td> 表中是否存在key的值</td>
</tr>
<tr>
<td><code>boolean isEmpty()</code> </td>
<td> 符号表是否为空</td>
</tr>
<tr>
<td><strong><code>String longestPrefixOf(String s)</code></strong> </td>
<td> s的前缀中最长的键 </td>
</tr>
<tr>
<td><strong><code>Iterable&lt;String&gt; keysWithPrefix(String s)</code></strong> </td>
<td> 所有以s为前缀的键</td>
</tr>
<tr>
<td><strong><code>Iterable&lt;String&gt; keysThatMatch(String s)</code></strong> </td>
<td> 所有和s匹配的键（其中“.”能够匹配任意字符）</td>
</tr>
<tr>
<td><code>int size()</code>  </td>
<td> 键值对的数量 </td>
</tr>
<tr>
<td><code>Iterable&lt;String&gt; keys()</code> </td>
<td> 符号表中的所有键 </td>
</tr>
</tbody>
</table>


<p>上面的API与符号表API的不同之处在于Key换成了String, 增加了粗体显示的三个方法。</p>

<h2>1. R向单词查找树</h2>

<p>与各种查找树一样，单词查找树也是由链接的结点所组成的数据结构。每个结点只有一个父结点（根结点除外），每个结点都含有R条链接，其中R为字母表的大小。每个键所关联的值保存在该键的最后一个字母所对应的结点中。值为空的结点在符号表中没有对应的键，它们的存在是为了简化单词查找树中的查找操作。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-16-tries-node.jpg" alt="image" /></p>

<h3>1.1 查找操作</h3>

<p>单词查找树的查找操作非常简单，从首字母开始延着树结点查找就可以：</p>

<ul>
<li>键的尾字符所对应的结点中的值非空，命中！</li>
<li>键的尾字符所对应的结点中的值为空，未命中！</li>
<li>查找结束于一条空链接，未命中！</li>
</ul>


<h3>1.2 插入操作</h3>

<p>和二叉查找树一样，在插入之前要进行一次查找。</p>

<ul>
<li>在到达键的尾字符之前就遇到了一个空链接。证明不存在匹配的结点，为键中还未被检查的每个字符创建一个对应的结点，并将键对应的值保存到最后一个字符的结点中。</li>
<li>在遇到空链接之前就到达了键的尾字符。将该结点的值设为键对应的值（无论该值是否为空）。</li>
</ul>


<h3>1.3 删除操作</h3>

<p>删除的第一步是找到键所对应的结点并将它的值设为空null. 如果该结点含有一个非空的链接指向某个子结点，那么就不需要再进行其他操作了。如果它的所有链接均为空，那就需要从数据结构中删除这个结点。如果删除它使得它的父结点的所有链接也均为空，就要继续删除它的父结点，依此类推。</p>

<h3>1.4 实现</h3>

<pre class='line-numbers language-java'><code class='language-java'>public class TrieST&lt;Value&gt; {
    private static final int R = 256;        // extended ASCII


    private Node root;      // root of trie
    private int N;          // number of keys in trie

    // R-way trie node
    private static class Node {
        private Object val;
        private Node[] next = new Node[R];
    }

    public TrieST() {
    }

   /**
     * Initializes an empty string symbol table.
     */

    /**
     * Returns the value associated with the given key.
     * @param key the key
     * @return the value associated with the given key if the key is in the symbol table
     *     and &lt;tt&gt;null&lt;/tt&gt; if the key is not in the symbol table
     * @throws NullPointerException if &lt;tt&gt;key&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;
     */
    public Value get(String key) {
        Node x = get(root, key, 0);
        if (x == null) return null;
        return (Value) x.val;
    }

    /**
     * Does this symbol table contain the given key?
     * @param key the key
     * @return &lt;tt&gt;true&lt;/tt&gt; if this symbol table contains &lt;tt&gt;key&lt;/tt&gt; and
     *     &lt;tt&gt;false&lt;/tt&gt; otherwise
     * @throws NullPointerException if &lt;tt&gt;key&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;
     */
    public boolean contains(String key) {
        return get(key) != null;
    }

    private Node get(Node x, String key, int d) {
        if (x == null) return null;
        if (d == key.length()) return x;
        char c = key.charAt(d);
        return get(x.next[c], key, d+1);
    }

    /**
     * Inserts the key-value pair into the symbol table, overwriting the old value
     * with the new value if the key is already in the symbol table.
     * If the value is &lt;tt&gt;null&lt;/tt&gt;, this effectively deletes the key from the symbol table.
     * @param key the key
     * @param val the value
     * @throws NullPointerException if &lt;tt&gt;key&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;
     */
    public void put(String key, Value val) {
        if (val == null) delete(key);
        else root = put(root, key, val, 0);
    }

    private Node put(Node x, String key, Value val, int d) {
        if (x == null) x = new Node();
        if (d == key.length()) {
            if (x.val == null) N++;
            x.val = val;
            return x;
        }
        char c = key.charAt(d);
        x.next[c] = put(x.next[c], key, val, d+1);
        return x;
    }

    /**
     * Returns the number of key-value pairs in this symbol table.
     * @return the number of key-value pairs in this symbol table
     */
    public int size() {
        return N;
    }

    /**
     * Is this symbol table empty?
     * @return &lt;tt&gt;true&lt;/tt&gt; if this symbol table is empty and &lt;tt&gt;false&lt;/tt&gt; otherwise
     */
    public boolean isEmpty() {
        return size() == 0;
    }

    /**
     * Returns all keys in the symbol table as an &lt;tt&gt;Iterable&lt;/tt&gt;.
     * To iterate over all of the keys in the symbol table named &lt;tt&gt;st&lt;/tt&gt;,
     * use the foreach notation: &lt;tt&gt;for (Key key : st.keys())&lt;/tt&gt;.
     * @return all keys in the sybol table as an &lt;tt&gt;Iterable&lt;/tt&gt;
     */
    public Iterable&lt;String&gt; keys() {
        return keysWithPrefix("");
    }

    /**
     * Returns all of the keys in the set that start with &lt;tt&gt;prefix&lt;/tt&gt;.
     * @param prefix the prefix
     * @return all of the keys in the set that start with &lt;tt&gt;prefix&lt;/tt&gt;,
     *     as an iterable
     */
    public Iterable&lt;String&gt; keysWithPrefix(String prefix) {
        Queue&lt;String&gt; results = new Queue&lt;String&gt;();
        Node x = get(root, prefix, 0);
        collect(x, new StringBuilder(prefix), results);
        return results;
    }

    private void collect(Node x, StringBuilder prefix, Queue&lt;String&gt; results) {
        if (x == null) return;
        if (x.val != null) results.enqueue(prefix.toString());  //有值才是键
        for (char c = 0; c &lt; R; c++) {
            prefix.append(c);
            collect(x.next[c], prefix, results);
            prefix.deleteCharAt(prefix.length() - 1);
        }
    }

    /**
     * Returns all of the keys in the symbol table that match &lt;tt&gt;pattern&lt;/tt&gt;,
     * where . symbol is treated as a wildcard character.
     * @param pattern the pattern
     * @return all of the keys in the symbol table that match &lt;tt&gt;pattern&lt;/tt&gt;,
     *     as an iterable, where . is treated as a wildcard character.
     */
    public Iterable&lt;String&gt; keysThatMatch(String pattern) {
        Queue&lt;String&gt; results = new Queue&lt;String&gt;();
        collect(root, new StringBuilder(), pattern, results);
        return results;
    }

    private void collect(Node x, StringBuilder prefix, String pattern, Queue&lt;String&gt; results) {
        if (x == null) return;
        int d = prefix.length();
        if (d == pattern.length() && x.val != null)
            results.enqueue(prefix.toString());
        if (d == pattern.length())
            return;
        char c = pattern.charAt(d);
        if (c == '.') {
            for (char ch = 0; ch &lt; R; ch++) {
                prefix.append(ch);
                collect(x.next[ch], prefix, pattern, results);
                prefix.deleteCharAt(prefix.length() - 1);
            }
        }
        else {
            prefix.append(c);
            collect(x.next[c], prefix, pattern, results);
            prefix.deleteCharAt(prefix.length() - 1);
        }
    }

    /**
     * Returns the string in the symbol table that is the longest prefix of &lt;tt&gt;query&lt;/tt&gt;,
     * or &lt;tt&gt;null&lt;/tt&gt;, if no such string.
     * @param query the query string
     * @throws NullPointerException if &lt;tt&gt;query&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;
     * @return the string in the symbol table that is the longest prefix of &lt;tt&gt;query&lt;/tt&gt;,
     *     or &lt;tt&gt;null&lt;/tt&gt; if no such string
     */
    public String longestPrefixOf(String query) {
        int length = longestPrefixOf(root, query, 0, 0);
        return query.substring(0, length);
    }

    // returns the length of the longest string key in the subtrie
    // rooted at x that is a prefix of the query string,
    // assuming the first d character match and we have already
    // found a prefix match of length length
    private int longestPrefixOf(Node x, String query, int d, int length) {
        if (x == null) return length;
        if (x.val != null) length = d;
        if (d == query.length()) return length;
        char c = query.charAt(d);
        return longestPrefixOf(x.next[c], query, d+1, length);
    }

    /**
     * Removes the key from the set if the key is present.
     * @param key the key
     * @throws NullPointerException if &lt;tt&gt;key&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;
     */
    public void delete(String key) {
        root = delete(root, key, 0);
    }

    private Node delete(Node x, String key, int d) {
        if (x == null) return null;
        if (d == key.length()) {
            if (x.val != null) N--;
            x.val = null;
        }
        else {
            char c = key.charAt(d);
            x.next[c] = delete(x.next[c], key, d+1);
        }

        // remove subtrie rooted at x if it is completely empty
        if (x.val != null) return x;
        for (int c = 0; c &lt; R; c++)
            if (x.next[c] != null)
                return x;
        return null;
    }

}</code></pre>


<p>上面的代码可以处理扩展ASCII码，但很容易就可以修改为能够处理由任意字母表得到的键：</p>

<ol>
<li>实现一个构造函数，接受Alphabet，将R设置为字母表大小。</li>
<li>在get()、put()中使用Alphabet的toIndex()，将字符串中的字符转化为0到R-1的索引值。</li>
<li>在keys()、keysWithPrefix()和keysThatMatch()方法中，使用Alphabet的toChar()方法，将0到R-1之间的索引值转化为字符型(char)值。</li>
</ol>


<h3>1.5 单词查找树的性质</h3>

<p>单词查找树的链表结构（形状）和键的插入或删除顺序无关，对于任意给定的一组键，其单词查找树都是唯一的。</p>

<p>在单词查找树中查找一个键或是插入一个键时，访问数组的次数最多为键的长度加1！</p>

<p>字母表的大小为R，在一棵由N个随机键构造的单词树中，未命中查找平均所需检查的结点数量为~log<sub>R</sub><sup>N</sup>。</p>

<p>一棵单词查找树中的链接总数在RN到RNw之间，其中w为键的平均长度。因此单词查找树的空间消耗非常大。长键也可能占用大量空间，因为它通常有一条长长的尾巴。单词查找树的内部也可能存在单向的分支。例如两个长键可能只有最后一个字符不同。</p>

<p>如果能够负担得起R向单词查找树的庞大空间，它的性能是无可匹敌的。</p>

<h2>2. 三向单词查找树</h2>

<p>三向单词查找树可以避免R向单词查找树过度的空间消耗。它的每个结点都含有一个字符、三条链接和一个值。三条链接分别对应当前字母小于、等于和大于结点字母的所有键。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-16-tst.jpg" alt="image" /></p>

<h3>2.1 查找、插入和删除操作</h3>

<p>在查找时，首先比较键的首字母和根结点的字母。如果键的首字母较小，就选择左链接；如果较大，就选择右链接；如果相等则选择中链接。然后递归地使用相同的算法。如果遇到一个空链接或者当键结束时结点的值为空，那么查找未命中。如果键结束时结点的值非空则查找命中。</p>

<p>插入一个新键时，首先进行查找，然后和单词查找树一样，在树中补全键末尾的所有结点。</p>

<p>在三向单词查找树中，需要使用在二叉查找树中删除结点的方法来删去与该字符对应的结点。</p>

<h3>2.2 实现</h3>

<pre class='line-numbers language-java'><code class='language-java'>public class TST&lt;Value&gt; {
    private int N;       // size
    private Node root;   // root of TST

    private class Node {
        private char c;                 // character
        private Node left, mid, right;  // left, middle, and right subtries
        private Value val;              // value associated with string
    }

    // return number of key-value pairs
    public int size() {
        return N;
    }

   /**************************************************************
    * Is string key in the symbol table?
    **************************************************************/
    public boolean contains(String key) {
        return get(key) != null;
    }

    public Value get(String key) {
        if (key == null) throw new NullPointerException();
        if (key.length() == 0) throw new IllegalArgumentException("key must have length &gt;= 1");
        Node x = get(root, key, 0);
        if (x == null) return null;
        return x.val;
    }

    // return subtrie corresponding to given key
    private Node get(Node x, String key, int d) {
        if (key == null) throw new NullPointerException();
        if (key.length() == 0) throw new IllegalArgumentException("key must have length &gt;= 1");
        if (x == null) return null;
        char c = key.charAt(d);
        if      (c &lt; x.c)              return get(x.left,  key, d);
        else if (c &gt; x.c)              return get(x.right, key, d);
        else if (d &lt; key.length() - 1) return get(x.mid,   key, d+1);
        else                           return x;
    }


   /**************************************************************
    * Insert string s into the symbol table.
    **************************************************************/
    public void put(String s, Value val) {
        if (!contains(s)) N++;
        root = put(root, s, val, 0);
    }

    private Node put(Node x, String s, Value val, int d) {
        char c = s.charAt(d);
        if (x == null) {
            x = new Node();
            x.c = c;
        }
        if      (c &lt; x.c)             x.left  = put(x.left,  s, val, d);
        else if (c &gt; x.c)             x.right = put(x.right, s, val, d);
        else if (d &lt; s.length() - 1)  x.mid   = put(x.mid,   s, val, d+1);
        else                          x.val   = val;
        return x;
    }


   /**************************************************************
    * Find and return longest prefix of s in TST
    **************************************************************/
    public String longestPrefixOf(String s) {
        if (s == null || s.length() == 0) return null;
        int length = 0;
        Node x = root;
        int i = 0;
        while (x != null && i &lt; s.length()) {
            char c = s.charAt(i);
            if      (c &lt; x.c) x = x.left;
            else if (c &gt; x.c) x = x.right;
            else {
                i++;
                if (x.val != null) length = i;
                x = x.mid;
            }
        }
        return s.substring(0, length);
    }

    // all keys in symbol table
    public Iterable&lt;String&gt; keys() {
        Queue&lt;String&gt; queue = new Queue&lt;String&gt;();
        collect(root, "", queue);
        return queue;
    }

    // all keys starting with given prefix
    public Iterable&lt;String&gt; prefixMatch(String prefix) {
        Queue&lt;String&gt; queue = new Queue&lt;String&gt;();
        Node x = get(root, prefix, 0);
        if (x == null) return queue;
        if (x.val != null) queue.enqueue(prefix);
        collect(x.mid, prefix, queue);
        return queue;
    }

    // all keys in subtrie rooted at x with given prefix
    private void collect(Node x, String prefix, Queue&lt;String&gt; queue) {
        if (x == null) return;
        collect(x.left,  prefix,       queue);
        if (x.val != null) queue.enqueue(prefix + x.c);
        collect(x.mid,   prefix + x.c, queue);
        collect(x.right, prefix,       queue);
    }


    // return all keys matching given wildcard pattern
    public Iterable&lt;String&gt; wildcardMatch(String pat) {
        Queue&lt;String&gt; queue = new Queue&lt;String&gt;();
        collect(root, "", 0, pat, queue);
        return queue;
    }
 
    private void collect(Node x, String prefix, int i, String pat, Queue&lt;String&gt; q) {
        if (x == null) return;
        char c = pat.charAt(i);
        if (c == '.' || c &lt; x.c) collect(x.left, prefix, i, pat, q);
        if (c == '.' || c == x.c) {
            if (i == pat.length() - 1 && x.val != null) q.enqueue(prefix + x.c);
            if (i &lt; pat.length() - 1) collect(x.mid, prefix + x.c, i+1, pat, q);
        }
        if (c == '.' || c &gt; x.c) collect(x.right, prefix, i, pat, q);
    }
}</code></pre>


<h3>2.3 三向单词查找树的性质</h3>

<p>三向单词查找树与R向单词查找树的数据结构性质截然不同。它和其他所有二叉查找树一样，每个单词查找树结点的二叉查找树表示也取决于键的插入顺序。</p>

<p>它的每个结点只含有三个链接，因此所需空间远小于对应的单词查找树。由N个平均长度为w的字符串构造的三向单词查找树中的链接总数在3N到3Nw之间。</p>

<p>在一棵由N个随机字符串构造的三向单词查找树中，查找未命中平均需要比较字符~lnN次。除~lnN次外，一次插入或命中的查找会比较一次被查找的键中的每个字符。</p>

<p>使用三向单词查找树的最大好处是它能够很好地适应实际应用中可能出现的被查找键的不规则性。它可以使用256个字符的ASCII编码或者65536个字符的Unicode编码，而不必担心分支带来的巨大开销。</p>

<h2>3. 总结</h2>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-16-wordsfind-conclude.jpg" alt="image" /></p>

<p>参考：<a href="http://algs4.cs.princeton.edu/52trie/">http://algs4.cs.princeton.edu/52trie/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字符串排序]]></title>
    <link href="http://blog.ubone.com/blog/2014/11/15/zi-fu-chuan-pai-xu/"/>
    <updated>2014-11-15T09:49:02+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/11/15/zi-fu-chuan-pai-xu</id>
    <content type="html"><![CDATA[<p>字符串是最常用的数据类型，因此它的排序算法非常重要。虽然Java的字符串排序已经非常快，但了解一些字符串的排序算法仍然很必要，也是进一步了解字符串其它应用的基础。</p>

<!--more-->


<p>在Java中表示字符串的两种方法：</p>

<table>
<thead>
<tr>
<th>操作 </th>
<th> 字符数组 </th>
<th> Java字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>声明</td>
<td> char[] a</td>
<td> String s</td>
</tr>
<tr>
<td>根据索引访问字符</td>
<td> a[i] </td>
<td> s.charAt(i)</td>
</tr>
<tr>
<td>获取字符串长度</td>
<td> a.length </td>
<td> s.length()</td>
</tr>
<tr>
<td>表示方法转换</td>
<td> a = s.toCharArray(); </td>
<td> s= new String(a);</td>
</tr>
</tbody>
</table>


<h2>1. 字母表</h2>

<p>字母表是字符串相关算法的基础，表示字符串由哪些字母组成。字符索引的数组能够提高算法的效率。在这个数组中，用字符作为索引来获取与之相关联的信息。在一些算法中会产生大量的这类数组。如果使用Java的String类，就必须使用大小为65536的数组。有了字母表，则只需要使用一个字母表大小的数组即可。</p>

<p>字母表(Alphabet)API定义如下：</p>

<table>
<thead>
<tr>
<th>方法 </th>
<th>  说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alphabet(String s) </td>
<td> 构造方法，根据s中的字符创建一张新的字母表</td>
</tr>
<tr>
<td>char toChar(int index) </td>
<td> 获取字母表中索引位置的字符</td>
</tr>
<tr>
<td>int toIndex(char c)  </td>
<td> 获取c的索引，在0到R-1之间</td>
</tr>
<tr>
<td>boolean contains(char c) </td>
<td> c在字母表中吗</td>
</tr>
<tr>
<td>int R() </td>
<td> 基数（字母表中的字符数量）</td>
</tr>
<tr>
<td>int lgR() </td>
<td> 表示一个索引所需的比特数</td>
</tr>
<tr>
<td>int[] toIndices(String s) </td>
<td> 将s转换为R进制的整数数组</td>
</tr>
<tr>
<td>String toChars(int[] indices) </td>
<td> 将R进制的整数数组转换为基于该字母表的字符串</td>
</tr>
</tbody>
</table>


<h3>标准字母表</h3>

<table>
<thead>
<tr>
<th>名称 </th>
<th> R() </th>
<th> lgR() </th>
<th> 字符集</th>
</tr>
</thead>
<tbody>
<tr>
<td>BINARY </td>
<td> 2 </td>
<td> 1 </td>
<td> 01</td>
</tr>
<tr>
<td>DNA </td>
<td> 4 </td>
<td> 2 </td>
<td> ACTG</td>
</tr>
<tr>
<td>OCTAL </td>
<td> 8 </td>
<td> 3 </td>
<td> 0..7</td>
</tr>
<tr>
<td>DECIMAL </td>
<td> 10 </td>
<td> 4 </td>
<td> 0..9</td>
</tr>
<tr>
<td>HEXADECIMAL </td>
<td> 16 </td>
<td> 4 </td>
<td> 0..9ABCDEF</td>
</tr>
<tr>
<td>PROTEIN </td>
<td> 20 </td>
<td> 5 </td>
<td> ACDEFGHIKLMNPQRSTVWY</td>
</tr>
<tr>
<td>LOWERCASE </td>
<td> 26 </td>
<td> 5 </td>
<td> a..z</td>
</tr>
<tr>
<td>UPPERCASE </td>
<td> 26 </td>
<td> 5 </td>
<td> A..Z</td>
</tr>
<tr>
<td>BASE64 </td>
<td> 64 </td>
<td> 6 </td>
<td> A..Za..z0..9+/</td>
</tr>
<tr>
<td>ASCII </td>
<td> 128 </td>
<td> 7 </td>
<td> ASCII字符集</td>
</tr>
<tr>
<td>EXTENDED_ASCII </td>
<td> 256 </td>
<td> 8 </td>
<td> 扩展ASCII字符集</td>
</tr>
<tr>
<td>UNICODE16 </td>
<td> 65536 </td>
<td> 16 </td>
<td> Unicode字符集</td>
</tr>
</tbody>
</table>


<h2>2. 键索引计数法</h2>

<p>假设老师在统计学生分数时，学生被分为若干组，标号为0、1、2、3等。老师希望将全班同学按组分类，也就是按组排序。因为组的编号是较小的整数，使用键索引计数法来排序非常合适。</p>

<p>我们用一个数组a[]来保存数据。每个元素都保存了一个姓名和一个组号。组号在0到R-1之间，a[i].key()会返回指定学生的组号。键索引计数法通过四个步骤来完成排序。</p>

<p><strong>第一步，频率统计</strong>
使用一个int数组count[]来计算每个键（组号）出现的频率。遍历一遍数组，如果键为r，则将count[r+1]加1。因此对第1组的学生，将会把count[2]++。（在第二步的代码中可以看到为什么是r+1）</p>

<pre class='line-numbers language-java'><code class='language-java'>for (int i = 0; i &lt; N; i++) {
    count[a[i].key() + 1]++;
}</code></pre>


<p><strong>第二步，将频率转换为索引</strong>
有了count[]中每个键出现的次数，就可以得到每个键在排序结果中的起始索引位置。假如第1组3个人，第2组5个人，那么第三种的同学在排序结果中的起始位置就是8. 因此可以将count[]转化为一张索引表。</p>

<pre class='line-numbers language-java'><code class='language-java'>for (int r= 0; r &lt; R; r++) {
    count[r+1] += count[r];
}</code></pre>


<p><strong>第三步，数据分类</strong>
在第二步中，得到了每个键的起始序号。我们就可以将所有元素（学生）移动到一个辅助数组aux[]。元素在aux[]中的位置由count[]值决定，在移动的过程中将count[]中对应的元素值加1。这个过程只需要遍历一遍数据就可以产生排序结果。并且这种方式是稳定的！键相同的元素在排序后会被聚集到一起，而且相对顺序没有变化。</p>

<pre class='line-numbers language-java'><code class='language-java'>for (int i = 0; i &lt; N; i++) {
    aux[count[a[i].key()]++]  = a[i];
}</code></pre>


<p><strong>第四步，回写</strong>
在第三步已经完成了排序，只需要将排序结果复制回原数组。</p>

<pre class='line-numbers language-java'><code class='language-java'>for(int i = 0; i &lt; N; i++) {
    a[i] = aux[i];
}</code></pre>


<p>键索引计数法是一种对于小整数键排序非常有效却常常被忽略的排序方法。它排序N个键为0到R-1之间的整数的元素需要访问数组11N+4R+1次。也就是说<strong>它突破了NlogN的排序算法运行时间下限（<a href="http://blog.ubone.com/blog/2014/09/27/kuai-su-pai-xu-suan-fa/">快速排序算法</a>）。原因是什么？因为它是不需要比较的，它只通过key()方法访问数据。只要当R在N的一个常数因子范围之内，它都是一个线性时间级别的排序方法。</strong></p>

<p>理解键索引计数法的工作原理非常重要。学生的组号对应字母表中的元素，利用字母表大小的数组count[]来统计每个字母出现的次数，计算出每个字母在最终数组的起始序号，从而完成排序。</p>

<p>有了键索引计数法，我们来看如何实现两种字符串排序算法。</p>

<h2>3. 低位优先(Least-Significant-DigitFirst, LSD)的字符串排序</h2>

<p>这种算法适用于<strong>键的长度相等</strong>的字符串排序应用。例如对车牌号进行排序。它会从右往左检查键中的字符，所以称为低位优先。</p>

<p>如果字符串的长度均为W，在排序的过程中，从右向左，将每个位置的字符作为键，用键索引计数法将字符串排序W遍。理解了键索引计数法，实现低位优先的字符串排序就很容易了：</p>

<pre class='line-numbers language-java'><code class='language-java'>public class LSD {
    public static void sort(String[] a, int W) {
        int N = a.length;
        int R = 256;   // extend ASCII alphabet size
        String[] aux = new String[N];

        for (int d = W-1; d &gt;= 0; d--) {
            //将第d个字符用键索引计数法排序
            // 计算出现次数
            int[] count = new int[R+1];
            for (int i = 0; i &lt; N; i++)
                count[a[i].charAt(d) + 1]++;

            // 将次数转换为索引
            for (int r = 0; r &lt; R; r++)
                count[r+1] += count[r];

            // 移到辅助数组，进行排序
            for (int i = 0; i &lt; N; i++)
                aux[count[a[i].charAt(d)]++] = a[i];

            // 回写数据
            for (int i = 0; i &lt; N; i++)
                a[i] = aux[i];
        }
    }
}</code></pre>


<p>低位优先的字符串排序算法能够将定长字符串排序，其中的键索引计数法的稳定性起了关键作用。</p>

<p>对于基于R个字符的字母表的N个以长为W的字符串为键的元素，低位优先的字符串排序需要访问~7WN+3WR次数组，使用的额外空间与N+R成正比。</p>

<h2>4. 高位优先(MSD)的字符串排序</h2>

<p>这种算法从左往右检查键中的字符，所以称为高位优先。它不一定要检查所有的输入才能完成排序。它是更通用的字符串排序算法，字符串的长度不一定相同。</p>

<p>和快速排序一样，高位优先的字符串排序会将数组切分为能够独立排序的子数组来完成排序任务，但它的切分会为每个首字母得到一个子数组，而不是像快速排序中那样产生固定的两个或三个切分。首先用键索引计数法将所有字符串按照首字母排序，然后（递归地）再将每个首字母所对应的子数组排序（忽略首字母，因为每个子数组中的首字母是相同的）。</p>

<p>由于高位优先字符串排序算法要处理不等长的字符串，因此要处理字符串已经结束的情况。因此约定charAt方法中，如果指定位置超出字符串长度则返回-1. 其它情况则加1后返回。因此字符串中的每个字符都可能产生R+1种不同的值，0表示结束，1表示字母表的第一个字符。而键索引计数法还需要一个额外的位置，所以count[]的长度应为R+2。</p>

<p>对于很小的子数组（15个以内），采用插入排序更快。</p>

<pre class='line-numbers language-java'><code class='language-java'>public class MSD {
    private static final int R             = 256;   // 基数 extended ASCII alphabet size
    private static final int CUTOFF        =  15;   // 小数组的切换阈值 cutoff to insertion sort

    // sort array of strings
    public static void sort(String[] a) {
        int N = a.length;
        String[] aux = new String[N];
        sort(a, 0, N-1, 0, aux);
    }

    // return dth character of s, -1 if d = length of string
    private static int charAt(String s, int d) {
        assert d &gt;= 0 && d &lt;= s.length();
        if (d == s.length()) return -1;
        return s.charAt(d);
    }

    // sort from a[lo] to a[hi], starting at the dth character
    private static void sort(String[] a, int lo, int hi, int d, String[] aux) {

        // cutoff to insertion sort for small subarrays
        if (hi &lt;= lo + CUTOFF) {
            insertion(a, lo, hi, d);
            return;
        }

        // 计算次数
        int[] count = new int[R+2];
        for (int i = lo; i &lt;= hi; i++) {
            int c = charAt(a[i], d);
            count[c+2]++;
        }

        // 将次数转换为索引
        for (int r = 0; r &lt; R+1; r++)
            count[r+1] += count[r];

        // 生成辅助数据内容，完成排序。
        for (int i = lo; i &lt;= hi; i++) {
            int c = charAt(a[i], d);
            aux[count[c+1]++] = a[i];
        }

        // 回写
        for (int i = lo; i &lt;= hi; i++) 
            a[i] = aux[i - lo];


        // 递归地以每个字符为键进行排序。
        for (int r = 0; r &lt; R; r++)
            sort(a, lo + count[r], lo + count[r+1] - 1, d+1, aux);
    }


    // 插入排序算法insertion sort a[lo..hi], starting at dth character
    private static void insertion(String[] a, int lo, int hi, int d) {
        for (int i = lo; i &lt;= hi; i++)
            for (int j = i; j &gt; lo && less(a[j], a[j-1], d); j--)
                exch(a, j, j-1);
    }

    // exchange a[i] and a[j]
    private static void exch(String[] a, int i, int j) {
        String temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }

    // is v less than w, starting at character d
    private static boolean less(String v, String w, int d) {
        // assert v.substring(0, d).equals(w.substring(0, d));
        for (int i = d; i &lt; Math.min(v.length(), w.length()); i++) {
            if (v.charAt(i) &lt; w.charAt(i)) return true;
            if (v.charAt(i) &gt; w.charAt(i)) return false;
        }
        return v.length() &lt; w.length();
    }
}</code></pre>


<h3>4.1 三个必须解决的问题</h3>

<h4>4.1.1 小型子数组</h4>

<p>高位优先的字符串排序算法能够快速地将需要排序的数组切分小的数组，但这肯定会需要处理大量的微型数组，因此必须快速处理它们。<strong>小型子数组对于高位优先的字符串排序性能至关重要！</strong>假设要将数百万个不同的ASCII字符串排序，每个字符串最终都会产生一个只含有它自己的子数组，因此你需要将数百万个大小为1的子数组排序。每次排序还需要将count[]r 258个元素初始化为0并转化为索引。这个代价比排序其他部分高得多。如果使用Unicode(R=65536)则可能会慢上千倍！</p>

<p>所以对小型子数组要切换到插入排序。在一个典型应用中，当长度小于等于10时切换到插入排序能够将运行时间降低到原来的十分之一。</p>

<h4>4.1.2 等值键</h4>

<p>如果字符串有大量重复的前缀，排序会较慢。高位优先字符串排序算法的最坏情况就是所有的键均相同。</p>

<h4>4.1.3 额外空间</h4>

<p>为了进行切分，高位优先的算法使用了两个辅助数组：aux[]和count[]. aux可以在递归方法sort()外创建。而count[]所需的空间是主要问题，它在内循环中创建。</p>

<p>解决这三个问题需要新算法。</p>

<h2>5. 三向字符串快速排序</h2>

<p>在高位优先的字符串排序算法上改进快速排序。根据键的首字母进行三向切分，分成三个数组：首字母小于、等于和大于切分字符的三个数组。仅在中间子数组中的下一个字符（因为首字母就是切分字符）继续递归排序。这是一种将高位优先字符串排序与快速排序结合的算法。</p>

<p>这种算法不会像高位优先算法那样创建大量（空）子数组，它的切分总是只有三个。能解决所有高位优先字符串排序算法不擅长的各种情况。并且它也不需要额外的空间。</p>

<p>对于所有递归算法都可以通过对小型子数组进行特殊处理高效率，所以它同样使用到了插入排序。</p>

<p>和快速排序一样，最好在排序之前将数组打乱，或者将第一个元素和一个随机位置的元素交换以得到一个随机的切分元素。这么做主要是预防数组已经有序或者接近有序的最坏情况。</p>

<pre class='line-numbers language-java'><code class='language-java'>public class Quick3string {
    private static final int CUTOFF =  15;   // cutoff to insertion sort

    // sort the array a[] of strings
    public static void sort(String[] a) {
        StdRandom.shuffle(a);
        sort(a, 0, a.length-1, 0);
        assert isSorted(a);
    }

    // return the dth character of s, -1 if d = length of s
    private static int charAt(String s, int d) { 
        assert d &gt;= 0 && d &lt;= s.length();
        if (d == s.length()) return -1;
        return s.charAt(d);
    }


    // 3-way string quicksort a[lo..hi] starting at dth character
    private static void sort(String[] a, int lo, int hi, int d) { 

        // cutoff to insertion sort for small subarrays
        if (hi &lt;= lo + CUTOFF) {
            insertion(a, lo, hi, d);
            return;
        }

        int lt = lo, gt = hi;
        int v = charAt(a[lo], d);
        int i = lo + 1;
        while (i &lt;= gt) {
            int t = charAt(a[i], d);
            if      (t &lt; v) exch(a, lt++, i++);
            else if (t &gt; v) exch(a, i, gt--);
            else              i++;
        }

        // a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi]. 
        sort(a, lo, lt-1, d);
        if (v &gt;= 0) sort(a, lt, gt, d+1);
        sort(a, gt+1, hi, d);
    }

    // sort from a[lo] to a[hi], starting at the dth character
    private static void insertion(String[] a, int lo, int hi, int d) {
        for (int i = lo; i &lt;= hi; i++)
            for (int j = i; j &gt; lo && less(a[j], a[j-1], d); j--)
                exch(a, j, j-1);
    }

    // exchange a[i] and a[j]
    private static void exch(String[] a, int i, int j) {
        String temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }

    // is v less than w, starting at character d
    // DEPRECATED BECAUSE OF SLOW SUBSTRING EXTRACTION IN JAVA 7
    // private static boolean less(String v, String w, int d) {
    //    assert v.substring(0, d).equals(w.substring(0, d));
    //    return v.substring(d).compareTo(w.substring(d)) &lt; 0; 
    // }

    // is v less than w, starting at character d
    private static boolean less(String v, String w, int d) {
        assert v.substring(0, d).equals(w.substring(0, d));
        for (int i = d; i &lt; Math.min(v.length(), w.length()); i++) {
            if (v.charAt(i) &lt; w.charAt(i)) return true;
            if (v.charAt(i) &gt; w.charAt(i)) return false;
        }
        return v.length() &lt; w.length();
    }

    // is the array sorted
    private static boolean isSorted(String[] a) {
        for (int i = 1; i &lt; a.length; i++)
            if (a[i].compareTo(a[i-1]) &lt; 0) return false;
        return true;
    }
}</code></pre>


<p>要将含有N个随机字符串的数组排序，三向字符串快速排序平均需要比较字符~2NlnN次。</p>

<p>Java系统的标准实现中的字符串比较非常快，因此它的排序性能与上面的算法不相上下。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-15-string-sort.jpg" alt="image" /></p>

<p>参考：<a href="http://algs4.cs.princeton.edu/51radix/">http://algs4.cs.princeton.edu/51radix/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android应用打破65K方法数限制]]></title>
    <link href="http://blog.ubone.com/blog/2014/11/12/androidying-multidex/"/>
    <updated>2014-11-12T16:52:42+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/11/12/androidying-multidex</id>
    <content type="html"><![CDATA[<p>普通Android应用的方法总数不能超过65536，这是开发者长期以来非常头疼的一个问题。最近Google发布了新的Multidex支持库，为方法总数超过65K的Android应用提供官方支持。</p>

<p>本文已经发表在<a href="http://www.infoq.com/cn/news/2014/11/android-multidex">InfoQ</a>。</p>

<!--more-->


<p>近日，<a href="https://plus.google.com/108967384991768947849">Android Developers</a>在Google+上宣布了<a href="http://developer.android.com/tools/support-library/features.html#multidex">新的Multidex支持库</a>，为方法总数超过65K的Android应用提供官方支持。</p>

<p>如果你是一名幸运的Android应用开发者，正在开发一个前景广阔的应用，不断地加入新功能、添加新的类库，那么终有一天，你会不幸遇到这个错误：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>Conversion to Dalvik format failed:
Unable to execute dex: method ID not in [0, 0xffff]: 65536</code></pre>


<p>这个错误是Android应用的方法总数限制造成的。Android平台的Java虚拟机Dalvik在执行DEX格式的Java应用程序时，使用原生类型short来索引DEX文件中的方法。这意味着单个DEX文件可被引用的方法总数被限制为65536。通常APK包含一个classes.dex文件，因此Android应用的方法总数不能超过这个数量，这包括Android框架、类库和你自己开发的代码。</p>

<p>这个问题可以通过将一个DEX文件分拆成多个DEX文件解决。Facebook介绍了为Android应用开发的<a href="https://www.facebook.com/notes/facebook-engineering/under-the-hood-dalvik-patch-for-facebook-for-android/10151345597798920">Dalvik补丁</a>；Android Developers博客介绍了通过<a href="http://android-developers.blogspot.com/2011/07/custom-class-loading-in-dalvik.html">自定义类加载过程</a>的方法来解决此问题。但这些方法有些复杂而且并不优雅。</p>

<p>随着<a href="http://developer.android.com/tools/support-library/features.html#multidex">新的MultiDex支持库发布</a>，Google正式为解决此问题提供官方支持。<a href="http://developer.android.com/tools/building/multidex.html">构建超过65K方法数的应用</a>介绍了如何使用Gradle构建多DEX应用。</p>

<p>首先使用Android SDK Manager升级到最新的Android SDK Build Tools和Android Support Library R21。然后进行以下两步操作：</p>

<p>1.修改Gradle配置文件，启用MultiDex并包含MultiDex支持：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>android {
    compileSdkVersion 21
    buildToolsVersion "21.1.0"

    defaultConfig {
        ...
        minSdkVersion 14
        targetSdkVersion 21
        ...

        // Enabling multidex support.
        multiDexEnabled true
    }
    ...
}

dependencies {
  compile 'com.android.support:multidex:1.0.0'
}</code></pre>


<p>2.让应用支持多DEX文件。在<a href="http://developer.android.com/reference/android/support/multidex/MultiDexApplication.html">MultiDexApplication JavaDoc</a>中描述了三种可选方法：</p>

<ul>
<li>在AndroidManifest.xml的application中声明android.support.multidex.MultiDexApplication；</li>
<li>如果你已经有自己的Application类，让其继承MultiDexApplication；</li>
<li>如果你的Application类已经继承自其它类，你不想/能修改它，那么可以重写attachBaseContext()方法：</li>
</ul>


<pre  class='line-numbers language-bash'><code class='language-bash'>@Override
protected void attachBaseContext(Context base) {
    super.attachBaseContext(base);
    MultiDex.install(this);
}</code></pre>


<p>经过以上步骤，你的应用已经可以实现多个DEX文件了。当应用构建时，构建工具会分析哪些类必须放在第一个DEX文件，哪些类可以放在附加的DEX文件中。当它创建了第一个DEX文件（classes.dex）后，如果必要会继续创建附加的DEX文件，如classes2.dex, classes3.dex。Multidex的支持类库将被包含在应用的第一个DEX文件中，帮助实现对其它DEX文件的访问。</p>

<p>文中还介绍了在开发多DEX应用时，通过设置productFlavors提高开发效率以及多DEX应用的测试方法。</p>

<p>Android 5.0和更高版本使用名为ART的运行时，它原生支持从APK文件加载多个DEX文件。在应用安装时，它会执行预编译，扫描classes(..N).dex文件然后将其编译成单个.oat文件用于执行。<a href="https://source.android.com/devices/tech/dalvik/art.html">了解更多关于ART的信息</a>。</p>

<p>虽然Google解决了应用总方法数限制的问题，但并不意味着开发者可以任意扩大项目规模。Multidex仍有一些限制：</p>

<ol>
<li>DEX文件安装到设备的过程非常复杂，如果第二个DEX文件太大，可能导致应用无响应。此时应该使用<a href="http://developer.android.com/tools/help/proguard.html">ProGuard</a>减小DEX文件的大小。</li>
<li>由于Dalvik linearAlloc的<a href="http://b.android.com/22586">Bug</a>，应用可能无法在Android 4.0之前的版本启动，如果你的应用要支持这些版本就要多执行测试。</li>
<li>同样因为Dalvik linearAlloc的限制，如果请求大量内存可能导致崩溃。Dalvik linearAlloc是一个固定大小的缓冲区。在应用的安装过程中，系统会运行一个名为dexopt的程序为该应用在当前机型中运行做准备。dexopt使用LinearAlloc来存储应用的方法信息。Android 2.2和2.3的缓冲区只有5MB，Android 4.x提高到了8MB或16MB。当方法数量过多导致超出缓冲区大小时，会造成dexopt崩溃。</li>
<li>Multidex构建工具还不支持指定哪些类必须包含在首个DEX文件中，因此可能会导致某些类库（例如某个类库需要从原生代码访问Java代码）无法使用。</li>
</ol>


<p>避免应用过大、方法过多仍然是Android开发者要注意的问题。Mihai Parparita的开源项目<a href="https://github.com/mihaip/dex-method-counts">dex-method-counts</a>可以用于统计APK中每个包的方法数量。</p>

<p>通常开发者自己的代码很难达到这样的方法数量限制，但随着第三方类库的加入，方法数就会迅速膨胀。因此选择合适的类库对Android开发者来说尤为重要。</p>

<p>开发者应该避免使用Google Guava这样的类库，它包含了13000多个方法。尽量使用专为移动应用设计的Lite/Android版本类库，或者使用小类库替换大类库，例如用<a href="https://code.google.com/p/google-gson/">Google-gson</a>替换Jackson JSON。而对于Google Protocol Buffers这样的数据交换格式，其标准实现会自动生成大量的方法。采用<a href="https://github.com/square/wire">Square Wire</a>的实现则可以很好地解决此问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最短路径]]></title>
    <link href="http://blog.ubone.com/blog/2014/11/03/zui-duan-lu-jing/"/>
    <updated>2014-11-03T20:22:31+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/11/03/zui-duan-lu-jing</id>
    <content type="html"><![CDATA[<p>最短路径算法可以解决很多问题，例如地图导航、任务调度和网络路由等。本章的主题就是找到从一个顶点到达另一个顶点的成本最小的路径。</p>

<blockquote><p>在一幅加权有向图中，从顶点s到顶点t的最短路径是所有从s到t的路径中的权重最小者。</p></blockquote>

<p>本章要涉及以下问题：</p>

<ul>
<li>加权有向图的API、单点最短路径的API及它们的实现；</li>
<li>解决边的权重非负的最短路径问题的经典Dijkstra算法；</li>
<li>在无环加权有向图中解决该问题的一种快速算法，边的权重甚至可以是负值；</li>
<li>适用于一般情况的经典Bellman-Ford算法，其中图可以含有环，边的权重也可以是负值。</li>
</ul>


<!--more-->


<h2>1. 最短路径的性质</h2>

<ul>
<li>路径是有向的；</li>
<li>权重不一定等价于距离，但示例图会用距离代表权重；</li>
<li>并不是所有顶点都是可达的；</li>
<li>负权重会使问题更复杂，暂时假定边的权重是非负的；</li>
<li>算法会忽略构成环的零权重边，找到的最短路径都不会含有环；</li>
<li>最短路径不一定是唯一的，只找到其中一条即可；</li>
<li>可能存在平行边和自环，为避免歧义假设不存在平行边，但代码处理它们并没有困难。</li>
</ul>


<p>单点最短路径的计算结果是一棵最短路径树（SPT），它包含了顶点s到达所有可达的顶点的最短路径。</p>

<blockquote><p>给定一幅加权有向图和一个顶点s，以s为起点的一棵最短路径树是图的一幅子图，它包含s和从s可达的所有顶点。这棵有向树的根结点是s，树的每条路径都是有向图中的一条最短路径。</p></blockquote>

<h2>2. 加权有向图的数据结构</h2>

<p>有向边的数据结构比无向边更简单，因为有向边只有一个方向。其API定义如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-04-directed-edge-api.png" alt="image" /></p>

<pre class='line-numbers language-java'><code class='language-java'>public class DirectedEdge { 
    private final int v;                //边的起点
    private final int w;                //边的终点
    private final double weight;        //边的权重

    public DirectedEdge(int v, int w, double weight) {
        if (v &lt; 0) throw new IndexOutOfBoundsException("Vertex names must be nonnegative integers");
        if (w &lt; 0) throw new IndexOutOfBoundsException("Vertex names must be nonnegative integers");
        if (Double.isNaN(weight)) throw new IllegalArgumentException("Weight is NaN");
        this.v = v;
        this.w = w;
        this.weight = weight;
    }

    public int from() {return v;}
    public int to() {return w;}
    public double weight() {return weight;}

    public String toString() {
        return v + "-&gt;" + w + " " + String.format("%5.2f", weight);
    }
}</code></pre>


<p>加权有向图的API也与无向图类似：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-04-edge-weighted-digraph-api.png" alt="image" /></p>

<pre class='line-numbers language-java'><code class='language-java'>public class EdgeWeightedDigraph {
    private final int V;                    //顶点总数
    private int E;                          //边的总数
    private Bag&lt;DirectedEdge&gt;[] adj;      //邻接表
    
    public EdgeWeightedDigraph(int V) {
        if (V &lt; 0) throw new IllegalArgumentException("Number of vertices in a Digraph must be nonnegative");
        this.V = V;
        this.E = 0;
        adj = (Bag&lt;DirectedEdge&gt;[]) new Bag[V];
        for (int v = 0; v &lt; V; v++)
            adj[v] = new Bag&lt;DirectedEdge&gt;();
    }

    public int V() {return V;}
    public int E() {return E;}

    //将e添加到有向图中
    public void addEdge(DirectedEdge e) {
        adj[e.from()].add(e);
        E++;
    }

    //从v指出的边
    public Iterable&lt;DirectedEdge&gt; adj(int v) {
        return adj[v];
    }

    //有向图中的所有边
    public Iterable&lt;DirectedEdge&gt; edges() {
        Bag&lt;DirectedEdge&gt; list = new Bag&lt;DirectedEdge&gt;();
        for (int v = 0; v &lt; V; v++) {
            for (DirectedEdge e : adj(v)) {
                list.add(e);
            }
        }
        return list;
    } 
}</code></pre>


<p>加权有向图的表示：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-04-edge-weighted-digraph-representation.png" alt="image" /></p>

<h3>2.1 最短路径</h3>

<p>最短路径的API：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-04-sp-api.png" alt="image" /></p>

<p>在实现时，分别用两个数组来表示最短路径：</p>

<ul>
<li>最短路径树中的边：DirectedEdge[] edgeTo，edgeTo[v]的值为树中连接v和它的父结点的边。</li>
<li>到达起点的距离：Double[] distTo，distTo[v]为从起点s到v的已知最短路径的长度。</li>
</ul>


<p>同时约定edgeTo[s] == null, distTo[s] == 0; 不可达的顶点的距离为Double.POSITIVE_INFINITY。</p>

<h3>2.2 松弛操作</h3>

<p>松弛（Relaxation）操作是最短路径实现中使用的关键操作。对边v->w松弛意味着检查从s到w的最短路径是否是先从s到v，然后再由v到w。如果是，则由v到达w的最短路径是distTo[v] + e.weight()。如果这个值不小于distTo[w]，则证明刚才的边失效可忽略，否则证明现在的值更小，需要更新数据。</p>

<p>下图演示了这种情况，左侧的v->w不满足条件，被忽略。而右侧的图v->满足条件，替换为新的最短路径。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-04-relaxation-edge.png" alt="image" /></p>

<p>对顶点的松弛操作就是对该顶点指出的所有边进行松弛操作。每次顶点的松弛操作都能得出到达某个顶点的更短的路径。算法就这样最终找出到达每个顶点的最短路径。</p>

<h2>3. 最短路径算法的理论基础</h2>

<p>最短路径的最优性条件：</p>

<blockquote><p>令G为一幅加权有向图，顶点s是G中的起点，distTo[]是一个由顶点索引的数组，保存的是G中路径的长度。对于从s可达的所有顶点v，distTo[v]的值是从s到v的某条路径的长度，对于从s不可达的所有顶点v，该值为无穷大。当且仅当对于从v到w的任意一条边e, 这些值都满足distTo[w] &lt;= distTo[v] + e.weight()时，它们是最短路径的长度。</p></blockquote>

<p>根据最优性条件，我们可以得到一个通用算法，暂时只考虑非负权重的情况：</p>

<blockquote><p>将distTo[s]初始化为0，其它distTo[]元素初始化为无穷大，继续如下操作：放松G中的任意边，直到不存在有效边为止。对于任意从s可达的顶点w，进行这些操作后，distTo[w]的值即为从s到w的最短路径的长度。</p></blockquote>

<h2>4. Dijkstra算法</h2>

<p>Dijkstra算法能够解决边权重非负的加权有向图的单起点最短路径问题。它与无向图的最小生成树的Prim算法（每一步都向最小生成树中添加一条新的边）非常相似。首先将distTo[s]初始华为0，distTo[]的其他元素初始化为正无穷。然后<strong>将distTo[]最小的非树顶点放松并加入树中，如此这般，直到所有的顶点都在树中或者所有的非树顶点的distTo[]值均为无穷大。</strong></p>

<p>Dijkstra算法实现时，除了要distTo[]和edgeTo[]之外，还需要一条索引优先队列pa，以保存需要被放松的顶点并确认下一个被放松的顶点。只要将v和distTo[v]关联起来放入队列就可以立即实现Dijkstra算法。Prim算法每次添加的都是离树最近的非树顶点，而Dijkstra算法每次添加的都是离起点最近的非树顶点。如果将加权无向图看成加权有向图，对无向图中的每条边都相应地创建方向相反的有向边，最短路径的问题是等价的。Dijkstra算法实现实现如下：</p>

<pre class='line-numbers language-java'><code class='language-java'>public class DijkstraSP {
    private double[] distTo;          // distTo[v] = distance  of shortest s-&gt;v path
    private DirectedEdge[] edgeTo;    // edgeTo[v] = last edge on shortest s-&gt;v path
    private IndexMinPQ&lt;Double&gt; pq;    // priority queue of vertices

    /**
     * Computes a shortest paths tree from &lt;tt&gt;s&lt;/tt&gt; to every other vertex in
     * the edge-weighted digraph &lt;tt&gt;G&lt;/tt&gt;.
     * @param G the edge-weighted digraph
     * @param s the source vertex
     * @throws IllegalArgumentException if an edge weight is negative
     * @throws IllegalArgumentException unless 0 &le; &lt;tt&gt;s&lt;/tt&gt; &le; &lt;tt&gt;V&lt;/tt&gt; - 1
     */
    public DijkstraSP(EdgeWeightedDigraph G, int s) {
        for (DirectedEdge e : G.edges()) {
            if (e.weight() &lt; 0)
                throw new IllegalArgumentException("edge " + e + " has negative weight");
        }

        distTo = new double[G.V()];
        edgeTo = new DirectedEdge[G.V()];
        for (int v = 0; v &lt; G.V(); v++)
            distTo[v] = Double.POSITIVE_INFINITY;
        distTo[s] = 0.0;

        // relax vertices in order of distance from s
        pq = new IndexMinPQ&lt;Double&gt;(G.V());
        pq.insert(s, distTo[s]);
        while (!pq.isEmpty()) {
            int v = pq.delMin();
            for (DirectedEdge e : G.adj(v))
                relax(e);
        }
    }

    // relax edge e and update pq if changed
    private void relax(DirectedEdge e) {
        int v = e.from(), w = e.to();
        if (distTo[w] &gt; distTo[v] + e.weight()) {
            distTo[w] = distTo[v] + e.weight();
            edgeTo[w] = e;
            if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);
            else                pq.insert(w, distTo[w]);
        }
    }

    /**
     * Returns the length of a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;.
     * @param v the destination vertex
     * @return the length of a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;;
     *    &lt;tt&gt;Double.POSITIVE_INFINITY&lt;/tt&gt; if no such path
     */
    public double distTo(int v) {
        return distTo[v];
    }

    /**
     * Is there a path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;?
     * @param v the destination vertex
     * @return &lt;tt&gt;true&lt;/tt&gt; if there is a path from the source vertex
     *    &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;, and &lt;tt&gt;false&lt;/tt&gt; otherwise
     */
    public boolean hasPathTo(int v) {
        return distTo[v] &lt; Double.POSITIVE_INFINITY;
    }

    /**
     * Returns a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;.
     * @param v the destination vertex
     * @return a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;
     *    as an iterable of edges, and &lt;tt&gt;null&lt;/tt&gt; if no such path
     */
    public Iterable&lt;DirectedEdge&gt; pathTo(int v) {
        if (!hasPathTo(v)) return null;
        Stack&lt;DirectedEdge&gt; path = new Stack&lt;DirectedEdge&gt;();
        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {
            path.push(e);
        }
        return path;
    }
}</code></pre>


<p>要解决<strong>加权有向图中给定两点（从s到t）的最短路径</strong>这个问题，只要使用Dijkstra算法并从优先队列中取到t之后终止搜索。</p>

<h2>5. 无环加权有向图中的最短路径算法</h2>

<p>如果加权有向图是不含有有向环的，那么可以采用一种比Dijkstra更快、更简单的最短路径算法。它能够在线性时间内解决单点最短路径问题，能够处理负权重的边，还能解决一些其它问题，如找出最长的路径。</p>

<p>根据在<a href="http://blog.ubone.com/blog/2014/10/30/you-xiang-tu/">有向图</a>中学习的拓扑顺序知识，我们知道一幅有向无环图的拓扑顺序就是所有顶点的逆后序排列。如果我们按照拓扑顺序放松顶点，就能在E+V成正比的时间内解决无环加权有向图的单点最短路径问题。代码实现如下：</p>

<pre class='line-numbers language-java'><code class='language-java'>public class AcyclicSP {
    private double[] distTo;         // distTo[v] = distance  of shortest s-&gt;v path
    private DirectedEdge[] edgeTo;   // edgeTo[v] = last edge on shortest s-&gt;v path


    /**
     * Computes a shortest paths tree from &lt;tt&gt;s&lt;/tt&gt; to every other vertex in
     * the directed acyclic graph &lt;tt&gt;G&lt;/tt&gt;.
     * @param G the acyclic digraph
     * @param s the source vertex
     * @throws IllegalArgumentException if the digraph is not acyclic
     * @throws IllegalArgumentException unless 0 &le; &lt;tt&gt;s&lt;/tt&gt; &le; &lt;tt&gt;V&lt;/tt&gt; - 1
     */
    public AcyclicSP(EdgeWeightedDigraph G, int s) {
        distTo = new double[G.V()];
        edgeTo = new DirectedEdge[G.V()];
        for (int v = 0; v &lt; G.V(); v++)
            distTo[v] = Double.POSITIVE_INFINITY;
        distTo[s] = 0.0;

        // visit vertices in toplogical order
        Topological topological = new Topological(G);
        if (!topological.hasOrder())
            throw new IllegalArgumentException("Digraph is not acyclic.");
        for (int v : topological.order()) {
            for (DirectedEdge e : G.adj(v))
                relax(e);
        }
    }

    // relax edge e
    private void relax(DirectedEdge e) {
        int v = e.from(), w = e.to();
        if (distTo[w] &gt; distTo[v] + e.weight()) {
            distTo[w] = distTo[v] + e.weight();
            edgeTo[w] = e;
        }       
    }

    /**
     * Returns the length of a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;.
     * @param v the destination vertex
     * @return the length of a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;;
     *    &lt;tt&gt;Double.POSITIVE_INFINITY&lt;/tt&gt; if no such path
     */
    public double distTo(int v) {
        return distTo[v];
    }

    /**
     * Is there a path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;?
     * @param v the destination vertex
     * @return &lt;tt&gt;true&lt;/tt&gt; if there is a path from the source vertex
     *    &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;, and &lt;tt&gt;false&lt;/tt&gt; otherwise
     */
    public boolean hasPathTo(int v) {
        return distTo[v] &lt; Double.POSITIVE_INFINITY;
    }

    /**
     * Returns a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;.
     * @param v the destination vertex
     * @return a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;
     *    as an iterable of edges, and &lt;tt&gt;null&lt;/tt&gt; if no such path
     */
    public Iterable&lt;DirectedEdge&gt; pathTo(int v) {
        if (!hasPathTo(v)) return null;
        Stack&lt;DirectedEdge&gt; path = new Stack&lt;DirectedEdge&gt;();
        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {
            path.push(e);
        }
        return path;
    }
}</code></pre>


<p>上面这个算法的效率几乎已经没有提高的空间。<strong>在已知加权图是无环的情况下，它是找出最短路径的最好方法。</strong>而且它与边的权重是否非负无关，因此无环加权有向图不会受到任何限制。</p>

<h3>5.1 最长路径</h3>

<p><strong>无环加权有向图中的单点最长路径。</strong>给定一幅无环加权有向图（边的权重可能为负）和一个起点s，回答“是否存在一条从s到达给定的顶点v的路径？如果有，找出最长（总权重最大）的那条路径。”</p>

<p>最短路径的算法可以稍加改动就可以用于最长路径的计算。</p>

<ul>
<li>方法一：将无环加权有向图复制一份，将副本的所有边的权重取反数。这样副本中的最短路径即为原图中的最长路径。</li>
<li>方法二：改变AcyclicLP类中relax()方法中的不等式方向。这种方法更加简单。</li>
</ul>


<p>最长路径有什么意义？例如并行任务调度中的关键路径问题。关键路径是最长的任务序列，是任务调度中的关键手段。如何利用无环加权有向图计算关键路径？</p>

<blockquote><p>解决并行任务调度问题的关键路径方法的步骤如下：创建一幅无环加权有向图，其中包含一个起点s和一个终点t且每个任务都对应两个顶点（一个起点和一个结点顶点）。对于每个任务都有一条从它的起始顶点指向结束顶点的边，边的权重为任务所需的时间。对于每条优先级限制v->w，添加一条从v的结束顶点指向w的起始顶点的权重为零的边。为每个任务添加一条从起点指向该任务的起始顶点的权重为零的边以及一条从该任务的结束顶点到终点的权重为零的边。这样，每个任务预计的开始时间即为从起点到它的起始顶点的最长距离。</p></blockquote>

<p>下图展示了一个任务调度的无环加权有向图表示。共有0-9个任务，红线表示任务依赖关系（如任务1、7和9依赖于任务0）其权重为0，图形表示如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-05-scheduling-reduction.png" alt="image" /></p>

<p>通过计算最长路径，得到任务的关键路径：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-05-scheduling-critical-path.png" alt="image" /></p>

<p>最后期限是任务调度中常见的问题，即某个任务必须在指定的时间点之前开始，这种类型的问题如何解决？相对最后期限限制下的并行任务调度问题是一个加权有向图中的最短路径问题（可能存在环和负权重边）。这时可以为每条最后期限限制添加一条边：如果任务v必须在任务w启动后的d个时间单位内开始，则添加一条从v指向w的负权重为d的边。将所有边的权重取反即可将该问题转化为一个最短路径问题。</p>

<p>因此，负权重的边具有实际作用，但前面的算法Dijkstra只适用于非负权重的边，AcyclicSP要求有向图是无环的。它们都无法完成任务，因此需要一种更通用的方法。</p>

<h2>6. 一般加权有向图中的最短路径问题</h2>

<p>所谓一般加权有向图的最短路径问题，就是能够处理有环、负权重边的加权有向图最短路径问题。一幅加权有向图中包含环并不可怕，可怕的是这个环的总权重为负，这时候最短路径就会失去意义。因为无论何时绕这个环一圈都能得到权重更小的路径。<strong>负权重环</strong>就是这样一个总权重（环上的所有边的权重之和）为负的有向环。</p>

<blockquote><p>当且仅当加权有向图中至少存在一条从s到v的有向路径且所有从s到v的有向路径上的任意顶点都不存在于任何负权重环中时，s到v的最短路径才是存在的。</p></blockquote>

<p>Bellman-Ford算法，在任意含有V个顶点的加权有向图中给定起点s，从s无法到达任何负权重环，以下算法能够解决其中的单点最短路径问题：将distTo[s]初始化为0，其他distTo[]元素初始化为无穷大。以任意顺序放松有向图的所有边，重复V轮。</p>

<p>Bellman-Ford算法所需的时间和EV成正比，空间和V成正比。因为每一轮算法都会放松E条边，共重复了V轮。把这个算法稍加改进可以提高效率。每一轮放松所有边的过程中，许多边的放松都不会成功。只有上一轮中的distTo[]值发生变化的顶点指出的边才能够改变其他distTo[]元素的值。因此可以用FIFO队列记录这样的顶点，不需要放松所有边。代码实现如下（先忽略负权重环的代码）：</p>

<pre class='line-numbers language-java'><code class='language-java'>public class BellmanFordSP {
    private double[] distTo;               // distTo[v] = 从起点到某个顶点的路径长度
    private DirectedEdge[] edgeTo;         // edgeTo[v] = 从起点到某个顶点的最后一条边
    private boolean[] onQueue;             // onQueue[v] = 该顶点是否存在于队列中
    private Queue&lt;Integer&gt; queue;          // 正在被放松的顶点
    private int cost;                      // relax()的调用次数
    private Iterable&lt;DirectedEdge&gt; cycle;  // edgeTo[]是否有负权重环

    /**
     * Computes a shortest paths tree from &lt;tt&gt;s&lt;/tt&gt; to every other vertex in
     * the edge-weighted digraph &lt;tt&gt;G&lt;/tt&gt;.
     * @param G the acyclic digraph
     * @param s the source vertex
     * @throws IllegalArgumentException unless 0 &le; &lt;tt&gt;s&lt;/tt&gt; &le; &lt;tt&gt;V&lt;/tt&gt; - 1
     */
    public BellmanFordSP(EdgeWeightedDigraph G, int s) {
        distTo  = new double[G.V()];
        edgeTo  = new DirectedEdge[G.V()];
        onQueue = new boolean[G.V()];
        for (int v = 0; v &lt; G.V(); v++)
            distTo[v] = Double.POSITIVE_INFINITY;
        distTo[s] = 0.0;

        // Bellman-Ford algorithm
        queue = new Queue&lt;Integer&gt;();
        queue.enqueue(s);
        onQueue[s] = true;
        while (!queue.isEmpty() && !hasNegativeCycle()) {
            int v = queue.dequeue();
            onQueue[v] = false;
            relax(G, v);
        }
    }

    // relax vertex v and put other endpoints on queue if changed
    private void relax(EdgeWeightedDigraph G, int v) {
        for (DirectedEdge e : G.adj(v)) {
            int w = e.to();
            if (distTo[w] &gt; distTo[v] + e.weight()) {
                //成功放松的边指向的所有顶点加入到FIFO队列
                distTo[w] = distTo[v] + e.weight();
                edgeTo[w] = e;
                if (!onQueue[w]) {
                    queue.enqueue(w);
                    onQueue[w] = true;
                }
            }
            //周期性地检查是否有负权重环，避免无限循环
            if (cost++ % G.V() == 0) 
                findNegativeCycle();
        }
    }

    /**
     * Is there a negative cycle reachable from the source vertex &lt;tt&gt;s&lt;/tt&gt;?
     * @return &lt;tt&gt;true&lt;/tt&gt; if there is a negative cycle reachable from the
     *    source vertex &lt;tt&gt;s&lt;/tt&gt;, and &lt;tt&gt;false&lt;/tt&gt; otherwise
     */
    public boolean hasNegativeCycle() {
        return cycle != null;
    }

    /**
     * Returns a negative cycle reachable from the source vertex &lt;tt&gt;s&lt;/tt&gt;, or &lt;tt&gt;null&lt;/tt&gt;
     * if there is no such cycle.
     * @return a negative cycle reachable from the soruce vertex &lt;tt&gt;s&lt;/tt&gt; 
     *    as an iterable of edges, and &lt;tt&gt;null&lt;/tt&gt; if there is no such cycle
     */
    public Iterable&lt;DirectedEdge&gt; negativeCycle() {
        return cycle;
    }

    // by finding a cycle in predecessor graph
    private void findNegativeCycle() {
        int V = edgeTo.length;
        EdgeWeightedDigraph spt = new EdgeWeightedDigraph(V);
        for (int v = 0; v &lt; V; v++)
            if (edgeTo[v] != null)
                spt.addEdge(edgeTo[v]);

        EdgeWeightedDirectedCycle finder = new EdgeWeightedDirectedCycle(spt);
        cycle = finder.cycle();
    }

    /**
     * Returns the length of a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;.
     * @param v the destination vertex
     * @return the length of a shortest path from the source vertex &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;;
     *    &lt;tt&gt;Double.POSITIVE_INFINITY&lt;/tt&gt; if no such path
     * @throws UnsupportedOperationException if there is a negative cost cycle reachable
     *    from the source vertex &lt;tt&gt;s&lt;/tt&gt;
     */
    public double distTo(int v) {
        if (hasNegativeCycle())
            throw new UnsupportedOperationException("Negative cost cycle exists");
        return distTo[v];
    }

    /**
     * Is there a path from the source &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;?
     * @param v the destination vertex
     * @return &lt;tt&gt;true&lt;/tt&gt; if there is a path from the source vertex
     *    &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;, and &lt;tt&gt;false&lt;/tt&gt; otherwise
     */
    public boolean hasPathTo(int v) {
        return distTo[v] &lt; Double.POSITIVE_INFINITY;
    }

    /**
     * Returns a shortest path from the source &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;.
     * @param v the destination vertex
     * @return a shortest path from the source &lt;tt&gt;s&lt;/tt&gt; to vertex &lt;tt&gt;v&lt;/tt&gt;
     *    as an iterable of edges, and &lt;tt&gt;null&lt;/tt&gt; if no such path
     * @throws UnsupportedOperationException if there is a negative cost cycle reachable
     *    from the source vertex &lt;tt&gt;s&lt;/tt&gt;
     */
    public Iterable&lt;DirectedEdge&gt; pathTo(int v) {
        if (hasNegativeCycle())
            throw new UnsupportedOperationException("Negative cost cycle exists");
        if (!hasPathTo(v)) return null;
        Stack&lt;DirectedEdge&gt; path = new Stack&lt;DirectedEdge&gt;();
        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {
            path.push(e);
        }
        return path;
    }
}</code></pre>


<h3>6.1 负权重环的检测</h3>

<p>BellmanFordSP的实现会检测负权重环来避免陷入无限循环。当BellmanFordSP构造函数运行之后，将所有边放松V轮之后当且仅当队列非空时有向图中才存在从起点可达的负权重环。如果是这样，edgeTo[]数组中所表示的子图必然含有这个负权重环。因此nagativeCycle()的实现中，会根据edgeTo[]中的边构造一幅加权有向图并在该图中检测环。我们修改DirectedCycle类来在加权有向图中寻找环：</p>

<pre class='line-numbers language-java'><code class='language-java'>public class EdgeWeightedDirectedCycle {
    private boolean[] marked;             // marked[v] = has vertex v been marked?
    private DirectedEdge[] edgeTo;        // edgeTo[v] = previous edge on path to v
    private boolean[] onStack;            // onStack[v] = is vertex on the stack?
    private Stack&lt;DirectedEdge&gt; cycle;    // directed cycle (or null if no such cycle)

    /**
     * Determines whether the edge-weighted digraph &lt;tt&gt;G&lt;/tt&gt; has a directed cycle and,
     * if so, finds such a cycle.
     * @param G the edge-weighted digraph
     */
    public EdgeWeightedDirectedCycle(EdgeWeightedDigraph G) {
        marked  = new boolean[G.V()];
        onStack = new boolean[G.V()];
        edgeTo  = new DirectedEdge[G.V()];
        for (int v = 0; v &lt; G.V(); v++)
            if (!marked[v]) dfs(G, v);
    }

    // check that algorithm computes either the topological order or finds a directed cycle
    private void dfs(EdgeWeightedDigraph G, int v) {
        onStack[v] = true;
        marked[v] = true;
        for (DirectedEdge e : G.adj(v)) {
            int w = e.to();

            // short circuit if directed cycle found
            if (cycle != null) return;

            //found new vertex, so recur
            else if (!marked[w]) {
                edgeTo[w] = e;
                dfs(G, w);
            }

            // trace back directed cycle
            else if (onStack[w]) {
                cycle = new Stack&lt;DirectedEdge&gt;();
                while (e.from() != w) {
                    cycle.push(e);
                    e = edgeTo[e.from()];
                }
                cycle.push(e);
            }
        }

        onStack[v] = false;
    }

    /**
     * Does the edge-weighted digraph have a directed cycle?
     * @return &lt;tt&gt;true&lt;/tt&gt; if the edge-weighted digraph has a directed cycle,
     * &lt;tt&gt;false&lt;/tt&gt; otherwise
     */
    public boolean hasCycle() {
        return cycle != null;
    }

    /**
     * Returns a directed cycle if the edge-weighted digraph has a directed cycle,
     * and &lt;tt&gt;null&lt;/tt&gt; otherwise.
     * @return a directed cycle (as an iterable) if the edge-weighted digraph
     *    has a directed cycle, and &lt;tt&gt;null&lt;/tt&gt; otherwise
     */
    public Iterable&lt;DirectedEdge&gt; cycle() {
        return cycle;
    }
}</code></pre>


<h3>6.2 套汇</h3>

<p>前面的问题都是权重之和，而套汇问题演示了另一种方式。套汇是通过不同货币间进行兑换赚取利润。这也是一个加权有向图的应用。顶点是货币，s->t表示货币s到t的汇率。如何交易使得利润最大，就是找到各权重之<strong>积</strong>最大者。但我们之前所学的都是权重之和，那么如何解决这个问题呢？</p>

<p>套汇问题等价于加权有向图中的负权重环的检测问题：</p>

<blockquote><p>取每条边权重的自然对数并取反，这样在原始问题中所有边的权重之积的计算就转化为新图中所有边的权重之和的计算。任意权重之积 w<sub>1</sub>w<sub>2</sub>&hellip;w<sub>k</sub>即对应-ln(w<sub>1</sub>)-ln(w<sub>2</sub>)&ndash;&hellip;-ln(w<sub>k</sub>)之和。转换后边的权重可能为正也可能为负。一条从v到w的路径表示将货币v兑换为货币w，任意负权重环都是一次套汇的好机会。</p></blockquote>

<h2>7. 总结</h2>

<p>最短路径算法的性能特点如下表：</p>

<table>
<thead>
<tr>
<th>算法</th>
<th>局限</th>
<th>一般情况</th>
<th>最坏情况</th>
<th>所需空间</th>
<th> 优势</th>
</tr>
</thead>
<tbody>
<tr>
<td>Dijkstra算法（即时版本） </td>
<td> 边的权重必须为正 </td>
<td> ElogV </td>
<td> ElogV </td>
<td> V </td>
<td> 最坏情况下仍有较好的性能</td>
</tr>
<tr>
<td>拓扑排序</td>
<td> 只适用于无环加权有向图</td>
<td> E + V </td>
<td> E + V </td>
<td> V </td>
<td> 是无环图中的最优算法</td>
</tr>
<tr>
<td>Bellman-Ford算法（基于队列）</td>
<td>不能存在负权重环</td>
<td> E+V </td>
<td> EV </td>
<td> V</td>
<td> 适用领域广泛</td>
</tr>
</tbody>
</table>


<p>参考：<a href="http://algs4.cs.princeton.edu/44sp/">http://algs4.cs.princeton.edu/44sp/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最小生成树]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/31/zui-xiao-sheng-cheng-shu/"/>
    <updated>2014-10-31T22:38:49+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/31/zui-xiao-sheng-cheng-shu</id>
    <content type="html"><![CDATA[<p>加权图是一种为每条边关联一个权值或成本的图模型。这种图最令人感兴趣的是将成本最小化。本节学习加权无向图模型并找到它的一棵最小生成树。</p>

<p>图的生成树是它的一棵含有其所有顶点的无环连通子图。一幅加权图的最小生成树（MST）是它的一棵权值（树中所有边的权值之和）最小的生成树。</p>

<!--more-->


<h2>1. 一些约定</h2>

<p>为了方便说明，有以下这些约定：</p>

<ul>
<li>只考虑连通图。如果图是非连通的，只能计算它的所有连通分量的最小生成树，合并起来称为最小生成森林。</li>
<li>边的权重不一定表示距离。但为了看起来方便，示意图会用距离来表示权重。</li>
<li>边的权重可能是0或者负数。</li>
<li>所有边的权重都各不相同。如果权重可以相同，最小生成树就不一定唯一，算法证明会更复杂。但实际上算法也适用于存在权重相等的情况。</li>
</ul>


<h2>2. 原理</h2>

<p>图的一种<strong>切分</strong>是将图的所有顶点分为两个非空且不重叠的两个集合。<strong>横切边</strong>是一条连接两个属于不同集合的顶点的边。</p>

<blockquote><p>切分定理：在一幅加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图的最小生成树。</p></blockquote>

<p>切分定理会把加权图中的所有顶点分为两个集合，检查横跨两个集合的所有边并识别哪边边应属于图的最小生成树。</p>

<h2>3. 加权无向图的数据结构</h2>

<p>通过扩展无向图的邻接矩阵来表示加权无向图。在无向图的邻接表表示中，第v个顶点的列表中每个元素都是和顶点v相邻的顶点。在加权无向图中，我们将其替换为一个加权边Edge：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-02-edge-api.png" alt="image" /></p>

<p>上图中，eaither()表示边的两个顶点中的某一个，而other()则返回另一个顶点。有了加权边Edge，加权无向图的API就与无向图非常接近，在实现上，只是在邻接表中用Edge对象替代了无向图Graph中的整数作为链表的结点：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-02-edge-weighted-graph-api.png" alt="image" /></p>

<p>加权无向图的表示如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-02-edge-weighted-graph-representation.png" alt="image" /></p>

<p>代码实现如下：</p>

<pre class='line-numbers language-java'><code class='language-java'>public class Edge implements Comparable&lt;Edge&gt; { 
    private final int v;
    private final int w;
    private final double weight;

    public Edge(int v, int w, double weight) {
        if (v &lt; 0) throw new IndexOutOfBoundsException("Vertex name must be a nonnegative integer");
        if (w &lt; 0) throw new IndexOutOfBoundsException("Vertex name must be a nonnegative integer");
        if (Double.isNaN(weight)) throw new IllegalArgumentException("Weight is NaN");
        this.v = v;
        this.w = w;
        this.weight = weight;
    }

    public double weight() {
        return weight;
    }

    public int either() {
        return v;
    }

    public int other(int vertex) {
        if      (vertex == v) return w;
        else if (vertex == w) return v;
        else throw new IllegalArgumentException("Illegal endpoint");
    }

    public int compareTo(Edge that) {
        if      (this.weight() &lt; that.weight()) return -1;
        else if (this.weight() &gt; that.weight()) return +1;
        else                                    return  0;
    }

    public String toString() {
        return String.format("%d-%d %.5f", v, w, weight);
    }
}    </code></pre>




<pre class='line-numbers language-java'><code class='language-java'>public class EdgeWeightedGraph {
    private final int V;
    private int E;
    private Bag&lt;Edge&gt;[] adj;
    
    /**
     * Initializes an empty edge-weighted graph with &lt;tt&gt;V&lt;/tt&gt; vertices and 0 edges.
     * param V the number of vertices
     * @throws java.lang.IllegalArgumentException if &lt;tt&gt;V&lt;/tt&gt; &lt; 0
     */
    public EdgeWeightedGraph(int V) {
        if (V &lt; 0) throw new IllegalArgumentException("Number of vertices must be nonnegative");
        this.V = V;
        this.E = 0;
        adj = (Bag&lt;Edge&gt;[]) new Bag[V];
        for (int v = 0; v &lt; V; v++) {
            adj[v] = new Bag&lt;Edge&gt;();
        }
    }

    /**
     * Initializes a random edge-weighted graph with &lt;tt&gt;V&lt;/tt&gt; vertices and &lt;em&gt;E&lt;/em&gt; edges.
     * param V the number of vertices
     * param E the number of edges
     * @throws java.lang.IllegalArgumentException if &lt;tt&gt;V&lt;/tt&gt; &lt; 0
     * @throws java.lang.IllegalArgumentException if &lt;tt&gt;E&lt;/tt&gt; &lt; 0
     */
    public EdgeWeightedGraph(int V, int E) {
        this(V);
        if (E &lt; 0) throw new IllegalArgumentException("Number of edges must be nonnegative");
        for (int i = 0; i &lt; E; i++) {
            int v = (int) (Math.random() * V);
            int w = (int) (Math.random() * V);
            double weight = Math.round(100 * Math.random()) / 100.0;
            Edge e = new Edge(v, w, weight);
            addEdge(e);
        }
    }

    /**  
     * Initializes an edge-weighted graph from an input stream.
     * The format is the number of vertices &lt;em&gt;V&lt;/em&gt;,
     * followed by the number of edges &lt;em&gt;E&lt;/em&gt;,
     * followed by &lt;em&gt;E&lt;/em&gt; pairs of vertices and edge weights,
     * with each entry separated by whitespace.
     * @param in the input stream
     * @throws java.lang.IndexOutOfBoundsException if the endpoints of any edge are not in prescribed range
     * @throws java.lang.IllegalArgumentException if the number of vertices or edges is negative
     */
    public EdgeWeightedGraph(In in) {
        this(in.readInt());
        int E = in.readInt();
        if (E &lt; 0) throw new IllegalArgumentException("Number of edges must be nonnegative");
        for (int i = 0; i &lt; E; i++) {
            int v = in.readInt();
            int w = in.readInt();
            double weight = in.readDouble();
            Edge e = new Edge(v, w, weight);
            addEdge(e);
        }
    }

    /**
     * Initializes a new edge-weighted graph that is a deep copy of &lt;tt&gt;G&lt;/tt&gt;.
     * @param G the edge-weighted graph to copy
     */
    public EdgeWeightedGraph(EdgeWeightedGraph G) {
        this(G.V());
        this.E = G.E();
        for (int v = 0; v &lt; G.V(); v++) {
            // reverse so that adjacency list is in same order as original
            Stack&lt;Edge&gt; reverse = new Stack&lt;Edge&gt;();
            for (Edge e : G.adj[v]) {
                reverse.push(e);
            }
            for (Edge e : reverse) {
                adj[v].add(e);
            }
        }
    }

    //图的顶点数
    public int V() {
        return V;
    }

    //图的边数
    public int E() {
        return E;
    }

    //向图中添加一条边e
    public void addEdge(Edge e) {
        int v = e.either();
        int w = e.other(v);
        if (v &lt; 0 || v &gt;= V) throw new IndexOutOfBoundsException("vertex " + v + " is not between 0 and " + (V-1));
        if (w &lt; 0 || w &gt;= V) throw new IndexOutOfBoundsException("vertex " + w + " is not between 0 and " + (V-1));
        adj[v].add(e);
        adj[w].add(e);
        E++;
    }

    //与v相关联的所有边
    public Iterable&lt;Edge&gt; adj(int v) {
        if (v &lt; 0 || v &gt;= V) throw new IndexOutOfBoundsException("vertex " + v + " is not between 0 and " + (V-1));
        return adj[v];
    }

    //图中的所有边
    public Iterable&lt;Edge&gt; edges() {
        Bag&lt;Edge&gt; list = new Bag&lt;Edge&gt;();
        for (int v = 0; v &lt; V; v++) {
            int selfLoops = 0;
            for (Edge e : adj(v)) {
                if (e.other(v) &gt; v) {
                    list.add(e);
                }
                // only add one copy of each self loop (self loops will be consecutive)
                else if (e.other(v) == v) {
                    if (selfLoops % 2 == 0) list.add(e);
                    selfLoops++;
                }
            }
        }
        return list;
    }

    public String toString() {
        String NEWLINE = System.getProperty("line.separator");
        StringBuilder s = new StringBuilder();
        s.append(V + " " + E + NEWLINE);
        for (int v = 0; v &lt; V; v++) {
            s.append(v + ": ");
            for (Edge e : adj[v]) {
                s.append(e + "  ");
            }
            s.append(NEWLINE);
        }
        return s.toString();
    }
}</code></pre>


<h2>4. 最小生成树的API及实现</h2>

<p>下面API定义的构造函数接受加权无向图作为参数，并返回最小生成树和其权重。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-02-mst-api.png" alt="image" /></p>

<p>Prim算法和Kruskal算法都可以实现最小生成树，它们都基于贪心算法，区别在于保存切分和判定权重最小的横切边的方式。</p>

<blockquote><p>贪心算法：初始状态下所有边均为灰色，找到一种切分，它产生的横切边均不为黑色。将权重最小的横切边标记为黑色。反复这个步骤直到标记了V-1条黑色边为止。</p></blockquote>

<h3>4.1 Prim算法</h3>

<p>Prim算法每一步都会为一棵生长中的树添加一条边。一开始这棵树只有一个顶点，然后会向它添加V-1条边，每次总是找到这样一条边并将其加入树中：这条边的一端在树中，另一端不在树中，并且权值最小。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-02-prim-eager.jpg" alt="image" /></p>

<p>每当向树中添加一条边后，也向树中添加了一个顶点。要维护一个包含所有横切边的集合，可以将连接这个顶点和其他所有不在树中的顶点的边加入优先队列。这样就可以得到符合条件的权值最小的边。当一个顶点加入树中后，连接这个顶点与树中其它顶点的所有边就失效了，因为这些边的两个顶点都已经在树中，这些边不再是横切边。那么何时删除这些边就形成了Prim算法的两种实现：</p>

<ul>
<li>延时(Lazy)实现会先把它们留在队列中，等要删除时再检查边的有效性；</li>
<li>即时实现可以将它们从优先队列中删除。</li>
</ul>


<p>这两种实现所需的时间都与ElogE成正比（最坏情况下），延时实现所需的空间与E成正比，瓶颈在于优先队列的insert()和delMin()中比较边的权重次数。而即时实现所需空间的上限与V成正比，比延时实现有优势。两种实现代码如下：</p>

<pre class='line-numbers language-java'><code class='language-java'>public class LazyPrimMST {
    private double weight;       // total weight of MST
    private Queue&lt;Edge&gt; mst;     // edges in the MST
    private boolean[] marked;    // marked[v] = true if v on tree
    private MinPQ&lt;Edge&gt; pq;      // edges with one endpoint in tree

    /**
     * Compute a minimum spanning tree (or forest) of an edge-weighted graph.
     * @param G the edge-weighted graph
     */
    public LazyPrimMST(EdgeWeightedGraph G) {
        mst = new Queue&lt;Edge&gt;();
        pq = new MinPQ&lt;Edge&gt;();
        marked = new boolean[G.V()];
        for (int v = 0; v &lt; G.V(); v++)     // run Prim from all vertices to
            if (!marked[v]) prim(G, v);     // get a minimum spanning forest
    }

    // run Prim's algorithm
    private void prim(EdgeWeightedGraph G, int s) {
        scan(G, s);
        while (!pq.isEmpty()) {                        // better to stop when mst has V-1 edges
            Edge e = pq.delMin();                      // smallest edge on pq
            int v = e.either(), w = e.other(v);        // two endpoints
            assert marked[v] || marked[w];
            if (marked[v] && marked[w]) continue;      // lazy, both v and w already scanned
            mst.enqueue(e);                            // add e to MST
            weight += e.weight();
            if (!marked[v]) scan(G, v);               // v becomes part of tree
            if (!marked[w]) scan(G, w);               // w becomes part of tree
        }
    }

    //标记顶点v并将所有连接v和未被标记顶点的边加入pq
    private void scan(EdgeWeightedGraph G, int v) {
        assert !marked[v];
        marked[v] = true;
        for (Edge e : G.adj(v))
            if (!marked[e.other(v)]) pq.insert(e);
    }
        
    //树的所有边
    public Iterable&lt;Edge&gt; edges() {
        return mst;
    }

    //树的权重
    public double weight() {
        return weight;
    }
}</code></pre>




<pre class='line-numbers language-java'><code class='language-java'>public class PrimMST {
    private Edge[] edgeTo;        // 距离树最近的边，edgeTo[v] = shortest edge from tree vertex to non-tree vertex
    private double[] distTo;      // distTo[v] = weight of shortest such edge
    private boolean[] marked;     // marked[v] = true if v on tree, false otherwise
    private IndexMinPQ&lt;Double&gt; pq;  //有效的横切边

    /**
     * Compute a minimum spanning tree (or forest) of an edge-weighted graph.
     * @param G the edge-weighted graph
     */
    public PrimMST(EdgeWeightedGraph G) {
        edgeTo = new Edge[G.V()];
        distTo = new double[G.V()];
        marked = new boolean[G.V()];
        pq = new IndexMinPQ&lt;Double&gt;(G.V());
        for (int v = 0; v &lt; G.V(); v++) distTo[v] = Double.POSITIVE_INFINITY;

        for (int v = 0; v &lt; G.V(); v++)      // run from each vertex to find
            if (!marked[v]) prim(G, v);      // minimum spanning forest
    }

    // run Prim's algorithm in graph G, starting from vertex s
    private void prim(EdgeWeightedGraph G, int s) {
        distTo[s] = 0.0;
        pq.insert(s, distTo[s]); //用顶点0和权重0初始化pq
        while (!pq.isEmpty()) {
            int v = pq.delMin();  
            scan(G, v);          //将最近的顶点添加到树中
        }
    }

    // scan vertex v
    private void scan(EdgeWeightedGraph G, int v) {
            //将顶点v添加到树中，更新数据
        marked[v] = true;
        for (Edge e : G.adj(v)) {
            int w = e.other(v);
            if (marked[w]) continue;         // v-w 已经失效
            if (e.weight() &lt; distTo[w]) {
                    //连接w和树的最佳边Edge变为e
                distTo[w] = e.weight();
                edgeTo[w] = e;
                if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);
                else                pq.insert(w, distTo[w]);
            }
        }
    }

    //所有边
    public Iterable&lt;Edge&gt; edges() {
        Queue&lt;Edge&gt; mst = new Queue&lt;Edge&gt;();
        for (int v = 0; v &lt; edgeTo.length; v++) {
            Edge e = edgeTo[v];
            if (e != null) {
                mst.enqueue(e);
            }
        }
        return mst;
    }

    //权重
    public double weight() {
        double weight = 0.0;
        for (Edge e : edges())
            weight += e.weight();
        return weight;
    }
}</code></pre>


<h3>4.2 Kruskal算法</h3>

<p>Kruskal算法构造最小生成树时也是一条边一条边地构造，但它寻找的边会连接一片森林中的两棵树。我们从一片由V棵单顶点的树构成的森林开始并不断将两棵树合并（用可以找到的最短边）直到只剩下一棵树。其主要思想是按边的权重顺序处理它们，将边加入最小生成树中，加入的边不会与已经加入的边构成环，直到树中含有V-1条边为止。</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-11-02-kruskal.jpg" alt="image" /></p>

<p>实现时，采用优先队列将边按照权重排序，用一个union-find数据结构识别会形成环的边，以及一个队列来保存最小生成树的所有边。代码实现如下：</p>

<pre class='line-numbers language-java'><code class='language-java'>public class KruskalMST {
    private double weight;  // weight of MST
    private Queue&lt;Edge&gt; mst = new Queue&lt;Edge&gt;();  // edges in MST

    public KruskalMST(EdgeWeightedGraph G) {
        // more efficient to build heap by passing array of edges
        MinPQ&lt;Edge&gt; pq = new MinPQ&lt;Edge&gt;();
        for (Edge e : G.edges()) {
            pq.insert(e);
        }

        // run greedy algorithm
        UF uf = new UF(G.V());
        while (!pq.isEmpty() && mst.size() &lt; G.V() - 1) {
            Edge e = pq.delMin();  //从pq得到权重最小的边和它的顶点
            int v = e.either();
            int w = e.other(v);
            if (!uf.connected(v, w)) { // v-w does not create a cycle
                uf.union(v, w);  // merge v and w components
                mst.enqueue(e);  // add edge e to mst
                weight += e.weight();
            }
        }
    }

    //树的所有边
    public Iterable&lt;Edge&gt; edges() {
        return mst;
    }

    //树的权重
    public double weight() {
        return weight;
    }
}</code></pre>


<p>Kruskal算法所需的空间与E成正比，所需时间与ElogE成正比（最坏情况下）。</p>

<p>Prim和Kruskal算法不能处理有向图。</p>

<p>参考：<a href="http://algs4.cs.princeton.edu/43mst/">http://algs4.cs.princeton.edu/43mst</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[有向图]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/30/you-xiang-tu/"/>
    <updated>2014-10-30T20:10:54+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/30/you-xiang-tu</id>
    <content type="html"><![CDATA[<p>有向图也就是有方向性的图，是由一组顶点和一组有方向的边组成，每条有方向的边都连接着有序的一对顶点。本文要解决的有向图问题：</p>

<ol>
<li>单点和多点的可达性</li>
<li>单点有向路径</li>
<li>单点最短有向路径</li>
<li>有向环检测</li>
<li>深度优先的顶点排序</li>
<li>优先级限制下的调度问题</li>
<li>拓扑排序</li>
<li>强连通性</li>
<li>顶点对的可达性</li>
</ol>


<!--more-->


<h2>1. 术语</h2>

<ul>
<li>出度：一个顶点指出的边的总数；</li>
<li>入度：指向该顶点的边的总数；</li>
<li>一条有向边的第一个顶点称为头，第二个顶点称为尾。</li>
<li>在一幅有向图中，有向路径由一系列顶点组成，对于其中的每个顶点都存在一条有向边从它指向序列中的下一个顶点。</li>
</ul>


<h2>2. 有向图的数据类型</h2>

<p>有向图的API与无向图本质相同，只是多了一个取反操作。如下图：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-20-digraph-api.png" alt="image" /></p>

<p>其中，reverse()方向返回有向图的一个副本，但是将其中的方向反转。adj()返回的是每个顶点指出的边所连接的所有顶点。</p>

<p>Diagraph的实现与无向图Graph非常类似，也是采用邻接表实现，但由于边是有向的，所以假设7&mdash;>8的一条边，则在顶点7的邻接表中有8，而顶点8的邻接表却没有7. <a href="http://algs4.cs.princeton.edu/42directed/Digraph.java.html">实现代码</a>不再重复。</p>

<h2>3. 有向图中的可达性</h2>

<ul>
<li>单点可达性：是否存在一条从s到达给定顶点v的有向路径？</li>
<li>多点可达性：是否存在一条从集合中的任意顶点到达给定顶点v的有向路径？</li>
</ul>


<p>API定义和实现如下：</p>

<pre  class='line-numbers language-bash'><code class='language-bash'>public class DirectedDFS {
    private boolean[] marked;
    
    //在G中找到从s可达的所有顶点
    public DirectedDFS(Digraph G, int s) {
        marked = new boolean[G.V()];
        dfs(G, s);
    }
    
    //在G中找到从sources中的所有顶点可达的所有顶点
    public DirectedDFS(Digraph G, Iterable&lt;Integer&gt; sources) {
        marked = new boolean[G.V()];
        for(int s : sources) {
            if (! marked[s]) dfs(G, s);
        }
    }
    
    private void dfs(Digraph G, int v) {
        marked[v] = true;
        for(int w : G.adj(v)){
            if (!marked[w]) dfs(G, w);
        }
    }
    
    //v是可达的吗？
    public boolean marked(int v) {
        return marked[v];
    }
}</code></pre>


<p><strong>标记-清除：</strong>多点可达性的一个重要典型应用就是内存管理，包括许多Java的实现。一个顶点表示一个对象，一条边表示一个对象对另一个对象的引用。在程序执行任何时候，都有某些对象是可以被直接访问的，而不能通过这些对象访问到的所有对象都应该被回收。标记-清除的垃圾回收策略会为每个对象保留一个位做垃圾收集之用。</p>

<p><strong>有向图的寻路：</strong></p>

<ul>
<li>单点有向路径：从s到给定的顶点v是否存在一条有向路径？如果有，找出这条路径。</li>
<li>单点最短有向路径：从s到给定的顶点v是否存在一条有向路径？如果有，找出最短的那边。</li>
</ul>


<p>这两个问题都可以通过深度优先和广度优先解决，它们仍是有向图的重要算法。API和代码也基本相同。</p>

<h2>4. 环和有向无环图</h2>

<h3>4.1 有向图中的环</h3>

<p>任务调度是一个典型的有向图用例，其限制条件包括任务的起始时间、时耗、优先级限制（某个任务是另一个任务的前置条件）等。如何进行正确的任务调度？这需要<strong>拓扑排序</strong>：给定一幅有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素。拓扑排序的例子还包括课程安排（先导课程限制）、继承（Java extends）、电子表格公式等等。</p>

<p>如果一个有优先级限制的问题中存在有向环，例如任务x必须在任务y之前完成，而y必须在z之前完成，但z又必须在x之前完成，那么这个问题就无解了！所以首先要解决<strong>有向环的检测</strong>：给定的有向图中包含有向环吗？</p>

<p><strong>有向无环图（DAG）是一幅不含有向环的有向图。</strong></p>

<p>有向环的检测可以通过深度优先搜索来解决。用一个栈表示正在遍历的有向路径，一旦找到一条有向边v->w且w已经在堆栈中，就找到了一个环。</p>

<pre class='line-numbers language-java'><code class='language-java'>public class DirectedCycle {
    private boolean[] marked;        // marked[v] = 顶点v是否已经访问过?
    private int[] edgeTo;            // edgeTo[v] = 指向v的前一个顶点
    private boolean[] onStack;       // onStack[v] = 顶点v在递归调用的堆栈上吗？
    private Stack&lt;Integer&gt; cycle;    // 有向环 (null表示不存在有向环)

    public DirectedCycle(Digraph G) {
        marked  = new boolean[G.V()];
        onStack = new boolean[G.V()];
        edgeTo  = new int[G.V()];
        for (int v = 0; v &lt; G.V(); v++)
            if (!marked[v]) dfs(G, v);
    }

    private void dfs(Digraph G, int v) {
        onStack[v] = true;
        marked[v] = true;
        for (int w : G.adj(v)) {
            // 如果环已找到，退出
            if (cycle != null) {
                   return;
            }
            //找到新顶点，继续
            else if (!marked[w]) {
                edgeTo[w] = v;
                dfs(G, w);
            }
            // 找到有向环，记录下路径
            else if (onStack[w]) {
                cycle = new Stack&lt;Integer&gt;();
                for (int x = v; x != w; x = edgeTo[x]) {
                    cycle.push(x);
                }
                cycle.push(w);
                cycle.push(v);
            }
        }

        onStack[v] = false;
    }

    //是否含有有向环
    public boolean hasCycle() {
        return cycle != null;
    }

    //有向环中的所有顶点（如果存在有向环的话）
    public Iterable&lt;Integer&gt; cycle() {
        return cycle;
    }
}</code></pre>


<h3>4.2 顶点的深度优先次序与拓扑排序</h3>

<p>优先级限制下的调度问题等价于计算有向无环图中的所有顶点的拓扑排序。只需要在标准深度优先搜索中，将<code>dfs()</code>的顶点参数保存在一个数据结构中，遍历这个数据结构就能访问所有的顶点。遍历的顺序取决于这个数据结构的性质以及是在递归调用之前还是之后进行保存。主要有3种排序顺序：</p>

<ol>
<li>前序(pre)：在递归调用之前将顶点加入队列。</li>
<li>后序(post)：在递归调用之后将顶点加入队列。</li>
<li>逆后序(reversePost)：在递归调用之后将顶点压入堆栈。</li>
</ol>


<p>对于这样一张有向图，三种顺序遍历过程如下：</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-29-dag.png" alt="image" /></p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-29-depth-first-orders.png" alt="image" /></p>

<p>下面实现的DepthFirstOrder实现了这三种排序：</p>

<pre class='line-numbers language-java'><code class='language-java'>public class DepthFirstOrder {
    private boolean[] marked;          // marked[v] = has v been marked in dfs?
    private Queue&lt;Integer&gt; pre;                 // pre[v]    = preorder  number of v
    private Queue&lt;Integer&gt; post;                // post[v]   = postorder number of v
    private Stack&lt;Integer&gt; reversePost;
    
    public DepthFirstOrder(Digraph G) {
        pre    = new Queue&lt;Integer&gt;();
        post   = new Queue&lt;Integer&gt;();
        reversePost = new Stack&lt;Integer&gt;();
        marked    = new boolean[G.V()];
        
        for (int v = 0; v &lt; G.V(); v++)
            if (!marked[v]) dfs(G, v);
    }

    private void dfs(Digraph G, int v) {
        pre.enqueue(v);
        
        marked[v] = true;
        
        for (int w : G.adj(v)) {
            if (!marked[w]) {
                dfs(G, w);
            }
        }
        
        post.enqueue(v);
        reversePost.push(v);
    }
    
    public Iterable&lt;Integer&gt; pre() {
        return pre;
    }
    public Iterable&lt;Integer&gt; post() {
        return post;
    }   
    public Iterable&lt;Integer&gt; reversePost() {
        return reversePost;
    }
}</code></pre>


<p>DepthFirstOrder提供了三种排序的顶点列表：pre, post, reversePost，因此拓扑排序就非常简单了：</p>

<pre class='line-numbers language-java'><code class='language-java'>public class Topological {
    private Iterable&lt;Integer&gt; order;    // topological order

    public Topological(Digraph G) {
        DirectedCycle finder = new DirectedCycle(G);
        if (!finder.hasCycle()) {
            DepthFirstOrder dfs = new DepthFirstOrder(G);
            order = dfs.reversePost();
        }
    }

    //拓扑有序的所有顶点
    public Iterable&lt;Integer&gt; order() {
        return order;
    }

    //G是有向无环图吗？
    public boolean isDAG() {
        return order != null;
    }
}    </code></pre>


<p><strong>一幅有向无环图的拓扑顺序就是所有顶点的逆后序排列。</strong>这是一个重要结论！证明如下：对于任意边v->w, 在调用dfs(v)时，必有以下三种情况之一：</p>

<ol>
<li>dfs(w)已经被调用过且已经返回（w已经被标记）。</li>
<li>dfs(w)还没有被调用，因此v->会直接或间接调用并返回dfs(w)，且dfs(w)会在dfs(v)返回前返回。</li>
<li>dfs(w)已经被调用但未返回。</li>
</ol>


<p>第3种情况表示存在环，所以在有向无环图中是不可能出现的。第1、2种情况都证明了dfs(w)会先于dfs(v)完成。后序排列时w在v之前，只有逆后序时，w排在v之后。因此逆后序是有向无环图的拓扑顺序。</p>

<p>再次说明，拓扑排序和有向环的检测总是一起出现的，因为有向环的检测是排序的前提。</p>

<h2>5. 有向图的强连通性</h2>

<p>如果两个顶点v和w是互相可达的，也就是存在一条从v到w的有向路径，同时还存在一条从w到v的有向路径，那么v和w是<strong>强连通</strong>的。</p>

<p>强连通性将所有顶点分为一些等价类，每个等价类都由相互均为强连通的顶点的最大子集组成，这些子集称为<strong>强连通分量</strong>。强连通分量的典型应用包括：网络（网页和超链接）、软件（模块和调用）、食物链（物种和捕食关系）等。强连通分量的API:</p>

<p><img src="http://blog.ubone.com/myresource/images/image_blog_2014-10-30-scc-api.png" alt="image" /></p>

<h3>5.1 Kosaraju算法</h3>

<p>Kosaraju算法实现了SCC API：</p>

<ul>
<li>在给定的一幅有向图G中，使用DepthFirstOrder来计算它的反向图G<sup>R</sup>的逆后序排列。</li>
<li>在G中进行标准的深度优先搜索，但是要按照刚才计算得到的顺序而非标准的顺序来访问所有未被标记的顶点。</li>
<li>在构造函数中，所有在同一个递归dfs()调用中被访问到的顶点都在同一个强连通分量中，将它们按照和CC相同的方式识别出来。</li>
</ul>


<p>要证明Kosaraju算法的正确性，首先证明：“每个和s强连通的顶点v都会在构造函数调用的dfs(G,s)中被访问到。”这个毫无疑问。然后再证明：“构造函数调用的dfs(G,s)所到达的任意顶点v都必然是和s强连通的。”设v为dfs(G,s)到达的某个顶点。那么G中必然存在一条从s到v的路径，因此只需证明G中还存在一条从v到s的路径即可。也就等价于证明G<sup>R</sup>中存在一条从s到v的路径：</p>

<blockquote><p>按照逆后序进行的深度优先搜索意味着，在G<sup>R</sup>中进行的深度优先搜索中，dfs(G,v)必然在dfs(G,s)之前就已经结束了，这样dfs(G,v)的调用就只会出现两种情况：</p>

<ol>
<li>调用在dfs(G,s)的调用之前（并且也在dfs(G,s)的调用之前结束）</li>
<li>调用在dfs(G,s)的调用之后（并且也在dfs(G,s)的调用之前结束）</li>
</ol>


<p>第一种情况不可能出现，因为在G<sup>R</sup>中存在一条从v到s的路径；而第二种情况说明G<sup>R</sup>中存在一条从s到v的路径。证毕。</p></blockquote>

<pre class='line-numbers language-java'><code class='language-java'>public class KosarajuSharirSCC {
    private boolean[] marked;     //已访问过的顶点
    private int[] id;             //强连通分量的标识符
    private int count;            //强连通分量的数量

    public KosarajuSharirSCC(Digraph G) {

        // compute reverse postorder of reverse graph
        DepthFirstOrder dfs = new DepthFirstOrder(G.reverse());

        // run DFS on G, using reverse postorder to guide calculation
        marked = new boolean[G.V()];
        id = new int[G.V()];
        for (int v : dfs.reversePost()) {
            if (!marked[v]) {
                dfs(G, v);
                count++;
            }
        }
    }

    private void dfs(Digraph G, int v) { 
        marked[v] = true;
        id[v] = count;
        for (int w : G.adj(v)) {
            if (!marked[w]) dfs(G, w);
        }
    }

    //图中的强连通分量的总数
    public int count() {
        return count;
    }

    //v和w是强连通的吗
    public boolean stronglyConnected(int v, int w) {
        return id[v] == id[w];
    }

    //v所在的强连通分量的标识符（在0至count()-1之间）
    public int id(int v) {
        return id[v];
    }
}    </code></pre>


<h3>5.2 顶点对的可达性</h3>

<p>给定一幅有向图，回答“是否存在一条从一个给定的顶点v到达另一个给定的顶点w的路径？”对于无向图，这个问题等价于连通性问题。而对有向图，有很大区别。看似简单的问题困难了专家数十年。如何大幅减少预处理所需的时间和空间，又保证常数的查询时间。这仍然是一个有待解决的问题。而且这个问题有重要的实际意义：处理互联网这样的巨型有向图。</p>

<p>下面的算法只是简单地实现了可达性，但不适用于处理大型有向图，因为它所需的空间与V<sup>2</sup>成正比，所需时间和V(V+E)成正比。但如果图小的话，仍然是一个理想的解决办法。</p>

<pre class='line-numbers language-java'><code class='language-java'>public class TransitiveClosure {
    private DirectedDFS[] tc;  // tc[v] = reachable from v

    //预处理的构造方法
    public TransitiveClosure(Digraph G) {
        tc = new DirectedDFS[G.V()];
        for (int v = 0; v &lt; G.V(); v++)
            tc[v] = new DirectedDFS(G, v);
    }

    //w是从v可达的吗？
    public boolean reachable(int v, int w) {
        return tc[v].marked(w);
    }
}</code></pre>


<p></p>

<p>参考：<a href="http://algs4.cs.princeton.edu/42directed/">http://algs4.cs.princeton.edu/42directed/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[发布两款自用的GAE应用]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/27/fa-bu-liang-kuan-zi-yong-de-gaeying-yong/"/>
    <updated>2014-10-27T22:58:19+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/27/fa-bu-liang-kuan-zi-yong-de-gaeying-yong</id>
    <content type="html"><![CDATA[<p>今天正式公开我的两款GAE(Google App Engine)应用：RSS2EPUB和背单词应用。供有需要的朋友使用。</p>

<!--more-->


<h2>RSS2EPUB/MOBI</h2>

<p>RSS2EPUB用于将RSS订阅全文转换成Epub或者MOBI格式，每天推送至邮箱或Kindle等阅读器。开发这款应用的目的主要是想专注于阅读，少一些网络的干扰。使用说明见：<a href="https://github.com/meixuesong/rss2epub">https://github.com/meixuesong/rss2epub</a></p>

<p>网址：<a href="rss2epub.appspot.com">http://rss2epub.appspot.com</a></p>

<h2>背单词</h2>

<p>背单词应用是我数年前开发的一款应用，也是第一次使用GAE。之后对页面升级改造过一次。这个应用提供了“词典”和“我的生词本”功能。词典内容来源于Collins英语学习词典和Collins英汉双解词典，并按四、六级和专四、专八进行了分类。系统按照记忆曲线列出您每天应该复习的单词。另外例句默写是非常有效的强化记忆功能，系统自动列出单词的所有例句，将单词空出来，默写完后可以检查答案。</p>

<p>网址：<a href="http://enubone.appspot.com">http://enubone.appspot.com</a></p>

<h2>注</h2>

<p>这两个应用都部署在Google的云上，所以需要翻墙才能使用。翻墙是我等这么多年练出的拿手绝活，应该不在话下。</p>

<p>GAE与几年前相比，不论是功能还是文档都有了长足进步，现在上手已经很简单了，最关键是免费，并且从GAE访问国外资源不会被墙。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[终于完成RSS2EPUB的项目]]></title>
    <link href="http://blog.ubone.com/blog/2014/10/18/zhong-yu-wan-cheng-rss2epubde-xiang-mu/"/>
    <updated>2014-10-18T22:37:33+08:00</updated>
    <id>http://blog.ubone.com/blog/2014/10/18/zhong-yu-wan-cheng-rss2epubde-xiang-mu</id>
    <content type="html"><![CDATA[<p>国庆期间，自从10月5日完成博客转EPUB电子书后，脑子突然短路，是不是可以把RSS订阅的内容也自动转成EPUB电子书呢？然后就没停下来，利用业余时间终于完成了，各项功能基本完善！</p>

<p>这个项目运行于GAE平台，接受用户订阅，然后每天把最新内容生成电子书发邮件给用户。</p>

<p>运行于GAE平台的好处是直接使用Google的云服务，特别是邮件服务和图片服务非常棒！但坏处是Google被墙，国内无法直接访问。所以又开发了邮件订阅的方法。总体来说效果不错！</p>

<p>项目地址：<a href="http://rss2epub.appspot.com/">http://rss2epub.appspot.com</a></p>

<p>使用方法参考：<a href="https://github.com/meixuesong/rss2epub">RSS2EPUB</a></p>
]]></content>
  </entry>
  
</feed>
